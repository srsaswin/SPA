{"version":3,"file":"lyte.js","mappings":";;;;;;;;AAAA;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7mUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC37EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/yCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9zCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACphBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACh1KA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://client/./node_modules/@slyte/component/src/ZohoSecurity/lyte-component-security.js","webpack://client/./node_modules/@slyte/component/src/compiler/cli/lyte-base-compile.js","webpack://client/./node_modules/@slyte/component/src/lyte-component.js","webpack://client/./node_modules/@slyte/component/src/utils/lyte-errors.js","webpack://client/./node_modules/@slyte/core/src/DataType.js","webpack://client/./node_modules/@slyte/core/src/JsonPath.js","webpack://client/./node_modules/@slyte/core/src/LyteAddon.js","webpack://client/./node_modules/@slyte/core/src/Mixin.js","webpack://client/./node_modules/@slyte/core/src/Utils.js","webpack://client/./node_modules/@slyte/core/src/errors.js","webpack://client/./node_modules/@slyte/core/src/lyte-error.js","webpack://client/./node_modules/@slyte/core/src/lyte-utils.js","webpack://client/./node_modules/@slyte/core/src/lyte.js","webpack://client/./node_modules/@slyte/core/src/rsvp.js","webpack://client/./node_modules/@slyte/core/src/service.js","webpack://client/./node_modules/@slyte/data/src/Connector.js","webpack://client/./node_modules/@slyte/data/src/Db.js","webpack://client/./node_modules/@slyte/data/src/Entity.js","webpack://client/./node_modules/@slyte/data/src/RESTConnector.js","webpack://client/./node_modules/@slyte/data/src/RESTSerializer.js","webpack://client/./node_modules/@slyte/data/src/Schema.js","webpack://client/./node_modules/@slyte/data/src/Serializer.js","webpack://client/./node_modules/@slyte/data/src/dberror.js","webpack://client/./node_modules/@slyte/data/src/utils.js","webpack://client/./node_modules/@slyte/router/index.js","webpack://client/./node_modules/@slyte/router/src/go-to.js","webpack://client/./node_modules/@slyte/router/src/history.js","webpack://client/./node_modules/@slyte/router/src/map-parser.js","webpack://client/./node_modules/@slyte/router/src/route.js","webpack://client/./node_modules/@slyte/router/src/router-errors.js","webpack://client/./node_modules/@slyte/router/src/router-utils.js","webpack://client/./node_modules/@slyte/router/src/router.js"],"sourcesContent":[";if(!window.ZSEC) {if(window.ZSEC||Object.defineProperty(window,\"ZSEC\",{value:{},writable:!1,configurable:!1,enumerable:!1}),Object.defineProperty(ZSEC,\"util\",{value:{},writable:!1,configurable:!1,enumerable:!1}),function(){if(!Object.defineProperty||!function(){try{return Object.defineProperty({},\"x\",{}),!0}catch(e){return!1}}()){var e=Object.defineProperty;Object.defineProperty=function(t,r,o){if(e)try{return e(t,r,o)}catch(e){}if(t!==Object(t))throw TypeError(\"Object.defineProperty called on non-object\");return Object.prototype.__defineGetter__&&\"get\"in o&&Object.prototype.__defineGetter__.call(t,r,o.get),Object.prototype.__defineSetter__&&\"set\"in o&&Object.prototype.__defineSetter__.call(t,r,o.set),\"value\"in o&&(t[r]=o.value),t}}}(),ZSEC.util.defineProperty=function(e,t,r,o,n,i,a){if(o||!(t in e))return n=1==n,i=1==i,a=1==a,Object.defineProperty(e,t,{value:r,writable:n,configurable:i,enumerable:a})},ZSEC.util.defineProperty(ZSEC,\"version\",\"4.0\",!0),ZSEC.util.defineProperty(ZSEC,\"constants\",ZSEC.constants||{},!0),ZSEC.util.ArrayIndexOf=Array.prototype.indexOf,ZSEC.util.ArrayIndexOf||(ZSEC.util.ArrayIndexOf=function(e){if(void 0===this||null===this)throw TypeError();var t=Object(this),r=t.length>>>0;if(0===r)return-1;var o=0;if(arguments.length>0&&(o=Number(arguments[1]),isNaN(o)?o=0:0!==o&&o!==1/0&&o!==-1/0&&(o=(o>0||-1)*Math.floor(Math.abs(o)))),o>=r)return-1;for(var n=o>=0?o:Math.max(r-Math.abs(o),0);n<r;n++)if(n in t&&t.charAt(n)===e)return n;return-1}),String.prototype.codePointAt)ZSEC.util.defineProperty(String.prototype,\"codePointAt\",String.prototype.codePointAt,!0);else{var codePointAt=function(e){if(null==this)throw TypeError();var t=String(this),r=t.length,o=e?Number(e):0;if(o!=o&&(o=0),!(o<0||o>=r)){var n,i=t.charCodeAt(o);return i>=55296&&i<=56319&&r>o+1&&(n=t.charCodeAt(o+1))>=56320&&n<=57343?1024*(i-55296)+n-56320+65536:i}};ZSEC.util.defineProperty(String.prototype,\"codePointAt\",codePointAt,!1)}if(String.fromCodePoint)ZSEC.util.defineProperty(String,\"fromCodePoint\",String.fromCodePoint,!0);else{var stringFromCharCode=String.fromCharCode,floor=Math.floor,fromCodePoint=function(){var e,t,r=[],o=-1,n=arguments.length;if(!n)return\"\";for(var i=\"\";++o<n;){var a=Number(arguments[o]);if(!isFinite(a)||a<0||a>1114111||floor(a)!=a)throw RangeError(\"Invalid code point: \"+a);a<=65535?r.push(a):(e=55296+((a-=65536)>>10),t=a%1024+56320,r.push(e,t)),(o+1==n||r.length>16384)&&(i+=stringFromCharCode.apply(null,r),r.length=0)}return i};ZSEC.util.defineProperty(String,\"fromCodePoint\",fromCodePoint,!1)}!function(){var e={log:function(e){if(navigator&&navigator.userAgent){var t=navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\\/)/i);if(t&&t[0].search(/trident|msie/i)<0)return window.console.log(\"%cSTOP!\",\"color:red;font-size:xx-large;font-weight:bold;\"),void window.console.log(\"%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\\nSee https://en.wikipedia.org/wiki/Self-XSS for more details\",\"font-size:large;\")}window.console.log(\"STOP!\\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\\nSee https://en.wikipedia.org/wiki/Self-XSS for more details\")}};ZSEC.util.defineProperty(ZSEC,\"Console\",e,!0,!1,!1,!0)}(),ZSEC.Console.log();};window.DOMPurifyCopy = window.DOMPurify ? window.DOMPurify : undefined;;if(!window.ZSEC.HTMLPurifier) {function addToSet(e,t){for(var r=t.length;r--;)e[t[r]]=!0;return e}function addObjsToSet(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=!0);return e}function removeFromSet(e,t){var r={};for(var o in e)e.hasOwnProperty(o)&&o!=t&&(r[o]=e[o]);return r}!function(e){window.DOMPurify=e(window)}(function e(t){var r=function(t){return e(t)};if(r.version=\"0.8.5\",r.removed=[],!t||!t.document||9!==t.document.nodeType)return r.isSupported=!1,r;var o=t.document,n=o,T=t.DocumentFragment,i=t.HTMLTemplateElement,a=t.Node,A=t.NodeFilter,_=t.NamedNodeMap||t.MozNamedAttrMap,E=t.Text,O=t.Comment,L=t.DOMParser;if(\"function\"==typeof i){var s=o.createElement(\"template\");s.content&&s.content.ownerDocument&&(o=s.content.ownerDocument)}var l=o.implementation,d=o.createNodeIterator,u=o.getElementsByTagName,c=o.createDocumentFragment,R=n.importNode,S={};r.isSupported=void 0!==l.createHTMLDocument&&9!==o.documentMode;var f=function(e,t){for(var r=t.length;r--;)\"string\"==typeof t[r]&&(t[r]=t[r].toLowerCase()),e[t[r]]=!0;return e},p=null,B=f({},[]),m=null,N=f({},[]),D=null,I=null,h=!0,U=!0,v=!1,b=!1,y=!1,g=/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm,G=/<%[\\s\\S]*|[\\s\\S]*%>/gm,F=!1,w=!0,M=!1,C=!1,P=!1,W=!0,J=!0,x=f({},[\"audio\",\"head\",\"math\",\"script\",\"svg\",\"video\",\"style\"]),H=f({},[\"audio\",\"video\",\"img\",\"source\",\"image\"]),k=f({},[\"alt\",\"class\",\"for\",\"id\",\"label\",\"name\",\"pattern\",\"placeholder\",\"summary\",\"title\",\"value\",\"style\",\"xmlns\"]),Y=null,z=o.createElement(\"form\"),V=function(e){\"object\"!=typeof e&&(e={}),p=\"ALLOWED_TAGS\"in e?f({},e.ALLOWED_TAGS):B,m=\"ALLOWED_ATTR\"in e?f({},e.ALLOWED_ATTR):N,D=\"FORBID_TAGS\"in e?f({},e.FORBID_TAGS):{},I=\"FORBID_ATTR\"in e?f({},e.FORBID_ATTR):{},h=!1!==e.ALLOW_ARIA_ATTR,U=!1!==e.ALLOW_DATA_ATTR,v=e.ALLOW_UNKNOWN_PROTOCOLS||!1,b=e.SAFE_FOR_JQUERY||!1,y=e.SAFE_FOR_TEMPLATES||!1,F=e.WHOLE_DOCUMENT||!1,M=e.RETURN_DOM||!1,C=e.RETURN_DOM_FRAGMENT||!1,P=e.RETURN_DOM_IMPORT||!1,w=!1!==e.FORCE_BODY,W=!1!==e.SANITIZE_DOM,J=!1!==e.KEEP_CONTENT,y&&(U=!1),C&&(M=!0),e.ADD_URI_SAFE_ATTR&&f(k,e.ADD_URI_SAFE_ATTR),J&&(p[\"#text\"]=!0),Object&&\"freeze\"in Object&&Object.freeze(e),Y=e},j=function(e){r.removed.push({element:e});try{e.parentNode.removeChild(e)}catch(t){e.outerHTML=\"\"}},Q=function(e,t){r.removed.push({attribute:t.getAttributeNode(e),from:t}),t.removeAttribute(e)},X=function(e){var t,r;w&&(e=\"<remove></remove>\"+e);try{t=(new L).parseFromString(e,\"text/html\")}catch(e){}return t&&t.documentElement||((r=(t=l.createHTMLDocument(\"\")).body).parentNode.removeChild(r.parentNode.firstElementChild),r.outerHTML=e),\"function\"==typeof t.getElementsByTagName?t.getElementsByTagName(F?\"html\":\"body\")[0]:u.call(t,F?\"html\":\"body\")[0]},Z=function(e){return d.call(e.ownerDocument||e,e,A.SHOW_ELEMENT|A.SHOW_COMMENT|A.SHOW_TEXT,function(){return A.FILTER_ACCEPT},!1)},K=function(e){return!(e instanceof E||e instanceof O)&&!(\"string\"==typeof e.nodeName&&\"string\"==typeof e.textContent&&\"function\"==typeof e.removeChild&&e.attributes instanceof _&&\"function\"==typeof e.removeAttribute&&\"function\"==typeof e.setAttribute)},q=function(e){return\"object\"==typeof a?e instanceof a:e&&\"object\"==typeof e&&\"number\"==typeof e.nodeType&&\"string\"==typeof e.nodeName},$=function(e){var t,o;if(ae(\"beforeSanitizeElements\",e,null),K(e))return j(e),!0;if(t=e.nodeName.toLowerCase(),ae(\"uponSanitizeElement\",e,{tagName:t,allowedTags:p}),!p[t]||D[t]){if(J&&!x[t]&&\"function\"==typeof e.insertAdjacentHTML)try{e.insertAdjacentHTML(\"AfterEnd\",e.innerHTML)}catch(e){}return j(e),!0}return\"style\"!=t?(!b||e.firstElementChild||e.content&&e.content.firstElementChild||!/</g.test(e.textContent)||(r.removed.push({element:e.cloneNode()}),e.innerHTML=e.textContent.replace(/</g,\"&lt;\")),y&&3===e.nodeType&&(o=(o=(o=e.textContent).replace(g,\" \")).replace(G,\" \"),e.textContent!==o&&(r.removed.push({element:e.cloneNode()}),e.textContent=o))):!b||e.firstElementChild||e.content&&e.content.firstElementChild||!/</g.test(e.textContent)||(r.removed.push({element:e.cloneNode()}),e.innerHTML=e.textContent.replace(/</g,\"\\\\3c \")),ae(\"afterSanitizeElements\",e,null),!1},ee=/^data-[-\\w.\\u00B7-\\uFFFF]/,te=/^aria-[-\\w]+$/,re=/^(?:(?:https?|mailto|tel):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,oe=/^(?:\\w+script|data):/i,ne=/[\\x00-\\x20\\xA0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g,Te=function(e){var t,n,T,i,a,A,_,E;if(ae(\"beforeSanitizeAttributes\",e,null),A=e.attributes){for(_={attrName:\"\",attrValue:\"\",keepAttr:!0,allowedAttributes:m},E=A.length;E--;)if(t=A[E],n=t.name,T=t.value.trim(),i=n.toLowerCase(),_.attrName=i,_.attrValue=T,_.keepAttr=!0,ae(\"uponSanitizeAttribute\",e,_),T=_.attrValue,\"name\"===i&&\"IMG\"===e.nodeName&&A.id?(a=A.id,A=Array.prototype.slice.apply(A),Q(\"id\",e),Q(n,e),A.indexOf(a)>E&&e.setAttribute(\"id\",a.value)):(\"id\"===n&&e.setAttribute(n,\"\"),Q(n,e)),_.keepAttr&&(!W||\"id\"!==i&&\"name\"!==i||!(T in o||T in z))){y&&(T=(T=T.replace(g,\" \")).replace(G,\" \"));if(U&&ee.test(i))!0;else if(h&&te.test(i))!0;else{if(!m[i]||I[i])continue;if(k[i])!0;else if(re.test(T.replace(ne,\"\")))!0;else if(\"src\"!==i&&\"xlink:href\"!==i||0!==T.indexOf(\"data:\")||!H[e.nodeName.toLowerCase()])if(v&&!oe.test(T.replace(ne,\"\")))!0;else{if(T)continue;!0}else!0}try{e.setAttribute(n,T),r.removed.pop()}catch(e){}}ae(\"afterSanitizeAttributes\",e,null)}},ie=function(e){var t,r=Z(e);for(ae(\"beforeSanitizeShadowDOM\",e,null);t=r.nextNode();)ae(\"uponSanitizeShadowNode\",t,null),$(t)||(t.content instanceof T&&ie(t.content),Te(t));ae(\"afterSanitizeShadowDOM\",e,null)},ae=function(e,t,o){S[e]&&S[e].forEach(function(e){e.call(r,t,o,Y)})};return r.sanitize=function(e,o){var i,A,_,E,O,L;if(e||(e=\"\\x3c!--\\x3e\"),\"string\"!=typeof e&&!q(e)){if(\"function\"!=typeof e.toString)throw new TypeError(\"toString is not a function\");e=e.toString()}if(!r.isSupported){if(\"object\"==typeof t.toStaticHTML||\"function\"==typeof t.toStaticHTML){if(\"string\"==typeof e)return t.toStaticHTML(e);if(q(e))return t.toStaticHTML(e.outerHTML)}return e}if(V(o),r.removed=[],e instanceof a)1===(A=(i=X(\"\\x3c!--\\x3e\")).ownerDocument.importNode(e,!0)).nodeType&&\"BODY\"===A.nodeName?i=A:i.appendChild(A);else{if(!M&&!F&&-1===e.indexOf(\"<\"))return e;if(!(i=X(e)))return M?null:\"\"}for(w&&j(i.firstChild),O=Z(i);_=O.nextNode();)3===_.nodeType&&_===E||$(_)||(_.content instanceof T&&ie(_.content),Te(_),E=_);if(M){if(C)for(L=c.call(i.ownerDocument);i.firstChild;)L.appendChild(i.firstChild);else L=i;return P&&(L=R.call(n,L,!0)),L}return F?i.outerHTML:i.innerHTML},r.addHook=function(e,t){\"function\"==typeof t&&(S[e]=S[e]||[],S[e].push(t))},r.removeHook=function(e){S[e]&&S[e].pop()},r.removeHooks=function(e){S[e]&&(S[e]=[])},r.removeAllHooks=function(){S={}},r}),function(e){var t={};t.ALLOW_ARIA_ATTR=!0,t.ALLOW_DATA_ATTR=!0,t.ALLOW_UNKNOWN_PROTOCOLS=!1,t.SAFE_FOR_JQUERY=!1,t.SAFE_FOR_TEMPLATES=!1,t.WHOLE_DOCUMENT=!1,t.RETURN_DOM=!1,t.RETURN_DOM_FRAGMENT=!1,t.RETURN_DOM_IMPORT=!1,t.FORCE_BODY=!0,t.SANITIZE_DOM=!0,t.KEEP_CONTENT=!0,t.STYLE_VALIDATION=!0,t.REMOVE_ONEVENTS=!0,t.ALLOWED_STYLE=\"NONE\",t.ALLOWED_TAGS=\"a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text\".split(\"|\"),t.ALLOWED_ATTR=\"accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox\".split(\"|\"),t.ALLOWED_STYLE_PROPS=\"azimuth|background|background-attachment|background-color|background-image|background-position|content|background-repeat|border-collapse|border-color|border-top-color|border-right-color|border-bottom-color|border-left-color|bottom|caption-side|clear|color|cue-after|cue-before|direction|display|elevation|empty-cells|float|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|height|left|letter-spacing|line-height|list-style-image|list-style-position|list-style-type|marker-offset|max-height|max-width|min-height|min-width|orphans|outline-color|overflow|page-break-after|page-break-before|page-break-inside|pause-after|pause-before|pitch|pitch-range|position|richness|right|size|speak|speak-header|speak-numeral|speak-punctuation|speech-rate|stress|table-layout|text-indent|text-transform|top|unicode-bidi|vertical-align|visibility|volume|white-space|widows|width|word-spacing|border-style|border-top-style|border-right-style|border-bottom-style|border-left-style|border-top-width|border-right-width|border-bottom-width|border-left-width|border-width|margin|margin-top|margin-right|margin-bottom|margin-left|outline-style|outline-width|padding|padding-top|padding-right|padding-bottom|padding-left|border|border-top|border-right|border-bottom|border-left|cue|list-style|marks|outline|pause|text-decoration|border-spacing|clip|counter-increment|clip|cursor|text-shadow|font|font-family|page|play-during|text-align|voice-family\".split(\"|\"),t.FORBID_TAGS=[],t.FORBID_ATTR=[],t.ALLOWED_TAGS_OBJ={},t.ALLOWED_ATTR_OBJ={},t.FORBID_TAGS_OBJ={},t.FORBID_ATTR_OBJ={},t.ADD_URI_SAFE_ATTR=[],t.EXTENDS=[\"GLOBAL_ATTRIBUTES\",\"GLOBAL_TAGS\",\"FORBID_TAGS\",\"FORBID_ATTR\",\"GLOBAL_APPEND_ATTRIBUTES\",\"GLOBAL_ATTRIBUTE_RULES\",\"ADD_URI_SAFE_ATTR\",\"TAG_RULES\"],t.TAG_RULES={a:{APPEND_ATTRIBUTES:[{NAME:\"rel\",VALUE:\"noopener noreferrer\",CRITERIA:[{NAME:\"target\",CONTAINS:\"_blank\"}]}]}},t.GLOBAL_APPEND_ATTRIBUTES=[],t.GLOBAL_ATTRIBUTE_RULES={},ZSEC.util.defineProperty(ZSEC,\"HTMLPurifier\",e(t,DOMPurify(window)),!0,!1,!1,!0),delete window.DOMPurify}(function e(t,r){function o(e){if(!e||e.constructor!==Object)return t;var r={};for(var o in t)t.hasOwnProperty(o)&&(o in e?o in m&&(1==e[o]||0==e[o]?r[o]=e[o]:r[o]=t[o]):r[o]=t[o]);return r.SAFE_FOR_TEMPLATES&&(r.ALLOW_DATA_ATTR=!1),r.RETURN_DOM_FRAGMENT&&(r.RETURN_DOM=!0),r.KEEP_CONTENT&&(r.ALLOWED_TAGS_OBJ[\"#text\"]=!0),r}function n(e){for(var t in e)e.hasOwnProperty(t)&&e[t].constructor==String&&(e[t]&&b[t]?v=!0:e[t]&&(\"cssText\"==t||/^\\d.*/.test(t)||(e[t]=\"\",I=!0)))}function T(e){for(var t=e.length-1;t>=0;t--){var r=e[t];1==r.type&&r.selectorText||8==r.type&&r.keyText?r.style&&n(r.style):4!=r.type&&7!=r.type||!r.cssRules||T(r.cssRules)}}function i(e,t){for(var r=t.length-1;r>=0;r--)1!=t[r].type&&4!=t[r].type&&7!=t[r].type||e.push(t[r].cssText)}function a(e,t,r){var r=void 0==r?e.IS_MANDATORY:r;if(e.NAME&&!t.hasAttribute(e.NAME.toLowerCase()))return e.IS_FORBIDDEN||!r;if(e.IS_FORBIDDEN)return!1;var o=t.getAttribute(e.NAME.toLowerCase());if(void 0!==o&&null!==o||(o=\"\"),o.constructor==String){if(e.DONT_TRIM||(o=o.trim()),e.CASE_SENSITIVE||!1||(o=o.toLowerCase()),e.MAX_LENGTH&&o.length>e.MAX_LENGTH)return!1;if(e.MIN_LENGTH&&o.length<e.MIN_LENGTH)return!1;if(void 0!=e.REGEX){if(e.REGEX.constructor==RegExp&&-1==o.search(e.REGEX))return!1;if(e.REGEX.constructor==Array)for(T=0;T<e.REGEX.length;T++)if(-1==o.search(e.REGEX[T]))return!1}}if(e.LIST&&-1==e.LIST.indexOf(o))return!1;if(\"INTEGER\"==e.TYPE||\"FLOAT\"==e.TYPE){var n;try{n=\"INTEGER\"==e.TYPE?window.parseInt(o,10):window.parseFloat(o)}catch(e){return!1}if(window.isNaN(n))return!1;if(void 0!=e.GREATER_THAN&&n<=e.GREATER_THAN)return!1;if(void 0!=e.GREATER_THAN_OR_EQUAL&&n<e.GREATER_THAN_OR_EQUAL)return!1;if(void 0!=e.LESSER_THAN&&n>=e.LESSER_THAN)return!1;if(void 0!=e.LESSER_THAN_OR_EQUAL&&n>e.LESSER_THAN_OR_EQUAL)return!1;if(void 0!=e.EQUAL&&n!=e.EQUAL)return!1;if(void 0!=e.NOT_EQUAL&&n==e.NOT_EQUAL)return!1}else if(o.constructor==String){if(void 0!=e.STARTS_WITH&&0!=o.indexOf(e.STARTS_WITH))return!1;if(void 0!=e.ENDS_WITH&&o.lastIndexOf(e.ENDS_WITH)!=o.length-e.ENDS_WITH.length)return!1;if(void 0!=e.CONTAINS){if(e.CONTAINS.constructor==String&&-1==o.indexOf(e.CONTAINS))return!1;if(e.CONTAINS.constructor==Array)for(T=0;T<e.CONTAINS.length;T++)if(-1==o.indexOf(e.CONTAINS[T]))return!1}if(void 0!=e.NOT_CONTAINS){if(e.NOT_CONTAINS.constructor==String&&o.indexOf(e.NOT_CONTAINS)>-1)return!1;if(e.NOT_CONTAINS.constructor==Array)for(var T=0;T<e.NOT_CONTAINS.length;T++)if(o.indexOf(e.NOT_CONTAINS[T])>-1)return!1}if(void 0!=e.EQUAL&&o!==e.EQUAL)return!1;if(void 0!=e.NOT_EQUAL&&o===e.NOT_EQUAL)return!1}return!0}function A(e){if(!e)return e;if(e.constructor==Object)for(var t in e)e.hasOwnProperty(t)&&(e[t]=E(e[t]));return e}function _(e){if(!e)return e;if(e.constructor==Array)for(var t=0;t<e.length;t++)if(e[t].CRITERIA)for(var r=0;r<e[t].CRITERIA.length;r++)e[t].CRITERIA[r]=E(e[t].CRITERIA[r]);return e}function E(e){if(e){var t=[\"STARTS_WITH\",\"ENDS_WITH\",\"CONTAINS\",\"EQUAL\",\"NOT_EQUAL\",\"LIST\"];if(!(e.CASE_SENSITIVE||!1))for(var r=0;r<t.length;r++){var o=t[r];e[o]&&(e[o]=O(e[o]))}}return e}function O(e){if(e&&e.constructor==String)return e.toLowerCase();if(e.constructor==Array)for(var t=0;t<e.length;t++)e[t]=O(e[t]);return e}function L(e,t){if(!e||e.constructor==Object)return e;for(var r={},o=0;o<e.length;o++){var n=e[o];r[n[t]]=n}return r}function s(e,t){if(e)for(var r=0;r<e.length;r++){var o=e[r];if(!t.hasAttribute(o.NAME.toLowerCase())){var n=!0;if(o.CRITERIA)for(var T=0;T<o.CRITERIA.length;T++)if(!a(o.CRITERIA[T],t,!0)){n=!1;break}n?t.setAttribute(o.NAME,o.VALUE):void 0!=o.DEFAULT_VALUE&&t.setAttribute(o.NAME,o.DEFAULT_VALUE)}}}function l(e,t){if(!t||t.constructor!==Object)return e;if(!e||e.constructor!==Object)return t;for(var r in t)t.hasOwnProperty(r)&&r in e?(void 0==e[r].APPEND_ATTRIBUTES&&(e[r].APPEND_ATTRIBUTES=t[r].APPEND_ATTRIBUTES),void 0==e[r].ATTRIBUTE_RULES&&(e[r].ATTRIBUTE_RULES=t[r].ATTRIBUTE_RULES)):e[r]=t[r];return e}function d(e,t,r){return!(t&&!a(t,e))||(void 0!==t.DEFAULT_VALUE?e.setAttribute(r,t.DEFAULT_VALUE):e.removeAttribute(r),!1)}function u(e){if(\"object\"==typeof e){e.ALLOWED_TAGS=e.GLOBAL_TAGS,e.ALLOWED_ATTR=e.GLOBAL_ATTRIBUTES;for(var r in h)!h.hasOwnProperty(r)||void 0!=e[r]||r in D||(e[r]=t[r]);if(e.TAG_RULES=L(e.TAG_RULES,\"NAME\"),e.TAG_RULES&&e.TAG_RULES.constructor==Object)for(var o in e.TAG_RULES)if(e.TAG_RULES.hasOwnProperty(o)){var n=e.TAG_RULES[o];n.ATTRIBUTE_RULES=A(L(n.ATTRIBUTE_RULES,\"NAME\")),n.APPEND_ATTRIBUTES=_(n.APPEND_ATTRIBUTES)}if(e.GLOBAL_ATTRIBUTE_RULES=A(L(e.GLOBAL_ATTRIBUTE_RULES,\"NAME\")),e.GLOBAL_APPEND_ATTRIBUTES=_(e.GLOBAL_APPEND_ATTRIBUTES),e.EXTENDS)for(var T=0;T<e.EXTENDS.length;T++){var i=e.EXTENDS[T];switch(\"GLOBAL_TAGS\"==i&&(i=\"ALLOWED_TAGS\"),\"GLOBAL_ATTRIBUTES\"==i&&(i=\"ALLOWED_ATTR\"),i){case\"ALLOWED_TAGS\":case\"ALLOWED_ATTR\":case\"FORBID_TAGS\":case\"FORBID_ATTR\":e[i+=\"_OBJ\"]={},t[i]&&(e[i]=addObjsToSet(e[i],t[i]));break;case\"ADD_URI_SAFE_ATTR\":case\"GLOBAL_APPEND_ATTRIBUTES\":if(e[i]||(e[i]=[]),!t[i]||t[i].constructor!==Array)break;e[i]=e[i].concat(t[i]);break;case\"GLOBAL_ATTRIBUTE_RULES\":if(e.GLOBAL_ATTRIBUTE_RULES||(e.GLOBAL_ATTRIBUTE_RULES={}),t.GLOBAL_ATTRIBUTE_RULES&&t.GLOBAL_ATTRIBUTE_RULES.constructor==Object)for(var a in t.GLOBAL_ATTRIBUTE_RULES)t.GLOBAL_ATTRIBUTE_RULES.hasOwnProperty(a)&&!e.GLOBAL_ATTRIBUTE_RULES[a]&&(e.GLOBAL_ATTRIBUTE_RULES[a]=t.GLOBAL_ATTRIBUTE_RULES[a]);break;case\"TAG_RULES\":e.TAG_RULES||(e.TAG_RULES={}),e.TAG_RULES=l(e.TAG_RULES,t.TAG_RULES)}}for(var E in N)N.hasOwnProperty(E)&&(e[E+\"_OBJ\"]||(e[E+\"_OBJ\"]={}),void 0!=e[E]?e[E].constructor===Array&&(e[E+\"_OBJ\"]=addToSet(e[E+\"_OBJ\"],e[E])):e[E]=[]);for(var O=0;O<B.length;O++){var s=B[O];e[s]||(e[s]=[])}\"ALL\"==e.ALLOWED_STYLE?(e.FORBID_TAGS_OBJ=removeFromSet(e.FORBID_TAGS_OBJ,\"style\"),e.FORBID_ATTR_OBJ=removeFromSet(e.FORBID_ATTR_OBJ,\"style\"),e.ALLOWED_TAGS_OBJ=addToSet(e.ALLOWED_TAGS_OBJ,[\"style\"]),e.ALLOWED_ATTR_OBJ=addToSet(e.ALLOWED_ATTR_OBJ,[\"style\"])):\"INLINE\"==e.ALLOWED_STYLE?(e.FORBID_ATTR_OBJ=removeFromSet(e.FORBID_ATTR_OBJ,\"style\"),e.ALLOWED_ATTR_OBJ=addToSet(e.ALLOWED_ATTR_OBJ,[\"style\"]),e.FORBID_TAGS_OBJ=addToSet(e.FORBID_TAGS_OBJ,[\"style\"]),e.ALLOWED_TAGS_OBJ=removeFromSet(e.ALLOWED_TAGS_OBJ,\"style\")):\"INTERNAL\"==e.ALLOWED_STYLE?(e.FORBID_TAGS_OBJ=removeFromSet(e.FORBID_TAGS_OBJ,\"style\"),e.ALLOWED_TAGS_OBJ=addToSet(e.ALLOWED_TAGS_OBJ,[\"style\"]),e.FORBID_ATTR_OBJ=addToSet(e.FORBID_ATTR_OBJ,[\"style\"]),e.ALLOWED_ATTR_OBJ=removeFromSet(e.ALLOWED_ATTR_OBJ,\"style\")):\"NONE\"==e.ALLOWED_STYLE&&(e.FORBID_TAGS_OBJ=addToSet(e.FORBID_TAGS_OBJ,[\"style\"]),e.FORBID_ATTR_OBJ=addToSet(e.FORBID_ATTR_OBJ,[\"style\"]),e.ALLOWED_TAGS_OBJ=removeFromSet(e.ALLOWED_TAGS_OBJ,\"style\"),e.ALLOWED_ATTR_OBJ=removeFromSet(e.ALLOWED_ATTR_OBJ,\"style\"));for(var d in N)if(N.hasOwnProperty(d)){for(var u in e[d+\"_OBJ\"])e[d+\"_OBJ\"].hasOwnProperty(u)&&e[d].push(u);e[d+\"_OBJ\"]=addToSet(e[d+\"_OBJ\"],e[d])}ZSEC.configValidator&&ZSEC.configValidator.HTMLPurifierValidation(e,h,N,c,R)}else{e={};for(var S in t)t.hasOwnProperty(S)&&(e[S]=t[S].valueOf())}return e}var c=addToSet({},[\"script\"]),R=addToSet({},[]),S=[\"ALLOW_ARIA_ATTR\",\"ALLOW_DATA_ATTR\",\"ALLOW_UNKNOWN_PROTOCOLS\",\"SAFE_FOR_JQUERY\",\"SAFE_FOR_TEMPLATES\",\"WHOLE_DOCUMENT\",\"RETURN_DOM\",\"RETURN_DOM_FRAGMENT\",\"RETURN_DOM_IMPORT\",\"FORCE_BODY\",\"SANITIZE_DOM\",\"KEEP_CONTENT\",\"ALLOWED_STYLE_PROPS\"],f=[\"ALLOWED_TAGS\",\"ALLOWED_ATTR\",\"FORBID_TAGS\",\"FORBID_ATTR\"],p=[\"ALLOWED_TAGS_OBJ\",\"ALLOWED_ATTR_OBJ\",\"FORBID_TAGS_OBJ\",\"FORBID_ATTR_OBJ\"],B=[\"ADD_URI_SAFE_ATTR\",\"GLOBAL_APPEND_ATTRIBUTES\",\"GLOBAL_ATTRIBUTE_RULES\",\"TAG_RULES\"],m=addToSet({},S),N=addToSet({},f),D=(addToSet({},p),addToSet({},B));D=addToSet(D,f),D=addToSet(D,p);var I,h=addToSet({},S.concat([\"STYLE_VALIDATION\",\"ALLOWED_STYLE\",\"EXTENDS\",\"REMOVE_ONEVENTS\",\"GLOBAL_ATTRIBUTES\",\"GLOBAL_TAGS\"],f,p,B)),U={iframe:{NAME:\"iframe\",ATTRIBUTE_RULES:{sandbox:{NAME:\"sandbox\",NOT_CONTAINS:[\"allow-top-navigation\",\"allow-popups-to-escape-sandbox\"],DEFAULT_VALUE:\"allow-popups allow-forms allow-scripts allow-same-origin\"}},APPEND_ATTRIBUTES:[{NAME:\"sandbox\",VALUE:\"allow-popups allow-forms allow-scripts allow-same-origin\"}]}},v=!1,b=addToSet({},t.ALLOWED_STYLE_PROPS);!function(){t.FORBID_TAGS_OBJ=addObjsToSet(t.FORBID_TAGS_OBJ,c),t.FORBID_ATTR_OBJ=addObjsToSet(t.FORBID_ATTR_OBJ,R);for(var e in N)N.hasOwnProperty(e)&&(t[e+\"_OBJ\"]=addToSet(t[e+\"_OBJ\"],t[e]));r.removeAllHooks(),I=!1,\"NONE\"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=addToSet(t.FORBID_TAGS_OBJ,[\"style\"]),t.FORBID_ATTR_OBJ=addToSet(t.FORBID_ATTR_OBJ,[\"style\"])),\"INLINE\"!=t.ALLOWED_STYLE&&\"ALL\"!=t.ALLOWED_STYLE||(t.STYLE_VALIDATION&&r.addHook(\"afterSanitizeAttributes\",function(e){if(!e.ownerDocument.baseURI){var t=document.createElement(\"base\");t.href=document.baseURI,e.ownerDocument.head.appendChild(t)}if(e.hasAttribute(\"style\")){var r=\"\";I=!1,n(e.style),(r=I?e.style.cssText:e.getAttribute(\"style\")).length?e.setAttribute(\"style\",r):e.removeAttribute(\"style\")}}),\"INLINE\"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=addToSet(t.FORBID_TAGS_OBJ,[\"style\"]),t.FORBID_ATTR_OBJ=removeFromSet(t.FORBID_ATTR_OBJ,\"style\"))),\"INTERNAL\"!=t.ALLOWED_STYLE&&\"ALL\"!=t.ALLOWED_STYLE||(t.STYLE_VALIDATION&&r.addHook(\"uponSanitizeElement\",function(e,t){if(\"style\"===t.tagName&&null!=e.sheet){var r=e.sheet.cssRules;if(I=!1,T(r),I){var o=[];i(o,r),e.textContent=o.join(\"\\n\")}}}),\"INTERNAL\"==t.ALLOWED_STYLE&&(t.FORBID_ATTR_OBJ=addToSet(t.FORBID_ATTR_OBJ,[\"style\"]),t.FORBID_TAGS_OBJ=removeFromSet(t.FORBID_TAGS_OBJ,\"style\"))),\"ALL\"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=removeFromSet(t.FORBID_TAGS_OBJ,\"style\"),t.FORBID_ATTR_OBJ=removeFromSet(t.FORBID_ATTR_OBJ,\"style\")),(t.GLOBAL_ATTRIBUTE_RULES||t.TAG_RULES)&&r.addHook(\"afterSanitizeAttributes\",function(e){for(var r=e.nodeName.toLowerCase(),o=t.GLOBAL_ATTRIBUTE_RULES,n=t.TAG_RULES&&t.TAG_RULES[r]&&t.TAG_RULES[r].ATTRIBUTE_RULES,T=U&&U[r]&&U[r].ATTRIBUTE_RULES,i=e.attributes.length;i--;){var a=e.attributes[i].name;d(e,n&&n[a]||o&&o[a],a)&&d(e,T&&T[a],a)}}),(t.GLOBAL_APPEND_ATTRIBUTES||t.TAG_RULES)&&r.addHook(\"afterSanitizeAttributes\",function(e){var r=e.nodeName.toLowerCase();s(t.TAG_RULES&&t.TAG_RULES[r]&&t.TAG_RULES[r].APPEND_ATTRIBUTES,e),s(t.GLOBAL_APPEND_ATTRIBUTES,e),s(U&&U[r]&&U[r].APPEND_ATTRIBUTES,e)}),t.REMOVE_ONEVENTS&&r.addHook(\"uponSanitizeAttribute\",function(e,t){0==t.attrName.indexOf(\"on\")&&(t.keepAttr=!1)})}();var y=function(t){return t=u(t),e(t,r(window))};return y.isSupported=r.isSupported,y.removed=\"\",ZSEC.util.defineProperty(y,\"sanitize\",function(e,t){var n=o(t),T=r.sanitize(e,n);return y.removed=r.removed,T},!1,!1,!0),y});};;if(window.DOMPurifyCopy) { window.DOMPurify = window.DOMPurifyCopy; window.DOMPurifyCopy = undefined; };;if(!window.ZSEC.Encoder) {!function(r){function e(r){for(var e=[],a=0;a<r.length;a++)e.push(r[a].charCodeAt(0));return e}var a={},t=\"34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams\";t=t.split(\"|\");for(var i=0;i<t.length;i++){var n=t[i].split(\"=\");a[n[0]]=n[1]}var u={characterToEntityMap:a,IMMUNE_HTML:e(new Array(\",\",\".\",\"-\",\"_\",\" \")),IMMUNE_HTMLATTR:e(new Array(\",\",\".\",\"-\",\"_\")),IMMUNE_CSS:e(new Array),IMMUNE_JAVASCRIPT:e(new Array(\",\",\".\",\"_\"))};ZSEC.util.defineProperty(ZSEC,\"Encoder\",r(u),!0,!1,!1,!0)}(function(r){function e(r,e,a,t){if(null==e||void 0==e||\"string\"!=typeof e)return e;for(var i=\"\",n=0;n<e.length;n++)if(t){var u=e.codePointAt(n);i+=a(r,u,t),u>65535&&n++}else i+=a(r,e.charCodeAt(n));return i}for(var a={},t=r.characterToEntityMap,i=[],n=0;n<255;n++)i[n]=n>=48&&n<=57||n>=65&&n<=90||n>=97&&n<=122?null:n.toString(16);var u=function(r){return r<256?i[r]:r.toString(16)},o=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCodePoint(e);var a=u(e);if(null==a)return String.fromCodePoint(e);if(e<=31&&\"\\t\"!=e&&\"\\n\"!=e&&\"\\r\"!=e||e>=127&&e<=159||\" \"==e)return\" \";var i=t[e];return null!=i?i+\";\":\"&#x\"+a+\";\"},l=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCharCode(e);if(null==u(e))return String.fromCharCode(e);var a=e.toString(16);if(e<256){var t=\"00\".substr(a.length);return\"\\\\x\"+t+a.toUpperCase()}return\"\\\\u\"+(t=\"0000\".substr(a.length))+a.toUpperCase()},c=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCodePoint(e);var a=u(e);return null==a?String.fromCodePoint(e):\"\\\\\"+a+\" \"};return a.encodeForHTML=function(a){return e(r.IMMUNE_HTML,a,o,!0)},a.encodeForHTMLAttribute=function(a){return e(r.IMMUNE_HTMLATTR,a,o,!0)},a.encodeForJavaScript=function(a){return e(r.IMMUNE_JAVASCRIPT,a,l,!1)},a.encodeForCSS=function(a){return e(r.IMMUNE_CSS,a,c,!0)},Object.freeze&&Object.freeze(a),a});};","// function BaseCompiler(){\n    let Compile = {};\n    Compile.regex = {\n        get lyteTemplateType1() { return /if|for|switch/g },\n        get getArrayArgRegex() { return /\\[(?=([\\s]*[\\w-_.]+)([\\(\\[]))/g },\n        get getArrayArgRegexCLI() { return /\\[(?=([\\s]*[\\w-_]+)([\\(\\[]))/g },\n        get matchInsideParentheses() { return /\\(.*\\)$/ },\n        get startsAndEndWithNumber() { return /^[0-9]$/ },\n        get matchInsideSquareBrackets() { return /\\[.*\\]/ },\n        get getHelperRegex() { return /\\((?:[^\\)]*|(?:(?:\"(?:[^\"\\\\]|\\\\.)*?\")|(?:'([^'\\\\]|\\\\.)*?')|[\\w\\s!@#$%^&*)([\\]+=.,_-]*?)*?)\\)$/ },\n        get matchAllEmptyCharacter() { return /\\s/g },\n        get endsWithCloseParantheses() { return /\\)$/g },\n        get startWithMustacheWithContent() { return /^{{(?=[\\s]*[\\w-_\\(\\$)]+)/ },\n        get dynamicValueCheck() { return /[\\w!@#\\$%\\^\\&*\\)\\(+=.,_-]+[\\s]*[(]{0,1}(?:\"([^\"]|\\\\\")*?\"|'([^']|\\\\')*?'|[\\w\\s!@#\\$%\\^\\&*\\)\\(\\[\\]+=.,_-]*?)*?[)]{0,1}[\\s]*(?=}})/g },\n        get validMustacheCheck() { return /{{[^}]*?(?:(?:('|\")[^\\1]*?\\1)[^}]*?)*}}$/ },\n        get mustacheCountCheck() { return /{{[a-zA-Z0-9_.\\[\\]\\(\\)]*(?![\\\\])}}/g },\n        get validateArrayIndexing() { return /[a-zA-z0-9]*\\[.*\\]/g },\n        get mustache() { return /{{[^}]*?(?:(?:[^\\1]*?\\1)[^}]*?)*}}/g },\n        get lyteTemplateType2() { return /(for|forIn|if|switch)$/ },\n        get splitTextNodesMustache() { return /{{[^}]*?(?:(?:('|\")[^\\1]*?\\1)[^}]*?)*}}/g },\n        get tableTags() { return /^(TR|TD|TH|TBODY|THEAD|TFOOT)$/ },\n        get tableTagsWithSelect() { return /^(SELECT|TR|TABLE|TBODY|THEAD|TFOOT)$/ },\n        get eventListRegexFull() { return /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|ondragstart|ondrag|ondragenter|ondragleave|ondragover|ondrop|ondragend|onload|onunload|onabort|onerror|onscroll|onreset|onblur|onafterprint|onbeforeprint|ononbeforeunload|onerror|onhashchange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onstorage|onunload|oninput|oninvalid|onsearch|ononmousewheel|onwheel|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|onabort|oncanplay|oncanplaythrough|oncuechange|ondurationchange|onemptied|onended|onloadeddata|onloadedmetadata|onloadstart|onpause|onplay|onplaying|onprogress|onratechange|onseeked|onseeking|onstalled|onsuspend|ontimeupdate|onvolumechange|onwaiting|onpaste)$/ },\n        get eventListRegexPart() { return /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu)$/ },\n        get keyWordsRegex() { return /((const)|(continue)|(default)|(delete)|(do)|(else)|(enum)|(export)|(extends)|(finally)|(for)|(function)|(if)|(import)|(in)|(instanceof)|(new)|(return)|(super)|(switch)|(try)|(typeof)|(var)|(void)|(while)|(with))(?!\\w)/g },\n        get lyteHelperRegex() { return /__LyteHelper(\\w*?)__/g },\n        get tableElementRegex() { return /^(TBODY|THEAD|TFOOT)$/ },\n        get getTransitionOrderRegex() { return /^f|fI|e|s|cD|cM|i|r|yield$/g },\n        get getChildRegex() { return /^f|fI|e|s|cD|i|r|yield$/g },\n        get startWithMustacheRegex() { return /^{{/ },\n        get endWithMustacheRegex() { return /}}$/ },\n        get baseCaseMustacheCheck() { return /{{.*}}/ },\n        get commentedMustacheCheck() { return /\\\\{{.*}}/ }\n    \n    }\n    Compile.getTrimmedContent = function(content, position, node) {\n        let dummyContent = content;\n        if(node) {\n            position = [];\n            let parentNode = node.parentNode;\n            while(true) {\n                position.$unshift(this.getArrayIndex(parentNode.childNodes,node));\n                parentNode = parentNode.parentNode;\n                node = node.parentNode;\n                if(!parentNode) {\n                    break;\n                }\n            }\n        }\n        for(let i=0;i<position.length;i++) {\n            for(let j=content.childNodes.length-1;j>position[i];j--) {\n                content.childNodes[j].remove();\n            }\n            content = content.childNodes[position[i]];\n        }\n        return dummyContent;\n    }\n    Compile.getArrayIndex = function(array,value) {\n        for(let i=0;i<array.length;i++) {\n            if(array[i] === value) {\n                return i\n            };\n        }\n    }\n\n    Compile.splitMixedText = function(str,componentName,errors){\n            // console.log(\"str\",str);\n        var stack = [],\n        start = 0,\n        flag = false,\n        helper = {\n            name: \"concat\",\n            args: []\n        };\n        for (var i = 0; i < str.length; i++) {\n            var j = i;\n            if (str[i - 1] !== \"\\\\\" && str[i] === \"{\" && str[++i] === \"{\") {\n                stack.push('{{');\n                helper.args.push(\"'\" + str.substr(start, j - start) + \"'\");\n                start = i + 1;\n            } else if (str[i] === \"}\" && str[++i] === \"}\" && stack.length) {\n                stack.pop(start);\n                var toPush = str.substr(start, j - start);\n                if((toPush.startsWith(\"'\") && toPush.endsWith(\"'\")) || (toPush.startsWith('\"') && toPush.endsWith('\"'))){\n                    console.warn(\"Rendering string value inside dynamic data (mustache) is depriciated\",\"for the value \",toPush ,\"on the attribute value \",str);\n                }\n                var actObj  =  this.getArray(toPush);  \n                if(actObj && actObj == \"timeoutError\"){\n                    errors.push(new Error(\"(LC:timeout8)Syntax error in node \"+node.node+\" for the value: \"+\" - \"+node.text));\n                    return;\n                }else if(actObj === false){\n                    errors.push(new Error(\"(LC:14)Syntax Error in node \"+node.node+\"for the value:\"+node.text));\n                    return;\n                }\n                if(actObj){\n                    toPush = actObj;\n                    helper.args.push({type:\"sq\",value:actObj});\n                    flag = true;\n                }\n                if(!actObj){\n                    actObj = this.getHelper(toPush);  \n                    if(actObj){\n                        if(actObj == \"timeoutError\"){\n                            errors.push(new Error(\"(LC:timeout5)Syntax Error in node \"+\"  for : \"+str));\n                            return;\n                        }\n                        else if(actObj.name == \"lbind\"){\n                            errors.push(new Error(\"(LC:lbind5) Syntax Error : lbind are not allowed with prepending or appending with texts \"+\" for : \"+str));\n                            return;\n                        }\n                        else if(actObj == \"lbindError\" || actObj.args == \"lbindError\"){\n                            errors.push(new Error(\"(LC:lbind6)Syntax Error : lbind are not allowed inside helpers on node \"+node.node+\" for: \"+ str));\n                            return;\n                        }\n                        else if(actObj.name == \"lbind\" && node.tagName == \"TEMPLATE\"&& node.hasAttribute(\"is\") && this.regex.lyteTemplateType1.test(node.attr.is)){\n                            errors.push(new Error(\"(LC:lbind7)Syntax Error : lbind not allowed as value in if/for/switch node\"+\"for: \"+str));\n                            return;\n                        }\n                        \n                        else if(actObj.name == \"action\"){\n                            errors.push(new Error(\"(LC:9)Syntax Error : action are not allowed with prepending or appending with texts \"+\"for :\"+str));\n                            return;\n                        }\n                        else if(actObj.name == \"method\"){\n                            errors.push(new Error(\"(LC:10)Syntax Error : method are not allowed with prepending or appending with texts \"+\"for :\"+str));\n                            return;\n                        }\n                        toPush = actObj;\n                        if(!this.fromCLI && this.regex.getArrayArgRegex.test(toPush)){\n                            flag = true;\n                        }\n                        helper.args.push({ type: \"helper\", value: toPush })\n                        if (this.fromCLI) {\n                            if (this.defaultImpDetails.helpers.indexOf(actObj.name) == -1 && this.defaultHelpers.indexOf(actObj.name) == -1) {\n                                this.defaultImpDetails.helpers.push(actObj.name);\n                            }\n                            this.getImportedHelpers(actObj.args, this.defaultImpDetails.helpers);\n                        }\n                    }\n                    else if(actObj === false){\n                        errors.push(new Error(\"(LC:13)Syntax error in node \"+node.node+\" for the attribute:\"+node.attributes[x].nodeName+\"- \"+node.attributes[x].text));\n                        return;\n                    }\n                    else{\n                        if((toPush.startsWith(\"'\") && toPush.endsWith(\"'\")) || (toPush.startsWith('\"') && toPush.endsWith('\"'))){\n                            console.warn(\"Rendering string value inside dynamic data (mustache) is depriciated\",\"for the value \",toPush ,\"on the attribute value \",str);\n                        }\n                        helper.args.push(toPush);\n                    }\n                    if(this.fromCLI){\n                        start = i + 1;  \n                    }\n                }\n                if (!this.fromCLI) {\n                    start = i + 1;//checkWithMentor 3055 it should come up one step\n                }\n                // var actObj = getHelper(toPush, componentName);\n                // if (actObj) {\n                //     toPush = actObj;\n                //     helper.args.push({\n                //         type: \"helper\",\n                //         value: toPush\n                //     });\n                // } else {\n                //     helper.args.push(toPush);\n                // }\n                // start = i + 1;\n            }\n\n        }\n        if (start < str.length) {\n            helper.args.push(\"'\" + str.substr(start, str.length - start) + \"'\");\n        }\n        if (flag) {\n            helper._t = \"hq\";\n            return helper;\n        }\n        else {\n            return helper;\n        }\n    }\n\n    Compile.getHelper = function(dynamicValue) {\n        let helperValue = this.regex.getHelperRegex.exec(dynamicValue);\n        if(helperValue){\n            let actObj = this.getHelperInfo(dynamicValue,helperValue);\n            if(this.regex.getArrayArgRegex.test(dynamicValue)){\n                actObj._t = 'hq';\n            }\n            // actObj._importHelperArray = importHelperArray;\n            return actObj;\n        }\n        return undefined;\n    }\n    \n\n    Compile.getHelperInfo = function(dynamicValue, helperValue){\n        let helperFunc = {};\n        helperFunc.name = dynamicValue.substr(0, helperValue.index).replace(this.regex.matchAllEmptyCharacter, '');\n        helperValue = (helperValue) ? helperValue[0].trim() : helperValue;\n        let args = this.getHelperArgs(helperValue.substr(1,helperValue.length-2));\n        if(helperFunc.name == \"lyteViewPort\" && helperValue == \"()\"){\n            helperFunc.args = [];\n            return helperFunc;\n        }\n        if (args === false) {\n            return false;\n        }\n        helperFunc.args = args;\n        return helperFunc;\n    }\n\n    Compile.getHelperArgs = function(str){\n        let stack = [],\n        escapeQuote = false,\n        stringStarted = false,\n        bracketStack = [],\n         args = [],\n          from = 0;\n        let lastPushed;\n        for(let i=0; i<str.length; i++){\n            if(!stack.length && str.charAt(i) === \",\"){\n                let toPush = str.substr(from,i-from);\n                toPush = toPush.trim();\n                if(toPush && toPush.startsWith(\"\\\"\") && toPush.endsWith(\"\\\"\")){\n                    toPush = toPush.slice(1,-1);\n                    toPush = \"'\" + toPush + \"'\";\n                }\n                try{\n                    toPush = this.getHelperArgValue(toPush);\n                }\n                catch(err){\n                    console.log(\"errr\",err);\n                    if(err.message == \"lbindError\"){\n                        return \"lbindError\"\n                    }\n                }\n                args.push(toPush);\n                from = i + 1;\n            }\n            else if(!bracketStack.length && stringStarted && str.charAt(i) === \"\\\\\" && /\\\\|\\'|\\\"/g.test(str.charAt(i+1))){\n                str = str.substr(0,i)  + str.substr(i+1,str.length);\n            }\n            else if(str.charAt(i) === \"\\\\\" && /\\\\/g.test(str.charAt(i+1))){\n                // str = str.substr(0,i)  + str.substr(i+1,str.length);\n                // continue;\n                i++;\n            }\n            else if(str.charAt(i) === \"\\\\\" && /\\'|\\\"/g.test(str.charAt(i+1))){\n                escapeQuote = true\n            }\n            else if(str.charAt(i) === \"(\"){\n                if(stack[stack.length - 1] != \"'\" && stack[stack.length - 1] != \"\\\"\"){\n                    stack.push(str.charAt(i));\n                    lastPushed = str.charAt(i);\n                    bracketStack.push(\"(\");\n                }\n            }\n            else if(str.charAt(i) === \")\"){\n                if(stack[stack.length-1] === \"(\"){\n                    stack.pop();\n                    bracketStack.pop();\n                }\n            }\n            else if(str.charAt(i) === \"'\"){// && str.charAt(i-1) !== \"\\\\\"\n                if(escapeQuote){\n                    escapeQuote = false;\n                    continue;\n                }\n                else if(stack[stack.length-1] === \"'\"){\n                    stringStarted = false\n                    stack.pop();\n                }\n                else if(stack[stack.length-1] !== \"\\\"\"){\n                    stack.push(str.charAt(i));\n                    lastPushed = str.charAt(i);\n                    stringStarted = true;\n                }\n            }\n            else if(str.charAt(i) === \"\\\"\"){// && str.charAt(i-1) !== \"\\\\\"\n                if(escapeQuote){\n                    escapeQuote = false;\n                    continue;\n                }\n                else if(stack[stack.length-1] === \"\\\"\"){\n                    stringStarted = false\n                    stack.pop();\n    //                  str.replaceAt(i, \"'\");\n                }\n                else if(stack[stack.length-1] !== \"'\"){\n                    stack.push(str.charAt(i));\n                    lastPushed = str.charAt(i);\n                    stringStarted = true;\n    //                  str.replaceAt(i, \"'\");\n                }\n            }\n        }\n        if (stack.length) {\n            return false;\n        }\n        let toPush = str.substr(from, str.length - from);\n        toPush = toPush.trim();\n        if (toPush && toPush.startsWith(\"\\\"\") && toPush.endsWith(\"\\\"\")) {\n            toPush = toPush.slice(1, -1);\n            toPush = \"'\" + toPush + \"'\";\n        }\n        try{\n            toPush = this.getHelperArgValue(toPush);\n        }\n        catch(err){\n            console.log(\"errr\",err);\n            if(err.message == \"lbindError\"){\n                return \"lbindError\"\n            }\n            return false;\n        }\n        args.push(toPush);\n        return args;\n    }\n    \n    Compile.getHelperArgValue = function(argValue) {\n        switch (argValue) {\n            case \"undefined\":\n                return undefined\n            case \"true\":\n                return true;\n            case \"false\":\n                return false;\n            case \"null\":\n                return null;\n            case \"\":\n                return undefined;\n            default:\n                if (argValue && argValue.startsWith(\"'\") && argValue.endsWith(\"'\")) {\n                    return (this.fromCLI)?this.decodeHtmlEntities.decode(argValue):argValue;\n                }else if(this.fromCLI && this.regex.getArrayArgRegexCLI.test(argValue) && !this.regex.endsWithCloseParantheses.test(argValue)){// //array //if array inside helepr or array inside array it should work/\\w+\\[.*\\]/g\n                    let arg = this.getArrayArg(argValue);\n                    return arg.args[0];\n                } \n                else if(!this.fromCLI && this.regex.getArrayArgRegex.test(argValue) && !this.regex.endsWithCloseParantheses.test(argValue)){\n                    let arg = this.getArrayArg(argValue);\n                    return arg.args[0];\n                }\n                else if(/\\([\\w\\s,')(]*/.test(argValue)) {\n                    let arg = this.getHelper(argValue);\n                    if(arg === false){\n                        throw new Error(argValue);\n                    }\n                    if(arg.name == \"lbind\"){\n                        throw new Error(\"lbindError\");\n                    }\n                    return {\"type\" : \"helper\" , \"value\" : arg}\n                } else if (!isNaN(argValue)) {\n                    return parseInt(argValue);\n                } else {\n                    return argValue;\n                }\n        }\n    }\n    Compile.getMustache = function(value,componentName,syn){\n        value=(value && typeof value === \"string\") ? value.trim() : value;\n            if(this.regex.startWithMustacheWithContent.test(value)){\n            let arr = value.match(this.regex.mustacheCountCheck);\n                if(arr && arr.length > 1){\n                    console.log(\"length>1\",value)\n                    return undefined;\n                }\n                // console.log(value);\n                if(syn && !syn.bool){\n                    console.log(\"syntax error\",syn)\n                    return {bool:false,err:syn.err};\n                }\n                if(!this.regex.validMustacheCheck.test(value)){\n                    return undefined;\n                }\n                let dynamic = value.match(this.regex.dynamicValueCheck); // /* */\n                if(dynamic && dynamic.length > 1){\n                    return undefined;\n                }\n                else{\n                    dynamic = (dynamic) ? dynamic[0].trim(): dynamic;                \n                }\n                // console.log(\"dynamic value before returning \", dynamic);\n                return dynamic;\n            }\n            return undefined;\n    }\n    Compile.syntaxCheckWorkerNew = function(val){\n        var parsingMustache;\n        var retObj = {\n            \"mustache\":0,\n            bool : true,\n            err : null\n        }\n        for(let i=0;i<val.length;i++){\n            if(parsingMustache){\n                if(val[i] == \"\\\\\"){\n                    i=i+1;\n                }\n                else if(val[i] == \"'\"){\n                    if(lastString != '\"'){//val[i-1] != \"\\\\\"  && \n                        if(!stringStarted){\n                            stringStarted = true;\n                            lastString = \"'\";\n                        }else{\n                            stringStarted = false;\n                            lastString = undefined;\n                        }\n                    }               \n                }\n                else if(val[i] == '\"'){\n                    if(lastString != \"'\"){//val[i-1] != \"\\\\\" &&\n                        if(!stringStarted){\n                            stringStarted = true;\n                            lastString = '\"'\n                        }else{\n                            stringStarted = false;\n                            lastString = undefined;\n                        }\n                    }\n                }\n                else if(val[i] == \"{\" && !stringStarted){\n                    retObj.bool = false;\n                    retObj.err = \" unexpected '{' bracket \";\n                    return retObj;\n                }\n                else if(val[i] == \"{\" && stringStarted && val[i-1] == \"{\"){\n                    retObj.mustache ++;\n                }\n                else if(val[i] == \"}\" && val[i-1] == \"}\" && !stringStarted){\n                    if(curlyBracket.length){\n                        retObj.bool = false;\n                        retObj.err = \" error unmatched '(' bracket \";\n                        return retObj;\n                    }\n                    if(squareBracket.length){\n                        retObj.bool = false;\n                        retObj.err = \" unmatched '['bracket \";\n                        return retObj;\n                    }\n                    parsingMustache = false;\n                }\n                else if(val[i] == \"[\" && !stringStarted){\n                    squareBracket.$push(\"[\");\n                }\n                else if(val[i] == \"]\" && !stringStarted){\n                    if(squareBracket.length){\n                        squareBracket.$pop();\n                    }else{\n                        retObj.bool = false;\n                        retObj.err = \" unmatched ']' bracket \";\n                        return retObj;\n                    }\n                }\n                else if(val[i] == \"(\" && !stringStarted){\n                    curlyBracket.$push('(');\n                }\n                else if(val[i] == \")\" && !stringStarted){\n                    if(curlyBracket.length){\n                        curlyBracket.$pop();\n                    }else{\n                        retObj.bool = false;\n                        retObj.err = \" unmatched ')' bracket \"; \n                        return retObj;\n                    }\n                }\n            }    \n            else if((val[i] == \"{\" && val[i-1] == \"{\" && val[i-2] != \"\\\\\")){\n                //start parsing\n                var curlyBracket =[] ,squareBracket =[] ,stringStarted ,lastString;\n                var parsingMustache = true;\n            }\n        }\n        if(parsingMustache){\n            retObj.bool = false;\n            retObj.err = \" unmatched '{' bracket\";\n            return retObj;\n        }\n        return retObj;\n    }\n    Compile.getArray = function(mustacheVal){\n        // becomses true if it is arr[arr[0]] or arr[helper()]\n        if(this.regex.getArrayArgRegex.test(mustacheVal) && !this.regex.endsWithCloseParantheses.test(mustacheVal)){\n            let arg = this.getArrayArg(mustacheVal);\n            if(arg && arg.args[0]){\n                arg.args[0].value._t = \"sq\";\n                return arg.args[0].value;\n            }else{\n                return false;\n            }\n        }\n    }\n    Compile.splitMultiDimensionArray = function(val,arrayExtra){\n        var openSq = 0,openSqPos = 0,lastString,stringStarted,openSPos,resultStack = [],extra = false,extraPos;\n        for(var i=0 ; i<val.length;i++){\n            if(val[i] == \"\\\\\"){\n                i=i+1;\n            }\n            else if(val[i] == \"'\"){\n                if(lastString != '\"'){//val[i-1] != \"\\\\\"  &&\n                    if(!stringStarted){\n                        stringStarted = true;\n                        lastString = \"'\";\n                    }else{\n                        stringStarted = false;\n                        lastString = undefined;\n                    }\n                }               \n            }\n            else if(val[i] == '\"'){\n                if(lastString != \"'\"){//val[i-1] != \"\\\\\" &&\n                    if(!stringStarted){\n                        stringStarted = true;\n                        lastString = '\"'\n                    }else{\n                        stringStarted = false;\n                        lastString = undefined;\n                    }\n                }\n            }\n            else if(val[i] == \"[\" && !stringStarted){\n                openSq = openSq + 1;\n                if(openSq == 1){\n                    openSqPos = i;\n                }\n            }\n            else if(val[i] == \"]\" && !stringStarted){\n                openSq = openSq - 1;\n                if(!extra && openSq == 0){\n                    resultStack.push(val.substring(openSqPos+1,i));//need to handlw []\n                    openSq = 0;\n                    if(val[i+1]=='.'){\n                        extra = true;\n                        extraPos = i+1;\n                    }\n                }\n            }\n        }\n        if(extra){\n            arrayExtra.push(val.substring(extraPos,i));//need to handlw []\n        }\n        return resultStack;\n    }\n    Compile.getArrayArg = function(argStr){\n        //argStr may be 0 or '0' or 'abc' or a() or a[] or a(b[]) or a[b()]\n        // var arg = {\"type\":\"sq\",\"value\":{\"args\":[],\"name\":\"\"}},arrayName;\n        if(this.regex.matchInsideParentheses.test(argStr)){\n            //if arr comes inside helper\n            let arg = this.getHelper(argStr);  \n            if(arg === false){\n                return false;\n            };\n            return {\"args\":[{ \"type\": \"helper\", \"value\": arg }]}\n        }\n        else if(this.regex.validateArrayIndexing.test(argStr)){\n            let arg = {'args':[]}, ret = [], temp,arrayExtra=[],retNew = [];\n            let arrayArg = this.regex.matchInsideSquareBrackets.exec(argStr);\n            let arrayName = argStr.substr(0,arrayArg.index);\n            // arrayArg = arrayArg[0];\n            //splitting multi dimensional array a[one][two][three] into array\n            var arr = this.splitMultiDimensionArray(argStr, arrayExtra);\n            for(var i=0; i<arr.length; i++){\n                if(this.regex.getArrayArgRegex.test(arr[i]) || this.regex.matchInsideParentheses.test(arr[i])){\n                    temp = this.getArrayArg(arr[i]);\n                    ret.push(temp.args[0]);\n                }\n                else{\n                    ret.push(arr[i])\n                }\n            }\n            for(var i=0; i<arrayExtra.length; i++){\n                if(this.regex.getArrayArgRegex.test(arrayExtra[i])){\n                    temp = this.getArrayArg(arrayExtra[i]);\n                    retNew.push(temp.args[0])\n                }else{\n                    retNew.push(arrayExtra[i])\n                }\n            }\n            ret.forEach(function(item,index){\n                if (item && item && typeof item == \"string\" && item.startsWith(\"\\\"\") && item.endsWith(\"\\\"\")) {\n                    item = item.slice(1, -1);\n                    item = \"'\" + item + \"'\";\n                }else if(typeof item == \"string\" && Compile.regex.startsAndEndWithNumber.test(item)){\n                    item = \"'\" + item + \"'\";\n                }\n                arg.args.push(item)\n            })\n            arg.name = arrayName;\n            if(retNew && retNew.length > 0){\n                arg.extra = retNew;\n            }\n            return {\"args\":[{\"type\" : \"sq\" , \"value\" : arg}]};\n        } \n    }\n    Compile.getDV = function(value){\n        var result = [],ref = result,arr = [],data = \"\",strStack = [],arrayStack = [],refStack = [],strLast,str;\n        for(var i=0;i<value.length;i++){\n            if(value[i] === \".\"){\n                if(data.length){\n                    ref.$push(data);\n                }\n                data = \"\";\n                continue;\n            }\n            else if(value[i] === \"[\"){\n                arrayStack.$push(i)\n                if(data.length){\n                    ref.$push(data);\n                }\n                while(value[i+1] === \"\\s\"){\n                    i++;\n                }\n                if(value[i+1] === \"\\\"\" || value[i+1] === \"'\"){\n                    strStack.$push(value[i+1]);\n                    strLast = value[i+1];\n                    i++;\n                }\n                else if(arr.length){\n                    ref.$push([]);\n                    refStack.$push(ref);\n                    ref = ref[ref.length-1];\n                }else{\n                    arr.$push([]);\n                    refStack.$push(ref);\n                    ref = arr[arr.length-1];\n                }\n                data = \"\";\n                continue;\n            }\n            else if((value[i] === \"\\\"\" || value[i] === \"'\" ) && value[i++] === strLast){\n                while(value[i] === \"\\s\" && value[i] != \"]\"){\n                    i++;\n                }\n                strStack.$pop();\n                str = true;\n            }\n            if(value[i] === \"]\"){\n                arrayStack.$pop();\n                if(data.length){\n                    if(str === true){\n                        ref.$push(data);    \n                    }\n                    else if(!isNaN(parseInt(data))){\n                        if(refStack.length){\n                            ref = refStack.$pop();\n                            if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){\n                                ref.$pop();\n                            }\n                            ref.$push(data);\n                            if(!arrayStack.length && arr.length){\n                                arr.$shift();\n                            }\n                        }\n                    }\n                    else{\n                        ref.$push(data);\n                    }\n                }\n                if(!arrayStack.length && arr.length){\n                    result.$push(arr.$shift());\n                    ref = result;\n                }\n                else if(refStack.length && !arr.length){ \n                    ref = refStack.$pop();\n                }\n                data = \"\";\n                str = \"\";\n                continue;\n            }\n            data = data.concat(value[i]);\n        }\n        if(data.length){\n            result.$push(data);\n        }\n        if(strStack.length || arrayStack.length){\n            console.log(\"check the syntax\",strStack,arrayStack);\n        }\n        return result;\n    }\n    // return Compile;\n// }\n\nif( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n    module.exports = Compile;\n}else{\n    window.BaseCompiler = Compile;\n}\n// BaseCompiler();\n","// debugger\nimport { establishObjectBinding, isEntity, validateData, establishObserverBindings, cmpData, removeNestScp, nestScp, bindObj, deepCopyObject, checkNestedProp, prop , checkWatchPath,establishWatchScope} from \"@slyte/core/src/lyte-utils\";\nimport { Lyte, LyteAddon } from \"@slyte/core\";\nimport { Jwalk } from \"@slyte/core/src/JsonPath.js\"\nimport Compile from './compiler/cli/lyte-base-compile.js';\nimport './ZohoSecurity/lyte-component-security.js'; //slicer af\nimport { ValidationError } from \"@slyte/data/src/dberror.js\"; //slicer store\nimport { Service } from \"@slyte/core/src/service\";\nimport { deepValueChange, setData } from \"@slyte/data/src/utils\";\nimport { Utils } from \"@slyte/core/src/Utils.js\";\n//@Slicer.developmentStart\nimport { ComponentError, ApiError, RegistryError } from \"./utils/lyte-errors.js\";\n//@Slicer.developmentEnd\nif(!window.__lyteConfig){\n    window.__lyteConfig = {\n        _definedBeforeBridging : [],\n        _alreadyDefinedBeforeBridging : [],\n        v4 : true\n    }\n}\nwindow.__lyteConfig.v4 = true;\nlet ltCf = window.__lyteConfig;\nif(!ltCf.customElementsDefine){\n    ltCf.customElementsDefine = customElements.constructor.prototype.define; \n    Object.defineProperty(customElements.constructor.prototype,\"define\",{\n        value : function(name, compClass, options, _lyteOptions){\n            if(customElements.get(name)){\n                ltCf._alreadyDefinedBeforeBridging.push({name : name, compClass : compClass, options : options, _lyteOptions : _lyteOptions, scope : this});\n            }else{\n                ltCf._definedBeforeBridging.push({name : name, compClass : compClass, options : options ,_lyteOptions : _lyteOptions, scope : this});\n                ltCf.customElementsDefine.apply(this,arguments);\n            }\n        },\n        enumerable: false\n    })\n}\n/*convert to custom class*/\nclass ComponentRegistry extends Service {\n    isComponentRegistry(){\n        return true;\n    }\n    getDirectiveObj(){\n        if(this._directive){\n            return this._directive;\n        }\n        return false;\n    }\n    static getFastObj(){\n        return this.turbo ? this.turbo : false;\n    }\n    constructor(opt){\n        super(opt);\n        var registryClass = this.constructor;\n        if(!registryClass._registered){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC001\", registryClass.name);\n            //@Slicer.developmentEnd\n            return;\n        }\n        // //@Slicer.afzalStart\n        // console.log(\"aaffff\")\n        // //@Slicer.$afzalEnd\n        /* registering component in app module - for router */\n        let app = _LC.getNearestParentApp(this);\n        app.$.modules.triggerEvent(\"add\", \"component\", this);\n        if(_LC.getDefaultRegistry() == registryClass){\n            //set default registry instance and it can be overrided with app's getRegistryInstance.\n            _LC.setDefaultRegistryIns(this)\n        }\n        registryClass._instanciated = true;\n        this.registeredComponents = {};\n        this.registeredCeComponents = {}\n        this._registeredComponents = {};\n        this._registeredCeComponents = {};\n        this._defaultDirectives = [];\n        this.registeredDirectives = [];\n        this._registeredDirectivesClass = {};\n        ComponentRegistry.registerAllComponent(registryClass._registeredComponentClass,this);\n        ComponentRegistry.registerAllCeComponent(registryClass._registeredCeComponentClass,this);\n        registryClass._instanceList.push(this);\n        _LC.setAddedRegistries(this,registryClass.name);\n        this.render = _LC.render;     \n        // this.renderHTML = _LC.renderHTML;\n        this.set = _LC.set;\n        this.get = _LC.get;\n        let currentAppOrAddon = _LC.getAppOrAddon(this);\n        this.setDefaultDirectives(currentAppOrAddon);\n        _LC.updateDomApis(this);\n        this.replaceWith = _LC.replaceWith;\n        this.throwEvent = _LC.throwEvent;\n        this.chI = _LC.chI;\n        this.chromeBugFix = _LC.chromeBugFix;\n        this.lyteComponentsDiv = _LC.lyteComponentsDiv;\n        this.String = _LC.String;\n        this.addAction = _LC.addAction;\n        this.getLyteComponentsDiv = function(){\n            return _LC.getComponentsDiv(_LC.lyteComponentsDiv,registryClass.name);\n        }\n        this._getLyteComponent = function(){\n            return _LC;\n        }\n    }\n    setDefaultDirectives(app){ \n        let defaultDirectives = [\"directive\",\"shadow\",\"shadow-style\",\"shadow-supported\",\"turbo\",\"turbo-supported\",\"unbound\",\"view\"];\n        let self = this;\n        defaultDirectives.forEach(function(item){\n            let directiveIns;\n            if(self.constructor[item]){\n                app.scopedInstance(self.constructor[item],[self],function(ins){\n                    directiveIns = ins;\n                },[])\n                self[\"_\"+item] = directiveIns;\n            }\n            self._defaultDirectives.push(item);\n        })\n    }\n    static register(options){\n        if(options){\n            if(options.app == true){\n                _LC.setDefaultRegistry(this);\n            }\n            if(options.hash){\n                this._hash = options.hash;\n            }\n            if(options.refHash){\n                this._refHash = options.refHash;\n            }\n        }\n        this._registeredComponentClass = Object.assign({},ComponentRegistry._defaultComponents);\n        this._registeredCeComponentClass = Object.assign({},ComponentRegistry._defaultCeComponents);\n        this._registered = true;\n        this.prototype.registeredHelpers = Object.assign({},ComponentRegistry._defaultHelpers,this._beforeRegisteredHelpers ? this._beforeRegisteredHelpers : {});\n        this.registeredHelpers = this.prototype.registeredHelpers;\n        this.appendChild = _LC.appendChild;//because of ui comps\n        this.insertAfter = _LC.insertAfter;\n        this.insertBefore = _LC.insertBefore;\n        this.replaceWith = _LC.replaceWith;\n        this.shouldIgnoreDisconnect = _LC.shouldIgnoreDisconnect;\n        this._beforeRegisteredHelpers = {};\n        this._instanceList = [];\n        var registryClassDef = this;\n        ComponentRegistry._registeredRegistries.push({\n            name : registryClassDef.name,\n            class : registryClassDef\n        });\n        if(Compile.needDummyComponentsDiv){\n            _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,this.name);\n        }\n        _LC.setComponentsDiv(_LC.lyteComponentsDiv,this.name);\n        if(registryClassDef.idePlugins){\n            registryClassDef.idePlugins.forEach(function(plugin){\n                plugin(_LC)\n            })\n        }\n        if(this.arrayOverride){\n            _LC.arrayOverride();\n        }\n        let lazyDir = this._lazyRegisterDirectives;\n        if(lazyDir){\n            for(let key in lazyDir){\n                this[key] = lazyDir[key];\n                _LC.updateDirectivesInReg(ComponentRegistry, lazyDir[key], key);\n            }\n        }\n        // if(registryClassDef.Compile.needDummyComponentsDiv){\n        //     _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,this.name);\n        // }\n        /*convert to custom class*/\n        this.Component = (function() {\n            class newC extends ComponentRegistry._componentApis {\n                constructor(){\n                    super();\n                }\n                static register(compName){\n                    compName = compName || _LC.String.dasherize(this.name);\n                    this._registryClass = registryClassDef;\n                    registryClassDef.registerComponent(compName, this);\n                }\n                static unregisterComponent(){\n                    _LC.unregisterComponent.apply(this,arguments);\n                }\n            }newC.__lMod = \"Component\";newC._registryClass = registryClassDef;newC._render = function(){\n                return _LC._render.apply(this,arguments);\n            };\n            return newC;\n        })();\n        this.registerDirective = function(name,directiveClass){\n            var registry = this;\n            if(registry._directivesList[name]){\n                //@Slicer.developmentStart\n                RegistryError.error(\"LC002\", \"Directive\", name, registry.name);\n                //@Slicer.developmentEnd\n                return;\n            }\n            registry._directivesList[name] = directiveClass;\n            directiveClass._registryClass = registry;\n            if(registry._instanciated){\n                registry._instanceList.forEach(function(ins){\n                    directiveClass.actualRegistration(name,directiveClass,ins);\n                })\n            }\n        }\n        /*convert to custom class*/\n        this.CustomElements = (function() {\n            class newCE extends Service {\n                constructor(){\n                    super();\n                }\n                static register(compName){\n                    compName = compName || _LC.String.dasherize(this.name);\n                    this._registryClass = registryClassDef;\n                    registryClassDef.registerCeComponent(compName, this, this.options);\n                }\n            }newCE._registryClass = registryClassDef;\n            return newCE;\n        })();\n    }\n    static registerCeComponent(name,CompClass, options){\n        var registry = this;\n        if(registry._registeredCeComponentClass[name]){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC002\", \"Raw Component\", name, registry.name);\n            //@Slicer.developmentEnd\n            return;\n        }\n        CompClass.activeInstances = 0;\n        registry._registeredCeComponentClass[name] = CompClass;//af move below\n        CompClass._compName = name;\n        CompClass._options = options;\n        if(registry._instanciated){\n            registry._instanceList.forEach(function(ins){\n                registry.registerAllCeComponent({[name] : CompClass},ins);\n            })\n        }\n    }\n    static registerComponent(name,CompClass){\n        var registry = this;\n        if(registry._registeredComponentClass[name] && registry._reRegisteredComponents.indexOf(name) == -1){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC002\", \"Component\", name, registry.name);\n            //@Slicer.developmentEnd\n            return;\n        }\n        CompClass.activeInstances = 0;\n        registry._registeredComponentClass[name] = CompClass;//af move below\n        CompClass._compName = name;\n        if(registry._instanciated){\n            registry._instanceList.forEach(function(ins){\n                registry.registerAllComponent({[name] : CompClass},ins);\n            })\n        }\n    }\n    static unregisterComponent(){\n        _LC.unregisterComponent.apply(this,arguments);\n    }\n    static registerHelper(name,helper){\n        //@Slicer.developmentStart\n        if(ComponentRegistry._defaultHelpers[name]){    \n            console.warn(\"Deprecated : Default helpers of Lyte can't be overrided - \" + name + \"\");\n        }else if(this._registered && this.prototype.registeredHelpers[name] || this._beforeRegisteredHelpers && this._beforeRegisteredHelpers[name]){\n            console.warn(\"Deprecated : Helper named - \" + name + \" is already registered\");\n        }\n        //@Slicer.developmentEnd\n        if(this._registered){\n            this.prototype.registeredHelpers[name] = helper;\n        }else if(this._beforeRegisteredHelpers){\n            this._beforeRegisteredHelpers[name] = helper;\n        }else{\n            this._beforeRegisteredHelpers = {[name] : helper};\n        }\n    }\n    static registerCustomPropHandler(){\n        _LC.registerCustomPropHandler.apply(this,arguments);\n    }\n}\nComponentRegistry.__lMod = \"ComponentRegistry\";\nComponentRegistry._registeredRegistries = [];\nComponentRegistry._definedComponents = {};\nComponentRegistry._definedCeComponents = {};\nComponentRegistry._registeredCommonClass = {};\nComponentRegistry._registeredCommonCeClass = {};\nComponentRegistry.customPropHandlers = [];\nComponentRegistry.customPropRegex = \"\";\nComponentRegistry._defaultHelpers = {};\nComponentRegistry._defaultComponents = {};\nComponentRegistry._defaultCeComponents = {};\nComponentRegistry.globalComponents = [\"lyte-event-listener\",\"import-shadow-style\"];\nComponentRegistry._unRegisteredComponents = [];\nComponentRegistry._reRegisteredComponents = [];\nComponentRegistry._directivesList = {};\nComponentRegistry._registeredDirectivesClass = {};\nComponentRegistry._lazyRegisterDirectives = {};\nComponentRegistry._preLoadedDirectives = {};\n/*convert to custom class*/\nComponentRegistry._componentApis = (function() {\n    class apis extends Service {\n        constructor(){\n            super();\n            this.$ = {\n                validate : function(){\n                    return _LC.validate.apply(this, arguments);\n                },\n                _ins : this\n            }\n        }\n        set(){\n            return _LC.componentSet.apply(this, arguments);\n        }\n        get(){\n            return _LC.componentGet.apply(this, arguments);\n        }\n        throwEvent(){\n            return _LC.throwEvent.apply(this, arguments);\n        }\n        executeMethod(){\n            return _LC.executeMethod.apply(this, arguments);\n        }\n        getData(){\n            return _LC.componentGetData.apply(this, arguments);\n        }\n        setData(){\n            return _LC.componentSetData.apply(this, arguments);\n        }\n        getMethods(){\n            return _LC.componentGetMethods.apply(this, arguments);\n        }\n        setMethods(){\n            return _LC.componentSetMethods.apply(this, arguments);\n        }\n        hasAction(){\n            return _LC.componentHasAction.apply(this, arguments);\n        }\n        getActions(){\n            return _LC.componentGetActions.apply(this, arguments);\n        }\n        getObservers(){\n            return _LC.componentGetObservers.apply(this, arguments);\n        }\n        getApp(){\n            return _LC.getApp.apply(this, arguments);\n        }\n        getAppOrAddon(){\n            return _LC.getAppOrAddon.apply(this, arguments);\n        }\n    }\n    return apis;\n})();\nComponentRegistry.registerAllComponent = function(compClassList, registryInstance) {\n    for(var compName in compClassList){\n        let compClass = compClassList[compName];\n        // if (registryInstance.constructor._reRegisteredComponents.indexOf(compName) == -1 && registryInstance.registeredComponents[compName]) {\n        //     _Lyte.error(\"Component \" + componentName + \" already registered\");\n        //     return;\n        // }\n    if (registryInstance.constructor._definedComponents[compName] && registryInstance.constructor._reRegisteredComponents.indexOf(compName) == -1 && !registryInstance.constructor._unRegisteredComponents[compName]) {\n            //same component class for same reigstry which has multiple registry instance\n            registryInstance.registeredComponents[compName] = true;\n            continue;\n        }\n        compClass._compName = compName;\n        compClass._data = compClass.prototype.data;\n        compClass._actions = compClass.actions();\n        compClass._methods = compClass.methods();\n        compClass.__observers = _LC.executeObservers(compClass);\n        compClass.addRegistries = compClass.prototype.addRegistries;\n        if(compClass._dynamicNodes && compClass._dynamicNodes.length && compClass._dynamicNodes[compClass._dynamicNodes.length-1].type == \"dc\"){\n            compClass.dc = compClass._dynamicNodes.$pop();\n        }\n        compClass._callBacks = {};\n        compClass._observers = [];\n        _LC.updateCustomCrmComponent(compClass);\n        compClass._observedMethodAttributes = compClass._observedMethodAttributes || {};\n        _LC.registerComponent(compName, compClass,registryInstance);\n        registryInstance.registeredComponents[compName] = true;\n        registryInstance._registeredComponents[compName] = compClass;\n    }\n};\nComponentRegistry.registerAllCeComponent = function(compClassList, registryInstance) {\n    for(var compName in compClassList){\n        let compClass = compClassList[compName];\n        if (registryInstance.constructor._definedCeComponents[compName]) {\n            //same component class for same reigstry which has multiple registry instance\n            registryInstance.registeredComponents[compName] = true;\n            continue;\n        }\n        compClass._compName = compName;\n        compClass.addRegistries = compClass.prototype.addRegistries;\n        _LC.registerCeComponent(compName, compClass,registryInstance);\n        registryInstance.registeredCeComponents[compName] = true;\n        registryInstance._registeredCeComponents[compName] = compClass;\n    }\n};\n/*convert to custom class*/\nComponentRegistry.Component = (function() {\n    class newC extends ComponentRegistry._componentApis {\n        constructor(){\n            super();\n        }\n        static register(compName){\n            compName = compName || _LC.String.dasherize(this.name);\n            if(ComponentRegistry.globalComponents.indexOf(compName) != -1){\n                let compClass = this;\n                compClass._registryClass = ComponentRegistry;\n                ComponentRegistry._defaultComponents[compName] = compClass;\n                compClass._compName = compName;\n                compClass.activeInstances = 0;   \n                ComponentRegistry._registeredRegistries.forEach(function(reg){\n                    let registry = reg.class;\n                    registry._registeredComponentClass[compName] = compClass;\n                    if(registry._instanciated){\n                        registry._instanceList.forEach(function(ins){\n                            registry.registerAllComponent({[compName] : compClass},ins);\n                        })\n                    }\n                })\n            }\n            //@Slicer.developmentStart\n            else{\n                RegistryError.error(\"LC003\" , compName);\n            }\n            //@Slicer.developmentEnd\n        }\n    }newC.__lMod = \"Component\";newC._registryClass = ComponentRegistry;\n    return newC;\n})();\nComponentRegistry.addFakeDirective = function(baseClass,name){\n    this._lazyRegisterDirectives[name] = baseClass;\n    this[name] = baseClass;\n    _LC.updateDirectivesInReg(this,baseClass,name);\n};\n/*convert to custom class*/\nclass Component extends ComponentRegistry._componentApis {\n    constructor(){\n        super();\n    }\n    // static _registryClass = registryClassDef;\n    static register(compName, options){\n        var _registryClass = _LC.getRegistryClass(options);\n        if(!_registryClass){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC004\", \"Component\", compName)\n            //@Slicer.developmentEnd\n            return\n        }\n        this._refHash = options.refHash\n        compName = compName || _LC.String.dasherize(this.name);\n        this._registryClass = _registryClass;\n        _registryClass.registerComponent(compName, this);\n    }\n    static unregisterComponent(){\n        _LC.unregisterComponent.apply(this,arguments);\n    }\n}\nComponent.__lMod = \"Component\";\nComponent._render = function(){\n    return _LC._render.apply(this,arguments);\n};\n/*convert to custom class*/\nclass RawComponent extends Service {\n    constructor(){\n        super();\n    }\n    // static _registryClass = registryClassDef;\n    static register(compName, options){\n        var _registryClass = _LC.getRegistryClass(options);\n        if(!_registryClass){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC004\", \"Raw Component\", compName)\n            //@Slicer.developmentEnd\n            return;\n        }\n        this._refHash = options.refHash\n        compName = compName || _LC.String.dasherize(this.name);\n        this._registryClass = _registryClass;\n        _registryClass.registerCeComponent(compName, this, this.options);\n    }\n}\nRawComponent.__lMod = \"RawComponent\";\nclass Helper {\n    static register(name, helper, options){\n        var _registryClass = _LC.getRegistryClass(options);\n        if(!_registryClass){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC004\", \"Helper\", name)\n            //@Slicer.developmentEnd\n            return;\n        }\n        helper._hash = options.hash;\n        helper._refHash = options.refHash;\n        //@Slicer.developmentStart\n        if(ComponentRegistry._defaultHelpers[name]){    \n            console.warn(\"Deprecated : Default helpers of Lyte can't be overrided - \" + name + \"\");\n        }else if(_registryClass._registered && _registryClass.prototype.registeredHelpers[name] || _registryClass._beforeRegisteredHelpers && _registryClass._beforeRegisteredHelpers[name]){\n            console.warn(\"Deprecated : Helper named - \" + name + \" is already registered\");\n        }\n        //@Slicer.developmentEnd\n        if(_registryClass._registered){\n            _registryClass.prototype.registeredHelpers[name] = helper;\n        }else if(_registryClass._beforeRegisteredHelpers){\n            _registryClass._beforeRegisteredHelpers[name] = helper;\n        }else{\n            _registryClass._beforeRegisteredHelpers = {[name] : helper};\n        }\n    }\n}\nHelper.__lMod = \"Helper\";\nfunction arrayUtils(){\n    return _LC.aF.apply(_LC, arguments);\n}\nfunction objectUtils(){\n    return _LC.oF.apply(_LC, arguments);\n}\nfunction set(){\n    return _LC.set.apply(_LC.String, arguments);\n}\nComponentRegistry._registeredComponentClass = {};\nComponentRegistry._registeredCeComponentClass = {};\n// ComponentRegistry.Compile = Compile;\nlet orgArrFns = [\"push\", \"pop\", \"splice\", \"shift\", \"unshift\", \"concat\"];\nfor(let i=0; i<orgArrFns.length; i++){\n    let arrFnName = orgArrFns[i];\n    // Array.prototype[\"$\"+orgArrFns[i]] = Array.prototype[orgArrFns[i]]\n    Object.defineProperty(Array.prototype, \"$\"+arrFnName, {\n        enumerable: false, \n        value : Array.prototype[arrFnName]\n    })\n}\nvar _LC = {\n    validateRenderData : function(data){\n        //@Slicer.developmentStart\n        if( !(data === undefined || data === null || (typeof data == \"object\" && !Array.isArray(data)) ) ){\n            Lyte.warn(\"Invalid data passed to render the component from route.\");\n            // return false;\n        }\n        //@Slicer.developmentEnd\n        return true;\n    },\n    _render : function(object){\n        let compClass = this;\n        ltCf.fromV4Render = true;\n        let oldLyteV4 = ltCf.lyteV4;\n        let outlet = object.outlet;\n        let registryInstance = object.registryInstance;\n        let data = object.data;\n        let options = object.options;\n        if(compClass._registered){\n            if(_LC.validateRenderData(data)){\n                if(data && data.lyteV4){\n                    ltCf.lyteV4 = true;\n                }\n                if(registryInstance){\n                    if(!_LC.isValidReg(registryInstance)){\n                        //@Slicer.developmentStart\n                        ApiError.error(\"LC006\");\n                        //@Slicer.developmentEnd\n                        ltCf.fromV4Render = false;\n                        ltCf.lyteV4 = oldLyteV4\n                        return;\n                    }\n                    let ele = registryInstance.render(compClass,data,outlet,options);\n                    if(object._route){\n                        ele._route = object._route;\n                    }\n                    ltCf.fromV4Render = false;\n                    ltCf.lyteV4 = oldLyteV4\n                    return ele;\n                }else{\n                    let registryClass = compClass._registryClass;\n                    if(registryClass._instanciated && registryClass._instanceList.length){\n                        // if(registryClass._instanceList.length > 1){\n                        //     Lyte.error(\"Registry not instanced for \",compClass.name);\n                        // }else{\n                            let ele = registryClass._instanceList[0].render(compClass, data, outlet, options);\n                            if(object._route){\n                                ele._route = object._route;\n                            }\n                            ltCf.fromV4Render = false;\n                            ltCf.lyteV4 = oldLyteV4\n                            return ele;\n                        // }\n                    }\n                    //@Slicer.developmentStart\n                    else{\n                        ApiError.error(\"LC007\");\n                    }\n                    //@Slicer.developmentEnd\n                }\n            }\n        }\n        //@Slicer.developmentStart\n        else{\n            ApiError.error(\"LC008\");\n        }\n        //@Slicer.developmentEnd\n    },\n    Security : {\n        defaultTags : [\"link-to\"],\n        defaultAttr : [\"yield-name\",\"lt-prop-route\", \"lt-prop-dp\", \"lt-prop-fragment\", \"lt-prop-qp\", \"lt-prop\", \"lt-prop-class\", \"lt-prop-id\", \"lt-prop-rel\", \"lt-prop-title\", \"lt-prop-style\", \"lt-prop-target\",\"lt-prop-td\",\"lt-prop-custom\",\"lt-prop-target\",\"lt-prop-id\",\"lt-prop-class\",\"lt-prop-style\",\"lt-prop-rel\",\"lt-prop-title\"],\n        sanitizeHTML : function(obj){\n            let clean;\n            let divEle = document.createElement(\"div\");\n            let html = obj.html;\n            let instance = obj.instance;\n            // let options = obj.options;\n            let additionalObject = obj.additionalObject ? obj.additionalObject : {};\n            if(instance && Object.keys(instance).length){\n                if(additionalObject && Object.keys(additionalObject).length){\n                    clean = _LC.Security.sanitizeWithConfig(html ,additionalObject, instance);\n                }\n                else{\n                    clean = instance.sanitize(html);\n                }\n            }else{\n                //@Slicer.developmentStart\n                ApiError.error(\"LC009\");\n                //@Slicer.developmentEnd\n                return;\n            }\n            divEle.innerHTML = clean;\n            return divEle;\n        },\n        createSanitizer : function (obb) {\n            _LC.Security.initializeConfig(obb);\n            _LC.Security.addConfig(obb);\n            _LC.Security.addLyteComponents(obb);\n            let instance = ZSEC.HTMLPurifier(obb);\n            instance._GLOBAL_TAGS = obb.GLOBAL_TAGS;\n            instance._GLOBAL_ATTRIBUTES = obb.GLOBAL_ATTRIBUTES;\n            instance._FORBID_TAGS = obb.FORBID_TAGS;\n            instance._FORBID_ATTR = obb.FORBID_ATTR;\n            return instance;\n        },\n        sanitizeWithConfig : function(html , additionalObject, instance){\n            _LC.Security.addGlobalObject(instance,additionalObject);\n            let clean = instance.sanitize(html);\n            _LC.Security.removeGlobalObject(instance,additionalObject);\n            return clean;\n        },\n        initializeConfig : function(obb){\n            if (!obb.GLOBAL_ATTRIBUTES) {\n                obb.GLOBAL_ATTRIBUTES = [];\n            }\n            if (!obb.FORBID_TAGS) {\n                obb.FORBID_TAGS = [];\n            }\n            if (!obb.FORBID_ATTR) {\n                obb.FORBID_ATTR = [];\n            }\n            if (!obb.GLOBAL_TAGS) {\n                obb.GLOBAL_TAGS = [];\n          }\n        },\n        addConfig : function(obb){\n            _LC.Security.defaultAttr.forEach(function(item){\n                obb.GLOBAL_ATTRIBUTES.$push(item);\n            })\n            _LC.Security.defaultTags.forEach(function(item){\n                obb.GLOBAL_TAGS.$push(item);\n            })\n        },\n        removeConfig : function(obb){\n            if(obb && Object.keys(obb) && Object.keys(obb).length > 0){\n                if(obb.GLOBAL_ATTRIBUTES && obb.GLOBAL_ATTRIBUTES.length > 0){\n                    _LC.Security.defaultAttr.forEach(function(item){\n                        var index = obb.GLOBAL_ATTRIBUTES.indexOf(item);\n                        if(index != -1){\n                            obb.GLOBAL_ATTRIBUTES.$splice(index,1);\n                        }\n                    })\n                }\n                if(obb.GLOBAL_TAGS && obb.GLOBAL_TAGS.length > 0){\n                    _LC.Security.defaultTags.forEach(function(item){\n                        var index = obb.GLOBAL_TAGS.indexOf(item);\n                        if(index != -1){\n                            obb.GLOBAL_TAGS.$splice(index,1);\n                        }\n                    })\n                }\n            }\n        },\n        addLyteComponents : function(obb){\n            var globalTagArr = Array.from(obb.GLOBAL_TAGS);\n            var attr = [];\n            for(var a=0; a<globalTagArr.length; a++){\n                let regComps = ComponentRegistry._registeredCommonClass;\n                if(regComps[globalTagArr[a]]){\n                    attr = regComps[globalTagArr[a]].observedAttributes;\n                }else if(Lyte.registeredCustomComponent[globalTagArr[a]]){\n                    if(Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes){\n                        attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;\n                    }\n                }\n                for(var i=0; i<attr.length; i++){\n                    if(obb.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){\n                        obb.GLOBAL_ATTRIBUTES.$push(attr[i]);\n                    }\n                }\n            }\n        },\n        addGlobalObject : function(instanceObj,additionalObj){\n            for (var property in additionalObj) {\n                    if(Array.isArray(additionalObj[property])){\n                        additionalObj[property].forEach(function(item){\n                            if(instanceObj[\"_\"+property].indexOf(item) == -1){\n                                instanceObj[\"_\"+property].$push(item);\n                            }\n                        });\n                }\n            }\n        },\n        removeGlobalObject : function(instanceObj,additionalObj){\n            for (var property in additionalObj) {\n                if(Array.isArray(additionalObj[property])){\n                    additionalObj[property].forEach(function(item){\n                        var index = instanceObj[\"_\"+property].indexOf(item);\n                        if(index != -1){\n                            instanceObj[\"_\"+property].$splice(index,1);\n                        }\n                    });\n            }\n            };\n        }\n    },\n    toBeRegistered : [],\n    getRegistryClass : function(options){\n        let registryClass;\n        ComponentRegistry._registeredRegistries.forEach(function(obj){\n            let reg = obj.class;\n            if(reg._hash == options.refHash){\n                registryClass = reg;\n                return\n            }\n\n        })\n        return registryClass;\n    },\n    \"setCurrentRegistryIns\" : function(currentReg){\n        _LC._currentRegistryInstance = currentReg;\n    },\n    \"setCurrentRegistry\" : function(reg){\n        _LC._currentRegistry = reg;\n    },\n    \"getCurrentRegistryIns\" : function(){\n        return _LC._currentRegistryInstance;\n    },\n    \"getCurrentRegistry\" : function(){\n        return _LC._currentRegistry;\n    },\n    \"getDecidedRegistry\" : function(){\n        return _LC._decidedRegistry;\n    },\n    \"setDecidedRegistry\" : function(reg){\n        _LC._decidedRegistry = reg;\n    },\n    \"setDefaultRegistry\" : function(reg){\n        _LC._defaultRegistry = reg;\n    },\n    \"setDefaultRegistryIns\" : function(regIns){\n        _LC._defaultRegistryIns = regIns;\n    },\n    \"getDefaultRegistryIns\" : function(){\n        return _LC._defaultRegistryIns;\n    },\n    \"getDefaultRegistry\" : function(){\n        return _LC._defaultRegistry;\n    },\n    \"setAddedRegistries\" : function(scope,scopeName){\n        let addedRegistries = scope.addRegistries ? scope.addRegistries.apply(scope) : [];\n        if(addedRegistries){\n            let validReg = _LC.validateArrRegistry(addedRegistries,scopeName);\n            scope.addedRegistries = validReg ? addedRegistries : [];\n        }else{\n            scope.addedRegistries = [];\n        }\n    },\n    \"validateArrRegistry\" : function(arr , moduleName){\n        for(let i=0; i<arr.length; i++){\n            if(!_LC.validateRegistry(arr[i],moduleName)){\n                return false;\n            }\n        }\n        return true;\n    },\n    \"isValidReg\" : function(reg){\n        return reg && reg.isComponentRegistry && reg.isComponentRegistry()\n    },\n    \"validateRegistry\" : function(reg,moduleName){\n        if(!_LC.isValidReg(reg)){\n            let name =  reg ? reg.constructor ? reg.constructor.name : reg : reg ;\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC005\", name, moduleName);\n            //@Slicer.developmentEnd\n            return false;\n        }\n        return true;\n    },\n    \"getApp\" : function(node){\n        if(node){\n            return node.$app ? node.$app : node.$addon.$app;\n        }else{\n            return this.$app ? this.$app : this.$addon.$app;\n        }\n    },\n    \"getNearestParentApp\" : function(node){\n        if(!node){\n            node = this;\n        }\n        while(node){\n            if(node.$app){\n                app = node.$app;\n                break;\n            }\n            else if(node.$addon){\n                if(node.$addon.$app){\n                    app = node.$addon.$app\n                    break;\n                }\n            }\n            node = node.$addon;\n        }\n        return app;\n    },\n    \"getAppOrAddon\" : function(node){\n        // node can be component or registry\n        node = node ? node : this;\n        if(node){\n            return node.$app ? node.$app : node.$addon;\n        }\n    },\n    \"migratedv2\" : function(app){\n        if((app.constructor._migration && app.constructor._migration.version == \"2\") || (app.constructor.__slyteApp)){\n            return true;\n        }\n    },\n    \"updateDirectivesInReg\" : function(self,dClass,name){\n        self._registeredRegistries.forEach(function(regObj){\n            let regClass = regObj.class;\n            if(regClass._instanciated){\n                regClass._instanceList.forEach(function(regIns){\n                    let directiveIns;\n                    let app = _LC.getAppOrAddon(regIns);\n                    app.scopedInstance(dClass,[regIns],function(ins){\n                        directiveIns = ins;\n                    },[])\n                    regIns[\"_\"+name] = directiveIns;\n                    regIns._defaultDirectives.push(name);\n                })\n            }\n        })\n    },\n    \"updateDomApis\" : function(regIns){\n        regIns.appendChild = _LC.appendChild;\n        regIns.insertAfter = _LC.insertAfter;\n        regIns.insertBefore = _LC.insertBefore\n    },\n    \"getMyScope\" : function(node){\n        if(node.$app){\n            return node.$app;\n        }else if(node.$addon){\n            return node.$addon;\n        }\n    },\n    \"setComponentsDiv\" : function(template,name){\n        let div = createElement(\"div\");\n        div.setAttribute(\"id\",name);\n        template.appendChild(div);\n        return div;\n    },\n    \"getComponentsDiv\" : function(template,name){\n        return template.querySelector(\"#\"+name);\n    },\n    \"getCompRegistry\" : function(obj,self){\n        var initProp = self._initProperties;\n        if((initProp && initProp.lyteRegistry) || (self.hasAttribute(\"lyte-registry\"))){\n            var reg = initProp.lyteRegistry || self.getAttribute(\"lyte-registry\");\n            var registryMap = new WeakMap();\n            if(this.checkInRegistry(reg,obj,registryMap)){\n                return;\n            }\n        }\n        var currentReg = _LC.getCurrentRegistryIns();\n        if(currentReg){\n            this.traverseRegistries([currentReg],obj,self);\n        }else{\n            let defRegIns = _LC.getDefaultRegistryIns();\n            if(defRegIns){\n                this.traverseRegistries([defRegIns],obj,self);    \n            }else{\n                let defaultReg = _LC.getDefaultRegistry();\n                let defaultRegInsArr = defaultReg._instanceList;\n                this.traverseRegistries(defaultRegInsArr,obj,self);\n            }\n        }\n    },\n    \"verifyDetails\" : function(obj){\n        var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;\n        if(!lIns || !compClass || !regIns){\n            return false;\n        }\n        return true;\n    },\n    \"isValidateLyteReg\" : function(reg,registryMap){\n        if(!_LC.isValidReg(reg)){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC006\", reg.constructor.name);\n            //@Slicer.developmentEnd\n            return false;\n        }else if(registryMap.get(reg)){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC007\", reg.constructor.name);\n            //@Slicer.developmentEnd\n            return false;\n        }\n        registryMap.set(reg,reg);\n        return true;\n    },\n    \"checkInRegistry\" : function(registry,obj,registryMap){\n        if(this.isValidateLyteReg(registry,registryMap)){\n            obj.compClass = obj.type == \"component\" ? registry.constructor._registeredComponentClass[obj.compName] : registry.constructor._registeredCeComponentClass[obj.compName];\n            if(obj.compClass){\n                obj.regIns = registry;\n                obj.lIns = registry.$app ? registry.$app : registry.$addon;\n                return true;\n            }else{\n                if(registry.addedRegistries){\n                    let addedReg = registry.addedRegistries;\n                    for(let i=0; i<addedReg.length; i++){\n                        if(this.checkInRegistry(addedReg[i],obj,registryMap)){\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"iterateRegistries\" : function(baseRegistryArr,obj,registryMap){\n        for(let i=0; i<baseRegistryArr.length; i++){\n            if(this.checkInRegistry(baseRegistryArr[i],obj,registryMap)){\n                return true;\n            }\n        }\n    },\n    \"traverseRegistries\" : function(baseRegistryArr,obj,self){\n        let registryMap = new WeakMap();\n        if(this.iterateRegistries(baseRegistryArr,obj,registryMap)){\n            return\n        }\n        let parentComp = self._callee || self.getCallee && self.getCallee(self.parentNode);\n        if(!parentComp){\n            return;\n        }\n        while(parentComp){\n            let parentCompReg = parentComp.$registry;\n            registryMap = new WeakMap();\n            if(this.checkInRegistry(parentCompReg,obj,registryMap)){\n                return;\n            }\n            if(parentComp.component.addedRegistries){\n                let pcAddedReg = parentComp.component.addedRegistries;\n                for(let i=0; i<pcAddedReg.length; i++){\n                    registryMap = new WeakMap();\n                    if(this.checkInRegistry(pcAddedReg[i],obj,registryMap)){\n                        return;\n                    }\n                }\n            }\n            parentComp = parentComp._callee || parentComp.getCallee && parentComp.getCallee(parentComp.parentNode);\n        }\n        \n    },\n    \"getCommonClass\" : function(componentName){\n        var customCrmComponent = ComponentRegistry._registeredCommonClass[componentName];\n        return customCrmComponent;\n    },\n    \"getCommonCustomClass\" : function(componentName){\n        var customCrmComponent = ComponentRegistry._registeredCommonClass[componentName];\n        return customCrmComponent;\n    },\n\n    \"registerCeComponent\" : function(componentName, componentClass, registryInstance){\n        let customLyteCustomComponent;\n        let registry = componentClass._registryClass;\n        let registryName = registry.name;\n        if(registryInstance.registeredCeComponents[componentName] && ComponentRegistry._registeredCommonCeClass[componentName]._reg[registryName]) {\n            customLyteCustomComponent = this.getCommonCustomClass(componentName,registryName);\n        }else{\n            customLyteCustomComponent = class extends LyteCustomElement {\n                constructor(){\n                    super()\n                }\n            }\n            customLyteCustomComponent._observedAttributes = componentClass.observedAttributes || [];\n            customLyteCustomComponent._deepWatchProperties = componentClass._deepWatchProperties || {};\n            registryInstance.registeredCeComponents[componentName] = true;\n            if (document.readyState === \"complete\" || document.readyState === \"interactive\") {     \n                customElements.define(componentName, customLyteCustomComponent, undefined, {v4raw : true});\n            }\n            else{\n                _LC.toBeRegistered.$push({name:componentName, def: customLyteCustomComponent, _lyteOptions : {v4raw : true} });//af check\n            }\n            ComponentRegistry._definedCeComponents[componentName] = customLyteCustomComponent;\n            componentClass._instanciated = true;\n            componentClass._registered = true;\n            ComponentRegistry._registeredCommonCeClass[componentName] = customLyteCustomComponent;\n            registry._registeredCeComponentClass[componentName] = componentClass;\n        } \n    },\n    \"validate\" : function() {\n        var compInstance = this._ins;\n        var data = compInstance.data;\n        for(var key in data) {\n            _LC.handleValidation(data, key, data[key], compInstance);\n        }\n    },\n    \"registerComponent\" : function(componentName,componentClass,registryInstance) {\n        let customCrmComponent;\n        let alreadyRegistered;\n        let registry = componentClass._registryClass;\n        let registryName = registry.name;\n        if(registryInstance.registeredComponents[componentName] && ComponentRegistry._registeredCommonClass[componentName]._reg[registryName]) {\n            //think this place wont be called need to remove this check\n            customCrmComponent = this.getCommonClass(componentName, registryName);\n        }\n        else if(ComponentRegistry._unRegisteredComponents[componentName]){\n            customCrmComponent = this.getCommonClass(componentName);\n            delete ComponentRegistry._unRegisteredComponents[componentName];\n            alreadyRegistered = true;\n        }\n         else {\n            customCrmComponent = class extends customElementPrototype {\n                constructor(){\n                    super()\n                }\n            }\n            registryInstance.registeredComponents[componentName] = true;\n            customCrmComponent._reg = {[registryName] : {}};\n            customCrmComponent._depthTemp = document.createElement(\"template\");//af check\n            customCrmComponent.prototype.throwAction = this.throwAction;\n            customCrmComponent._compName = componentName;\n            Object.defineProperty(customCrmComponent.prototype, \"setData\", {\n                configurable : true, \n                writable : true,\n                value : function(arg0, arg1 ,options) {\n                    return this.component.setData(arg0, arg1, options);\n                }\n            });\n\n            Object.defineProperty(customCrmComponent.prototype, \"getData\", {\n                configurable : true, \n                writable : true,\n                value : function(arg0) {\n                    return this.component.getData(arg0);\n                }\n            });\n\n            Object.defineProperty(customCrmComponent.prototype, \"setMethods\", {\n                configurable : true, \n                writable : true, \n                value : function(arg0, arg1) {\n                    return this.component.setMethods(arg0, arg1);\n                }\n            })\n            customCrmComponent.prototype.get = this.nodeGet;\n            customCrmComponent.prototype.set = this.nodeSet;\n        }\n        if(componentClass.ssr){\n            customCrmComponent._ssr = componentClass.ssr();\n            if(customCrmComponent._ssr.config){\n                customCrmComponent._config = customCrmComponent._ssr.config;\n            }\n        }\n\n        customCrmComponent.componentClass = componentClass;\n        var Component;\n        if(ComponentRegistry._registeredCommonClass[componentName]){\n            Component = ComponentRegistry._registeredCommonClass[componentName].component;\n            Component.list.push(componentClass);\n        }else{\n            Component = {list : [componentClass]};\n        }\n        componentClass._v4 = true;\n        customCrmComponent.component = Component;\n        customCrmComponent._observedAttributes = componentClass._observedAttributes || [];\n        customCrmComponent._deepWatchProperties = componentClass._deepWatchProperties || {};\n        // if(!componentClass._registered){\n            customCrmComponent._registerComponent(\n                componentName,\n                customCrmComponent,\n                componentClass,\n                registry,\n                registryInstance\n            );\n        // }\n        customCrmComponent._bindsIds = [];\n        if(!ComponentRegistry._definedComponents[componentName]) {\n            if (document.readyState === \"complete\" || document.readyState === \"interactive\") {     \n                customElements.define(componentName, customCrmComponent, undefined, {v4 : true});\n            }\n            else{\n                _LC.toBeRegistered.$push({name:componentName, def: customCrmComponent, _lyteOptions : {v4 : true}});\n            }\n        }\n        ComponentRegistry._definedComponents[componentName] = customCrmComponent;\n        let depthTemp = customCrmComponent._depthTemp;\n        if(depthTemp && depthTemp.content.childNodes.length) { //removed _ie\n            depthTemp.setAttribute(\"data-id\", \"depthTemp_\" + componentName);\n            let lyteComponentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv,registry.name);\n            lyteComponentsDiv.appendChild(depthTemp);\n        } else {\n            delete customCrmComponent._depthTemp;\n        }\n        componentClass._instanciated = true;\n        componentClass._registered = true;\n        ComponentRegistry._registeredCommonClass[componentName] = customCrmComponent;\n        registry._registeredComponentClass[componentName] = componentClass;\n        if(alreadyRegistered) {\n            var pendingComps = customCrmComponent._pendingComponents || [];\n            pendingComps.forEach(function(item) {\n                delete item.__lyteIgnore \n                item.actualConstructor();\n                var arr = Array.from(item.attributes);\n                arr.forEach(function(attr) {\n                    if(item.constructor.observedAttributes.indexOf(attr.name) != -1) {\n                        item.attributeChangedCallback(attr.name, null, attr.value);\n                    }\n                    \n                });\n                item.connectedCallback();\n            });\n            customCrmComponent._pendingComponents = [];\n        }\n        return customCrmComponent;\n    },\n    // \"_lyteInstance\": Lyte,\n    \"shadow\" : {\n        \"getHostElement\" : function(node){\n            if(node){\n                let host = node.host;\n                if(host && host.tagName){\n                    return host;\n                }\n            }\n        },\n        \"stringToStyle\" : function(str){\n            var wrapper = document.createElement(\"wrapper\");\n            wrapper.innerHTML = str;\n            return wrapper.firstChild;\n        },\n    },\n    \"directive\" : {\n        setTagDirectives : function(compClass,comp){\n            if(compClass._lyteOptions && compClass._lyteOptions.attributes && compClass._lyteOptions.attributes.length){\n                let attr = compClass._lyteOptions.attributes;\n                for(let i=0; i<attr.length; i++){\n                    if(typeof attr[i] == \"object\"){\n                        if(attr[i].name.startsWith(\"@\")){\n                            comp._tagDirectives.push(attr[i]);\n                            compClass._lyteOptions.attributes.splice(i,1);\n                            i--;\n                        }\n                    }else{\n                        if(attr[i].startsWith(\"@\")){\n                            comp._tagDirectives.push(attr[i]);\n                            compClass._lyteOptions.attributes.splice(i,1);\n                            i--;\n                        }\n                    }\n                }\n            }\n        },\n        checkSameAttrName : function(arr,directiveName,arg){\n            let duplicateFound;\n            arr.forEach(function(attr){\n                if(attr.hookName == directiveName && arg){\n                    attr.stringValue = arg;\n                }\n            })\n            return duplicateFound;\n        },\n        isDirectiveNode : function(node){\n            if(node.hookNode || (node.nodeName && node.nodeName.startsWith(\"@\")) || node._isDirectiveNode){\n                return true;\n            }\n            return false;\n        },\n        getActualTransitionArg : function(attr,node){\n            if(attr.hasOwnProperty(\"dynamicValue\") || attr.hasOwnProperty(\"helperInfo\")){\n                if(node.hasOwnProperty(\"_transitionArgs\")){\n                    if(node._transitionArgs.hasOwnProperty(attr.hookName)){\n                        return node._transitionArgs[attr.hookName];\n                    }\n                }\n            }else if(attr.hasOwnProperty(\"stringValue\")){\n                if(attr.hasOwnProperty(\"stringValue\")){\n                    if(attr.stringValue === \"\"){\n                        return true\n                    }if(attr.stringValue === \"true\"){\n                        return true\n                    }else if(attr.stringValue === \"false\"){\n                        return false\n                    }else{\n                        return attr.stringValue;\n                    }\n                }\n            }\n        },\n        getTransitionArg : function(node,directiveName){\n            let transitionArg;\n            if(node.component && node.component.constructor._options){\n                this.setAttrFromRender(node);\n            }\n            var self = this;\n            if(node._specialAttributeDetails){\n                node._specialAttributeDetails.forEach(function(attr){\n                    if(directiveName == attr.hookName){\n                        transitionArg = self.getActualTransitionArg(attr,node);\n                        return;\n                    }\n                })\n            }\n            return transitionArg;\n        },\n        setAttrFromRender : function(comp,tagDirectives){\n            if(tagDirectives.length){\n                if(!comp._specialAttributeDetails){\n                    comp._specialAttributeDetails = [];\n                }\n                var self = this;\n                tagDirectives.forEach(function(directiveName){\n                    if(self.checkSameAttrName(comp._specialAttributeDetails,directiveName,directiveName.value)){\n                        return;\n                    }\n                    let attr;\n                    if(typeof directiveName == \"string\"){ \n                        attr = {\n                            hookName : directiveName.slice(1,directiveName.length),\n                            hookNode : true,\n                            name : directiveName,\n                            stringValue : \"\"\n                        }   \n                    }else{\n                        attr = {\n                            hookName : directiveName.name.slice(1,directiveName.name.length),\n                            hookNode : true,\n                            name : directiveName.name,\n                            stringValue : directiveName.value\n                        }\n                    }\n                    comp._specialAttributeDetails.push(attr)\n                })\n            }\n        },\n        setNodeArgs : function(node,nodeValue){\n            // node.ownerElement._transitionArgs = nodeValue;\n            let nodeName = node.nodeName;\n            node.ownerElement.removeAttribute(nodeName);\n            // node.nodeName = node.nodeName.slice(1,node.nodeName.length);\n            if(!node.ownerElement._transitionArgs){\n                node.ownerElement._transitionArgs = {};\n            }\n            let actNodeName = nodeName\n            if(nodeName.startsWith(\"@\")){\n                actNodeName = nodeName.slice(1,nodeName.length);\n            }\n            node.ownerElement._transitionArgs[actNodeName] = nodeValue;\n            node.ownerElement.setAttribute(\"lyte-directive-\" + actNodeName,\"\");\n        }\n    },\n    \"fRP\" : {},\n    \"fRC\" : 0,\n    // \"frcUnused\" : [],\n    \"customPropRegex\" : \"\",\n    // \"pushFrc\" : function(fastRenderIndex) {\n    //     this.frcUnused.$push(fastRenderIndex);\n    //     delete _LC.fRP[fastRenderIndex];\n    // },\n    // \"getFrc\" : function() {\n    //     let frcIndex;\n    //     if(this.frcUnused.length) {\n    //         frcIndex = this.frcUnused.$shift()\n    //     } else {\n    //         frcIndex = this.fRC++;\n    //     }\n    //     return frcIndex;\n    // },\n    \"customPropHandlers\" : [],\n    \"_registeredComponents\" : {},\n    // \"_reRegisteredComponents\" : [],\n    // \"toBeRegistered\" : [],\n    \"updateCustomCrmComponent\" : function(componentClass){\n        var def = componentClass.__observers;\n        for(let key in def) {\n            if (def[key] && def[key].type === \"observer\") {\n                def[key].fnName = key;\n                componentClass._observers.$push(def[key]);\n            } else if (def[key] && def[key].type === \"callBack\") {\n                var props = def[key].properties;\n                for (var k = 0; k < props.length; k++) {\n                    if (!componentClass._callBacks[props[k]]) {\n                        componentClass._callBacks[props[k]] = [];\n                    }\n                    def[key].fnName = key;\n                    componentClass._callBacks[props[k]].$push(def[key]);\n                }\n                if (def[key].observes) {\n                    def[key].observes.fnName = key;\n                    componentClass._observers.$push(def[key].observes);\n                }\n            }\n        }\n        // delete orgDef.observers;\n        // for (let key in orgDef) {\n        //     componentClass.prototype[key] = orgDef[key];\n        // }\n        // return orgDef;\n    },\n    // \"dataFromMixin\" : function(mixinsToBeUsed,actionsFromMixin,methodsFromMixin,newDefinition){\n    //     var mixinslen = mixinsToBeUsed.length;\n    //     for(let i=0; i<mixinslen ; i++) {\n    //         for(let item in mixinsToBeUsed[i]){\n    //             if(item === \"actions\") {\n    //                 Object.assign(actionsFromMixin, mixinsToBeUsed[i][item]);    \n    //             } else if(item === \"methods\") {\n    //                 Object.assign(methodsFromMixin, mixinsToBeUsed[i][item]);    \n    //             } else {\n    //                 newDefinition[item] = mixinsToBeUsed[i][item];\n    //             }\n    //         }\n    //     }\n    //     return{\"actionsFromMixin\":actionsFromMixin,\"methodsFromMixin\":methodsFromMixin,\"newDefinition\":newDefinition}\n    //   },\n    \"throwEvent\" : function(eventName){\n        let self = this.$node ? this.$node : this;\n        const evt = self._actions? self._actions[eventName] : undefined; \n        let customArgs = [];        \n        if(arguments.length > 1){        \n            for(let i=1;i<arguments.length; i++){            \n                customArgs.$push(arguments[i]);                \n                }        \n            }\n            //wait for release\n            //eventName = _LC.String.toCamelCase(eventName);\n            _LC.throwAction.call(self, self._callee, eventName, undefined, true, customArgs, self);\n        if(this.$node) {\n            self.dispatchEvent(evt? evt : new CustomEvent(eventName, {\"detail\" : customArgs}));\n        }\n    },\n    //this and scope reference should be either a node or a route.\n    \"throwAction\" : function(scope,eventName,actObj,isCustom,customArgs, node, event, hasHandled, fromEv){\n        let actionsObj;\n        let app = _LC.getNearestParentApp(this.component);\n        if(this._route && isCustom) {\n            // scope = Lyte.Router.getRouteInstance(this._route);\n            scope = app.$.modules.router[0].getRouteInstance(this._route)//.__lp.fns;\n            var fns = scope.__lp.fns;\n            actionsObj = fns.actions || (fns.actions = {});\n        } else if(this.routeName) {\n            //process for the parent route and get the current component and proceed;\n            let parentRoute = this.parent;\n            if(parentRoute) {\n                if(parentRoute.component && parentRoute.component.component) {\n                    scope = parentRoute.component;\n                    actionsObj = scope.component.constructor._actions; \n                } else {\n                    scope = parentRoute;\n                    // actionsObj =  scope.actions || (scope.actions = {});            \n                    var fns = scope.__lp.fns;\n                    actionsObj = fns.actions || (fns.actions = {});\n                }\n            }\n        } else if(scope){\n                actionsObj = scope.component.constructor._actions\n        }\n        if(!scope) {\n            //Only warning is thrown because, we can have a eventListener for the dom directly. \n            //@Slicer.developmentStart\n            if(!hasHandled) {\n                Lyte.warn(\"Nothing handled the action \"+ eventName + \".\");    \n            }\n            //@Slicer.developmentEnd\n            return;\n        }\n        actObj = (actObj) ? actObj : this._actions && this._actions[eventName]? this._actions[eventName].processAction : void 0;     \n        //wait for release\n        /* \n        var dasherizedEventName = _LC.String.dasherize(eventName);\n        actObj = (actObj) ? actObj : this._actions && this._actions[dasherizedEventName]? this._actions[dasherizedEventName].processAction : void 0;     \n        */\n        let args = customArgs ? customArgs : [];\n        if(actObj){\n            var contextSwitchArray = [];\n            if(node) {\n                _LC.adCx(node, contextSwitchArray);\n            }\n            let concatArgs;\n            if(actObj.skipArgProcessing) {\n                // concatArgs = deepCopyObject(actObj.args);\n                // concatArgs.$shift();\n                // var eventIndex = concatArgs.indexOf(\"__lyteEvent__\");\n                // var nodeIndex = concatArgs.indexOf(\"__lyteNode__\");\n                // if(eventIndex !== -1) {\n                //     concatArgs[eventIndex] = event;\n                // } \n                // if(nodeIndex !== -1) {\n                //     concatArgs[nodeIndex] = target;\n                // }\n                concatArgs = actObj.args;\n            } else {\n                concatArgs = this.processArgs(scope,{\"helperInfo\" : actObj}, undefined, event, node);\n            }\n            args.$splice.apply(args, [0,0].$concat(concatArgs) );\n            if(node) {\n                _LC.rmCx(node, contextSwitchArray);\n            }\n            if(actionsObj[actObj.name]){\n                if(!isCustom){  \n                    //args.$unshift(window.event);\n                    let parent = node.parentNode;\n                    let val = actionsObj[actObj.name].apply(this.component,args);\n                    if(event.currentTarget !== document.body && !_LCSD.getHostElement(event.currentTarget) && !fromEv) {\n                        val = false;\n                    }\n                    hasHandled = true;\n                    if(val !== false && !event.cancelBubble){\n                        if(actObj.from && node.getAttribute(event.type) && node._boundEvents && node._boundEvents[event.type]) {\n                            let actions = node._callee.component.constructor._actions;\n                            let actObj = node._boundEvents[event.type];\n                            let cloneActObj = deepCopyObject(actObj);\n                            // cloneActObj.args.$shift();\n                            _LC.skipArgProcessing(cloneActObj, event, node);\n                            _LC.throwAction.call(node._callee,node._callee,event.type,cloneActObj, undefined, undefined, node, event, hasHandled);\n                        } else {\n                            if(_LC.hasLyteEvents(node, eventName)) {\n                                let eventStopped = _LC.handleLyteEvents(node, event);\n                                val = eventStopped ? false : true;       \n                            }\n                            if(val === false) {\n                                return;\n                            }\n                            if(_LC.isCustomElement(node)){\n                                scope = parent;\n                            }\n                            if(parent){\n                                let eventStopped;\n                                while(parent && !_LCSD.getHostElement(parent) && (!parent.getAttribute(eventName) || parent.hasAttribute(\"disabled\") ) && parent.tagName != \"BODY\"){\n                                    if(_LC.hasLyteEvents(parent, eventName)) {\n                                        eventStopped = _LC.handleLyteEvents(parent, event);\n                                        if(eventStopped) {\n                                            break;\n                                        }\n                                    }\n                                    parent = parent.parentNode;\n                                }\n                                if(eventStopped || !parent || parent.tagName === \"BODY\"){\n                                    return;\n                                }\n                                if(!parent._callee){\n                                    parent._callee = parent.getCallee ? parent.getCallee(parent) : _LC.getCallee(parent);\n                                }\n                                if(parent && event.type === eventName && !event.cancelBubble){\n                                   if(parent._evBoundEvents && parent._evBoundEvents[eventName]) {\n                                       let actObj = parent._evBoundEvents[eventName];\n                                       let cloneActObj = deepCopyObject(actObj);\n                                    //    cloneActObj.args.$shift();\n                                        _LC.skipArgProcessing(cloneActObj, event, parent);\n                                       _LC.throwAction.call(parent,parent,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  \n                                   } else if(parent && parent._boundEvents && parent._boundEvents[eventName]) {\n                                       let actObj = parent._boundEvents[eventName];\n                                       let cloneActObj = deepCopyObject(actObj);\n                                       _LC.skipArgProcessing(cloneActObj, event, parent);\n                                       _LC.throwAction.call(parent._callee,parent._callee,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  \n                                   }\n                                }\n                            }\n                        }\n                    }\n                }            \n                else{                \n                    actionsObj[actObj.name].apply(this._callee.component,args);\n                    hasHandled = true;                                             \n                } \n            }\n            //@Slicer.developmentStart\n            else{\n                ComponentError.error(app, \"LC004\" , actObj.name);\n            }\n            //@Slicer.developmentEnd\n        } else if(isCustom) {\n            var eventsObj = actionsObj[eventName]  || actionsObj[_LC.String.toCamelCase(eventName)] || actionsObj[_LC.String.dasherize(eventName)];\n            if(eventsObj) {\n                var scopeS = _LC.isCustomElement(scope) ? scope.component : scope;   \n                let val = eventsObj.apply(scopeS, args);\n                //let val = eventsObj.apply(_LC.isCustomElement(scope)? scope.component : scope, args);\n                hasHandled = true;\n                if(val !== false) {\n                    _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);\n                }\n            } else {\n                _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);\n            }\n        }\n        \n    },\n    \"isControlHelper\" : function(ownerElement) {\n        return (ownerElement.tagName === \"TEMPLATE\" && ownerElement.getAttribute(\"is\") && ownerElement.getAttribute(\"is\") !== \"component\") || (ownerElement.hasAttribute(\"lyte-for\") || ownerElement.hasAttribute(\"lyte-if\") || ownerElement.hasAttribute(\"lyte-switch\") || ownerElement.hasAttribute(\"lyte-forin\"));\n    },\n    \"isCustomElement\" : function(node, isTemplate) {\n        return node.hasAttribute && ((( node.tagName ===\"TEMPLATE\" || node.attributes[\"lyte-for\"] || node.attributes[\"lyte-if\"] || node.attributes[\"lyte-switch\"] || node.attributes[\"lyte-forin\"] ) && isTemplate )  || (node.nodeName && node.nodeName.indexOf('-') !== -1 && (ComponentRegistry._registeredCommonClass[node.localName] || node.tagName === \"LYTE-YIELD\")));\n    },\n    \"componentSet\" : function(key, value, options, forceExecute, fromParent) {\n        if(!forceExecute && this.get(key) === value) {\n            _LC.clearError(this.data, key);\n            //@Slicer.developmentStart\n            if(!fromParent){\n                if(typeof value == \"object\"){\n                    Lyte.warn(\"The data passed to update '\" + key + \"' is the same reference of the actual data. So component bindings won't be updated.\");\n                }\n            }\n            //@Slicer.developmentEnd\n            return;\n        }\n        //temporary fix\n        _LC.set(this.data, key, value, options, undefined, fromParent);\n    },\n    \"componentGet\" : function(key) {\n        return key ? _LC.get(this.data, key) : this.data;\n    },\n    \"nodeGet\" : function(key) {\n        return key ? this.component.get(key) : this.component.data;\n    },\n    \"nodeSet\" : function(key, value, options, fromParent) {\n        this.component.set(key, value, options, undefined, fromParent);\n    },\n    \"registerMixin\" : function(name,mixin){\n        Lyte.Mixin.register.call(Lyte, name, mixin);\n    },\n    \"sendtoclient\": function(prop,server,node){\n        var data = server ? prop.component.data : prop;\n        var newData = {};\n        var data_prop = node;\n        for (var i in data){\n            if(server){\n                var def = prop.component.__data[i];\n                if(i == \"bindIds\"){ \n                    newData[i] = {value : data[i] }\n                }\n                    if(def && /^(object|array)$/.test(def.type) && prop._attributeDetails && prop._attributeDetails.hasOwnProperty(_LC.String.dasherize(i))){\n                        newData[i] = { \"fP\" : true };\n                    }\n                    else if(data[i] instanceof Date){\n                        newData[i] = { \"value\" : data[i] , \"type\" : \"Date\" }\n                    }\n                    else if(data_prop[i]){\n                        newData[i] = { \"value\" : data[i] , \"type\" : data_prop[i].type }\n                    }else{\n                        var type = typeof(data[i])\n                        if(data[i] == undefined){\n                            type = undefined;\n                        }\n                        newData[i] = {\"value\" : data[i] ,\"type\":type}\n                    }\n            }else{\n                if(data[i].type==\"Date\"){\n                    newData[i] = new Date(data[i].value);\n                }\n                else if(!data[i].fP){\n                    newData[i]= data[i].value;\n                }\n            }\n        }\n        return newData;        \t\n    },\n    \"typeCast\" : function(value, dataType, obj) {\n        if(value === null) {\n            return value;\n        }\n        try {\n            switch(dataType) {\n            case \"string\" : \n                return typeof value === \"object\" ? JSON.stringify(value) : value.toString(); \t\n            break;\n            case \"number\" :\n                {\n                if(value == \"\") {\n                    return undefined;\n                }\n                let val = +value;\n                if(isNaN(val)) {\n                    throw \"TypeCast exception\";\n                } \n                return val;\n                }\n            break;\n            case \"array\" : \n            case \"object\" :\n                return JSON.parse(value);\n                break;\n            case \"boolean\" :\n                return ( (!value && value !== \"\") || value=== \"false\") ? false : true; \n            break;\n            default : \n                return value;\n            }\n        } catch(e) {\n            if(obj) {\n                obj.isError = true;\n            }\n            return value;\n        }\n        \n    },\n    \"getDataType\" : function(value) {\n        var type = typeof value;\n        if(type === \"object\") {\n            if(Array.isArray(value)) {\n                return \"array\";\n            }\n        }\n        return type;\n    },\n    \"handleValidation\" : function(object, property, value, component ,init) {\n        let error = validateData(object, property, value, component ,this._lyteInstance ,init);\n        if(error) {\n            _LC.set(component.data.errors, property, error);\n            if(component.$node.callback) {\n                component.$node.callback(\"onError\", property, error);\n            }\n        } else {\n            _LC.clearError(object, property);\n        }\n        return error;\n    },\n    \"clearError\" : function(data, property) {\n        if(data.errors && data.errors[property]) {\n            _LC.oF(data.errors, \"delete\", property);\n        }\n    },\n    \"createLyteId\" : function(comp){\n        comp.__counter++;\n        return \"__lyteId\" + comp.__counter;\n    },\n    \"apdNode\" : function(node, comp) {\n        _LC.tDiv.content.appendChild(node);\n        let id = this.createLyteId(comp);\n        comp.__h[id] = node;\n        node.__lyteId = id;\n    },\n    \"update\":function(object, property, value, options, fromStore,oldValue,setterScope, actualProperty, fromParent ,FromUtils, storeRecord){\n        let fromComponent = object.__component__;\n        let updateAttr = true;\n        let dataType, dataDef, estObjBind = false;\n        if(!oldValue){\n            oldValue = object[property];\n            if(fromComponent && fromComponent.tagName !== \"LYTE-YIELD\") {\n                dataDef = fromComponent.component.__data[property];\n                if(dataDef && (dataType = dataDef.type)) {\n                    updateAttr = !dataDef.hideAttr;\n                    if(dataType !== _LC.getDataType(value) && (value !== undefined || dataType === \"boolean\")) {\n                        value = _LC.typeCast(value, dataType);\n                    }\n                }\n                if(value === oldValue) {\n                    _LC.clearError(object, property);\n                    return;\n                }\n                if(!options || (typeof options == \"object\" && options.skipValidation != true)){\n                    let error = _LC.handleValidation(object, property, value, fromComponent.component);\n                    if(error) {\n                        // if(fromComponent.component.data.errors && Object.keys(fromComponent.component.data).length){\n                        //     Lyte.error(\"Error in data passed to component '\"+fromComponent.component.$node.localName+\"' for the properties - \"+Object.keys(fromComponent.component.data.errors).toString());\n                        // }\n                        return;\n                    }\n                }\n        }\n            //object[property] = value;\n            if(!object.hasOwnProperty(property) && !(Array.isArray(object))) {\n                _LC.oF(object, \"add\", property, value, true )\n            } else {\n                object[property] = value;\n            }\n        }\n        let toBeExecuted = fromComponent ? true : false;\n        let dasherizedAttr = _LC.String.dasherize(property);\n        if(fromComponent && actualProperty && ( (typeof value === \"string\" && fromComponent.getAttribute(dasherizedAttr) !==  value) || fromComponent.hasAttribute(dasherizedAttr) )) {\n            // (customPropRegex && this.customPropRegex)\n            let cpr;\n            if(fromComponent.tagName == \"LYTE-YIELD\"){\n                cpr = fromComponent._callee.component._registryClass.customPropRegex;\n            }else{\n                cpr = fromComponent.component._registryClass.customPropRegex;\n            }\n             if((!cpr.exec(property) || fromComponent.hasAttribute(dasherizedAttr) ) && updateAttr) {\n                 if(value && typeof value === \"object\") {\n                     let jsonString;\n                     try{\n                        jsonString = JSON.stringify(value);\n                        fromComponent.attributes.getNamedItem(dasherizedAttr).__lyteIgnore = true;\n                        fromComponent.setAttribute(dasherizedAttr, jsonString);\n                     } catch(e) {\n\n                     }\n                 } else {\n                     let attributeString = _LC.typeCast(value, \"string\");\n                     if(fromComponent.getAttribute(dasherizedAttr) !== attributeString) {\n                         let detAttr = fromComponent.attributes.getNamedItem(dasherizedAttr);\n                         if(detAttr) {\n                             detAttr.__lyteIgnore = true;\n                         }\n                         attributeString = attributeString || \"\";\n                         fromComponent.setAttribute(dasherizedAttr, attributeString);\n                     }\n                 }\n             }\n        }\n        if(value && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\" ) {\n            //newValue is of type object \n            \n            if(oldValue && typeof oldValue === \"object\" && oldValue._bindings) {\n                //Both oldValue and newValue are objects. \n                if(!value._bindings) {\n                    defProp(value, \"_bindings\", {\n                        enumerable: false, \n                        writable: true, \n                        value : new Set(),\n                        configurable: true\n                    });\n                }\n                //for changing only child component\n                if(fromComponent && fromComponent.component.data === object && property.indexOf('.')=== -1) {\n                    let bindings = fromComponent.getProperty(property);\n                    this.removeSelectedBindingDeep(bindings, oldValue);\n                    addBindings(value._bindings,bindings);\n                    this.establishBindings(bindings, value);\n                    //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).\n                    if(bindings._forHelpers) {\n                        let bindfor = bindings._forHelpers.toArrayLyte();\n                        for(var i=0;i<bindfor.length;i++){\n                            let item = bindfor[i];\n                            if(item._propBindingObject) {\n                                this.removeSelectedBindingDeep(item._propBindingObject, oldValue);\n//                                  value._bindings.add(item._propBindingObject);\n//                                  this.establishBindings(item._propBindingObject, value);\n                            }\n                        }\n                    }\n                    let stack = [];\n                    this.affectChanges(bindings,undefined,oldValue,setterScope,object[property],stack);\n                    this.executeObserver(stack);\n                } else {\n                    //To change only the bindings present in the object and not all the bindings present in the oldValue.\n                    if(object._bindings) {\n                        let oldbind = object._bindings.toArrayLyte();\n                        for(let i=0; i<oldbind.length;i++){\n                            let item = oldbind[i][property];\n                            if(item) {\n                                this.removeSelectedBindingDeep(item, oldValue);\n                                addBindings(value._bindings,item);\n                                this.establishBindings(item, value);\n                                //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).\n                                if(item._forHelpers) {\n                                    let forbind = item._forHelpers.toArrayLyte();\n                                    for(let j=0;j<forbind.length;j++){\n                                        let itemBinding = forbind[j];\n                                        if(itemBinding._propBindingObject) {\n                                            this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);\n                                        }\n                                    }\n                                }\n                                let stack = [];\n                                this.affectChanges(item,undefined,oldValue,setterScope,object[property],stack);\n                                this.executeObserver(stack);\n                            }\n                        }\n                    }\n                \n                \n                }\n            } else {\n                //newValue is object and oldValue is string. Hence establish bindings from oldValue's object and place it in the newValue. \n                if(object._bindings) {\n                    makeSet(value, \"_bindings\");\n                    let objbind = object._bindings.toArrayLyte();\n                    for(let i=0;i<objbind.length;i++){\n                        let item = objbind[i];\n                        if(item[property]) {\n                            addBindings(value._bindings,item[property]);\n                            this.establishBindings(item[property], value);\n                            let stack = [];\n                            this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],stack);\n                            this.executeObserver(stack);\n                        }\n                    }\n                }\n            }\n            dataDef = dataDef || (fromComponent && fromComponent.tagName !== \"LYTE-YIELD\" ? fromComponent.component.__data[property] : undefined); \n            if((fromStore && isEntity(object)) || (object && object.hasOwnProperty(\"_scp\") && object._scp.size) || (dataDef && (/^(object|array)$/.test(dataDef.type)) && (dataDef.watch || dataDef.hasOwnProperty(\"items\") || dataDef.hasOwnProperty(\"properties\")))){\n                estObjBind = true;\n            }\n        } else {\n            //newValue is string\n            \n            if(oldValue && typeof oldValue === \"object\" && oldValue._bindings && object._bindings) {\n                //newValue is string and oldValue is object \n                let objbind = object._bindings.toArrayLyte();\n                for(let i=0;i<objbind.length;i++){\n                    let item = objbind[i];\n                    if(item[property]) {\n                        //oldValue._bindings.delete(item[property]);\n                        //if(oldValue._bindings.size === 0) {\n                        //  delete oldValue._bindings;\n                        //  break;\n                        //}\n                    this.removeSelectedBindingDeep(item[property], oldValue);\n                        if(item[property]._forHelpers) {\n                            let forbind = item[property]._forHelpers.toArrayLyte();\n                            for(let j=0;j<forbind.length;j++){\n                                let itemBinding =forbind[j];\n                                if(itemBinding._propBindingObject) {\n                                    this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            \n            //when newValue and oldValue , both are string, no need to change bindings. \n            if(object._bindings) {\n                let objbind = object._bindings.toArrayLyte();\n                for(let i=0;i<objbind.length;i++){\n                    let item = objbind[i];\n                    if(item[property]) {\n                        let stack = [];\n                        this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],stack);\n                        this.executeObserver(stack);\n                    }\n                }\n            }\n        }\n        if(object._scp){\n            if(!cmpData(oldValue, value)){\n                this.callDeepObservers(object, { type:\"deepChange\", oldValue:oldValue, newValue : value }, property);\n            }\n            if(oldValue && (Array.isArray(oldValue) || typeof oldValue == \"object\")){\n                var keys = Array.from(object._scp.keys());\n                keys.forEach(function(id){\n                    var nestObj = nestScp[id];\n                    var isCyclic = nestObj.cyclic;\n                    removeNestScp(oldValue, id);\n                    if(isCyclic){\n                        bindObj(nestObj._data, undefined, id, [], new Map());\n                    }\n                });\n            }\n        }\n        if((isEntity(object) && object.$.__scpObj) || (object.hasOwnProperty(\"__component__\") && object.__component__.__scpObj)){\n            var _scpObj, kmpKey;\n            if(isEntity(object)){\n                _scpObj = object.$.__scpObj;\n                kmpKey = object;\n            }else{\n                _scpObj = object.__component__.__scpObj;\n                kmpKey = object.__component__;\n            }\n            if(_scpObj.hasOwnProperty(property)){\n                var _sId = _scpObj[property].split(\"_\");\n                removeNestScp(oldValue, _sId[0], _sId[1], undefined, kmpKey, undefined, isEntity(value) || Array.isArray(value) && value.model && value.add ? value : undefined);\n                delete _scpObj[property];\n            }\n        }\n        if (!FromUtils) {\n            _LC.callObjectObservers(object, { type: \"change\", \"oldValue\": oldValue, \"newValue\": value, item: property });\n        }\n        if(estObjBind){\n            // establishObjectBinding(object, property, fromStore, true);\n            establishObjectBinding(\n                object,\n                property,\n                fromStore,\n                true,\n                storeRecord,\n                (dataDef && dataDef.watch)?dataDef.watch:undefined\n            );\n        }\n        if(toBeExecuted && !fromParent && fromComponent._attributeDetails && fromComponent._callee) {\n            //let syntaxValue = fromComponent.getAttributeNode(property).syntaxValue;\n            let attrDetail = fromComponent._attributeDetails[_LC.String.dasherize(property)];\n            let syntaxValue;\n            if(attrDetail && attrDetail.isLbind) {\n                syntaxValue = attrDetail.dynamicValue;\n            }\n            if(syntaxValue) {\n                let contextSwitchArray;\n                if(fromComponent._cx) {\n                    contextSwitchArray = [];\n                    _LC.changeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )\n                }\n                let obj = _LC.getNew(fromComponent._callee.component.data, syntaxValue);\n                if(!obj.context){\n                    return;\n                }\n                let exec = false;\n                if(obj.context === fromComponent._callee.component.data) {\n                    if(fromComponent._callee._properties[obj.lastKey] && fromComponent._callee._properties[obj.lastKey].__fromComponent) {\n                        exec = true;\n                    }\n                } else {\n                    exec = true;\n                }\n                //self.setData(this._lbind,this.value);\n                if(exec) {\n                    let lastKeyIndex = +obj.lastKey;\n                    if(Array.isArray(obj.context) && typeof lastKeyIndex == \"number\") {\n                        _LC.aF(obj.context, lastKeyIndex < obj.context.length ? \"replaceAt\" : \"insertAt\", lastKeyIndex, value);\n                    } else {\n                        _LC.set(obj.context, obj.lastKey, value, options);\n                    }\n                }\n                if(contextSwitchArray) {\n                    _LC.removeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )\n                }\n            }\n        }\n    },\n    \"getContentForIE\" : function getContentForIE(content, constr, newlyCreated, info) {\n        if(typeof content === \"string\") {\n            newlyCreated = true;\n            var div = createElement(\"div\");\n            div.innerHTML = content;\n            content = div.childNodes[0];\n            constr.splitTextNodes(content);\n        }\n        if(content.getAttribute && content.getAttribute(\"depth\")) {\n            if(info) {\n                info._content = div;\n            }\n            var itr = parseInt(content.getAttribute(\"depth\"));\n            content =  newlyCreated ? content.content : content.content.cloneNode(true);\n            // content = Lyte._ie ? content : (newlyCreated ? content.content : content.content.cloneNode(true));\n            for(var i=0;i<itr;i++) {\n                content = content.childNodes[0];\n            }\n        }\n        return content;\n    },\n    \"replaceWithPf\" : function(node1, node2) {\n        // if(Lyte._rwpf) {\n        //     _LC.insertBeforeNative(node1.parentNode,node2, node1);\n        //     node1.remove();\n        // } else {\n            node1.replaceWith(node2);\n        // }\n    },\n    \"getCallee\" : function(callee, self){\n        while(callee &&  !_LC.isCustomElement(callee) && callee.tagName !== \"LYTE-YIELD\") {\n            if(callee.tagName === \"BODY\") {\n                callee = null;\n                break;\n            }\n            let hostEle = _LCSD.getHostElement(callee)\n            if(!callee.parentNode && hostEle){\n                callee = hostEle;\n            }\n            else{\n                callee = callee.parentNode;\n            }\n        }\n        if(callee && callee.tagName === \"LYTE-YIELD\") {\n        return callee._registerYield? callee._registerYield._callee : undefined;\n        }\n        return ((self ===  callee) ? undefined : callee);\n    },\n    \"set\" : function(object, property, value, options, fromStore, fromParent, FromUtils) {\n        let lastIndex = -1;\n        var s_rec,check={},recDottedProp;\n        if(isEntity(object) && fromStore){\n            s_rec=object;\n        }\n        if(!(typeof property === \"object\") || !property){\n            property = property+\"\";\n            lastIndex = property.lastIndexOf('.');\n        }\n        let actualProperty = property;\n        if(lastIndex !== -1) {\n            let outerPropertyPath = property.substring(0, lastIndex);\n            property = property.substring(lastIndex + 1);\n            object = _LC.get(object, outerPropertyPath);\n            recDottedProp = true;\n        }\n        if(typeof property === \"string\" && object[property] === value) {\n            if(object.__component__) {\n                _LC.clearError(object, property);\n            } else if(isEntity(object)) {\n                if(!object.$.isCloned){\n                    ValidationError.clrRecErr(object.$, property);\n                }\n                object.$.emit(\"set\", [object, property]);\n                if(object.$.schema){\n                    object.$.schema.emit(\"set\", [object.$.schema._name, object, property]);\n                    object.$.schema.db.emit(\"set\", [object.$.schema._name, object, property]);\n                }\n                else if(object.$.model){\n                    object.$.model.emit(\"set\", [object.$.model._name, object, property]);\n                    object.$.model.db.emit(\"set\", [object.$.model._name, object, property]);\n                }\n\n            }\n            return;\n        }\n        let oldValues = [];\n        if(object._setterScope){\n            var setterScope = object._setterScope;\n        }\n        var checkSim = false, watch = [];\n        if(object._scp && object._scp.size){\n            var keys = Array.from(object._scp.keys()), obj;\n            keys.forEach(function(id){\n                var _obj = object._scp.get(id);\n                obj = _obj.paths;\n                var recObj = nestScp[id], model, field, rec, attr, wobj = {};\n                var pathArr = Object.keys(obj), aPath;\n                if(pathArr.length > 1){\n                    aPath = \"*\";\n                }\n                else if(pathArr.length == 1){\n                    aPath = pathArr[0];\n                }\n                wobj.path = aPath;\n                wobj.id = id;\n                if(pathArr.length > 1){\n                    wobj.paths = pathArr;\n                }\n                wobj.attr = attr;\n                wobj.data = recObj.data;\n                wobj.dtype=recObj.dtype||undefined;\n                wobj.key=recObj.key||undefined;\n                wobj.Error=recObj.Error||undefined;\n                var db = recObj.db;\n                if(recObj.model){\n                    var mMap = recObj.model;\n                    var mKeys = Array.from(recObj.model.keys());\n                    for(var i=0; i<mKeys.length; i++){\n                        var mName = mKeys[i];\n                        var pkMap = mMap.get(mName);\n                        if(pkMap){\n                            var pkArr = Array.from(pkMap.keys());\n                            var pkLen = pkArr.length;\n                            for(var j=0; j<pkLen; j++){\n                                var mPk = pkArr[j];\n                                var attrMap = pkMap.get(mPk);\n                                var attrArr = Array.from(attrMap.keys());\n                                var attrLen = attrArr.length;\n                                for(k=0; k<attrLen; k++){\n                                    var mAttr = attrArr[k];\n                                    var mObj = Object.assign({}, wobj);\n                                    if(db.getSchema){\n                                        var mRec = recObj.db.cache.getEntity({schema:db.getSchema(mName), pK:mPk});\n                                    }\n                                    else{\n                                        var mRec = recObj.db.cache.getEntity({model:db.getModel(mName), pK:mPk});\n                                    }\n                                    if(mRec){\n                                        model = mRec.$.schema ? mRec.$.schema : mRec.$.model;\n                                        field = model.fieldList[mAttr];\n                                        if(field && field.watch == true){\n                                            mObj.data = deepCopyObject(mRec[mAttr]);\n                                            mObj.rec = mRec;\n                                            mObj.isRec = true;\n                                            mObj.attr = mAttr;\n                                            mObj.dtype = model.fieldList[mAttr];\n                                            mObj.Error=mRec.$.error;\n                                        }\n                                        watch.$push(mObj);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } \n                else{\n                    watch.$push(wobj);\n                }         \n            });\n            watch.forEach(function(val){\n                if((!options || (typeof options == \"object\" && options.skipValidation != true)) && (val.dtype || val.rec) ){\n                    var id = val.id,path=val.path.split(\".\"),dtype=val.dtype;\n                    checkNestedProp(id,path,dtype,val,object,property,value,check);\n                    if(object.$ && Object.values(object.$.error).length==0){\n                        delete object.$\n                    };\n                }\n            })\n            if(check.value && check.value.code){\n                return;\n            }\n        }\n        actualProperty = actualProperty === property ? actualProperty : undefined;\n        var shareObj = {};\n        if(typeof property === \"object\"){\n            if(isEntity(object) && !fromStore && !object.$.isCloned) {\n                    // for(let key in property){\n                    //     if(Array.isArray(object[key])){\n                    //         oldValues.$push({key:key,oldValue:object[key].slice(0)});    \n                    //     }\n                    //     else{\n                    //         oldValues.$push({key:key,oldValue:object[key]});\n                    //     }\n                    // }\n                    for(let key in property) {\n                        let locValue = property[key];\n                        let dataType = object.$.schema ? object.$.schema.fieldList[key] : object.$.model.fieldList[key];\n                        dataType = dataType ? dataType.type : undefined;\n                        if(dataType && (locValue !== undefined || dataType === \"boolean\") && dataType !== _LC.getDataType(locValue)) {\n                            property[key] = _LC.typeCast(locValue, dataType);\n                        }\n                    }\n                    let record = setData(object.$, property, undefined, options, undefined, undefined, shareObj);\n                    if(record.$.isError){\n                        return record;\n                    }\n                    // for(let i=0; i<oldValues.length; i++){\n                    //     _LC.update(object,oldValues[i].key,object[oldValues[i].key],fromStore,(oldValues[i].oldValue === undefined)?null:oldValues[i].oldValue ,setterScope, actualProperty, fromParent);\n                    // }\n            } else {\n                //object[property] =  value;\n                for(let key in property){\n                    //_LC.update(object,key,property[key],fromStore,undefined,setterScope, actualProperty, fromParent);\n                    //value is option here\n                    _LC.set(object, key, property[key], value, fromStore, fromParent);\n                }\n            }\n        }\n        else{\n            if(isEntity(object) && (!fromStore || (fromStore && recDottedProp)) && !object.$.isCloned) {\n                let old = object[property];\n                let dataType = object.$.schema ? object.$.schema.fieldList[property] : object.$.model.fieldList[property];\n                dataType = dataType ? dataType.type : undefined;\n                if(dataType && (value !== undefined || dataType === \"boolean\") && dataType !== _LC.getDataType(value)) {\n                    value = _LC.typeCast(value, dataType);\n                }\n                let record = setData(object.$, property,value, options, undefined, undefined, shareObj);\n                if(record.$.isError){\n                    return record;\n                }\n                //Commented because update will happend when \"set\" is called from setData of store. \n                //_LC.update(object,property,value,fromStore,(old === undefined) ? null : old,setterScope , actualProperty);    \n            } else {\n                _LC.update(object,property,value,options,fromStore,undefined,setterScope,actualProperty, fromParent, FromUtils, s_rec);\n            }\n        }\n        if(watch && watch.length){\n            watch.forEach(function(obj){\n                if(obj.isRec){\n                    deepValueChange(obj.rec, obj.attr, obj.rec[obj.attr], obj);\n                }\n            });\n        }\n    },\n    \"adCx\" : function(node, contextSwitchArray) {\n        let isYield = node.tagName === \"LYTE-YIELD\";\n        if(node._cx && (!isYield || node._cx.node.tagName !== \"LYTE-YIELD\")) {\n            _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, isYield);\n        } else if(isYield && node._callee._cx) {\n            _LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);\n        }\n    }, \n    \"rmCx\" : function(node, contextSwitchArray) {\n        let isYield = node.tagName === \"LYTE-YIELD\";\n        if(node._cx && (!isYield || node._cx.node.tagName !== \"LYTE-YIELD\")) {\n            _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, isYield);\n        } else if(isYield && node._callee._cx) {\n            _LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);\n        }\n    },\n    \"changeContext\" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {\n        if(!contextSwitchInfo) {\n            return;\n        }\n        let isYield = node.tagName === \"LYTE-YIELD\";\n        if(node._cx && (!isYield || node._cx.node.tagName !== \"LYTE-YIELD\")) {\n            _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === \"LYTE-YIELD\" || proceedFurther);\n        } else if((node.tagName === \"LYTE-YIELD\" || proceedFurther) && node._callee && node._callee._cx) {\n            _LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx);\n        }\n        if(isYield) {\n            let insertYield = node._registerYield;\n            let callee = insertYield._callee;\n            if(callee && callee._cx) {\n                _LC.changeContext(callee._cx.node, contextSwitchArray, callee._cx);\n            }\n        }\n        let indexValue, itemValue;\n        if(contextSwitchInfo.type) {\n            if(contextSwitchInfo.type === \"for\") {\n                indexValue = node.getAttribute(\"index\");\n                itemValue = node.getAttribute(\"item\");\n                if(node._items.length === 0) {\n                    return;\n                }\n            } else {\n                indexValue = node.getAttribute(\"key\");\n                itemValue = node.getAttribute(\"value\");\n                if(Object.keys(node._items).length === 0) {\n                    return;\n                }\n            }\n            let callee = node._callee;\n            let initialItemValue = callee.component.data[itemValue];\n            let initialIndexValue = callee.component.data[indexValue];\n            let initialItemProp = callee._properties[itemValue];\n            let initialIndexProp = callee._properties[indexValue];\n             let items = contextSwitchInfo.type === \"for\" ? node._currentItems : node._currentObject;\n            callee.component.data[itemValue] = items[contextSwitchInfo.itemIndex];\n            callee.component.data[indexValue] = contextSwitchInfo.itemIndex;\n            callee._properties[itemValue] = node._items[contextSwitchInfo.itemIndex].itemProperty;\n            callee._properties[indexValue] = node._items[contextSwitchInfo.itemIndex].indexProperty;\n            let dummyObject = {\"initialItemValue\" : initialItemValue , \"initialIndexValue\" : initialIndexValue, \"initialItemProp\" : initialItemProp, \"initialIndexProp\" : initialIndexProp};\n            contextSwitchArray.$push(dummyObject);\n        } else {\n            //handling for yield\n            let dummyObject = {};\n            let callee = node._registerYield._callee;\n            Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {\n                dummyObject[key] = {};\n                dummyObject[key].value = callee.component.data[key];\n                dummyObject[key].property = callee._properties[key];\n                callee._properties[key] = contextSwitchInfo.node._properties[key];\n                callee.component.data[key] = contextSwitchInfo.node.component.data[key];\n            }); \n            contextSwitchArray.$push(dummyObject);\n        }\n    },\n    \"removeContext\" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {\n        if(!contextSwitchInfo) {\n            return;\n        }\n        let isYield = node.tagName === \"LYTE-YIELD\";\n        if(node._cx && (!isYield || node._cx.node.tagName !== \"LYTE-YIELD\")) {\n            _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === \"LYTE-YIELD\" || proceedFurther);\n        } else if((node.tagName === \"LYTE-YIELD\" || proceedFurther) && node._callee && node._callee._cx) {\n            _LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx)\n        }\n        if(isYield) {\n            let insertYield = node._registerYield;\n            let callee = insertYield._callee;\n            if(callee && callee._cx) {\n                _LC.removeContext(callee._cx.node, contextSwitchArray, callee._cx);\n            }\n        }\n        let indexValue, itemValue;\n        if(contextSwitchInfo.type) {\n            if(contextSwitchInfo.type === \"for\") {\n                indexValue = node.getAttribute(\"index\");\n                itemValue = node.getAttribute(\"item\");\n                if(node._items.length === 0) {\n                    return;\n                }\n            } else {\n                indexValue = node.getAttribute(\"key\");\n                itemValue = node.getAttribute(\"value\");\n                if(Object.keys(node._items).length === 0) {\n                    return;\n                }\n            }\n            let callee = node._callee;\n            let items = node._attributes.items;\n            let removedObject = contextSwitchArray.$shift();\n            callee.component.data[itemValue] = removedObject.initialItemValue;\n            callee.component.data[indexValue] = removedObject.initialIndexValue;\n            callee._properties[itemValue] = removedObject.initialItemProp;\n            callee._properties[indexValue] = removedObject.initialIndexProp;\n        } else {\n            let callee = node._registerYield._callee;\n            let removedObject = contextSwitchArray.$shift();\n            Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {\n                callee.component.data[key] = removedObject[key].value;\n                callee._properties[key] = removedObject[key].property;\n            });\n        }\n    },\n    \"objectUtils\" : function(){\n        return _LC.oF.apply(_LC, arguments);\n    },\n    \"sortCommands\" : function(array1, arrayB) {\n        var retVal = {};\n        var arrayA = array1.slice();\n        retVal.origianlArray = array1;\n        var commands = [];\n        \n        for (let i = 0; i < arrayB.length; i++) {\n            // var targetIndex = arrayA.findIndex((element) => element === arrayB[i]);\n            var targetIndex = arrayA.indexOf(arrayB[i]);\n        \n            if (targetIndex === -1) {\n            commands.push({\n                type: 'Add',\n                element: arrayB[i], \n                toIndex : i\n            });\n            arrayA.splice(i, 0, arrayB[i]);\n            } else {\n            if (targetIndex !== i) {\n                commands.push({\n                type: 'Move',\n                element: arrayB[i],\n                fromIndex: targetIndex,\n                toIndex: i\n                });\n                arrayA.splice(targetIndex, 1);\n                arrayA.splice(i, 0, arrayB[i]);\n            }\n            }\n        }\n        \n        for (let i = arrayA.length - 1; i >= arrayB.length; i--) {\n            commands.push({\n            type: 'Remove',\n            element: arrayA[i]\n            });\n            arrayA.splice(i, 1);\n        }\n        retVal.commands = commands;\n        retVal.changedArray = arrayB;\n        return retVal;\n    },\n    \"oF\" : function() {\n        let object = arguments[0];\n        let functionName = arguments[1];\n        let property = arguments[2];\n        let newValue = arguments[3];\n        let fromComponent = arguments[4];\n        let fromStore = arguments[5];\n        if(functionName === \"add\" && !fromComponent) {\n            let obj = {type:\"change\",\"oldValue\":object[property],\"newValue\":newValue,\"item\":property};\n            _LC.set(object, property, newValue,undefined, fromStore,undefined,true);\n            _LC.callObjectObservers(object,obj);\n            return;\n        }\n        let options = {};\n        options.type = functionName;\n        options.property = property;\n        if(!/^(add|delete)$/.test(functionName)) {\n            //@Slicer.developmentStart\n            ApiError.error(\"LC001\", functionName);\n            //@Slicer.developmentEnd\n            return;\n        }\n        let bindings = object._bindings;\n        if(functionName === \"delete\") {\n            let obj = {type:\"change\",\"oldValue\":object[property],\"newValue\":newValue,\"item\":property};\n            _LC.set(object, property, undefined, undefined, fromStore,undefined,true);\n            _LC.callObjectObservers(object,obj);\n        } else {\n            object[property] = newValue;\n        }\n        if(bindings) {\n            let bind = bindings.toArrayLyte();\n            for(let i=0;i<bind.length;i++) {\n                let binding = bind[i];\n                let forHelpers = binding._forHelpers;\n                if(forHelpers) {\n                    let helperBind = forHelpers.toArrayLyte();\n                    for(let j=0;j<helperBind.length;j++) {\n                        let forHelper = helperBind[j];\n                        if(forHelper.getAttribute(\"is\") != \"forIn\"){\n                            continue;\n                        }\n                        let itemValue = forHelper.getAttribute(\"key\");\n                        //Need to check\n//                            _LC.removeSelectedBindingDeep({[itemValue] :                        forHelper._items[property].itemProperty}, {[itemValue] : object[property]});\n                        let contextSwitchArray = [];\n                        if(functionName === \"add\") {\n                            _LC.adCx(forHelper, contextSwitchArray);\n                        }\n                        forHelper._callee.updateForInHelper(forHelper, options);\n                        if(functionName === \"add\") {\n                            _LC.rmCx(forHelper, contextSwitchArray);\n                        }\n                    }\n                }\n            }\n        }\n        if(functionName === \"delete\") {\n            delete object[property];\n        }\n    },\n    \"arrayUtils\" : function(){\n        return _LC.aF.apply(_LC, arguments);\n    },\n    \"aF\" : function() {\n        var argumentsArr = Array.from(arguments);\n        var fromOverride = false;\n        if(argumentsArr[0] && typeof argumentsArr[0] == \"object\" && argumentsArr[0].fromOverride){\n            argumentsArr.$shift();\n            fromOverride = true;\n        }\n        let array = argumentsArr[0];\n        let initialArrLength = array.length;\n        let callLengthObserver = true;\n        let functionName = argumentsArr[1];\n        let value = arguments[3],check={};\n        if(/^(replaceAt|removeAt|shift)$/.test(functionName) && !array.length) {\n            //@Slicer.developmentStart\n            Lyte.warn(functionName + \" operation cannot be performed on empty array\");\n            //@Slicer.developmentEnd\n            return;\n        }\n        let commands;\n        if(functionName == \"sort\") {\n            var originalArray = arguments[0];\n            var sortFunction = arguments[2];\n            var addedArguments = arguments[3] || [];\n            var dummyArray = originalArray.slice();\n            addedArguments.forEach(function(item) {\n                dummyArray.push(item);\n            });\n            if(typeof arguments[2] == \"function\") {\n                dummyArray.sort(sortFunction);\n            } else {\n                var obj = arguments[2];\n                var key = obj.sortBy;\n                var order = obj.sortOrder;\n                function sorting(item1, item2) {\n                    var item1 = key ? item1[key] : item1;\n                    var item2 = key ? item2[key] : item2;\n                    if(item1 > item2) {\n                        return order ? 1 : -1;\n                    } else if(item1 < item2) {\n                        return order ? -1 : 1;\n                    } else {\n                        return 0;\n                    }\n                }\n                dummyArray.sort(sorting)\n            }\n            commands = this.sortCommands(originalArray, dummyArray).commands;\n        }\n        let commArgs = arguments[2], oldVal, obsObj, watch = [];\n        if(array._scp && /^(replaceAt|splice|removeAt|remove|insertAt)$/.test(functionName)){\n            array._scp.forEach(function(_obj, id){\n                var rec, attr, wobj = {};\n                var recObj = nestScp[id];\n                var obj = _obj.paths;\n                var pathArr = Object.keys(obj), aPath;\n                if(pathArr.length > 1){\n                    aPath = \"*\";\n                }\n                else if(pathArr.length == 1){\n                    aPath = pathArr[0];\n                }\n                wobj.path = aPath;\n                wobj.id = id;\n                if(pathArr.length > 1){\n                    wobj.paths = pathArr;\n                }\n                wobj.attr = attr;\n                wobj.data = recObj.data;\n                wobj.reInit = isEntity(recObj.data) || (Array.isArray(recObj.data) && (recObj.data.schema || recObj.data.model) && recObj.data.add);\n                wobj.dtype=recObj.dtype||undefined;\n                wobj.key=recObj.key||undefined;\n                wobj.Error=recObj.Error||undefined;\n                wobj.index=commArgs;\n                if(recObj.model){\n                    var mMap = recObj.model;\n                    var mKeys = Array.from(recObj.model.keys());\n                    for(var i=0; i<mKeys.length; i++){\n                        var mName = mKeys[i];\n                        var pkMap = mMap.get(mName);\n                        if(pkMap){\n                            var pkArr = Array.from(pkMap.keys());\n                            var pkLen = pkArr.length;\n                            for(var j=0; j<pkLen; j++){\n                                var mPk = pkArr[j];\n                                var attrMap = pkMap.get(mPk);\n                                var attrArr = Array.from(attrMap.keys());\n                                var attrLen = attrArr.length;\n                                for(k=0; k<attrLen; k++){\n                                    var mAttr = attrArr[k];\n                                    var mObj = Object.assign({}, wobj);\n                                    if(recObj.db.getSchema){\n                                        var mRec = recObj.db.cache.getEntity({schema:recObj.db.getSchema(mName), pK:mPk});\n                                    }\n                                    else{\n                                        var mRec = recObj.db.cache.getEntity({model:recObj.db.getModel(mName), pK:mPk});\n                                    }\n                                    if(mRec){\n                                        var model = mRec.$.schema ? mRec.$.schema : mRec.$.model;\n                                        var field = model.fieldList[mAttr];\n                                        if(field && (field.properties || field.items || field.watch == true)){\n                                            mObj.data = deepCopyObject(mRec[mAttr]);\n                                            mObj.rec = mRec;\n                                            mObj.isRec = true;\n                                            mObj.attr = mAttr;\n                                            mObj.dtype = model.fieldList[mAttr];\n                                            mObj.Error=mRec.$.error;\n                                            mObj.key=mAttr;\n                                        }\n                                        // mObj.reInit = true;\n                                        watch.push(mObj);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } \n                else{\n                    wobj.reInit = isEntity(recObj.data) || (Array.isArray(recObj.data) && (recObj.data.schema || recObj.data.model ) && recObj.data.add);\n                    watch.push(wobj);\n                }\n            });\n            watch.forEach(function(val){\n                if((val.dtype || val.rec) ){\n                    var id = val.id,path=val.path.split(\".\"),dtype=val.dtype;\n                    checkNestedProp(id,path,dtype,val,array,path,commArgs,check);\n                    if(array.$ && Object.values(array.$.error).length==0){\n                        delete array.$\n                    };\n                }\n            });\n            if(check.value && check.value.code){return;}\n        }  \n        switch(functionName) {\n        case \"replaceAt\" : \n            {\n            let index = parseInt(argumentsArr[2]);\n            if(index > array.length) {\n                Lyte.warn(\"index provided for replaceAt is greater than array length\");\n                return [];\n            }\n            //let args = Array.prototype.slice.call(argumentsArr, 3);\n            let args = argumentsArr[3];\n            if(!(Array.isArray(args))) {\n                args = [args];\n            }\n            else if(fromOverride){\n                args = [args];\n            }\n            let deletedItems = array.$splice.apply(array, [index, 1].$concat(args));\n            let options = {\"firstIndex\" : index, \"secondIndex\" : args.length, \"type\" : \"replace\"};\n            //All references updated by now\n            if(options.secondIndex == 1){\n                callLengthObserver = false;\n            }\n            //remove binding from previous object\n            if(array._bindings) {\n                let objbind = array._bindings.toArrayLyte();\n                for(let i=0;i<objbind.length;i++){\n                    let item = objbind[i];\n                    if(item._forHelpers) {\n                        let helperbind = item._forHelpers.toArrayLyte();\n                        for(let j=0;j<helperbind.length;j++){\n                            let helper = helperbind[j];\n                            if(helper.getAttribute(\"is\") != \"for\"){\n                                continue;\n                            }\n                            /*if(helper.hasAttribute(\"unbound\")) {\n                                continue;\n                            }*/\n                            let finalIndex = index + deletedItems.length;\n                            let itemValue = helper.getAttribute(\"item\");\n                            for(let i=index, j=0;i<finalIndex;i++,j++) {\n                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});\n                            }\n                            let contextSwitchArray = [];\n                            _LC.adCx(helper, contextSwitchArray);\n                            helper._callee.updateForHelper(helper, options);\n                            _LC.rmCx(helper, contextSwitchArray);\n                        }\n                    }\n                    for(let key in item) {\n                        let parsedKey = parseInt(key);\n                        let cond = (options.secondIndex == 1) ? (parsedKey == options.firstIndex) : (parsedKey >= options.firstIndex);\n                        if(!isNaN(parsedKey) && cond) {\n                            let diff = parsedKey - options.firstIndex;\n                            let oldObject;\n                            if(diff < 1) {\n                                oldObject = deletedItems[diff];\n                            } else {\n                                oldObject = array[options.firstIndex - 1  + options.secondIndex + diff];\n                            }\n                            this.removeSelectedBindingDeep(item[key], oldObject);\n                            if(item[key]._forHelpers) {\n                                let bindfor = item[key]._forHelpers.toArrayLyte();\n                                for(var j=0;j<bindfor.length;j++){\n                                    let item1 = bindfor[j];\n                                    if(item1._propBindingObject) {\n                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);\n//                                          value._bindings.add(item._propBindingObject);\n//                                          this.establishBindings(item._propBindingObject, value);\n                                    }\n                                }\n                            }\n                            if(array[parsedKey] && typeof array[parsedKey] === \"object\") {\n                                makeSet(array[parsedKey], \"_bindings\");\n                            this.establishBindings({\"dummy\" : item[key]},{\"dummy\" : array[parsedKey]});\n                            }\n                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);\n                            if(options.secondIndex == 1){\n                                break; \n                            }\n                        }\n                    }\n                }\n            }\n            obsObj = {type:\"array\",insertedItems:args, removedItems:deletedItems, index:index};\n            _LC.bindWatchObj(watch, array, args, deletedItems, index);\n            _LC.callArrayObservers(array,obsObj,callLengthObserver,initialArrLength);\n            return deletedItems[0];\n            }\n            break;\n        case \"splice\" : {\n            let index = parseInt(argumentsArr[2]);\n            if(index > array.length) {\n                Lyte.warn(\"index provided is greater than array length\");\n                return [];\n            }\n            let toBeDeleted = argumentsArr.length > 3 ? argumentsArr[3] : array.length - index;\n            let args;\n            let skip = false;\n            if(argumentsArr.length > 4){\n                args = argumentsArr[4]\n            }else{\n                args = []\n                skip = true;\n            }\n            if(!(Array.isArray(args))) {\n                args = [args];\n            }\n            else if(!skip && fromOverride){\n                args = [args];\n            }\n            let deletedItems = array.$splice.apply(array, [index, toBeDeleted].$concat(args));\n            let options = {\"firstIndex\" : index, \"secondIndex\" : args.length, \"thirdIndex\" : toBeDeleted, \"type\" : \"splice\"};\n            //All references updated by now\n            if(options.secondIndex == options.thirdIndex){\n                callLengthObserver = false\n            }\n            //remove binding from previous object\n            if(array._bindings) {\n                let objbind = array._bindings.toArrayLyte();\n                for(let i=0;i<objbind.length;i++){\n                    let item = objbind[i];\n                    if(item._forHelpers) {\n                        let helperbind = item._forHelpers.toArrayLyte();\n                        for(let j=0;j<helperbind.length;j++){\n                            let helper = helperbind[j];\n                            /*if(helper.hasAttribute(\"unbound\")) {\n                                continue;\n                            }*/\n                            if(helper.getAttribute(\"is\") != \"for\"){\n                                continue;\n                            }\n                            let finalIndex = index + deletedItems.length;\n                            let itemValue = helper.getAttribute(\"item\");\n                            for(let i=index, j=0;i<finalIndex;i++,j++) {\n                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});\n                            }\n                            let contextSwitchArray = [];\n                            _LC.adCx(helper, contextSwitchArray);\n                            helper._callee.updateForHelper(helper, options);\n                            _LC.rmCx(helper, contextSwitchArray);\n                        }\n                    }\n                    for(let key in item) {\n                        let parsedKey = parseInt(key);\n                        var cond = options.secondIndex == options.thirdIndex ? key >= options.firstIndex && key < (options.firstIndex+options.secondIndex) : parsedKey >= options.firstIndex;\n                        if(!isNaN(parsedKey) && cond) {\n                            let diff = parsedKey - options.firstIndex;\n                            let oldObject;\n                            if(diff < options.thirdIndex) {\n                                oldObject = deletedItems[diff];\n                            } else {\n                                oldObject = array[options.firstIndex - options.thirdIndex  + options.secondIndex + diff];\n                            }\n                            this.removeSelectedBindingDeep(item[key], oldObject);\n                            if(item[key]._forHelpers) {\n                                let bindfor = item[key]._forHelpers.toArrayLyte();\n                                for(var j=0;j<bindfor.length;j++){\n                                    let item1 = bindfor[j];\n                                    if(item1._propBindingObject) {\n                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);\n//                                          value._bindings.add(item._propBindingObject);\n//                                          this.establishBindings(item._propBindingObject, value);\n                                    }\n                                }\n                            }\n                            if(array[parsedKey] && typeof array[parsedKey] === \"object\") {\n                                makeSet(array[parsedKey], \"_bindings\");\n                            this.establishBindings({\"dummy\" : item[key]},{\"dummy\" : array[parsedKey]});\n                            }\n                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);\n                        }\n                    }\n                }\n            }\n            obsObj = {type:'array',index:index,insertedItems:args, removedItems:deletedItems};\n            _LC.bindWatchObj(watch, array, args, deletedItems, index);\n            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);\n            return deletedItems;\n        }\n        break;\n        case \"push\" : \n            {\n            let toPush = argumentsArr[2];\n            if(fromOverride && argumentsArr.length > 3){\n                toPush = argumentsArr.$splice(2,argumentsArr.length);\n            }\n            else if(!(Array.isArray(toPush))) {\n                toPush = [toPush];\n            }\n            else if(fromOverride){\n                toPush = [toPush];\n            }\n            _LC.aF(array, 'insertAt', array.length, toPush);\n            }\n            break;\n        case \"pop\" : \n               return _LC.aF(array, 'remove', array.length -1)[0];\n            break;\n        case \"shift\" : \n        case \"shiftObject\" :\n              return _LC.aF(array, 'remove', 0)[0];\n              break;\n        case \"removeAt\" : \n        case \"remove\" : \n            {\n            let index = parseInt(argumentsArr[2]);\n            if(index > array.length) {\n                Lyte.warn(\"index provided for removeAt is greater than array length\");\n                return [];\n            }\n            let length = argumentsArr[3] ? parseInt(argumentsArr[3]) : 1;\n            let options = {\"firstIndex\" : index, \"secondIndex\" : length, \"type\" : \"remove\"};\n            let deletedItems = array.$splice(index,length);\n            if(array._bindings) {\n                let objbind = array._bindings.toArrayLyte();\n                for(let i=0;i<objbind.length;i++){\n                    let item = objbind[i];\n                    if(item._forHelpers) {\n                        let helperbind = item._forHelpers.toArrayLyte();\n                        for(let j=0;j<helperbind.length;j++){\n                            let helper = helperbind[j];\n                            /*if(helper.hasAttribute(\"unbound\")) {\n                                continue;\n                            }*/\n                            if(helper.getAttribute(\"is\") != \"for\"){\n                                continue;\n                            }\n                            let finalIndex = index + deletedItems.length;\n                            let itemValue = helper.getAttribute(\"item\");\n                            for(let i=index, j=0;i<finalIndex;i++,j++) {\n                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});\n                            }\n                            let contextSwitchArray = [];\n                            _LC.adCx(helper, contextSwitchArray);\n                            helper._callee.updateForHelper(helper, options);\n                            _LC.rmCx(helper, contextSwitchArray);\n                        }\n                       }\n                        for(let key in item) {\n                        let parsedKey = parseInt(key);\n                        if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {\n                            let diff = parsedKey - options.firstIndex;\n                            let oldObject;\n                            if(diff < options.secondIndex) {\n                                oldObject = deletedItems[diff];\n                            } else {\n                                oldObject = array[options.firstIndex - options.secondIndex + diff];\n                            }\n                            this.removeSelectedBindingDeep(item[key], oldObject);\n                            if(item[key]._forHelpers) {\n                                let bindfor = item[key]._forHelpers.toArrayLyte();\n                                for(var j=0;j<bindfor.length;j++){\n                                    let item1 = bindfor[j];\n                                    if(item1._propBindingObject) {\n                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);\n//                                          value._bindings.add(item._propBindingObject);\n//                                          this.establishBindings(item._propBindingObject, value);\n                                    }\n                                }\n                            }\n                            if(array[parsedKey] && typeof array[parsedKey] === \"object\") {\n                                makeSet(array[parsedKey], \"_bindings\");\n                            this.establishBindings({\"dummy\" : item[key]},{\"dummy\" : array[parsedKey]});\n                            }\n                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);\n                        }\n                    }\n                }\n            }\n            obsObj = {type:\"array\",removedItems:deletedItems,index:index};\n            _LC.bindWatchObj(watch, array, undefined, deletedItems, index);\n            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength); \n            return deletedItems;\n            }\n            break;\n        case \"removeObject\" : \n                commArgs = [commArgs];\n        case \"removeObjects\" :\n            if(!(Array.isArray(commArgs))) {\n                commArgs = [commArgs];\n            }\n            else if(fromOverride){\n                commArgs = [commArgs];\n            }\n            if(commArgs == array){\n                commArgs = Array.from(commArgs);// both array are same instance so cloning\n            }\n            for(var i=0;i<commArgs.length;i++) {\n                let inde = array.indexOf(commArgs[i]);\n                if(inde !== -1) {\n                   _LC.aF(array, 'removeAt', inde);                         \n                }\n            }\n            //Lyte.arrayUtils(array, 'removeObject', actObj);\n            //Lyte.arrayUtils(array, 'removeObjects', []);\n        break;\n        case \"unshift\" : \n        case \"unshiftObject\" : \n        case \"unshiftObjects\" : \n            //_LC.aF.apply(_LC, [array, 'insertAt', 0].$concat(Array.prototype.slice.call(argumentsArr, 2)));\n            {\n            let toPush = argumentsArr[2];\n            if(!(Array.isArray(toPush))) {\n                toPush = [toPush];\n            }\n            else if(fromOverride){\n                toPush = [toPush];\n            }\n            _LC.aF(array, 'insertAt', 0, toPush);\n            }\n            break;\n        case \"insertAt\" : \n            {\n            let index = parseInt(argumentsArr[2]);\n            //let args = Array.prototype.slice.call(argumentsArr, 3);\n            let args = argumentsArr[3];\n            let len = args.length;\n            if(!(Array.isArray(args))) {\n                args = [args];\n            }\n            else if(fromOverride){\n                args = [args];\n            }\n            for(let i=index;i>array.length;i--) {\n                args.$unshift(undefined);\n                index--;\n            }\n            let options = {\"firstIndex\" : index, \"secondIndex\" : args.length, \"type\" : \"insert\"};\n            array.$splice.apply(array, [index, 0].$concat(args));\n            if(array._bindings) {\n                let arrbind = array._bindings.toArrayLyte();\n                for(let i=0;i<arrbind.length;i++){\n                    let item = arrbind[i];\n                    if(item._forHelpers) {\n                        let forbind = item._forHelpers.toArrayLyte();\n                        for(let j=0;j<forbind.length;j++){\n                            /*if(forbind[j].hasAttribute(\"unbound\")) {\n                                continue;\n                            }*/\n                            let helper = forbind[j];\n                            if(helper.getAttribute(\"is\") != \"for\"){\n                                continue;\n                            }\n                            let contextSwitchArray = [];\n                            _LC.adCx(helper, contextSwitchArray);\n                            helper._callee.updateForHelper(helper, options);\n                            _LC.rmCx(helper, contextSwitchArray);\n                        }\n                    }\n                    for(let key in item) {\n                        let parsedKey = parseInt(key);\n                        if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {\n                            this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);\n                            if(item[key]._forHelpers) {\n                                let bindfor = item[key]._forHelpers.toArrayLyte();\n                                for(var j=0;j<bindfor.length;j++){\n                                    let item1 = bindfor[j];\n                                    if(item1._propBindingObject) {\n                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);\n//                                          value._bindings.add(item._propBindingObject);\n//                                          this.establishBindings(item._propBindingObject, value);\n                                    }\n                                }\n                            }\n                            if(array[parsedKey] && typeof array[parsedKey] === \"object\") {\n                                makeSet(array[parsedKey], \"_bindings\");\n                            this.establishBindings({\"dummy\" : item[key]},{\"dummy\" : array[parsedKey]});    \n                            }\n                            this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);\n                        }\n                    }\n                }\n            }\n            let position = parseInt(argumentsArr[2]);\n            obsObj = {type:\"array\",insertedItems:(!(Array.isArray(argumentsArr[3]))) ? [argumentsArr[3]]: argumentsArr[0].slice(position,position+len),index:position};\n            _LC.bindWatchObj(watch, array, args, undefined, position);\n            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);                \n            }\n            break;\n        case \"concat\" : \n            //_LC.aF.apply(_LC, [array, 'insertAt',array.length].$concat(argumentsArr[2]));\n            _LC.aF(array, 'insertAt', array.length, argumentsArr[2]);\n            break;\n        case \"sort\" : \n            let optionsArray = [];\n            commands.forEach(function(command) {\n                switch(command.type) {\n                    case \"Remove\" : {\n                        let removedItems = array.splice(command.toIndex, 1);\n                        optionsArray.push({\"firstIndex\" : command.toIndex, \"secondIndex\" : 1, \"type\" : \"remove\", \"removedItem\" : removedItems[0]});\n                    }\n                    break;\n                    case \"Move\" : {\n                        let removedItems = array.splice(command.fromIndex, 1);\n                        array.splice(command.toIndex, 0, command.element);\n                        optionsArray.push({\"firstIndex\" : command.fromIndex, \"secondIndex\" : 1, \"type\" : \"remove\", \"removedItem\" : removedItems[0]});\n                        // optionsArray.push({\"firstIndex\" : command.toIndex, \"secondIndex\" : 1, \"thirdIndex\" : 0, \"type\" : \"splice\"});\n                        optionsArray.push({\"firstIndex\" : command.toIndex, \"secondIndex\" : 1, \"type\" : \"insert\"});\n                    }\n                    break;\n                    case \"Add\" : {\n                        array.splice(command.toIndex, 0, command.element);\n                        // optionsArray.push({\"firstIndex\" : command.toIndex, \"secondIndex\" : 1, \"thirdIndex\" : 0, \"type\" : \"splice\"});\n                        optionsArray.push({\"firstIndex\" : command.toIndex, \"secondIndex\" : 1, \"type\" : \"insert\"});\n                    }\n                    break;\n                }\n            });\n            if(array._bindings) {\n                let arrbind = array._bindings.toArrayLyte();\n                for(let i=0;i<arrbind.length;i++){\n                    let item = arrbind[i];\n                    if(item._forHelpers) {\n                        let forbind = item._forHelpers.toArrayLyte();\n                        for(let j=0;j<forbind.length;j++){\n                            /*if(forbind[j].hasAttribute(\"unbound\")) {\n                                continue;\n                            }*/\n                            let helper = forbind[j];\n                            if(helper.getAttribute(\"is\") != \"for\"){\n                                continue;\n                            }\n                            let contextSwitchArray = [];\n                            _LC.adCx(helper, contextSwitchArray);\n                            for(let j=0;j<optionsArray.length;j++) {\n                                let optionItem = optionsArray[j];\n                                // Removal of bindings\n                                let itemValue = helper.getAttribute(\"item\");\n                                if(optionItem.type == \"remove\") {\n                                    this.removeSelectedBindingDeep({[itemValue] : helper._items[optionItem.firstIndex].itemProperty}, {[itemValue] : optionItem.removedItem});\n                                }\n                                helper._callee.updateForHelper(helper, optionItem);\n                            }\n                            _LC.rmCx(helper, contextSwitchArray);\n                        }\n                    }\n//                         for(let key in item) {\n//                             let parsedKey = parseInt(key);\n//                             if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {\n//                                 this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);\n//                                 if(item[key]._forHelpers) {\n//                                     let bindfor = item[key]._forHelpers.toArrayLyte();\n//                                     for(var j=0;j<bindfor.length;j++){\n//                                         let item1 = bindfor[j];\n//                                         if(item1._propBindingObject) {\n//                                             this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);\n// //                                          value._bindings.add(item._propBindingObject);\n// //                                          this.establishBindings(item._propBindingObject, value);\n//                                         }\n//                                     }\n//                                 }\n//                                 if(array[parsedKey] && typeof array[parsedKey] === \"object\") {\n//                                 \tmakeSet(array[parsedKey], \"_bindings\");\n//                                 this.establishBindings({\"dummy\" : item[key]},{\"dummy\" : array[parsedKey]});    \n//                                 }\n//                                 this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);\n//                             }\n//                         }\n                }\n            }\n            break;\n        default: \n            //@Slicer.developmentStart\n            ApiError.error(\"LC002\", functionName);\n            //@Slicer.developmentEnd\n            return;\n        }\n        return array;\n    },\n    \"callDeepObservers\" : function (data, args, property ,callLengthObserver){\n        var self = this;\n        var keys = Array.from(data._scp.keys());\n        keys.forEach(function(id){\n            var _scp = data._scp.get(id), \n            scp = _scp.paths,\n            pathArr = Object.keys(scp), \n            aPath;\n            if(pathArr.length == 1){\n                aPath = pathArr[0];\n            }\n            else if(pathArr.length > 1){\n                aPath = pathArr;\n            }\n            var recObj = nestScp[id], \n            attr, \n            rec, \n            isRec = false;\n            if(recObj.model){\n                var mMap = recObj.model;\n                var db = recObj.db;\n                var mKeys = Array.from(recObj.model.keys());\n                for(var i=0; i<mKeys.length; i++){\n                    var mName = mKeys[i];\n                    var pkMap = mMap.get(mName);\n                    if(pkMap){\n                        var pkArr = Array.from(pkMap.keys());\n                        var pkLen = pkArr.length;\n                        for(var j=0; j<pkLen; j++){\n                            var mPk = pkArr[j];\n                            var attrMap = pkMap.get(mPk);\n                            var attrArr = Array.from(attrMap.keys());\n                            var attrLen = attrArr.length;\n                            for(k=0; k<attrLen; k++){\n                                var mAttr = attrArr[k];\n                                if(db.getSchema){\n                                    var mRec = db.cache.getEntity({schema:db.getSchema(mName), pK:mPk});\n                                }\n                                else{\n                                    var mRec = db.cache.getEntity({model:db.getModel(mName), pK:mPk});\n                                }\n                                self.deepObsBind(mRec, true, mAttr, args, pathArr, aPath, data, property, callLengthObserver)                                    \n                            }\n                        }\n                    }\n                }\n            } \n            else{\n                rec = recObj.data;\n                self.deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver)\n            }\n        });\n    },\n    \"deepObsBind\":function(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver){\n        var type = args.type\n        var watchPath , propPath;\n        if(rec._bindings){\n            var newArgs = Object.assign({},args);\n            var objbind = rec._bindings.toArrayLyte();\n            for (var _i65 = 0; _i65 < objbind.length; _i65++) {\n                propPath = aPath;\n                var binding = objbind[_i65], obj = undefined;\n                watchPath = objbind[_i65]._path\n                if(isRec){\n                    if(binding.hasOwnProperty(attr) && binding[attr].hasOwnProperty(\"*\")){\n                        obj = binding[attr][\"*\"];\n                        watchPath = binding[attr]._path;\n                    } \n                }\n                else if(binding.hasOwnProperty(\"*\")){\n                    obj = binding[\"*\"];\n                }\n                if(obj){\n                    var obsbind = obj._observers ? obj._observers.toArrayLyte() : [], path;\n                    if(property){\n                        if(pathArr.length > 1){\n                            var len = pathArr.length, nPathArr = [];\n                            for(var i=0;i<len;i++){\n                                nPathArr.push(pathArr[i] ? pathArr[i]+\".\"+property : property);\n                            }\n                            propPath = nPathArr;\n                        }\n                        else if(pathArr.length == 1){\n                            propPath = aPath ? aPath.concat(\".\" + property) : property;\n                        }\n                    }\n                    for (var j = 0; j < obsbind.length; j++) {\n                        var observer = obsbind[j];\n                        newArgs.path = propPath;\n                        newArgs.type = \"deepChange\";\n                        newArgs.data = rec;\n                        var argPath = obj._path.split('.');\n                        argPath.$pop();\n                        newArgs.item = argPath.join('.'); \n                        var exactPath = newArgs.index!=undefined?(propPath!=\"\"?propPath+\".\":propPath)+newArgs.index:propPath\n                        if(observer.callee && observer.callee.component){\n                            //  observer.observer.value.call(observer.callee.component, newArgs);\n                            var calldeep = true;\n                            var _data = observer.callee.component.__data[newArgs.item];\n                            var _watch = _data ? _data.watch : undefined;\n                            if(_data && typeof _watch != \"boolean\"){\n                                var watchArr = obsbind[j].observer.Jpath[watchPath];\n                                calldeep = checkWatchPath(exactPath , watchArr);\n                            }\n                            if(calldeep){\n                                observer.observer.value.call(observer.callee.component, newArgs);\n                            }\n                        }\n                        else{\n                            var scope = data._setterScope ? data._setterScope : window;\n                            if(Array.isArray(scope)){\n                                var sLen = scope.length;\n                                for(var k=0;k<sLen;k++){\n                                    var itm = scope[k];\n                                    var calldeep = true;\n                                    if(newArgs.data && newArgs.hasOwnProperty(\"item\")){\n                                        var watchArr = newArgs.data.$.schema._fldGrps.watch[newArgs.item].watch\n                                        if(Array.isArray(watchArr)){\n                                            watchArr = obsbind[j].observer.Jpath[watchPath];\n                                            calldeep = checkWatchPath(exactPath , watchArr);\n                                        }\n                                    }\n                                    if(calldeep){\n                                        observer.observer.value.call(itm, newArgs);\n                                    }\n                                }\n                            }\n                            else{\n                                var calldeep = true;\n                                if(newArgs.data && newArgs.hasOwnProperty(\"item\")){\n                                    var watchArr = newArgs.data.$.schema._fldGrps.watch[newArgs.item].watch\n                                    if(Array.isArray(watchArr)){\n                                        watchArr = obsbind[j].observer.Jpath[watchPath];\n                                        calldeep = checkWatchPath(exactPath , watchArr);\n                                    }\n                                }\n                                if(calldeep){\n                                    observer.observer.value.call(scope, newArgs);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!callLengthObserver && type == \"array\" && binding.length) {\n                    this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,callLengthObserver);\n                }\n            }\n        }\n    },\n    \"callArrayObservers\" : function(array, args ,callLengthObserver ,initialArrLength) {\n        if(array._scp && array._scp.size){\n            this.callDeepObservers(array, Object.assign({},args) ,undefined, true);          \n        }\n        if(array._bindings) {\n            let objbind = array._bindings.toArrayLyte();\n            for(let i=0;i<objbind.length;i++){\n                let binding = objbind[i];\n                let path = objbind[i]._path;\n                if(binding._observers) {\n                    let obsbind = binding._observers.toArrayLyte();\n                    for(let j=0;j<obsbind.length;j++){\n                        let observer = obsbind[j];\n                        if(observer.isArrayObserver) {\n                            if(args){\n                                args.item = path;\n                            }\n                            if(observer.callee && observer.callee.component){\n                                observer.observer.value.call( observer.callee.component, args);\n                            }\n                            else{\n                                var scope = array._setterScope ? array._setterScope : window;\n                                if(Array.isArray(scope)){\n                                    var sLen = scope.length;\n                                    for(var k=0;k<sLen;k++){\n                                        var itm = scope[k];\n                                        observer.observer.value.call( itm, args);                                                        \n                                    }\n                                }\n                                else{\n                                    observer.observer.value.call(scope, args);\n                                }\n                            }\n                        }\n                    }\n                }\n                if(binding.length) {\n                    this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,undefined,callLengthObserver);\n                }\n            }\n        }\n    },\n    \"callObjectObservers\" : function(obj, args) {\n        if(obj._bindings) {\n            let objbind = obj._bindings.toArrayLyte();\n            if(args.oldValue !== args.newValue){\n                for(let i=0;i<objbind.length;i++){\n                    let binding = objbind[i];\n                    let path = objbind[i]._path;\n                    if(binding[\"{}\"]){\n                        this.affectChanges(binding[\"{}\"]);\n                    }\n                    if(binding._objectObservers && binding._observers) {\n                        let obsbind = binding._observers.toArrayLyte();\n                        for(let j=0;j<obsbind.length;j++){\n                            let observer = obsbind[j];\n                            if(observer.isObjectObserver) {\n                                if(args){\n                                    if(args.item){\n                                        args.item = path + \".\" + args.item;\n                                    }else{\n                                        args.item = path;\n                                    }\n                                }\n                                observer.observer.value.call( observer.callee && observer.callee.component ? observer.callee.component : obj._setterScope? obj._setterScope : window , args);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"bindWatchObj\" : function(watch, data, insItems, remItems, pos){\n        if(watch && watch.length){\n            watch.forEach(function(wObj){\n                if(wObj.isRec){\n                    deepValueChange(wObj.rec, wObj.attr, data, wObj);\n                }\n                if(remItems){\n                    remItems.forEach(function(itm){\n                        removeNestScp(itm, wObj.id, undefined, undefined, undefined, undefined, wObj.reInit ? wObj.data : undefined);\n                    });\n                }\n                if(insItems){\n                    insItems.forEach(function(itm,idx){\n                        if(itm && ( Array.isArray(itm) || typeof itm == \"object\" )){\n                            var pth = wObj.path.split(',');\n                            pth.$push(pos+idx);\n                            bindObj(itm, undefined, wObj.id,  pth && pth.length ? pth : [], undefined, undefined, true);\n                        }\n                    });\n                }\n                if(pos !== undefined){\n                    var nestObj = nestScp[wObj.id];\n                    if(nestObj.cyclic){\n                        removeNestScp(nestObj._data, wObj.id);\n                        bindObj(nestObj._data, undefined, wObj.id, [], undefined, undefined, true);\n                    }\n                    else{\n                        var insLen = insItems ? insItems.length : 0, newInd = pos+insLen;\n                        var arr = data.slice(newInd);\n                        arr.forEach(function(itm){\n                            removeNestScp(itm, wObj.id);\n                        });\n                        arr.forEach(function(itm,idx){\n                            if(itm && ( Array.isArray(itm) || typeof itm == \"object\" )){\n                                var pth = wObj.path.split(',');\n                                pth.$push(newInd+idx);\n                                bindObj(itm, undefined, wObj.id,  pth && pth.length ? pth : [], undefined, undefined, true);\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    },\n    \"establishUpdateBindings\" : function(bindings, property, actualData) {\n        let objbind = bindings.toArrayLyte();\n        for(let i=0;i<objbind.length;i++){\n            let item = objbind[i];\n            if(item[property]) {\n                makeSet(actualData, \"_bindings\");\n                addBindings(actualData._bindings,item[property]);\n                this.establishBindings(item[property], actualData);\n            }\n\n        }\n    },\n    \"establishSelectedBinding\" : function(property, actualData,node) {\n        if(!property) {\n            return;\n        }\n        let propName = property._path;\n        let props = propName.split('.');\n        let currentProp = node.getProperty(props[0]);\n        let currentValue = actualData[props[0]];\n        for(let i=0;i<props.length;i++) {\n            if(!currentValue || typeof currentValue !== \"object\") {\n                break;\n            } \n            makeSet(currentValue, \"_bindings\");\n                addBindings(currentValue._bindings,currentProp);\n                currentProp = currentProp[props[i+1]];\n                currentValue = currentValue[props[i+1]];\n        }\n    },\n    \"establishBindings\": function(properties, actualData) {\n        if(properties._helperNodes) {\n            let path = properties._path;\n            let arr = properties._helperNodes.toArrayLyte();\n            for(let s=0;s<arr.length;s++) {\n                let nodes = arr[s]._dynamicProperty ? arr[s]._dynamicProperty[path]: undefined;\n                if(nodes) {\n                    for(let j=0;j<nodes.length;j++) {\n                        let node = nodes[j];\n                        let helper = node.ownerElement;\n                        if(helper && helper.tagName === \"TEMPLATE\" && helper.getAttribute(\"is\") === \"for\") {\n                            if(helper._items) {\n                                let item = helper.getAttribute(\"item\");\n                                for(let i=0;i<helper._items.length;i++) {\n                                    let data = actualData[i];\n                                    let item = helper.getAttribute(\"item\");\n                                    if(data) {\n                                        if(typeof helper._items[i] === \"object\") {\n                                            this.establishBindings(helper._items[i].itemProperty, {[item] : data});\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for(let i in properties) {\n            let actData = actualData[i];\n            if(!actData || typeof actData === \"string\" || typeof actData === \"number\" || typeof actData === \"boolean\") {\n                if(!actualData._bindings) {\n                    makeSet(actualData, \"_bindings\");\n                }\n                addBindings(actualData._bindings,properties);\n            } else {\n                if(!actData._bindings) {\n                    makeSet(actData, \"_bindings\");\n                }\n                addBindings(actData._bindings,properties[i]);\n                if(typeof properties[i] === \"object\") {\n                    this.establishBindings(properties[i], actData);\n                }\n            }\n        }\n    },\n    \"removeSelectedBindingDeep\" : function(binding, actualData, fromDisConnect) {\n        var del = \"delete\";\n        if(!actualData && !fromDisConnect) {\n            return;\n        }\n        if(actualData && actualData._bindings) {\n            deleteBindingCheckSize(actualData, \"_bindings\", binding);\n        }\n        for(let i in binding) {\n            let actData;\n            if(actualData){\n                actData = actualData[i];\n            }   \n            if(actData && actData._bindings) {\n                deleteBindingCheckSize(actData, \"_bindings\", binding[i]);\n            }\n            if(typeof binding[i] === \"object\") {\n                this.removeSelectedBindingDeep(binding[i], actData ,fromDisConnect);\n            }\n        }\n        if(fromDisConnect){\n            let dynNodes = binding._dynamicNodes;\n            let helperNodes = binding._helperNodes;\n            if(dynNodes && dynNodes.length){\n                binding._dynamicNodes.$splice(0,dynNodes.length);   \n            }\n            if(helperNodes && helperNodes.size){\n                helperNodes.clear();\n            }\n        }\n        if(binding && binding._forHelpers) {\n            let objbind = binding._forHelpers.toArrayLyte();\n            for(let i=0;i<objbind.length;i++){\n                let fH = objbind[i];\n                if(fH.getAttribute(\"is\") === \"for\") {\n                    let item = fH.getAttribute(\"item\");\n                    let items = fH._attributes.items;\n                    let itemCases = fH._items;\n                    for(let i=0;i<itemCases.length;i++) {\n                        this.removeSelectedBindingDeep(itemCases[i].itemProperty, items[i], fromDisConnect);\n                    }\n                } else {\n                    if(fH._propBindingObject) {\n                        if(actualData && actualData._bindings) {\n                            deleteBindingCheckSize(actualData, \"_bindings\", fH._propBindingObject);\n                            this.removeSelectedBindingDeep(fH._propBindingObject, actualData, fromDisConnect);\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"removeAllBindings\" : function(properties, data) {\n        var del = \"delete\";\n        for(let key in properties) {\n            if(data[key] && data[key]._bindings) {\n//                    data[key]._bindings[del](properties[key]);\n//                    if(!data[key]._bindings.size) {\n//                        delete data[key]._bindings;\n//                    }\n                deleteBindingCheckSize(data[key], \"_bindings\", properties[key]);\n            }\n            if(data[key] && typeof data[key] !== \"string\") {\n                _LC.removeAllBindings(properties[key], data[key]);\n            }\n        }\n    },\n    \"affectChanges\" : function(item, contextAlreadySwitched,oldValue,setterScope,newValue,stack,callLengthObserver) {\n        if(item._dynamicNodes) {\n            for(let i=0;i<item._dynamicNodes.length;i++) {\n                item._dynamicNodes[i]._callee.updateNode(item._dynamicNodes[i], item._path);\n            }\n        }\n        let propPath = item._path;\n        if(item._helperNodes) {\n            let nodes = [],itemHelperNodes = item._helperNodes.toArrayLyte();\n            for(let s=0;s<itemHelperNodes.length;s++){\n                if(!item._helperNodes.has(itemHelperNodes[s])) {\n                    continue;\n                }\n                if(itemHelperNodes[s].getAttribute(\"is\") === \"for\" && itemHelperNodes[s]._items) {\n                    let innerContextSwitchArray = [];\n                    _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);\n                    let  indexValue = itemHelperNodes[s].getAttribute(\"index\");\n                    let itemValue = itemHelperNodes[s].getAttribute(\"item\");\n                    let callee = itemHelperNodes[s]._callee;\n                    let initialItemValue = callee.component.data[itemValue];\n                    let initialIndexValue = callee.component.data[indexValue];\n                    let initialItemProp = callee._properties[itemValue];\n                    let initialIndexProp = callee._properties[indexValue];\n                    let items = itemHelperNodes[s]._attributes.items;\n                    for(let i=0;i<itemHelperNodes[s]._items.length;i++) {\n                        callee.component.data[itemValue] = items[i];\n                        callee.component.data[indexValue] = i;\n                        callee._properties[itemValue] = itemHelperNodes[s]._items[i].itemProperty;\n                        if(itemHelperNodes[s]._items[i]._dynamicProperty[propPath]) {\n                            nodes = itemHelperNodes[s]._items[i]._dynamicProperty[propPath];\n                            for(let i=0;i<nodes.length;i++) {\n                                nodes[i]._callee.updateNode(nodes[i], propPath);\n                            }\n                        }\n                    }\n                    callee.component.data[itemValue] = initialItemValue;\n                    callee.component.data[indexValue] = initialIndexValue;\n                    callee._properties[itemValue] = initialItemProp;\n                    callee._properties[indexValue] = initialIndexProp;\n                    _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);                                    \n                } else if(itemHelperNodes[s].getAttribute(\"is\") === \"forIn\" && itemHelperNodes[s]._items) {\n                    let innerContextSwitchArray = [];\n                    _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);\n                    let  indexValue = itemHelperNodes[s].getAttribute(\"key\");\n                    let itemValue = itemHelperNodes[s].getAttribute(\"value\");\n                    let callee = itemHelperNodes[s]._callee;\n                    let initialItemValue = callee.component.data[itemValue];\n                    let initialIndexValue = callee.component.data[indexValue];\n                    let initialItemProp = callee._properties[itemValue];\n                    let initialIndexProp = callee._properties[indexValue];\n                    let object = itemHelperNodes[s]._attributes.object;\n                    for(let key in itemHelperNodes[s]._items) {\n                        callee.component.data[itemValue] = object[key];\n                        callee.component.data[indexValue] = key;\n                        callee._properties[itemValue] = itemHelperNodes[s]._items[key].itemProperty;\n                        if(itemHelperNodes[s]._items[key]._dynamicProperty[propPath]) {\n                            nodes = itemHelperNodes[s]._items[key]._dynamicProperty[propPath];\n                            for(let i=0;i<nodes.length;i++) {\n                                nodes[i]._callee.updateNode(nodes[i], propPath);\n                            }\n                        }\n                    }\n                    callee.component.data[itemValue] = initialItemValue;\n                    callee.component.data[indexValue] = initialIndexValue;\n                    callee._properties[itemValue] = initialItemProp;\n                    callee._properties[indexValue] = initialIndexProp;\n                    _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);    \n                } else {\n                    nodes = itemHelperNodes[s]._dynamicProperty[item._path] || [];\n                    let contextSwitchArray = [];\n                    if(nodes.length) {\n                        _LC.adCx(itemHelperNodes[s], contextSwitchArray);\n                        for(let i=0;i<nodes.length;i++) {\n                            nodes[i]._callee.updateNode(nodes[i], item._path);\n                        }\n                        _LC.rmCx(itemHelperNodes[s], contextSwitchArray);    \n                    }\n                    \n                }\n            }\n        }\n        if(item._observers) {\n            let objbind = item._observers.toArrayLyte();\n            let cond = callLengthObserver == false ? false : oldValue != undefined || newValue != undefined;\n            if(cond){\n                for(let i=0;i<objbind.length;i++){\n                    let observer = objbind[i];\n                    let obsObj = {type:\"change\",oldValue:oldValue,newValue:newValue, item: item._path};\n                    if(observer.callee && observer.callee.component){\n                        if(stack && observer.isObjectObserver){\n                            obsObj.observer = observer;\n                            stack.$push(obsObj);\n                        }else{\n                            observer.observer.value.call(  observer.callee.component, obsObj);                      \n                        }\n                    }\n                    else{\n                        var scope = setterScope ? setterScope : window;\n                        if(Array.isArray(scope)){\n                            var sLen = scope.length;\n                            for(var k=0;k<sLen;k++){\n                                var itm = scope[k];\n                                observer.observer.value.call( itm, obsObj);\n                            }\n                        }\n                        else{\n                            observer.observer.value.call( scope, obsObj);                      \n                        }\n                    }\n                }\n            }\n        }\n        if(Array.isArray(item)){\n            for(var i=0;i<item.length;i++){\n                for(let key in item[i]) {\n                    this.affectChanges(item[i][key], true,oldValue?(oldValue[i]?oldValue[i][key]:oldValue[i]):oldValue,setterScope,newValue?(newValue[i]?newValue[i][key]:newValue[i]):newValue);\n                }\n            }\n        }\n        else{\n            for(let key in item) {\n                var oldV = oldValue ? oldValue[key] : oldValue, newV = newValue ? newValue[key] : newValue;\n                if(key == \"*\" && item[key].hasOwnProperty(\"_observers\")){\n                    oldV = oldValue;\n                    newV = newValue\n                }\n                this.affectChanges(item[key], true, oldV, setterScope, newV,stack);\n            }\n        }\n    },\n    \"executeObserver\": function(stack){\n        stack.forEach(function(obj){\n            obj.observer.observer.value.call( obj.observer.callee && obj.observer.callee.component ? obj.observer.callee.component : setterScope ? setterScope : window ,{type:obj.type,oldValue:obj.oldValue,newValue:obj.newValue, item: obj.item});   \n        });\n    },\n    \"skipArgProcessing\" : function(cloneActObj,ev,target) {\n        if(cloneActObj.skipArgProcessing) {\n            let args = cloneActObj.args = cloneActObj.actArgs;\n            args.$shift();\n            var eventIndex = args.indexOf(\"__lyteEvent__\");\n            var nodeIndex = args.indexOf(\"__lyteNode__\");\n            if(eventIndex !== -1) {\n                args[eventIndex] = ev;\n            } \n            if(nodeIndex !== -1) {\n                args[nodeIndex] = target;\n            }\n        } else {\n            cloneActObj.args.$shift();\n        }\n    },\n    // getDV added\n    // \"getDV\" : function(value){    \n    //     var result = [],ref = result,arr = [],data = \"\",strStack = [],arrayStack = [],refStack = [],strLast,str;\n    //     for(var i=0;i<value.length;i++){\n    //         if(value[i] === \".\"){\n    //             if(data.length){\n    //                 ref.$push(data);\n    //             }\n    //             data = \"\";\n    //             continue;\n    //         }\n    //         else if(value[i] === \"[\"){\n    //             arrayStack.$push(i)\n    //             if(data.length){\n    //                 ref.$push(data);\n    //             }\n    //             while(value[i+1] === \"\\s\"){\n    //                 i++;\n    //             }\n    //             if(value[i+1] === \"\\\"\" || value[i+1] === \"'\"){\n    //                 strStack.$push(value[i+1]);\n    //                 strLast = value[i+1];\n    //                 i++;\n    //             }\n    //             else if(arr.length){\n    //                 ref.$push([]);\n    //                 refStack.$push(ref);\n    //                 ref = ref[ref.length-1];\n    //             }else{\n    //                 arr.$push([]);\n    //                 refStack.$push(ref);\n    //                 ref = arr[arr.length-1];\n    //             }\n    //             data = \"\";\n    //             continue;\n    //         }\n    //         else if((value[i] === \"\\\"\" || value[i] === \"'\" ) && value[i++] === strLast){\n    //             while(value[i] === \"\\s\" && value[i] != \"]\"){\n    //                 i++;\n    //             }\n    //             strStack.$pop();\n    //             str = true;\n    //         }\n    //         if(value[i] === \"]\"){\n    //             arrayStack.$pop();\n    //             if(data.length){\n    //                 if(str === true){\n    //                     ref.$push(data);    \n    //                 }\n    //                 else if(!isNaN(parseInt(data))){\n    //                     if(refStack.length){\n    //                         ref = refStack.$pop();\n    //                         if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){\n    //                             ref.$pop();\n    //                         }\n    //                         ref.$push(data);\n    //                         if(!arrayStack.length && arr.length){\n    //                             arr.$shift();\n    //                         }\n    //                     }\n    //                 }\n    //                 else{\n    //                     ref.$push(data);\n    //                 }\n    //             }\n    //             if(!arrayStack.length && arr.length){\n    //                 result.$push(arr.$shift());\n    //                 ref = result;\n    //             }\n    //             else if(refStack.length && !arr.length){ \n    //                 ref = refStack.$pop();\n    //             }\n    //             data = \"\";\n    //             str = \"\";\n    //             continue;\n    //         }\n    //         data = data.concat(value[i]);\n    //     }\n    //     if(data.length){\n    //         result.$push(data);\n    //     }\n    //     if(strStack.length || arrayStack.length){\n    //         console.log(\"check the syntax\",strStack,arrayStack);\n    //     }\n    //     return result;\n    // },\n    \"ccDelay\" : [],\n    \"callCC\" : function() {\n        this.ccDelay.forEach(function(item) {\n            if(item.component) {\n                item.actualConnectedCallback();\n            }\n        });\n        this.ccDelay = [];\n    },\n    \"getDD\":function(context,dataArr){\n        var self = context;\n        dataArr.forEach(function(item,index){\n            if(Array.isArray(item)){\n                if(context == undefined){\n                    return undefined;\n                }\n                var inner = _LC.getDD(self,item);\n                if(inner == undefined){\n                    return undefined;\n                }\n                context = context[inner];\n            }else{\n                if(context == undefined){\n                    return undefined;\n                }\n                context = context[item];\n            }\n        });\n        return context;\n    },\n\n    \"processStatic\" : function(temp) {\n        let arr = temp.innerHTML.split(\"__**\");\n        let newArr = [];\n        for(var i=0;i<arr.length;i++) {\n            if(arr[i].startsWith(\"--Lyte\")) {\n                newArr.$push(parseInt(arr[i].substring(6)));\n            } else {\n                newArr.$push(undefined);\n            }\n        }\n        arr.cc = newArr;\n        return arr;\n    },\n    \"findLastNodeL\" : function(lastNode1,count,node){\n        var totalNodeIndex = 0;\n        if(count != undefined){\n            totalNodeIndex = count; \n        }\n        var helperNode;\n        switch(node.getAttribute(\"is\")) {\n            case \"for\" : \n                if(node._helpers[totalNodeIndex]){\n                    helperNode = node._helpers[totalNodeIndex][0];   \n                }\n                if(!lastNode1) {\n                    if(node._forContent[0]){\n                        lastNode1 = node._forContent[0][0];\n                    }\n                }\n                break;\n            case \"forIn\" : \n                if(node._helpers[node._keysArray[0]]){\n                    helperNode = node._helpers[node._keysArray[0]][0];\n                }\n                if(!lastNode1) {\n                    if(node._forContent[node._keysArray[0]]){\n                        lastNode1 = node._forContent[node._keysArray[0]][0];\n                    }\n                }                   \n                break;\n            case \"if\" : \n            case \"switch\" : \n                helperNode = node._helpers[totalNodeIndex];\n                if(!lastNode1) {\n                    lastNode1 = node._caseContent[0];\n                }\n            break;\n            case \"component\" : \n                lastNode1 = lastNode1._renderedComponent[lastNode1._currentComponent] || lastNode1;\n                return lastNode1;\n        }\n        if(!lastNode1){\n            lastNode1 = node._placeHolder;\n        }\n        if(helperNode && (lastNode1 == helperNode._placeHolder)) {\n            lastNode1 =  this.findLastNodeL(undefined, undefined, helperNode);\n        }\n        return lastNode1;\n    },\n    \"processAction\" : function(node) {\n        Array.from(node.querySelectorAll('[lyteaction]')).forEach(function(item) { \n            let locIndex = item.attributes.lyteaction.value;\n            item._boundEvents = _LC.fRP[locIndex];\n            delete _LC.fRP[locIndex];\n            // _LC.$pushFrc(locIndex);\n            // item._boundEvents = JSON.parse(item.attributes.lyteaction.value);\n            var _cx = item._boundEvents._cx;\n            let boundEvents = item._boundEvents;\n            delete boundEvents._cx;\n            let componentName = boundEvents.componentName;\n            delete boundEvents.componentName;\n            for(var key in item._boundEvents) {\n                if(key.indexOf(\"-\") !== -1) {\n                    item._actions = item._actions || {};\n                    item._actions[key] = new CustomEvent(key);\n                    item._actions[key].processAction = item._boundEvents[key];\n                    item._boundEvents[key].actArgs.$shift();\n                    let nodeIndex = item._boundEvents[key].actArgs.indexOf(\"__lyteNode__\");\n                    if(nodeIndex !== -1) {\n                        item._boundEvents[key].actArgs[nodeIndex] = item;\n                    }\n                    item._boundEvents[key].args = item._boundEvents[key].actArgs;\n                    delete item._boundEvents[key];\n                } else {\n                    let actArgs = deepCopyObject(item._boundEvents[key].args);\n                    let actName = actArgs.$splice(0,1)[0];\n                    actName = actName.startsWith(\"'\")? actName.replace(/'/g,''):  actName;\n                    let actString = getArgString(actName, actArgs);\n                    item.setAttribute(key.startsWith(\"on\") ? key.substr(2) : key ,componentName+\" => \"+ actString);\n                    if(!item._boundEvents[key].globalEvent) {\n                        item.addEventListener(key,globalEventHandler);\n                    }\n                }\n            }\n            item._boundEvents._cx = _cx;\n            item.removeAttribute(\"lyteaction\");\n            //item._boundEvents = item.\n        });\n    },\n    \"getCtxVal\" : function(context,val){\n        if(context != undefined){\n            return context[val];\n        }else{\n            return undefined;\n        }\n    },\n    \"get\" : function(context, path, ac,cache) {\n        if(!ac) {\n            ac = [];\n        }\n        if(cache && cache.hasOwnProperty(path)){// cache.cacheData[path]\n            var nodeValue = cache[path]._data; /* put as local variable due to error. plz cross check - christo */\n            if(cache[path]._dyn){\n                cache[path]._dyn.forEach(function(item){\n                    ac.$push(item);\n                });\n            }\n            return nodeValue;\n        }\n        else{\n        try{\n            if(path.search(/^\\$\\./g)!=-1){\n                return Jwalk(context,path);\n            }\n            let arr = path.match(/([^[\\]]+|\\[\\])/g);\n            let initialContext = context;\n            ac.$push(arr[0]);\n            let locArr = arr[0].split('.'); \n            for(let k=0;k<locArr.length;k++) {\n                context = _LC.getCtxVal(context,locArr[k])\n            }\n            for(let i=1;i<arr.length;i++) {\n                let locVal = arr[i];\n                //this is context switching\n                if(locVal.startsWith(\".\")) {\n                    //direct context switching\n                    let locArr = locVal.substring(1).split('.');\n                    for(let k=0;k<locArr.length;k++) {\n                        context = _LC.getCtxVal(context,locArr[k])\n                    }\n                    // ac[ac.length -1] = ac[ac.length - 1] + locVal;\n                    ac[0] = ac[0] + locVal;\n                } else if(locVal.startsWith(\"'\") || locVal.startsWith('\"') || !isNaN(locVal)) {\n                    if(!isNaN(locVal)) {\n                        // ac[ac.length-1] = ac[0] + \".\" + locVal;\n                        ac[0] = ac[0] + \".\" + locVal;\n                        context = _LC.getCtxVal(context,locVal)\n                    } else {\n                        // ac[ac.length-1] = ac[0] + \".\" + locVal.substring(1, locVal.length -1);\n                        ac[0] = ac[0] + \".\" + locVal.substring(1, locVal.length -1);\n                        context = _LC.getCtxVal(context,locVal.substring(1, locVal.length -1))\n                    } \n                } else {\n                    let length = ac.length;\n                    let val = _LC.get(initialContext, locVal, ac);\n                    ac[0] = ac[0] + \".\" + val;\n                    context = _LC.getCtxVal(context,val)\n                }\n                }\n                if(cache){\n                    cache[path] = {};\n                    cache[path]._data = context;  \n                    cache[path]._dyn = ac;\n                }\n            return context;\n        } catch(e) {\n            return undefined;\n        }\n        }\n    },\n    \"getNew\" : function(context, path) {\n        try{\n            let arr = path.match(/([^[\\]]+|\\[\\])/g);\n            let initialContext = context;\n            let locArr = arr[0].split('.'); \n            if(arr.length < 2) {\n                if(locArr.length <2) {\n                    return {\"context\": initialContext, \"lastKey\" : locArr[0]};\n                } else {\n                    for(var k=0;k<locArr.length-1;k++) {\n                        context = context[locArr[k]];\n                    }\n                    return {\"context\" : context, \"lastKey\" : locArr[k]}\n                }\n            }\n            for(let k=0;k<locArr.length;k++) {\n                context = context[locArr[k]];\n            }\n            for(var i=1;i<arr.length - 1;i++) {\n                let locVal = arr[i];\n                //this is context switching\n                if(locVal.startsWith(\".\")) {\n                    //direct context switching\n                    let locArr = locVal.substring(1).split('.');\n                    for(let k=0;k<locArr.length;k++) {\n                        context = context[locArr[k]];\n                    }\n                } else if(locVal.startsWith(\"'\") || locVal.startsWith('\"') || !isNaN(locVal)) {\n                    context = context[locVal.substring(1, locVal.length -1)];\n                } else {\n                    let val = this.get(initialContext, locVal);\n                    context = context[val];\n                }\n                }\n            let lastKey = arr[i];\n            if(lastKey.startsWith(\".\")) {\n                //direct context switching\n                let locArr = lastKey.substring(1).split('.');\n                let k=0\n                for(;k<locArr.length - 1;k++) {\n                    context = context[locArr[k]];\n                }\n                lastKey = locArr[k];\n            } else if(lastKey.startsWith(\"'\") || lastKey.startsWith('\"') || !isNaN(lastKey)) {\n                lastKey = lastKey.substring(1, lastKey.length -1);\n            } else {\n                lastKey = this.get(initialContext, lastKey);\n            }\n            return {\"context\" : context, \"lastKey\" : lastKey };\n        } catch(e) {\n            return undefined;\n        }\n    },\n    \"componentGetData\" : function(key){\n        if(key) {\n            return this.get(key);\n        } else {\n            return this.data;\n        }\n    },\n    \"componentSetData\" : function(arg0, arg1 ,options) {\n        if(typeof arg0 === \"string\") {\n            this.set(arg0, arg1 ,options);\n        } else if(typeof arg0 === \"object\") {\n            for(let key in arg0) {\n                this.set(key, arg0[key],arg1);\n            }\n        }\n    },\n    \"componentGetMethods\" : function(key) {\n        if(key) {\n            return this._methods[key];\n        } else {\n            return this._methods;\n        }\n    }, \n    \"componentHasAction\" : function(key) {\n        if(key && this.$node._actions[key]) {\n            return true;\n        } else {\n            return false;\n        }\n    }, \n    \"componentGetActions\" : function(key) {\n        if(key) {\n            return this.constructor._actions[key];\n        } else {\n            return this.constructor._actions;\n        }\n    }, \n    \"componentGetObservers\" : function() {\n        return this.constructor._observers;\n    },\n    \"componentsetActions\" : function(arg0,arg1) {\n        let actions = this.$node.constructor._actions;\n        if(typeof arg0 === \"string\") {\n            actions[arg0] = arg1;\n        } else if(typeof arg0 === \"object\") {\n            for(let key in arg0) {\n                actions[key] = arg0[key];\n            }\n        }\n    },\n    \"componentSetMethods\" : function(arg0, arg1) {\n        if(typeof arg0 === \"string\") {\n            this._methods[arg0] = arg1;\n        } else if(typeof arg0 === \"object\") {\n            for(let key in arg0) {\n                this._methods[key] = arg0[key];\n            }\n        }\n    },\n    \"String\" : {\n        \"cache_c\":{},\n        \"cache_d\":{},\n        \"upperCaseFirstLetter\" : function(string) {\n            return string.charAt(0).toUpperCase() + string.slice(1);\n        },\n        \"lowerCaseFirstLetter\" : function(string) {\n            return string.charAt(0).toLowerCase() + string.slice(1);\n        }, \n        \"toCamelCase\" : function(string) {\n            if(!this.cache_c[string]){\n                this.cache_c[string] = string.replace(/(-\\w)/g, function(m){return m[1].toUpperCase();});\n            }\n            return this.cache_c[string];\n        }, \n        \"dasherize\" : function(string) {\n            if(!this.cache_d[string]){\n                this.cache_d[string] = string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n            }\n            return this.cache_d[string];\n        }\n    },\n    \"appendChild\" : function(outlet, component) {\n        _LC.ignoreDisconnect = Lyte.ignoreDisconnect = true;\n        outlet.appendChild(component);\n        _LC.ignoreDisconnect = Lyte.ignoreDisconnect = false;\n    },\n    \"replaceWith\" : function() {\n        var argumentsArr = Array.from(arguments);\n        var oldNode = argumentsArr.$shift();\n        _LC.ignoreDisconnect = true;\n        var parentNode = oldNode.parentNode;\n        for(var i=0,node;node=argumentsArr[i];i++) {\n            _LC.insertBeforeNative(parentNode, node, oldNode);\n        }\n        oldNode.remove();\n        _LC.ignoreDisconnect = false;\n    },\t\n    // \"removeIfCaseContent\" : function(comp,node,direct){\n    //     if(!direct){\n    //         for(let tempName in node._tempList) {\n    //             this.removeDynamicNodes(node._tempList[tempName],comp);\n    //         }\n    //     }\n    // },\n    // \"removeYieldContent\" : function(node,){\n    //     if(!direct){\n    //         for(let tempName in node._tempList) {\n    //             this.removeDynamicNodes(node._tempList[tempName]);\n    //         }\n    //     }\n    // },\n    \"insertBeforeNative\" : function(parent, newNode, refNode) {\n        parent.insertBefore(newNode, refNode);\n    },\n    \"insertBefore\" : function(referenceNode, newNode, parentNode) {\n        _LC.ignoreDisconnect = true;\n        if(!parentNode) {\n            if(!referenceNode) {\n                //@Slicer.developmentStart\n                ApiError.error(\"LC005\");\n                //@Slicer.developmentEnd\n                _LC.ignoreDisconnect = false;\n                return;\n            } else {\n                parentNode = referenceNode.parentNode;\n            }\n        }\n        _LC.insertBeforeNative(parentNode , newNode, referenceNode ? referenceNode : null);\n        _LC.ignoreDisconnect = false;\n    },\n    \"insertAfter\" : function() {\n        var argumentsArr = Array.from(arguments);\n        var referenceNode = argumentsArr.shift();\n        _LC.ignoreDisconnect = true;\n        referenceNode.after.apply(referenceNode, argumentsArr);\n        _LC.ignoreDisconnect = false;\n    },\n    \"executeMethod\" : function() {\n        let args = Array.prototype.slice.call(arguments, 1);\n        var methodName = _LC.String.toCamelCase(arguments[0]);\n        if(!this._methods[methodName]) {\n            //@Slicer.developmentStart\n            let app = _LC.getNearestParentApp(this.component);\n            ComponentError.error(app, \"LC005\", methodName, this.$node.tagName);\n            //@Slicer.developmentEnd\n            return;\n        }\n        return this._methods[methodName].apply(this, args);\n    },\n    // \"getProperData\" : function(obj) {\n    //     var dataType = obj.dataType;\n    //     var attr = obj.attr;\n    //     var newValue = obj.newValue;\n    //     var tagName = obj.tagName;\n    //     switch(dataType) {\n    //     case \"boolean\" : \n    //         {\n    //             if(!newValue || newValue === \"false\") {\n    //                 newValue= false;\n    //             } else {\n    //                 newValue = true;\n    //             }\n    //         }\n    //         break;\n    //     case \"object\" : \n    //         try{\n    //             newValue = JSON.parse(newValue);\n    //             if(!(newValue instanceof Object)) {\n    //                 Lyte.warn(\"data type of the value provided for attribute \"+ attr + \" of \" + tagName + \" is not valid\");\n    //             }\n    //         } catch(e) {\n    //             Lyte.warn(\"attribute \"+attr+ \" is not a valid JSON string.\");\n    //             return;\n    //         }\n    //         break;\n    //     case \"array\":\n    //         try{\n    //             newValue = JSON.parse(newValue);\n    //             if(!(newValue instanceof Array)) {\n    //                 Lyte.warn(\"data type of the value provided for attribute \"+ attr + \" of \" + tagName + \" is not valid\");\n    //             }\n    //         } catch(e) {\n    //             Lyte.warn(\"attribute \"+attr+ \" is not a valid JSON string.\");\n    //             return;\n    //         }\n    //         break;\n    //     case \"number\":\n    //         {\n    //     let numValue = +newValue;\n    //         if(newValue === numValue+\"\") {\n    //             newValue = numValue;\n    //         } else {\n    //             Lyte.warn(\"data type of the value provided for attribute \"+ attr + \" of \" + tagName + \" is not valid\");\n    //             return;\n    //         }\n    //     }\n    //         break;\n    //     }\n    //     obj.newValue = newValue;\n    //     return true;\n    // }, \n    \"cssEscape\" : function(string) {\n        if(string) {\n            return string.replace(/['\"]/g, \"\\\\$&\");    \n        } else {\n            return string;\n        }\n        \n    },\n    \"arrayOverride\" : function(){\n        let allArrFns = [\"push\",\"pop\",\"splice\",\"shift\",\"unshift\",\"concat\",\"replaceAt\",\"shiftObject\",\"remove\",\"removeAt\",\"removeObject\",\"removeObjects\",\"unshiftObject\",\"unshiftObjects\",\"insertAt\"];\n        for(let i=0; i<allArrFns.length; i++){\n            let fnName = allArrFns[i];\n            Array.prototype[fnName] = (function() {\n                return function() {\n                    let actArgs = Array.from(arguments);\n                    if(_LC){\n                        let opt = {fromOverride : true};\n                        actArgs.$unshift(opt,this,fnName);\n                        return _LC.aF.apply(_LC, actArgs);\n                    }else{\n                        return this[\"$\"+fnName].apply(this,actArgs);\n                    }\n                };\n            })();\n        }\n    },\n    \"render\" : function(componentName, data, outlet, _lyteOptions) {\n        var component;\n        ltCf.fromV4Render = true;\n        let oldLyteV4 = ltCf.lyteV4;\n        if(_LC.validateRenderData(data)) {\n            var currentReg = _LC.getCurrentRegistryIns();\n            var currentRegClass = _LC.getCurrentRegistryIns();\n            _LC.setCurrentRegistryIns(_lyteOptions && _lyteOptions.registryInstance ? _lyteOptions.registryInstance : this);\n            _LC.setCurrentRegistry(_lyteOptions && _lyteOptions.registry ? _lyteOptions.registry : undefined);\n            if(data && data.lyteV4){\n                ltCf.lyteV4 = true;\n            }\n            if(componentName && typeof componentName == \"string\") {\n                //@Slicer.developmentStart\n                if(!this._registeredComponents[componentName]){\n                    Lyte.warn(\"Invalid Lyte Component name : '\" + componentName + \"'. It is not registered with Lyte.\");\n                }\n                Lyte.warn(\"Passing component name '\" +componentName+ \"' as string is depricated.\");\n                //@Slicer.developmentEnd\n                component = createElement(componentName);\n            } else if(componentName && componentName._compName) {\n                componentName._lyteOptions = _lyteOptions;\n                component = createElement(componentName._compName);\n                if(componentName._lyteOptions && componentName._lyteOptions.attributes && componentName._lyteOptions.attributes.length){\n                    componentName._lyteOptions.attributes.forEach(function(attr){\n                        if(typeof attr == \"object\"){\n                            component.setAttribute(attr.name,attr.value);\n                        }else{\n                            component.setAttribute(attr,\"\");\n                        }\n                    })\n                }\n                componentName._lyteOptions = undefined;\n            } else {\n                //@Slicer.developmentStart\n                ApiError.error(\"LC003\");    \n                //@Slicer.developmentEnd\n                _LC.setCurrentRegistryIns(currentReg); \n                _LC.setCurrentRegistry(currentRegClass);\n                ltCf.fromV4Render = false;\n                ltCf.lyteV4 = oldLyteV4\n                return;\n            }\n        } else {\n            //@Slicer.developmentStart\n            ApiError.error(\"LC0010\");\n            //@Slicer.developmentEnd\n            _LC.setCurrentRegistryIns(currentReg);\n            _LC.setCurrentRegistry(currentRegClass)\n            ltCf.fromV4Render = false;\n            ltCf.lyteV4 = oldLyteV4\n            return;\n        }\n        \n        if(data){ \n            component.setData(data);\n        }\n        if(_lyteOptions && _lyteOptions.methods){\n            component.setMethods(_lyteOptions.methods);\n        }\n        if(outlet) {\n            let actOutlet;\n            if(typeof outlet == \"string\"){\n                actOutlet = document.querySelector(outlet);\n            }else{\n                actOutlet = outlet;\n            }\n            if(actOutlet) {\n                if(_lyteOptions && _lyteOptions.clearOutlet){\n                    actOutlet.innerHTML = \"\";    \n                }\n                actOutlet.appendChild(component);\n                component._callee = component.getCallee ? component.getCallee(actOutlet) : undefined;\n            } \n            //@Slicer.developmentStart\n            else {\n                ApiError.error(\"LC004\", outlet);\n            }\n            //@Slicer.developmentEnd\n        }\n        _LC.setCurrentRegistryIns(currentReg);\n        _LC.setCurrentRegistry(currentRegClass);\n        ltCf.fromV4Render = false;\n        ltCf.lyteV4 = oldLyteV4\n        return component;\n    },\n    // \"renderHTML\" : function(string,outlet,options){\n    //     var currentReg = _LC.getCurrentRegistryIns();\n    //     _LC.setCurrentRegistryIns(options && options.registryInstance ? options.registryInstance : this)\n    //     if(typeof string == \"string\") {\n    //         if(outlet) {\n    //             let actOutlet;\n    //             if(typeof outlet == \"string\"){\n    //                 actOutlet = document.querySelector(outlet);\n    //             }else{\n    //                 actOutlet = outlet;\n    //             }\n    //             if(actOutlet) {\n    //                 actOutlet.innerHTML = string;\n    //             } else {\n    //                 Lyte.error(\"LC008\", outlet);\n    //             }\n    //         }\n    //     }\n    //     _LC.setCurrentRegistryIns(currentReg);\n    // },\n    \"removeForContent\" : function(node){\n        for(let s=0;s<node._forContent.length;s++) {\n            for(let i=0;i<node._forContent[s].length; i++ ) {\n                node._forContent[s][i].remove();\n            }\n        }\n    },\n    \"removeForInContent\" : function(node){\n        for(var ind in node._forContent) {\n            for(let i=0;i<node._forContent[ind].length; i++ ) {\n                node._forContent[ind][i].remove();\n            }\n        }\n    },\n    \"removeIfContent\" : function(node){\n        for(let i=0;i<node._caseContent.length; i++ ) {\n            node._caseContent[i].remove();\n        }\n    },\n    \"removeIfCaseContent\" : function(comp,node,direct){\n        if(!direct){\n            for(let tempName in node._tempList) {\n                this.removeDynamicNodes(node._tempList[tempName],comp);\n            }\n        }\n    },\n    \"removeYieldContent\" : function(node){\n        if(!direct){\n            for(let tempName in node._tempList) {\n                this.removeDynamicNodes(node._tempList[tempName]);\n            }\n        }\n    },\n    \"removeDynamicNodes\" : function(node,comp){\n        for(let key in node._dynamicProperty) {\n            if(node._dynamicProperty[key].isActualNode) {\n                node._dynamicProperty[key].isActualNode._helperNodes[del](node);\n            }else {\n                let helperNodes = comp.getProperty(key)._helperNodes;\n                if(helperNodes) {\n                    helperNodes.delete(node);\n                }\n            }\n        }\n        node._dynamicProperty = {};\n    },\n    \"insertInDom\" : function(placeHolder,lastNode,toAppendMain){\n        if(placeHolder) {\n            _LC.insertBeforeNative(placeHolder.parentNode, toAppendMain, placeHolder);                \t\n        } else {\n            _LC.insertBeforeNative(lastNode.parentNode,toAppendMain, lastNode);                \n        } \n    },\n    \"appendInDom\" : function(comp,content){\n        comp.appendChild(content);\n    },\n    \"instantiateSecurity\" : function(lyteIns){\n        lyteIns.Security = {\n            \"_ourSanitizerInstance_\" :{},\n            \"_userSanitizerInstance_\":{}, \n            \"_eM\" : {\n                '&': '&amp;',\n                '<': '&lt;',\n                '>': '&gt;',\n                '\"': '&quot;',\n                \"'\": '&#x27;',\n                '`': '&#x60;',\n                '=': '&#x3D;'\n              }, \n            \"_eR\" : /[&<>\"'`=]/g,\n            \"_eF\" : function(str) {\n                return this._eM[str];\n            }, \n            \"escape\" : function(string) {\n                if (typeof string !== 'string') {\n                    string = '' + string;\n                }\n                return string.replace(this._eR, this._eF.bind(this));\n            }\n        };\n        var sec = {};\n        lyteIns.Security._ourSanitizerInstance_ = _LC.Security.createSanitizer(sec);\n        lyteIns.Security.createSanitizer = function (obb) {\n            return _LC.Security.createSanitizer(obb);\n        };\n    },\n    \"setAttribute\" : function(node,name,val){\n        node.setAttribute(name,val);\n    }\n}\n_LC.setData = function(arg0, arg1) {\n    this._initProperties = this._initProperties || {};\n    if(typeof arg0 === \"string\") {\n        this._initProperties[arg0] = arg1\n    } else if(typeof arg0 === \"object\") {\n        for(let key in arg0) {\n            this._initProperties[key] = arg0[key];\n        }\n    }\n}\n_LC.setMethods = function(arg0, arg1) {\n    this._initMethods = this._initMethods || {};\n    if(typeof arg0 === \"string\") {\n        this._initMethods[arg0] = arg1\n    } else if(typeof arg0 === \"object\") {\n        for(let key in arg0) {\n            this._initMethods[key] = arg0[key];\n        }\n    }\n}\nLyte.$.shadowDiv._duplicateStyle = [];\nLyte.$.assetsDiv._duplicateStyle = [];\nLyte.$.shadowDiv._compList = [];\nLyte.$.shadowDiv._shadowChild = [];\nvar div = document.createElement(\"div\");\ndiv.setAttribute(\"id\",\"lessDiv\");\nLyte.$.shadowDiv._lessDiv = div;\ndiv._impNames = [];\n\nLyte._component.init = function(lyteIns){\n    _LC.instantiateSecurity(lyteIns);\n    lyteIns.addEventListener(\"afterRouteTransition\", function() {\n        _LC.chromeBugFix();\n    });\n}\nLyteAddon._component.init = function(addOnIns){\n    _LC.instantiateSecurity(addOnIns);\n}\nLyte._component.didConnect = function(lyteIns){\n    //will be called after afterlookups\n    if(lyteIns.getDefaultRegistry){\n        let regIns = lyteIns.getDefaultRegistry();\n        if(!_LC.isValidReg(regIns)){\n            let name =  regIns ? regIns.constructor ? regIns.constructor.name : regIns : regIns ;\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC008\", name, name);\n            //@Slicer.developmentEnd\n            return false;\n        }\n        _LC.setDefaultRegistryIns(regIns);\n    }\n}\n//var toArrayLyte = \"toArrayLyte\";\n//var bindStr = \"_bindings\";\n//var compStr = \"component\";\n//var forHelperStr = \"_forHelpers\";\n//var dynamicNodesStr = \"_dynamicNodes\";\n//var calleeStr = \"_callee\";\n//var getAttributeStr = \"getAttribute\";\n//var hasAttributeStr = \"hasAttribute\";\n//var removeAttributeStr =\"removeAttribute\";\n//var setAttributeStr = \"setAttribute\";\n//var parentNodeStr = \"parentNode\";\n//var nodeNameStr = \"nodeName\";\n//var ownerElementStr = \"ownerElement\";\nvar globalDOMEvents = [\n    \"focus\",\n    \"focusin\",\n    \"focusout\",\n    \"resize\",\n    \"scroll\",\n    \"click\",\n    \"dblclick\",\n    \"mousedown\",\n    \"mouseup\",\n    \"mousemove\",\n    \"mouseover\",\n    \"mouseout\",\n    \"change\",\n    \"select\",\n    \"submit\",\n    \"keydown\",\n    \"keypress\",\n    \"keyup\",\n    \"contextmenu\"\n];\n// var registerHelperStr = \"registerHelper\";\nvar delStr = \"delete\";\n\nfunction defProp() {\n\tObject.defineProperty.apply(Object, arguments);\n}\n\nfunction makeSet(obj, key) {\n\tif(!obj[key]) {\n\t\tdefProp(obj, key, {\n\t\t\tvalue : new Set(),\n\t\t\tenumerable : false,\n\t\t\twritable : true,\n\t\t\tconfigurable : true\n\t\t})\n\t}\n}\nfunction addBindings(bindings, property) {\n    bindings.add(property);\n}\n\nfunction makeArray(obj, key) {\n\tif(!obj[key]) {\n\t\tdefProp(obj, key, {\n\t\t\tvalue : [],\n\t\t\tenumerable : false,\n\t\t\twritable : true,\n\t\t\tconfigurable : true\n\t\t})\n\t}\n}\n\nfunction createDocFragment() {\n\treturn document.createDocumentFragment();\n}\n\nfunction createElement(elm) {\n\treturn document.createElement(elm);\n}\n\n// function insertBefore(parent, newNode, refNode) {\n// \tparent.insertBefore(newNode, refNode);\n// }\n\nfunction deleteBindingCheckSize(obj, key, valToDelete) {\n\tobj[key][delStr](valToDelete);\n\tif(!obj[key].size) {\n\t\tdelete obj[key];\n\t}\n}\n\n/*\tIE Browser\n\tLyte._ie \n\tEdge Browser\n\tLyte._ed \n\tReplace with needed;\n\tLyte._rwpf \n\tIE / Edge Browser\n\tLyte._ms\n*/\n\nlet userAgent = navigator.userAgent;\n// //temporary fix for IE 11\n// if(userAgent.match(/rv:11\\.0/) && userAgent.match(/Trident/)) {\n// \tLyte._ie = true;\n//     window.action = function() {\n//         return;\n//     }\n// }\n// if(userAgent.match('Edge')) {\n//     var s = createElement(\"div\");\n//     s.innerHTML= \"<template><div>c</div></template>\";\n//     if(s.querySelector(\"template\").childNodes.length) {\n//         Lyte._ie = true;\n//     } else {\n//         Lyte._ed = true;    \n//     }\n//     s.remove()\n// }\n\nclass Test extends HTMLElement {\n    constructor() {\n        super();\n        if(!this.attributes.t) {\n            _LC.frSpecial = true;\n        }\n    }\n}\n\n// if(Lyte._ie || Lyte._ed) {\n// \tvar doc = createDocFragment();\n// \tdoc.appendChild(document.createTextNode(\"  dummy \"));\n// \tdoc.childNodes[0].replaceWith(document.createTextNode(\"changed\"));\n// \tif(doc.childNodes[0].textContent !== \"changed\") {\n// \t\tLyte._rwpf = true;\n// \t}\n// \tLyte._ms = true;\n// }\n\n// Lyte.Component = {}//mainClass;\n// Lyte.compile = {};//af check\n// var _LyteComponent = Lyte.Component;\n\n// let arrayUtils =  function() {\n// \t//arrayFunctions\n//     return _LC.aF.apply(_LC, arguments);\n// };\n// let objectUtils =  function() {\n// \t//objectFunctions\n//     return _LC.oF.apply(_LC, arguments);\n// }\n\n_LC.errorNodeDetails = function(node) {\n    var str = node.cloneNode(true);\n    str.innerHTML = \".....\";\n    return str.outerHTML;\n}\n// _LyteComponent.register = function() {\n//     _LC.registerComponent.apply(_LC, arguments);\n// }\n// _LyteComponent.directive = {\n//     register : function() {\n//         _LC.registerDirective.apply(_LC, arguments);\n//     }\n// }\n// _LyteComponent.destroy = function() {\n//     _LC.destroy.apply(_LC, arguments);\n// }\n\n// _LyteComponent.registerDirective = function() {\n//     _LC.registerDirective.apply(_LC, arguments);\n// }\n\n// _LyteComponent.registerHelper = function() {\n//     _LC.registerHelper.apply(_LC, arguments);\n// }\n// _LyteComponent.set = function() {\n//     _LC.set.apply(_LC, arguments);\n// }\n// _LyteComponent.registeredHelpers = {};\n// _LyteComponent.registeredComponents = {};\n// _LyteComponent.registeredDirectives = [];\nfunction noop() {\n\n}\n_LC.registerCustomPropHandler = function(propName) {\n    let dasherized = _LC.String.dasherize(propName);\n    propName = _LC.String.toCamelCase(propName);\n    if(this.customPropHandlers.indexOf(propName) === -1) {\n        this.customPropHandlers.$push(propName);\n        customElementPrototype.prototype[propName] = function() {\n            _LC.customPropRegex = this.component._registryClass.customPropRegex;\n            let argsLength = arguments.length;\n            let arg0 = arguments[0];\n            let options = arguments[2];\n            let compData = this.component.data;\n            if(!arg0) {\n                //Read all the values\n                let obj = {};\n                for(let key in compData) {\n                    if(key.startsWith(propName)) {\n                        let objKey = key.substring(propName.length);\n                        objKey = _LC.String.lowerCaseFirstLetter(objKey);\n                        obj[objKey] = compData[key];\n                    }\n                }\n                return obj;\n                \n            } else if(typeof arg0 === \"string\") {\n                if(argsLength > 1) {\n                    //Set a value\n                    this.set(propName+ _LC.String.upperCaseFirstLetter(arg0), arguments[1], options);\n                } else {\n                    //Read a value\n                    let actKey = propName + _LC.String.upperCaseFirstLetter(arg0);\n                    return compData[actKey];\n                }\n            } else if(typeof arg0 === \"object\") {\n                //Write a set of values\n                for(let key in arg0) {\n                    let objKey = propName + _LC.String.upperCaseFirstLetter(key);\n                    this.set(objKey, arg0[key], arguments[1]);\n                }\n            }\n            _LC.customPropRegex  = \"\";\n        }\n        this.customPropRegex = new RegExp(\"^(\" + this.customPropHandlers.join(\"|\")+ \")\");\n    }\n}\n_LC.unregisterComponent = function(componentName) {//af check\n    if(this._registeredComponentClass[componentName]) {\n        var compClass = this._registeredComponentClass[componentName];\n        var commonClass = this._registeredCommonClass[componentName];\n        if(compClass.activeInstances > 0) {\n            //@Slicer.developmentStart\n            Lyte.warn(\n                \"There are active instances of the component \" + componentName + \" and hence cannot be unregistered\"\n            );\n            //@Slicer.developmentEnd\n        } else {\n            // comp._properties = {};\n            let ind = commonClass.component.list.indexOf(compClass);\n            if(ind != -1){\n                commonClass.component.list.splice(ind,1);\n            }\n            delete commonClass.componentClass;\n            compClass._actions = compClass._template = compClass._dynamicNodes = compClass.__observers = null;            \n            compClass._callBacks = {};\n            compClass._observers = [];\n            compClass._data = undefined;\n            compClass._methods = {};\n            compClass._classFunc = null;\n            compClass._registered = false\n            compClass.prototype.get = noop;\n            compClass.prototype.set = noop;\n            Object.defineProperty(commonClass.prototype, \"setData\", {\n                configurable : true, \n                writable : true, \n                value : function(arg0, arg1) {\n                    this._initProperties = this._initProperties || {};\n                    if(typeof arg0 === \"string\") {\n                        this._initProperties[arg0] = arg1\n                    } else if(typeof arg0 === \"object\") {\n                        for(let key in arg0) {\n                            this._initProperties[key] = arg0[key];\n                        }\n                    }\n                }\n            });\n\n            Object.defineProperty(commonClass.prototype, \"setMethods\", {\n                configurable : true, \n                writable : true, \n                value : function(arg0, arg1) {\n                    this._initMethods = this._initMethods || {};\n                    if(typeof arg0 === \"string\") {\n                        this._initMethods[arg0] = arg1\n                    } else if(typeof arg0 === \"object\") {\n                        for(let key in arg0) {\n                            this._initMethods[key] = arg0[key];\n                        }\n                    }\n                }\n            });\n\n            delete this._registeredComponentClass[componentName];\n            this._instanceList.forEach(function(registryIns){\n                delete registryIns._registeredComponents[componentName];\n                delete registryIns.registeredComponents[componentName];\n            })\n            // var template = document.querySelector(\"template[tag-name=\"+componentName+ \"]\")\n            var lyteComponentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv, this.name);\n            var template = lyteComponentsDiv.querySelector(\"template[tag-name=\"+componentName+ \"]\");\n            if(template) {\n                template.remove();\n            }\n            // lyteht -> lyteHelperTemplates\n            var helperTemplate = compClass._helperTemplate;\n            if(helperTemplate) {\n                helperTemplate.remove();\n            }\n            if(commonClass._depthTemp) {\n                commonClass._depthTemp.remove();    \n            }\n            if(compClass._style){\n                compClass._style = undefined;\n            }\n        }\n        ComponentRegistry._unRegisteredComponents[componentName] = true;\n    } \n    //@Slicer.developmentStart\n    else {\n        Lyte.warn(\"Component \"+ componentName + \" not yet registered\");\n    }\n    //@Slicer.developmentEnd\n}\n\nvar elementPrototype = typeof HTMLElement !== \"undefined\" ? HTMLElement : Element;\n\nLyte.$.appendTemplateDiv = function() {\n    document.body.appendChild(_LC.tDiv);\n    document.body.appendChild(_LC.h1Div);\n}\n\nfunction onDomContentForLyte() {\n    // if(!Lyte._ie){//_ie\n    \tdocument.body.appendChild(_LC.lyteComponentsDiv);\n        //document.body.appendChild(_LC.tDiv);\n    // }\n    document.body.appendChild(_LC.hDiv);\n    let bodyEvents = globalDOMEvents;    \n    for(let i=0; i<bodyEvents.length; i++){    \n        var evnt = bodyEvents[i];    \n        document.body.addEventListener(evnt,globalEventHandler, true);    \n    }    \n    \n    let comp = _LC.toBeRegistered;    \n    if(comp.length){    \n        for(let j=0; j<comp.length;j++){\n            customElements.define(comp[j].name, comp[j].def, undefined, comp[j]._lyteOptions);    \n        }    \n        _LC.toBeRegistered = [];    \n    }\n    if(/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {\n        var style = createElement(\"style\");\n        style.innerHTML = \"* { cursor : pointer}\";\n        document.head.appendChild(style);\n    }\n    document.head.appendChild(Lyte.$.shadowDiv._lessDiv);\n}\n\nvar changeEventhandler = function(event) {\n\tvar target = event.target || event.srcElement;\n\tif(!target._attributeDetails) {\n\t\treturn;\n\t}\n\tvar attributeName = \"value\";\n\tif(target.type === \"checkbox\" || target.type=== \"radio\") {\n\t\tattributeName = \"checked\";\n\t}\n\tlet contextSwitchArray = [];\n\tvar attrNode ;\n\tvar attrDetail = target._attributeDetails[attributeName]\n\tif(!attrDetail || !attrDetail.isLbind) {\n\t\treturn;\n\t}\n\t//attrNode = (attributeName === \"checked\") ? target._attributeDetails[attributeName].bindedNode : target.getAttributeNode(attributeName);\n\tvar callee = target;\n\tif(!target._callee){\n\t\twhile(callee && !_LC.isCustomElement(callee) && callee.tagName !== \"LYTE-YIELD\") {\n\t\t\tif(callee.tagName === \"BODY\") {\n\t\t\t\tcallee = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcallee = callee.parentNode;\n\t\t}\n\t\tif(callee && callee.tagName === \"LYTE-YIELD\"){\n\t\t\ttarget._callee = callee._registerYield._callee;\n\t\t} else {\n\t\t\ttarget._callee = callee;\n\t\t}\n\t}\n\tlet self = target._callee;\n\tif(target) {\n\t\t_LC.adCx(target, contextSwitchArray);\n\t}\n    let obj = _LC.getNew(self.component.data, attrDetail.dynamicValue);\n    if(!obj.context){\n        return;\n    }\n    let lastKeyIndex = +obj.lastKey;\n    if(Array.isArray(obj.context) && typeof lastKeyIndex == \"number\") {\n        _LC.aF(obj.context, lastKeyIndex < obj.context.length ? \"replaceAt\" : \"insertAt\", lastKeyIndex, target[attributeName]);\n    } else {\n        _LC.set(obj.context, obj.lastKey, target[attributeName]);\n    }\n\t// _LC.set(obj.context, obj.lastKey, target[attributeName]);\n\tif(target) {\n\t\t_LC.rmCx(target, contextSwitchArray);\n\t}\t\t\n}\ndocument.addEventListener(\"change\", changeEventhandler);\nvar globalEventHandler = function(ev){\n\tvar evnt = ev.type;\n    var target = ev.target,toRemove;\n    if(ev.target.shadowRoot){\n        return;\n    }\n    if(/^(click|dblclick|mouseover|mouseout|mousemove|mousedown|mouseup|contextmenu|keydown|keyup|keypress|submit|reset|focus|blur|input|change|select|load|resize|scroll|unload|beforeunload|DOMContentLoaded|readystatechange|touchstart|touchmove|touchend|touchcancel|play|pause|ended|volumechange|durationchange|ratechange|dragstart|drag|dragenter|dragleave|dragover|drop|dragend)$/g.test(evnt) && target.getAttribute && target.getAttribute(\"lyte-state\") != null){\n        ev.preventDefault();\n\t\treturn;\n\t}\n    if(ev.currentTarget !== document.body && !_LCSD.getHostElement(ev.currentTarget)) {\n        target = ev.currentTarget;\n    }\n\tif(!window.event){\n\t\ttoRemove = true;\n\t\twindow.event = ev;\n\t}\n    let eventStopped = false;\n    while(target && target.getAttribute && (!target.getAttribute(evnt) || (target.hasAttribute(\"disabled\") && evnt != \"blur\")) && target.tagName != \"BODY\"){\n\t\tif(_LC.hasLyteEvents(target, evnt)) {\n            eventStopped = _LC.handleLyteEvents(target, ev);\n            if(eventStopped) {\n                break;\n            }\n        }\n        target = target.parentNode;\n\t}\n    if(eventStopped || !target) {\n        return;\n    }\n \tvar callee = target;\n    if((target._callee && target._callee.component && target._callee.component.constructor._v3) || (target.component && target.component.constructor && target.component.constructor._v3)){\n        return;\n    }\n\tif(!target._callee){\n\t\twhile(callee && !_LC.isCustomElement(callee) && callee.tagName !== \"LYTE-YIELD\") {\n\t\t\tif(callee.tagName === \"BODY\") {\n\t\t\t\tcallee = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcallee = callee.parentNode;\n\t\t}\n\t\tif(callee && callee.tagName === \"LYTE-YIELD\"){\n\t\t\ttarget._callee = callee._registerYield._callee;\n\t\t} else {\n\t\t\ttarget._callee = callee === target ? undefined : callee;\n\t\t}\n\t}\n    if(target._callee && !target._callee.component){\n        Lyte.warn(\"Component of the target node is destroyed and so \"+ evnt +\" wont be triggered.\");    \n        return;\n    }\n    event.$lTarget = target;\n\tif(target._evBoundEvents && target._evBoundEvents[evnt]) {\n        //Not needed - but check and remove\n\t\t// let actions = target._callee? target._callee.component.constructor._actions : target.component.constructor._actions ;\n        //let actions = target.component.constructor._actions;\n\t\tlet actObj = target._evBoundEvents[evnt];\n        let cloneActObj = deepCopyObject(actObj);\n        _LC.skipArgProcessing(cloneActObj, ev, target);\n\t\t_LC.throwAction.call(target,target,evnt,cloneActObj, undefined, undefined, target, ev, undefined, true);\n\t} else if(target.getAttribute && target.getAttribute(evnt) && target._boundEvents && target._boundEvents[evnt]){\n\t\t// let actions = target._callee.component.constructor._actions;\n        // let func = target.getAttribute(evnt).split(\" => \")[1];\n        let actObj = target._boundEvents[evnt];\n\t\tlet cloneActObj = deepCopyObject(actObj);\n\t\t_LC.skipArgProcessing(cloneActObj, ev, target);\n\t\t_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, target, ev);\n\t}\n\tif(target.tagName === \"LABEL\"){\n\t\tvar input = target.querySelector(\"input\");\n\t\tif(input && input.getAttribute(evnt)){\n\t\t\t// let actions = target._callee.component.constructor._actions;\n\t\t\t// let func = input.getAttribute(evnt).split(\" => \")[1];\n\t\t\t//\tlet actObj = target._callee.constructor.getHelper(func);\n            let actObj = target._boundEvents[evnt];\n            let cloneActObj = deepCopyObject(actObj);\n\t\t\t_LC.skipArgProcessing(cloneActObj, ev, target);\n\t\t\t_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, input,ev);\n\t\t}\n\t}\n\tif(toRemove){\n\t\twindow.event = undefined;\n\t}\n}\nclass LyteYield extends HTMLElement {\n    constructor() {\n        super();   \n        this.decideConstructor();\n    }\n    decideConstructor(){\n        if(ltCf.versionBridge){\n            let V3Registry = ltCf.versionBridge.component.V3Registry;\n            let foundInV3List = V3Registry.allList.v3[this.localName]\n            let foundInV4List = V3Registry.allList.v4[this.localName]\n            if(foundInV3List){\n                if(!foundInV4List || (!this.hasAttribute(\"lyte-v4\") && !ltCf.lyteV4 && !ltCf.v4Render && (ltCf.fromV3Render || _LC.getCurrentRegistry() == V3Registry || foundInV3List))){\n                    //v3\n                    let v3CompClass = foundInV3List;\n                    let self = this;\n                    LyteYield._V3InsApi.forEach(function(apiName){\n                        self[apiName] = v3CompClass.prototype[apiName];\n                    })\n                }\n            }\n        }\n    }\n    connectedCallback(){\n        this._connectedCallback();\n    }\n    _connectedCallback() {\n        this._callee = this._callee || _LC.getCallee(this.parentNode, this);\n        let registry,shadowObj,directiveObj;\n        if(this._callee){\n            registry = this._callee.$component;\n           if(registry){\n            shadowObj = registry._shadow;\n            directiveObj = registry._directive;\n           }\n        }\n        if(directiveObj){\n            this._transitionAppend = []\n        }\n        if(shadowObj && this.shadowRoot){\n            shadowObj.insertInLessDiv(this._shadowParent,this._lessDiv)\n            shadowObj.updateLessDiv(this._lessDiv,this.shadowRoot._compList);\n        }\n        if(!this._registerYield && this._callee) {\n            var yieldName;\n            if(this._callee._fR && this._callee._fR._yieldCallee) {\n                this._registerYield = {\"_callee\" : this._callee._fR._yieldCallee.component.$node};\n            } else if(this._callee._yields &&  (yieldName=this.attributes[\"yield-name\"]) && (yieldName = yieldName.nodeValue) && this._callee._yields[yieldName]) {\n                this._registerYield = {\"_callee\" : this._callee._yields[yieldName]._callee};\n            }\n        }\n    }\n    disconnectedCallback(){\n        this._disconnectedCallback();\n    }\n    _disconnectedCallback(){\n        if(_LC.ignoreDisconnect || this._deleted) {\n            return;\n        }\n        let shadowObj = this._callee.getShadowObj();\n        shadowObj && shadowObj.destroyRef(this);\n        let registry = this._callee.$component;\n        let directiveObj = registry._directive;\n        this._deleted = true;\n        if(!this._properties) {\n            return;\n        }\n        var nodeContextSwitchArray = [];\n        _LC.adCx(this, nodeContextSwitchArray);\n        _LC.removeSelectedBindingDeep(this._properties, this.component.data, true);\n        let node = this._registerYield;\n        if(!node) {\n        _LC.rmCx(this, nodeContextSwitchArray);\n        return;\n        }\n        var toAppendContextSwitchArray = [];\n        //newContext not needed\n        var del = \"delete\";//for ie 11.0\n        _LC.adCx(node, toAppendContextSwitchArray);\n        for(let key in this._dynamicProperty) {\n            if(this._dynamicProperty[key].isActualNode) {\n                this._dynamicProperty[key].isActualNode._helperNodes[del](this);\n            }else {\n                let helperNodes = node._callee.getProperty(key)._helperNodes;\n                if(helperNodes) {\n                    helperNodes[del](this);\n                }\n            }\n        }\n        this._dynamicProperty = {};\n        for(let i=0;i<this._helpers.length;i++) {\n            node._callee.removeHelpers(this._helpers[i]);\n        }\n        this._helpers = [];\n        _LC.rmCx(node, toAppendContextSwitchArray);\n        _LC.rmCx(this, nodeContextSwitchArray);\n        directiveObj && directiveObj.destroyPromises(this);\n        // var self = this;\n        // setTimeout(function() {\n        //     self._registerYield = null\n        //     self._callee = null;\n        // },0);\n    }\n    getProperty(key) {\n            var arr = key.match(/([^[\\].]+|\\[\\])/g);\n            let property = this;\n            if(!property._properties[arr[0]]) {\n                    property._properties[arr[0]] = {};\n            } \n            property = property._properties[arr[0]];\n        \n            defProp(property, '_path', {enumerable: false, value : arr[0]});\n            for(let i=1;i<arr.length;i++) {\n                if (arr[i].startsWith(\"'\") || arr[i].startsWith('\"')) {//added check\n                    arr[i] = arr[i].substring(1, arr[i].length -1);\n                }\n                    if(!property[arr[i]]) {\n                        property[arr[i]] = {};\n                        defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + \".\" + arr[i]});\n                }\n                property = property[arr[i]];\n            }\n            return property;\n        }\n}\nLyteYield._V3InsApi = [\"_connectedCallback\", \"getProperty\",\"_disconnectedCallback\"]; //no i18n\nltCf._LyteYield = LyteYield;\ncustomElements.define(\"lyte-yield\", LyteYield, undefined, {v4 : true});\nltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();\n//v4 class code\nclass LyteCustomElement extends HTMLElement {\n    constructor(){\n        super();\n        this.decideConstructor();\n    }\n    decideConstructor(){\n        if(ltCf.versionBridge){\n            let V3Registry = ltCf.versionBridge.component.V3Registry;\n            let foundInV3List = V3Registry.allList.v3raw[this.localName];\n            let foundInV4List = V3Registry.allList.v4raw[this.localName];\n            if(foundInV3List){\n                if(!foundInV4List || (!this.hasAttribute(\"lyte-v4\") && !ltCf.lyteV4 && !ltCf.fromV4Render && (ltCf.fromV3Render || _LC.getDecidedRegistry() == V3Registry || foundInV3List))){\n                    //v3\n                    let v3CompClass = V3Registry.allList.v3raw[this.localName];\n                    let self = this;\n                    LyteCustomElement._V3InsApi.forEach(function(apiName){\n                        self[apiName] = v3CompClass.prototype[apiName];\n                    })\n                }\n            }\n        }\n        //v4 \n        this.actualConstructor();\n    }\n    actualConstructor(){\n        this.__lyteCustomElement = true;\n        if(this.isClonedNode()){\n            this.__cloned = true;\n            let attrList = this.attributes;\n            for(let i=0; i<attrList.length; i++){\n              let attrNode = attrList[i];\n              attrNode._lyte = {cloned : true,userCloned : true, name : attrNode.nodeName ,value : attrNode.nodeValue};\n            }\n        }\n        if(!_LC.getDefaultRegistry()){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC009\");\n            //@Slicer.developmentEnd\n            return;\n        }\n        var obj = {compName : this.localName, type : \"customComponent\"};\n        _LC.getCompRegistry(obj,this);\n        if(!_LC.verifyDetails(obj)){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC010\", \"Raw Component\", this.localName);\n            //@Slicer.developmentEnd\n            return\n        }\n        var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;\n        var compInstance;\n        lIns.scopedInstance(compClass,[this],function(ins){\n            compInstance = ins;\n        },[regIns])\n        this.$component = this.$registry = regIns;\n        compInstance.$component = compInstance.$registry = regIns;\n        compInstance._registryClass = compClass._registryClass;\n        this._registryClass = compClass._registryClass;\n        _LC.setAddedRegistries(compInstance,this.localName);\n        this.component = compInstance;\n        compInstance.$node = this;\n        let options = compClass._options;\n        if(options && options.clone){\n            this._allCallbacks = options.clone.allCallbacks;\n            if(typeof options.clone.attributeChangedCallback == \"object\"){\n                this._duringClone = options.clone.attributeChangedCallback.duringClone;\n                this._afterClone = options.clone.attributeChangedCallback.afterClone;\n            }else{\n                this._allAttributesCallback = options.clone.attributeChangedCallback;\n            }\n            this.__connectedCallback = options.clone.connectedCallback;\n            this.__disconnectedCallback = options.clone.disconnectedCallback;\n        }\n        this._actualConnectedCallback = compClass.prototype.connectedCallback;\n        this._actualAttributeChangedCallback = compClass.prototype.attributeChangedCallback;\n        this._actualDisconnectedCallback = compClass.prototype.disconnectedCallback;\n        this._reconnectedCallback = compClass.prototype.reconnectedCallback;\n        this._removedCallback = compClass.prototype.removedCallback;\n    }\n    executeLyteCallbacks(callBack,argArr){\n        if(callBack) {\n            callBack.apply(this.component, Array.from(argArr));\n        }\n    }\n    isClonedNode(){\n        if(this.hasAttribute(\"lyte-rendered-ce\") && !this.LyteConnected || this.__cloned){\n            return true;\n        }\n        return false;\n    }\n    _isClonedAttribute(attrName,oldVal,newVal){\n        let attrNode = this.attributes[attrName];\n        if(attrNode._lyte && attrNode._lyte.cloned && attrNode._lyte.name == attrName && attrNode._lyte.value == newVal && oldVal === null){\n            return true;\n        }\n        return false;\n    }\n    isClonedAttribute(attrName){\n        let attrNode = this.attributes[attrName];\n        if(attrNode._lyte && attrNode._lyte.userCloned){\n            return true;\n        }\n        return false;\n    }\n    connectedCallback(){\n        this._connectedCallback();\n    }\n    _connectedCallback(){\n        if(_LC.ignoreDisconnect || Lyte.ignoreDisconnect){\n            if(this._reconnectedCallback){\n                this.executeLyteCallbacks(this._reconnectedCallback,arguments);\n            }\n            return;\n        }\n        if(this.isClonedNode() && (this._allCallbacks == false || this.__connectedCallback == false)){\n            return;\n        }\n        this.executeLyteCallbacks(this._actualConnectedCallback,arguments);\n        this.setAttribute(\"lyte-rendered-ce\", \"\");\n        this.LyteConnected = true;\n    }\n    static get observedAttributes() {\n        return this._observedAttributes;\t\n    }\n    attributeChangedCallback(attr, oldValue, newValue) {\n        this._attributeChangedCallback(attr, oldValue, newValue);\n    }\n    _attributeChangedCallback(attr, oldValue, newValue){\n        var cloneStatus;\n        var clonedNode = this.isClonedNode();\n        if(clonedNode){\n            if(this._allCallbacks == false || this._allAttributesCallback == false){\n                return;\n            }else{\n                let attrName = arguments[0];\n                let oldVal = arguments[1];\n                let newVal = arguments[2];\n                let attrNode = this.attributes[attrName];\n                cloneStatus = this.attributes[arguments[0]]._lyte.userCloned;\n                let isClonedAttribute = this._isClonedAttribute(attrName,oldVal,newVal,attrNode);\n                if(isClonedAttribute){\n                    this.attributes[arguments[0]]._lyte.userCloned = true;\n                    if(this._duringClone == false){\n                        return;\n                    }\n                }else{\n                    this.attributes[arguments[0]]._lyte.userCloned = false;\n                    if(this._afterClone == false){\n                        return;\n                    }\n                }\n            }\n        }\n        this.executeLyteCallbacks(this._actualAttributeChangedCallback,arguments);\n        if(clonedNode && this.attributes[arguments[0]] && this.attributes[arguments[0]]._lyte){\n            this.attributes[arguments[0]]._lyte.userCloned = cloneStatus;\n        }\n    }\n    disconnectedCallback() {\n        this._disconnectedCallback();\n    }\n    _disconnectedCallback(){\n        if(_LC.ignoreDisconnect || Lyte.ignoreDisconnect){\n            if(this._removedCallback){\n                this.executeLyteCallbacks(this._removedCallback,arguments);\n            }\n            return;\n        }\n        if(this.isClonedNode() && (this._allCallbacks == false || this.__disconnectedCallback == false)){\n            return;\n        }\n        this.executeLyteCallbacks(this._actualDisconnectedCallback,arguments);\n    }\n}\nLyteCustomElement._V3InsApi = [\"_connectedCallback\", \"_attributeChangedCallback\" ,\"_disconnectedCallback\",\"actualConstructor\",\"executeCallbacks\",\"isNewComp\"];\nltCf._LyteCustomElement = LyteCustomElement;\nltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();\n//v4 class code\nclass customElementPrototype extends elementPrototype {\n    constructor() {\n        super();\n        this.decideConstructor();\n    }\n    decideConstructor(){\n        let self = this;\n        if(ltCf.versionBridge){\n            let V3Registry = ltCf.versionBridge.component.V3Registry;\n            let foundInV3List = V3Registry.allList.v3[this.localName]\n            let foundInV4List = V3Registry.allList.v4[this.localName]\n            if(foundInV3List){\n                if((!foundInV4List) || (!this.hasAttribute(\"lyte-v4\") && !ltCf.lyteV4 && !ltCf.fromV4Render && (ltCf.fromV3Render || _LC.getDecidedRegistry() == V3Registry || foundInV3List ))){\n                    //v3\n                    let v3CompClass = foundInV3List;\n                    customElementPrototype._V3InsApi.forEach(function(apiName){\n                        self[apiName] = v3CompClass.prototype[apiName];\n                    })\n                    self.component = self.constructor.component = v3CompClass.component;\n                    this.setData = v3CompClass.component.prototype.setData;\n                    this.setMethods = v3CompClass.component.prototype.setMethods;\n                }else if(foundInV4List){\n                    //v4\n                    let v4CompClass = foundInV4List;\n                    customElementPrototype._v4RegClassApi.forEach(function(apiName){\n                        self.constructor[apiName] = v4CompClass[apiName];\n                    })\n                    customElementPrototype._v4RegProtoApi.forEach(function(apiName){\n                        self[apiName] = v4CompClass.prototype[apiName];\n                    })\n                }\n            }\n        }\n        //v4 \n        this.actualConstructor();\n    }\n    actualConstructor() {\n        // this.setData = _LC.setData;\n        // this.setMethods = _LC.setMethods;\n        if(this.hasAttribute(\"lyte-rendered\") || this._ccCalled) {//aaf check\n            this.__lyteIgnore = true;\n        \treturn;\n        } else if(ComponentRegistry._unRegisteredComponents[this.localName]){\n            this.__lyteIgnore = true;\n            var origClass = ComponentRegistry._registeredCommonClass[this.localName];\n            origClass._pendingComponents = origClass._pendingComponents || [];\n            origClass._pendingComponents.push(this);\n            return;\n        }\n        if(!_LC.getDefaultRegistry()){\n            //@Slicer.developmentStart\n            RegistryError.error(\"LC009\");\n            //@Slicer.developmentEnd\n            return;\n        }\n        let fastRenderIndex;\n        let lytePropAttr = this.attributes._lyteprop;\n        lytePropAttr = lytePropAttr ? lytePropAttr.nodeValue : undefined;\n        let fastRenderedProp = (fastRenderIndex = lytePropAttr) ? _LC.fRP[fastRenderIndex] : undefined;\n        let compInstance;// = this.component = new this.constructor.component.list[0]();//this.component = fastRenderedProp ? fastRenderedProp.component : new this.constructor.component();\n        var self = this;\n        if(!fastRenderedProp){\n            var obj = {compName : this.localName, type : \"component\"};\n            _LC.getCompRegistry(obj,this);\n            if(!_LC.verifyDetails(obj)){\n                //@Slicer.developmentStart\n                RegistryError.error(\"LC010\", \"Component\", this.localName);\n                //@Slicer.developmentEnd\n                return\n            }\n            var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;\n            lIns.scopedInstance(compClass,[],function(ins){\n                compInstance = self.component = ins\n            },[regIns])\n            this.$component = this.$registry = regIns;\n            compInstance.$component = compInstance.$registry = regIns;\n            compInstance._registryClass = compClass._registryClass;\n            this._registryClass = compClass._registryClass;\n            _LC.setAddedRegistries(compInstance,this.localName);\n        }else{\n            compInstance = self.component = fastRenderedProp.component;\n            var compClass = this.constructor.component.list[0];\n            this.$component = this.$registry = compInstance.$component;\n            this._registryClass = compInstance._registryClass;\n        }\n        this._properties = {};\n        this._compClass = compClass;\n        this._tagDirectives = [];\n        _LC.directive.setTagDirectives(compClass,this);\n        _LC.directive.setAttrFromRender(this,this._tagDirectives);\n        compInstance._methods = {};\n        \n        compInstance._config = this.constructor._config;\n        compInstance.actions = Object.assign({},compClass._actions);\n        //@Slicer.developmentStart\n        var act = compInstance.actions;\n        Object.defineProperty(compInstance,\"actions\",{\n            get : function() {\n        \t\tLyte.warn(\"Accessing actions directly is deprecated. Move the required common code from action block to a common function and access it.\");\n        \t\treturn act;\n        \t}   \n        });\n        var met = compInstance.methods;\n        Object.defineProperty(compInstance,\"methods\",{\n            get : function() {\n        \t\tLyte.warn(\"Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.\");\n        \t\treturn met;\n        \t}   \n        });\n        //@Slicer.developmentEnd\n        compClass.activeInstances++; \n        let compData;\n        \n        if(!fastRenderedProp) {\n            compData = compInstance.data = {};\n            let data = compClass._data ? compClass._data.apply(compInstance) : {};\n            var def = \"default\";\n            defProp(compData, '__component__', {\n                value : this,\n                configurable : true,\n                writable: true,\n                enumerable : false\n            });\n            compInstance.__data = data;\n            compData.errors = {};\n            for(let key in data) {\n                var obj = data[key];\n                compData[key] = obj[def];\n                if(/^(object|array)$/.test(obj.type) && (obj.watch || (obj.hasOwnProperty(\"items\") || obj.hasOwnProperty(\"properties\")) )){\n                    establishObjectBinding(compData, key, false,undefined,undefined,obj.watch?true:undefined);\n                }\n            }\n            compData.errors = {};\n            compInstance.__data = data;\n        }\n        \n        for(let key in compClass._methods) {\n            compInstance._methods[key] = compClass._methods[key];\n        }\n        if(compInstance.$node) {    \n            for(var key in compInstance.$node) {\n                if(key != \"localName\"){\n                    this[key] = compInstance.$node[key];\n                }\n            }\n        }\n        compInstance.$node = this;\n        let _overrides;\n        let _config_flag;\n        if(compInstance._ssr && compInstance._ssr.config){\n            if( compInstance._ssr.config.clientLifeCycleHooks != undefined ){\n                _config_flag = compInstance._ssr.config.clientLifeCycleHooks == true || ( typeof compInstance._ssr.config.clientLifeCycleHooks == 'object' ? compInstance._ssr.config.clientLifeCycleHooks.includes('init') : false );\n            }\n        }\n        \n        if(!fastRenderedProp) {\n            // this.callback(\"constructor\"); //af check // no need\n            this._actions = this._actions ? this._actions : {};\n            this._callee = this._callee || this.getCallee(this.parentNode);\n\n            //check if it is called from server || to ssr bind\n            \n            //check if it has ssr contructor for ssr\n            //ssrcode_client\n            if( _config_flag || !this.hasAttribute( 'server-rendered' ) ){\n                if( _overrides && _overrides.constructor && this.serverCall ){\n                    _overrides.constructor.apply( this.component );\n                }\n            } \n\n            //checking lyte.attr ytpe and given default value type\n            for (var key in compData) {\n                var field = compData.__component__.component.__data[key];\n                var error = _LC.handleValidation(compData, key, compData[key], compInstance ,true);\n                if (error) {\n                    compData[key] = undefined;\n                    var field = compData.__component__.component.__data[key]; \n                    if(field && /^(object|array)$/.test(field.type)){\n                        establishObjectBinding(compData, key, undefined,undefined,undefined,field.watch ? true:undefined);\n                    }\n                }\n            }\n            // if(compData.errors && Object.keys(compData.errors).length){\n            //     Lyte.error(\"Error in data passed to component '\"+ this.localName +\"' for the properties - \"+Object.keys(compData.errors).toString());\n            // }\n        } else {\n            this._fR = fastRenderedProp;\n            delete _LC.fRP[fastRenderIndex];\n            // _LC.$pushFrc(fastRenderIndex);\n        }\n    }\n    getDirectiveObj(){\n        if(!_LC.directive.bundled){\n            return false;\n        }\n        return _LC.directive;\n    }\n    getShadowObj(){\n        if(this.$registry._shadow){\n            return this.$registry._shadow;\n        }\n        return false;\n    }\n    getFastObj(){\n        if(this.$registry[\"_turbo\"]){\n            return this.$registry[\"_turbo\"];\n        }\n        return false;\n    }\n    getViewObj(){\n        if(this.$registry[\"_view\"]){\n            return this.$registry[\"_view\"];\n        }\n        return false;\n    }\n    getMethods(arg0) {\n        return this.component.getMethods(arg0);\n    }\n    hasAction(arg0) {\n        return this.component.hasAction(arg0);\n    }\n    setActions(arg0,arg1){\n        return this.component.setActions(arg0,arg1);\n    }\n    getActions(arg0) {\n        return this.component.getActions(arg0);\n    }\n    getObservers() {\n        return this.component.getObservers();\n    }\n    setMethods(arg0, arg1) {\n        return this.component.setMethods(arg0, arg1);\n    }\n    // getData(arg0) {\n    //     return this.component.getData(arg0);\n    // }\n    // setData(arg0, arg1 ,options) {\n    //     return this.component.setData(arg0, arg1, options);\n    // }\n    getCallee(callee){\n        return _LC.getCallee(callee, this);\n    }\n    afterConnected(fastRenderProp,ssrBind) {\n        let constr = this.component.constructor;\n        //initProperties is used because, we may have cases where the component wouldn't have been registered but \n        //it would be in dom already with some attributes. In those cases we can store the data in _initProperties as key, value.\n        //These properties would then be applied to the component, once it gets instantiated. \n        \n        //This is done, in order to solve when on a string value update of an if helper, the binding in the true or false case must be established. \n        //Without this, we won't establish the _properties in the component to the actual Data. \n        if(this.getAttribute(\"_lyteprop\")) {\n        \treturn \"\";\n        }\n        let obsattr = this.constructor._observedAttributes;\n        for(let i=0;i<obsattr.length;i++){\n            let key = obsattr[i];\n            let prop = this.getProperty(key);\n            defProp(prop, '__fromComponent', {\n            \tvalue : true,\n                enumerable : false\n            });\n        }\n        this.getProperty(\"errors\");\n        let app = this.component.getAppOrAddon();\n        var $lg = app.__gl, \n        compInstance = this.component,\n        compData = compInstance.data;\n        compData.$lg = $lg;\n        this.component.constructor.prototype.$lg = $lg;\n        if(this._initProperties) {\n            let initProperties = this._initProperties;\n            // if(initProperties[\"lyteUnbound\"] && _LC.migratedv2(app)){ //devmode\n            //     Lyte.error(\"lyteUnbound is moved to directive. so please make use of @unbound\");\n            // }\n            for(let key in initProperties) {\n                let actVal;\n                let field = compInstance.__data[key]; \n                if(field && field.type !== _LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || field.type === \"boolean\")) {\n                    actVal = _LC.typeCast(initProperties[key], compInstance.__data[key].type);\n                } else {\n                     actVal = initProperties[key];\n                }\n                let error = _LC.handleValidation(compData, key, actVal, compInstance ,true);\n                if(!error) {\n                    compData[key] = actVal;    \n                    if(field && /^(object|array)$/.test(field.type) && (field.watch || (field.hasOwnProperty(\"items\") || field.hasOwnProperty(\"properties\")))){\n                        establishObjectBinding(compData, key, undefined,undefined,undefined,field.watch?true:undefined);\n                    }\n                }\n            }\n            this._initProperties = undefined;\n        }\n        //@Slicer.developmentStart\n        if(compData.errors && Object.keys(compData.errors).length){\n            ComponentError.error(\"LC006\",this.component.$node.localName,+Object.keys(this.component.data.errors).toString())\n        }\n        //@Slicer.developmentEnd\n        if(this._initMethods) {\n            let initMethods = this._initMethods;\n            for(let key in initMethods) {\n                compInstance._methods[key] = initMethods[key];\n            }\n            this._initMethods = undefined;\n        }\n        let _config_flag;\n        if( compInstance._ssr && compInstance._ssr.config ){\n            if( compInstance._ssr.config.clientLifeCycleHooks != undefined ){\n                _config_flag = compInstance._ssr.config.clientLifeCycleHooks == true || ( typeof compInstance._ssr.config.clientLifeCycleHooks == 'object' ? compInstance._ssr.config.clientLifeCycleHooks.includes('init') : false );\n            }\n        }\n        let _overrides;      \n        \n        //ssrcode client        \n        ssrBind && this.cmpBind(fastRenderProp);\n        if( _config_flag || !this.hasAttribute( 'server-rendered' ) )\n        {\n            if( _overrides && _overrides.init && this.serverCall ){\n                _overrides.init.apply( this.component );\n            }else{        \n                this.callback('init');\n            }\n            this.onCallBack('init');\n        }\n        // this.callback('init');\n        // this.onCallBack('init');\n        let templateAttributes = this.component.constructor._templateAttributes;\n        if(templateAttributes && templateAttributes.a) {\n        \tfor(let key in templateAttributes.a) {\n//        \t\tlet attr = templateAttributes.attr[i];\n\t\t\t\tlet attr = templateAttributes.a[key];\n        \t\tif((!this.hasAttribute(attr.name) && !compData.hasOwnProperty(attr.name) ) || attr.globalEvent) {\n        \t\t\tif(attr.helperInfo && attr.helperInfo.name === \"action\") {\n                        this._evBoundEvents = this._evBoundEvents || {};\n                        let actionName = attr.helperInfo.args[0];\n\t\t\t\t\t    let boundName;\n\t\t\t\t\t    if(actionName.startsWith('\"') || actionName.startsWith(\"'\")) {\n\t\t\t\t\t\tboundName = actionName.substring(1, actionName.length - 1);\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t//Lyte.warn(\"Deprecation warning. Action name should be in quotes\");\n\t\t\t\t\t\tboundName = actionName;\n                        }\n                        let actualAttrName = attr.globalEvent ? attr.name : (attr.name.indexOf(\"-\") !== -1)? attr.name : attr.name.substr(2);\n                        this._evBoundEvents[actualAttrName] = {\"name\" : boundName, \"args\" : attr.helperInfo.args, \"from\" : \"component\"};\n                        let prevAttribute = this.getAttribute(attr.name);\n                        let currentAttribute = this.component.constructor._template.getAttribute(attr.name);\n                        //this.setAttribute(\"ev:\"+attr.name, this.component.constructor._template.getAttribute(attr.name));\n                        this.setAttribute(attr.name, currentAttribute + (prevAttribute ? \" ; \" + prevAttribute : \"\"));\n                    }\n                    if(!attr.globalEvent) {\n                        attr.from = \"component\";\n                        if(attr.staticValue) {\n                            this.setAttribute(templateAttributes.a[key].name, attr.staticValue);\n                        }\n                        else if(_LC.directive.isDirectiveNode(attr)){\n                            let actAttrName = attr.name;\n                            let attrName = actAttrName;\n                            let duplicateFound;\n                            if(!this._specialAttributeDetails){\n                                this._specialAttributeDetails = [];\n                            }else{\n                                this._specialAttributeDetails.forEach(function(oldAttr){\n                                    if(oldAttr.hookName == actAttrName){\n                                        duplicateFound = true;\n                                    }\n                                })\n                            }\n                            if(attr.hasOwnProperty(\"stringValue\")){\n                                \n                                if(!duplicateFound){\n                                    let strAttr = {\n                                        hookName : attr.hookName,\n                                        hookNode : attr.hookNode,\n                                        name : attr.name,\n                                        stringValue : attr.stringValue\n                                    }\n                                    this._specialAttributeDetails.push(strAttr);\n                                }\n                            }else if(attr.hasOwnProperty(\"dynamicValue\")){\n                                this.setAttribute(attr.hookName, \"{{dummy}}\");\n                                let attrNode = this.attributes.getNamedItem(attr.hookName);\n                                attr._isDirectiveNode = true;\n\t\t\t\t\t\t\t    this.bindNode(attrNode, [], undefined, {}, attr, undefined, undefined, true );\n                                if(!this._specialAttributeDetails){\n                                    this._specialAttributeDetails = [];\n                                }\n                                let dynAttr = {\n                                    hookName : attr.hookName,\n                                    hookNode : attr.hookNode,\n                                    name : attr.name,\n                                    dynamicValue : attr.dynamicValue\n                                }\n                                this._specialAttributeDetails.push(dynAttr);\n                            }\n                            \n                        }\n                        //@Slicer.developmentStart\n                        else if(key.startsWith(\"@\")){\n                            ComponentError.error(\"LC007\")\n                        }\n                        //@Slicer.developmentEnd\n                        else{\n                            this.setAttribute(templateAttributes.a[key].name, \"{{dummy}}\");\n\t\t\t\t\t\t\tthis.bindNode(this.attributes.getNamedItem(templateAttributes.a[key].name), [], undefined, {}, templateAttributes.a[key], undefined, undefined, true );\n                        }\n                    }\n        \t\t\t\n        \t\t}\n        \t}\n        }\n        this.registerYields();\n        let dumFlg;\n        if(compData.lyteUnbound && !_LC.migratedv2(app)) {\n        \t_LC.unbound = true;\n            dumFlg = true\n        }\n        let unboundDirective = _LC.directive.getTransitionArg(this,\"unbound\");\n        if(unboundDirective){\n            _LC.unbound = true;\n        }\n        if(!dumFlg){\n            this.component.data.lyteUnbound = unboundDirective;//add in future   \n        }\n        let content = \"\";\n        let fastRender,fastRenderSupported\n        let unboundBeta = compData.lyteFastRender;\n        fastRender = _LC.directive.getTransitionArg(this,\"turbo\");\n        this.component.data.lyteFastRender = fastRender;\n        if(fastRender){\n            fastRenderSupported = _LC.directive.getTransitionArg(this,\"unbound-supported\") || _LC.directive.getTransitionArg(this,\"turbo-supported\");\n            if(!fastRenderSupported){\n                //@Slicer.developmentStart\n                ComponentError.error(\"LC008\", this.localName)\n                //@Slicer.developmentEnd\n                this.component.data.lyteFastRender = false;\n            }\n        }\n        \n        let fastObj = this.getFastObj();\n        if((unboundBeta && !(_LC.migratedv2(app))) || (fastRender && fastRenderSupported && fastObj)){\n            content = fastObj.renderFast(constr._dynamicNodes, constr._sta, compInstance, undefined, this);\n            requestAnimationFrame(function() {\n                requestAnimationFrame(function() {\n                    _LC.callCC();\n                });\n            });\n        }\n        else {\n            content = this.renderNodes(constr._template, constr._dynamicNodes,undefined,undefined, undefined, undefined, this.component.constructor._tC);\n        }\n        return content;\n    }\n\n    //RN\n    renderNodes(toAppend, dynamicNodes, helperNode, options, establishBindings, returnVal, templateContent ,yieldComp) {\n        options = options || {};\n        let content;\n        let constr = this.constructor;\n        // let Compile = this.component.constructor.Compile;\n        let directiveObj = this.getDirectiveObj();\n        /*if(Lyte._ie){\n            let newFrag = toAppend.cloneNode(true, \"lyte\");\n            this.constructor.splitTextNodes(newFrag);\n            content = newFrag;\n        }\n        else{\n            content = toAppend.cloneNode(true, \"lyte\");\n        }*/\n        let templateDepthHandlingNeeded = false;\n        if (!toAppend) {\n            templateDepthHandlingNeeded = true;\n            content = _LC.getContentForIE(templateContent , constr);\n        } else if(toAppend.hasAttribute(\"depth\")) {\n        \ttemplateDepthHandlingNeeded = true;\n        \tcontent = _LC.getContentForIE(toAppend , constr);\n        } else {\n            content = toAppend.content.cloneNode(true, \"lyte\");\n        }\n        let updateHelpers = [],processLast = [],helperFunc,stoppedNode;\n        \n        let toBeInsMap = new Map();\n        for(let i=0;i<dynamicNodes.length;i++) {\n            let info = dynamicNodes[i], type = info.t, pos = info.p, dynamicN = content, helperInfo;\n            dynamicN = getDynamicNode(dynamicN,pos);\n            if(directiveObj && info.trans){\n                dynamicN._hooksPresent = true;\n            }\n            if(!dynamicNodes._cache){\n                dynamicNodes._cache = {};\n            }\n            if(type ===  \"cD\") {\n            \tif(options.node) {\n            \t\tdynamicN._cx = options;\n            \t} else if(helperNode) {\n            \t\tdynamicN._cx\t= helperNode._cx;\n            \t}\n                  \n                if(directiveObj){\n                    directiveObj.infoCD(this,info,dynamicN,helperNode,options);\n                }\n                // dynamicN._callee = this//af check\n            } \n            else if(type === \"tX\"){\n                 this.bindNode(dynamicN, undefined, helperNode, options, dynamicNodes[i], processLast, establishBindings,undefined,dynamicNodes._cache,type,undefined,toBeInsMap);\n            }\n            else if(type === \"a\"){\n            \tdynamicN._attributeDetails = info.a;            \t\n                if(dynamicN.nodeName === \"LYTE-YIELD\") {\n                    dynamicN._callee = this;\n                    dynamicN.component = {}\n                    dynamicN.component.data = {};\n                    defProp(dynamicN.component.data, \"__component__\", {\n                    \tvalue : dynamicN,\n                    \tconfigurable : true,\n                    \twritable : true,\n                        enumerable : false\n                    });\n                    dynamicN._properties = {};\n                    for(let j=0;j<dynamicN.attributes.length;j++) {\n                        let attr = dynamicN.attributes[j];\n                        if(attr.nodeName !== \"is\" && attr.nodeName !== \"yield-name\") {\n                            dynamicN._properties[_LC.String.toCamelCase(attr.nodeName)] = {};\n                        }\n                    }\n                }\n                let toBeRemoved = [];\n\t\t\t\tfor(let key in info.a) {\n                \tlet attr = info.a[key];\n                \tattr._depthTemp = info._depthTemp;\n                \tlet attrName = key;\n                    if(attr && (attr.dynamicValue || attr.helperInfo)) {\n                        if(options.node) {\n                                dynamicN._cx = options;\n                        }\n                        else if(helperNode) {\n                            dynamicN._cx = helperNode._cx;\n                        }\n                        let actionName, boundName;\n                        if(attr.helperInfo && attr.helperInfo.name === \"action\") {\n                            dynamicN._boundEvents = dynamicN._boundEvents || {};\n                            actionName = attr.helperInfo.args[0];\n                            if(actionName.startsWith('\"') || actionName.startsWith(\"'\")) {\n                                boundName = actionName.substring(1, actionName.length - 1);\n                            } else {\n                                // Lyte.warn(\"Deprecation warning. Action name \" + actionName + \" must be in quotes\");\n                                boundName = actionName;\n                            }\n                            let actualAttrName = attr.globalEvent ? attrName : (attrName.indexOf(\"-\") !== -1)? attrName : attrName.substr(2);\n                            dynamicN._boundEvents[actualAttrName] = {\"name\" : boundName, \"args\" : attr.helperInfo.args};\n                            //to bind actions in ssr components\n                            let id;\n                               \n                        }            \n\t\t\t            if(!attr.globalEvent) {\n                            /*this.bindNode(dynamicN.getAttributeNode(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings);\n                             */\n                            if(!dynamicN.hasAttribute(attrName)) {\n                                dynamicN.setAttribute(attrName, \"{{dummy}}\");\n                            }\n                        \tvar node = this.bindNode(dynamicN.attributes.getNamedItem(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings,undefined,dynamicNodes._cache,type,i);\n                            if(node !== dynamicN.attributes.getNamedItem(attrName)) {\n                            \tdynamicN._removedAttributes = dynamicN._removedAttributes || {};\n                            \tdynamicN._removedAttributes[attrName] = node;\n                            }\n                        }\n                    }\n                    if(directiveObj && attr.hookNode){\n                        directiveObj.infoA(this,info,dynamicN,helperNode,attr,yieldComp,options);\n                    }\n                }\n                //Added now\n                if(info.a && Object.keys(info.a).length) {\n                \tdynamicN._callee = this;\n                }\n                for(let d=0;d<toBeRemoved.length;d++) {\n                    dynamicN.removeAttribute(toBeRemoved[d]);\n                }\n            }\n            else if(/^(f|fI|cM)$/.test(type)){\n            \tif(options.node) {\n            \t\tdynamicN._cx = options;\n            \t} else if(helperNode) {\n            \t\tdynamicN._cx\t= helperNode._cx;\n            \t}\n                if(directiveObj){\n                    directiveObj.infoF(this,info,dynamicN,helperNode,type,options);\n                }\n                dynamicN._dynamicNodes = info.dN;\n                // if(Lyte._ms) {\n                //     dynamicN._tC = info.templateContent;  \n                // }\n                if(info.actualTemplate) {\n                    dynamicN._tC = info.actualTemplate;\n                }\n                let returnVal;\n                switch(type) {\n                case \"f\" : \n                    dynamicN._ht = info._ht;\n                \treturnVal = this.updateForHelper(dynamicN,{\"type\" : \"default\"} , options.node? options : undefined, establishBindings, info._sta ,yieldComp);\n                \tbreak;\n                case \"fI\" : \n                    dynamicN._ht = info._ht;\n                \treturnVal = this.updateForInHelper(dynamicN,{\"type\" : \"default\"} , options.node? options : undefined, establishBindings ,yieldComp);\n                \tbreak;\n                case \"cM\" : \n                \treturnVal = this.updateDynamicComponent(dynamicN, false, options.node ? options : undefined, establishBindings ,yieldComp);\n                }\n                if(returnVal) {\n                \tupdateHelpers.$push(returnVal);\n                }\n            }\n            else if(/^(e|s)$/.test(type)){\n                var def =\"default\";\n                dynamicN._cases = info.c; \n                dynamicN._hd = info.hd;\n                dynamicN._co = info.co\n                dynamicN._default = info.d;\n                dynamicN._ht = info._ht;\n                if(options.node) {\n            \t\tdynamicN._cx = options;\n            \t} else if(helperNode) {\n            \t\tdynamicN._cx\t= helperNode._cx;\n            \t}\n                if(directiveObj){\n                    directiveObj.infoE(this,helperNode,dynamicN,info,options);\n                }\n                if(info.actualTemplate) {\n                    dynamicN._tC = info.actualTemplate;\n                    if(!dynamicN._origTemplate) {\n                    \t// if(Lyte._ie) {\n                    \t// \tdynamicN._origTemplate = createElement(\"template\")\n                    \t// } else {\n        \t            \tdynamicN._origTemplate = info._depthTemp.cloneNode(true);\n                    \t// }\n                    \tif(dynamicN.hasAttribute(\"value\")) {\n                    \t\tdynamicN._origTemplate.setAttribute(\"value\", dynamicN.getAttribute(\"value\"));\n                    \t}\n                        if(dynamicN.hasAttribute(\"l-c\")) {\n                    \t\tdynamicN._origTemplate.setAttribute(\"l-c\", dynamicN.getAttribute(\"l-c\"));\n                    \t}\n                    }\n                }\n                let id,obj;\n                \n                \n                let returnVal = this.updateSwitchHelper(type, dynamicN, options.node ? options : undefined, undefined, establishBindings ,yieldComp,undefined,helperNode,id,i);\n                if( !_LC.unbound && ( this._ssrBind || ( this._callee && this._callee._ssrBind ) )){\n                    // delete obj.node;\n                    // obj.case = dynamicN._currentCase || dynamicN._currentScope; \n                    if(dynamicN.getAttribute(\"l-c\")){\n                        obj._new = dynamicN.getAttribute(\"_new\") ? true:undefined;\n                        obj.lc = true;\n                        obj.case = dynamicN._currentScope;\n                    }else{\n                        obj.case = dynamicN._currentCase; \n                    }\n                }\n                if(returnVal) {\n                \tupdateHelpers.$push(returnVal);\n                \tlet isBreak = returnVal.toAppendMain.querySelector(\"template[is=break]\");\n                \tif(isBreak) {\n                \t\tdynamicN._isStopped = \"break\";\n                \t\tcontent = Compile.getTrimmedContent(content, info.p,undefined);\n                \t\tstoppedNode = info.p;\n                \t\tbreak;\n                \t}\n                \tlet isContinue = returnVal.toAppendMain.querySelector(\"template[is=continue]\");\n                \tif(isContinue) {\n                \t\tdynamicN._isStopped = \"continue\";\n                \t\tcontent = Compile.getTrimmedContent(content, info.p,undefined);\n//                \t\tstoppedNode = info.position;\n                \t\tbreak;\n                \t}\n                }\n            } else if(type === \"r\") {\n                dynamicN._childPromise = [];\n                \n                dynamicN._dynamicNodes = info.dN;\n                dynamicN._sta = info._sta;\n                dynamicN._ht = info._ht;\n                // if(Lyte._ms) {\n                //     dynamicN._tC = info.templateContent;  \n                // }\n//                updateHelpers.$push(dynamicN);\n                if(directiveObj){\n                    dynamicN._childPromise = [];\n                    directiveObj.infoE(this,helperNode,dynamicN,info,options);\n                }\n                if(options.node) {\n                    dynamicN._cx = options;\n                }\n                else if(helperNode) {\n                    dynamicN._cx = helperNode._cx;\n                }\n                //Added now                \n                dynamicN._callee = this;\n            } else if(type === \"i\") {\n            \tif(options.node) {\n            \t\tdynamicN._cx = options;\n            \t} else if(helperNode) {\n            \t\tdynamicN._cx\t= helperNode._cx;\n            \t}\n                \n                dynamicN.component = dynamicN.component || {\"data\" : {}};\n                dynamicN._properties = dynamicN._properties || {};\n                if(directiveObj){\n                    directiveObj.infoI(this,info,dynamicN,helperNode,options);\n                }\n                for(let x=0; x<dynamicN.attributes.length; x++) {\n                    let attrObj = dynamicN.attributes[x];\n                    let attrName = attrObj.name;\n                    let attrValue = attrObj.value;\n                    if(attrName !== \"yield-name\") {\n                        if(dynamicN._properties && !dynamicN._properties[attrName]){\n                            dynamicN._properties[attrName] = {};\n                        }\n                        if(dynamicN._attributeDetails && !dynamicN._attributeDetails[attrName]){\n                            dynamicN.component.data[attrName] = attrValue;\n                        }\n                    }\n                }\n                this.updateYield(dynamicN, false, options.node? options : undefined,helperNode);\n                if(info.chld){\n                    dynamicN._chld = info.chld;\n                }\n                if(info.sibl){\n                    dynamicN._sibl = info.sibl;\n                }\n            }\n        }\n        dynamicNodes._cache = undefined;\n        for(let i=0;i<processLast.length;i++) {\n             let dynamicPosition = processLast[i].dynamicPositions;\n                 let processNode = dynamicPosition.initialNode;\n                 let nodeValue = dynamicPosition.dynamicNodeValue;\n                 let childLen = nodeValue.childNodes.length;\n                 if(!childLen) {\n                    nodeValue.appendChild(document.createTextNode(\"\"));\n                        childLen = 1;\n                 }\n                 let startingNode = nodeValue.childNodes[0];\n                 if(processNode.parentNode.nodeName === \"#document-fragment\") {\n                 \twhile(nodeValue.childNodes.length) {\n                 \t\t_LC.insertBeforeNative(processNode.parentNode, nodeValue.childNodes[0], processNode);\n                    }\n                 \tprocessNode.remove();\n                 } else {\n                \t processNode.replaceWith.apply(processNode,nodeValue.childNodes);\n                 }\n                 processLast[i].dynamicPositions = {startingNode : startingNode, length: childLen}\n        }\n        if(toBeInsMap.size){\n            toBeInsMap.forEach(function(val, key){\n                val.pN.insertBefore(key, val.cN);\n                if(val.cN.nextSibling){\n                    val.pN.insertBefore(document.createElement(\"textend\"), val.cN.nextSibling);\n                }\n                else{\n                    val.pN.appendChild(document.createElement(\"textend\"));\n                }\n            })\n        }  \n        if(stoppedNode) {\n        \treturnVal = returnVal || {};\n        \treturnVal.stop = true;\n        }\n        if(helperNode) {\n            if(options.type) {\n                helperNode._helpers[options.itemIndex] = updateHelpers;\n                if(templateDepthHandlingNeeded) {\n                    content = constr.createDocFragment1(content);  \n                }\n                return content;\n            } else {\n                helperNode._helpers = helperNode._helpers || [];\n                helperNode._helpers.$push.apply(helperNode._helpers, updateHelpers);\n                if(templateDepthHandlingNeeded) {\n                    content = constr.createDocFragment1(content);  \n                }\n                return content;\n            }\n        }\n        this.executeBlockHelpers(updateHelpers);\n        if(templateDepthHandlingNeeded) {\n            content = constr.createDocFragment1(content);  \n        }\n        return content;\n    }\n\n    executeBlockHelpers(updateHelpers, node) {\n\t    for(let i=0;i<updateHelpers.length;i++) {\n            var lastNode = updateHelpers[i].lastNode;\n            var parentNode = lastNode.parentNode; \n                \n            if(lastNode._placeHolder) {\n                lastNode = lastNode._placeHolder;\n                parentNode = lastNode.parentNode;\n            }\n            //parentNode = updateHelpers[i].lastNode.parentNode || updateHelpers[i].lastNode._placeHolder.parentNode;\n            _LC.insertBeforeNative(parentNode, updateHelpers[i].toAppendMain, lastNode);\n            updateHelpers[i] = updateHelpers[i].lastNode;\n\t    \t\t// updateHelpers[i].lastNode.parentNode.insertBefore(updateHelpers[i].toAppendMain, updateHelpers[i].lastNode);\n\t    \t\t// updateHelpers[i] = updateHelpers[i].lastNode;\n\t    \t\t//updateHelpers[i]._parentIf = node;\n//\t    \t\tif(!updateHelpers[i]._cx && node) {\n//\t    \t\t\tupdateHelpers[i]._cx = node._cx;\n//\t    \t\t}\n\t    }\t\n    }\n\n    updateBlockHelpers(updateHelpers,contextSwitchInfo){\n        for(let i=0;i<updateHelpers.length;i++) {\n            switch(updateHelpers[i].getAttribute('is')) {\n            case \"f\" :\n                this.updateForHelper(updateHelpers[i], {\"type\" : \"default\"},contextSwitchInfo);\n                break;\n            case \"e\" : \n                this.updateSwitchHelper(\"e\",updateHelpers[i],contextSwitchInfo);\n                break;\n            case \"fI\" : \n                this.updateForInHelper(updateHelpers[i] , {\"type\" : \"default\"},contextSwitchInfo);\n                break;\n            case \"s\" :\n                this.updateSwitchHelper(\"s\",updateHelpers[i],contextSwitchInfo);\n                break;\n            case \"cM\" : \n                this.updateDynamicComponent(updateHelpers[i], false, contextSwitchInfo);\n                break;\n            case \"i\" : \n//              this.updateYield(updateHelpers[i], false, contextSwitchInfo);\n                break;\n            case \"yield\" : \n            case \"r\" : \n                if(contextSwitchInfo) {\n                    updateHelpers[i]._cx = contextSwitchInfo;\n                }\n                break;\n            default: \n                if(updateHelpers[i].tagName === \"LYTE-YIELD\") {\n                    this.updateYield(updateHelpers[i], false, contextSwitchInfo);\n                }\n                \n            }\n         }\n    }\n    //AttributeChangedCallback will be called for the attributes mentioned in the this._observedAttributes array. \n    static get observedAttributes() {\n    \t\tlet newArr = [];\n            for(let i=0;i<this._observedAttributes.length;i++) {\n                newArr[i] = _LC.String.dasherize(this._observedAttributes[i]);\n            }\n            let customPropHandlers;\n            if(this.componentClass){\n                customPropHandlers = this.componentClass._registryClass.customPropHandlers\n            }else{\n                customPropHandlers = _LC.customPropHandlers;\n            }\n            customPropHandlers.forEach(function(item,index) {\n                newArr.$push(_LC.String.dasherize(item));\n            })\n            return newArr;\t\n    }\n\n    //Callback from browser, whenever any of the observed attribute changes. \n    //We call the component set, in order to affect the related changes. \n    attributeChangedCallback(attr, oldValue, newValue) {\n        this._attributeChangedCallback(attr, oldValue, newValue);\n    }\n    _attributeChangedCallback(attr, oldValue, newValue){\n        if(!this._registryClass || !this.$registry.registeredComponents[this.localName]) {\n            return;\n        }\n        let constr = this.constructor;\n       \tif((constr._observedMethodAttributes && constr._observedMethodAttributes[attr]) || this.__lyteIgnore) {\n   \t\t \treturn;\n    \t}\n        let actualAttr = _LC.String.toCamelCase(attr);\n        let isCustomProp = this.component._registryClass.customPropHandlers.indexOf(actualAttr);\n        if(isCustomProp !== -1) {\n            let propValue = this.component._registryClass.customPropHandlers[isCustomProp];\n            let lyteProps = newValue;\n            if(lyteProps) {\n                try{\n                    lyteProps = JSON.parse(lyteProps);\n                    for(let key in lyteProps) {\n                        let actKey = propValue + _LC.String.upperCaseFirstLetter(key);\n                        this.set(actKey, lyteProps[key]);\n                    }\n                } catch (e) {\n                    //@Slicer.developmentStart\n                    ComponentError.error(\"LC001\", attr, this.localName);\n                    //@Slicer.developmentEnd\n                }\n            }\n            return;\n        }\n        if(oldValue === newValue) {\n            return;\n        }\n        var attrNode = this.attributes.getNamedItem(attr);\n        if(attrNode) {\n            if(attrNode.__lyteIgnore) {\n                this.attributes.getNamedItem(attr).__lyteIgnore = false;\n                return;    \n            }\n        } else if(this[\"__\"+attr]) {\n            this[\"__\"+attr] = false;\n            return;\n        }\n        let compInstance = this.component;\n        let dataType = compInstance.__data[actualAttr].type;\n        if(dataType !== \"string\") {\n        \tlet obj = {\"attr\" : attr, \"tagName\" : this.tagName};\n        \tnewValue = _LC.typeCast(newValue, dataType, obj);\n        \tif(obj.isError) {\n                //@Slicer.developmentStart\n        \t\tLyte.warn(\n                    \"data type of the value provided for attribute \"+attr+ \" of \" + this.tagName + \" is not valid\"\n                );\n                //@Slicer.developmentEnd\n        \t\treturn;\n        \t}\n        }\n        let compData = compInstance.data;\n        if(compData[actualAttr] !== newValue) {\n            // Null check is done because when we do a removeAttribute directly on a component, the corresponding value expected is that of undefined and not null.\n            this.set(actualAttr, newValue === null ? undefined: newValue);\n        } else {\n            _LC.clearError(compData, actualAttr);\n        }\n    }\n\n    //Used to remove helpers of specific index in a for helper. \n    removeHelpersSpecificIndex(node, index,totalProms,fakeRemove,previousPromise) {\n        if(node.hc){\n            fakeRemove = true;\n        }\n        if(node._helpers[index]) {\n            for(let j=0;j<node._helpers[index].length;j++) {\n                    this.removeHelpers(node._helpers[index][j],undefined,undefined,totalProms,fakeRemove,previousPromise);\n            }\n        }\n        let directiveObj = this.getDirectiveObj();\n        if(directiveObj && node.hc && node._forContent[index] && node._specialNodes){\n            directiveObj.removeForIndexContent(this,node,totalProms,previousPromise,index);\n        }else if(node._forContent[index]) {\n            if(!fakeRemove){\n                // this.rmOtherNodes(node,node._forContent[index],totalProms);\n                // if(node._helpers[index]) {\n                //     for(let j=0;j<node._helpers[index].length;j++) {\n                //         directiveObj.removeFromDomNormal(node._helpers[index][j]);\n                //     }\n                // }\n                if(node._forContent[index]) {\n                    for(let i=0;i<node._forContent[index].length; i++ ) {\n                        node._forContent[index][i].remove();\n                    }\n                }\n            }\n            var self = this;\n            Object.keys(node._items[index]._dynamicProperty).forEach(function(key) {\n                node._dynProps[key]--;  \n                if(!node._dynProps[key]) {\n                    let prop  = self.getProperty(key);\n                    if(prop._helperNodes) {\n                        prop._helperNodes[delStr](node);\n                    }\n                }\n            });\n            node._items[index] = {\"_dynamicProperty\" : {}, \"itemProperty\" : {}, \"indexProperty\": {}};\n        }\n    }\n    //Used to remove all the helpers within an helper. \n    removeHelpers(node, update, direct,totalProms,fakeRemove,previousPromise) {\n        \n        if(!direct) {\n            node.remove();\n            var helpersObj = node.getAttribute(\"is\") === \"component\" ? this.__dc : this.__h;\n            let nodeId = node.__lyteId;\n            delete helpersObj[nodeId];\n        }\n        if(direct && node.hc){\n            fakeRemove = true;\n        }\n        var del = \"delete\";\n        let parent;\n        var contextSwitchArray = [];\n        let directiveObj = this.getDirectiveObj();\n        _LC.adCx(node, contextSwitchArray);\n        if(node._forContent) {\n            if(node.getAttribute(\"is\") === \"for\") {\n        \tif(node._helpers) {\n                for(let i=0;i<node._helpers.length;i++) {\n                    for(let j=0;j<node._helpers[i].length;j++) {\n                            this.removeHelpers(node._helpers[i][j],undefined,undefined,totalProms,fakeRemove,previousPromise);\n                    }\n                    directiveObj && directiveObj.checkFakeForAndRemove(fakeRemove,node,i);\n                }\n            }\n            if(directiveObj){\n                directiveObj.removeForContent(this,direct,fakeRemove,node,totalProms);\n            }else{\n                _LC.removeForContent(node);\n            }\n            let key = node.getAttribute(\"item\");\n            if(node._items.length) {\n                let prop = node._items[0].itemProperty;\n                for(let i=0;i<node._items.length;i++) {\n                    let dynProp = node._items[i]._dynamicProperty;\n                    for(let dP in dynProp) {\n                        let property = this.getProperty(dP); \n                        if(property._helperNodes){\n                            property._helperNodes[del](node);                    \n                        }\n                    }    \n                }\n                if(prop) {\n                    for(let i=0;i<node._items.length;i++) {\n                        this.removeBindings({[key] : node._items[i].itemProperty}, {[key] : node._attributes.items[i]});\n                    }\n                }\n            }\n            if(!update) {\n            \tif(node._actualBinding) {\n            \t\tif(node._attributes.items && node._attributes.items._bindings && node._actualBinding._createdBinding) {\n                        node._attributes.items._bindings[del](node._actualBinding);\n                    } \n                    if(node._actualBinding._forHelpers) {\n                        node._actualBinding._forHelpers[del](node);\n                    }\n                    var multiplePrpty = node._removedAttributes.items._multipleProperty;\n                    if(node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {\n                    \tmultiplePrpty[0].actProp._forHelpers[del](node);\n                    }\n            \t}\n            }\n            node._items = [];\n        } else {\n        \tif(node._helpers) {\n                let keys = Object.keys(node._helpers);\n                for(let i=0;i<keys.length;i++) {\n                    for(let j=0;j<node._helpers[keys[i]].length;j++) {\n                        this.removeHelpers(node._helpers[keys[i]][j],undefined,undefined, totalProms, fakeRemove, previousPromise);\n                    }\n                    directiveObj && directiveObj.checkFakeForAndRemove(fakeRemove,node,keys[i]);\n                }\n            }\n            if(directiveObj){\n                directiveObj.removeForInContent(this,direct,fakeRemove,node,totalProms);\n            }else{\n                _LC.removeForInContent(node);\n            }\n            let items = node._items;\n            let key = node.getAttribute(\"key\");\n            for(let index in items){\n                let item = items[index];\n                let prop = item.itemProperty;\n                let dynamicProp = item._dynamicProperty;\n                for(let dP in dynamicProp) {\n                    let property = this.getProperty(dP); \n                    if(property._helperNodes){\n                        property._helperNodes[del](node);                    \n                    }\n                }\n                if(prop) {\n                    this.removeBindings({[key] : node._items[index].itemProperty}, {[key] : node._attributes.object[index]});\n                }\n\n            }\n            if(!update) {\n                if(node._actualBinding) {\n                    if(node._attributes.object && node._attributes.object._bindings && node._actualBinding._createdBinding) {\n                        node._attributes.object._bindings[del](node._actualBinding);\n                    } \n                    if(node._actualBinding._forHelpers) {\n                        node._actualBinding._forHelpers[del](node);\n                    }\n                }\n                var multiplePrpty = node._removedAttributes.object._multipleProperty;\n                if(node._removedAttributes.object && !node._removedAttributes.object.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {\n                    multiplePrpty[0].actProp._forHelpers[del](node);\n                }\n                if(node._propBindingObject && node._attributes.object && node._attributes.object._bindings) {\n                    node._attributes.object._bindings[del](node._propBindingObject);\n                }\n            }\n            node._items= {};\n          }\n        } else if(node._caseContent || node._yieldContent) {\n        \tif(node._helpers) {\n                for(let j=0;j<node._helpers.length;j++) {\n                    this.removeHelpers(node._helpers[j],undefined,undefined, totalProms, fakeRemove, previousPromise);\n                }\n                directiveObj && directiveObj.checkFakeIfAndRemove(fakeRemove,node);\n            }\n            if(directiveObj){\n                directiveObj.removeIfContent(this,direct,fakeRemove,node,totalProms,previousPromise,this);\n            }else{\n                _LC.removeIfContent(node)\n                _LC.removeIfCaseContent(this,node,direct);\n                if(node._yieldContent){\n                    for(let i=0;i<node._yieldContent.length; i++ ) {\n                        node._yieldContent[i].remove();\n                    }\n                }\n            }\n            if(node._caseContent){\n                for(let key in node._dynamicProperty) {\n                    if(node._dynamicProperty[key].isActualNode) {\n                        node._dynamicProperty[key].isActualNode._helperNodes[del](node);\n                    }else {\n                        let helperNodes = this.getProperty(key)._helperNodes;\n                        if(helperNodes) {\n                            helperNodes[del](node);\n                        }\n                    }\n                }\n            }\n            node._dynamicProperty = {};\n            let viewObj = this.getViewObj()\n            if(viewObj){\n                viewObj.rmCaseContent(node)\n            }\n        } else if(node._renderedComponent) {\n            for(let key in node._renderedComponent) {\n                if(node._renderedComponent[key]) {\n                    var renderedComponent = node._renderedComponent[key];\n                    if(directiveObj && direct && renderedComponent._hooksPresent){\n                        directiveObj.removeRenderedComponent(comp,node,previousPromise);\n                    }else{\n                        if(!fakeRemove){\n                            node._renderedComponent[key].remove();\n                            node._renderedComponent[key] = null;\n                        }\n                    }\n                }\n            }\n        }\n          _LC.rmCx(node, contextSwitchArray);\n          if(!fakeRemove){\n            node._helpers = [];\n          }\n    }\n    updateYield(node, update, contextSwitchInfo,helperNode) {\n        let shadowObj = this.getShadowObj();\n        let directiveObj = this.getDirectiveObj();\n        let app = this.component.getAppOrAddon();\n        if(directiveObj){\n            node._childPromise = [];\n            node._specialNodes = [];\n        }\n        let constr = this.constructor;\n        if(!node._callee) {\n            node._callee = this;\n        }        \n        let toAppend = node._callee._yields[this.getYieldName(node)];\n        if(!toAppend) {\n        \treturn;\n        }\n        node._registerYield = toAppend;\n        //ADded now\n        let parentScope = toAppend._callee || node._callee._callee;\n        if(!parentScope) {\n            // if(Lyte._ms) {\n            //     var div = createElement(\"div\");\n            //     div.innerHTML = toAppend.outerHTML;\n            //     // if(Lyte._ie){\n            //     //     div.firstChild.innerHTML = toAppend.innerHTML;\n            //     //  }\n            //     var content1 = div.childNodes[0];\n            //     constr.splitTextNodes(content1);\n            //     content1 = constr.createDocFragment1(content1);\n            //     if(shadowObj && directiveObj && directiveObj.getTransitionArg(this,\"shadow-supported\") && directiveObj.getTransitionArg(this,\"shadow\") == true){\n            //         shadowObj.updateYield(this,node,toAppend,content1);\n            //     }else if(content1){\n            //         node.appendChild(content1);\n            //     }\n            //     else{\n            //         node.appendChild(toAppend.content.cloneNode(true, \"lyte\"));\n            //     }\n            // } else {\n                 if(shadowObj && directiveObj && directiveObj.getTransitionArg(this,\"shadow-supported\") && directiveObj.getTransitionArg(this,\"shadow\") == true){\n                    shadowObj.updateYield(this,node,toAppend);\n                }else{\n                    node.appendChild(toAppend.content.cloneNode(true, \"lyte\"));\n                }\n            // }\n            \n            node._helpers = [];\n            return;\n        }    \n\t    if(!toAppend._callee) {\n    \t\ttoAppend._callee = parentScope;\n    \t} \n        node._dynamicProperty = node._dynamicProperty || {};\n        //set values from child component. \n        let obj = {},contextSwitchingArray = {},self = this,contextSwitchArray = [];\n        _LC.adCx(toAppend, contextSwitchArray);\n        Object.keys(node._properties).forEach(function(key) {\n            contextSwitchingArray[key] = {};\n            contextSwitchingArray[key].value = parentScope.component.data[key];\n            contextSwitchingArray[key].property = parentScope._properties[key];\n            parentScope._properties[key] = node._properties[key];\n            parentScope.component.data[key] = node.component.data[key];\n        }); \n        // htA -> helpertemplateApplied\n        if(toAppend._ht && !toAppend._htA) {\n            toAppend._htA = true;\n            toAppend.content.append(toAppend._ht.content.cloneNode(true));\n        }\n        let yieldComp = node._callee;\n        let content = parentScope.renderNodes(toAppend, toAppend._dynamicNodes || [], node, {\"node\" : node}, true, undefined, toAppend._tC , yieldComp);\n        directiveObj && directiveObj.updateSpecialNodeRef(this,node,toAppend,helperNode);\n        if(!_LC.directive.getTransitionArg(node,\"unbound\")) {\n        \t_LC.establishBindings(node._properties, node.component.data);\n        }else if(!node.component.data.lyteUnbound && !_LC.migratedv2(app)) {        \t\n        \t_LC.establishBindings(node._properties, node.component.data);\n        }\n        parentScope.executeBlockHelpers(node._helpers);\n        Object.keys(node._properties).forEach(function(key) {\n            parentScope.component.data[key] = contextSwitchingArray[key].value;\n            parentScope._properties[key] = contextSwitchingArray[key].property;\n        });\n        _LC.rmCx(toAppend, contextSwitchArray); \n        if(shadowObj  && _LC.directive.getTransitionArg(this,\"shadow-supported\") && _LC.directive.getTransitionArg(this,\"shadow\") == true){\n            shadowObj.updateYield(this,node,toAppend,content,parentScope);\n        }else if(content){\n            node.appendChild(content);\n        }\n        else{\n            node.appendChild(toAppend.content.cloneNode(true, \"lyte\"));\n        }\n    }\n    //upddc\n    updateDynamicComponent(node, update, contextSwitchInfo, establishBindings) {\n    \tlet returnVal;\n        // let registryClass = this._registryClass;\n        let directiveObj = this.getDirectiveObj();\n        node._callee = this;\n        let keepAlive = node.hasAttribute(\"lyte-keep-alive\");\n        if(!node._renderedComponent) {\n            node._renderedComponent = {};\n            let id = _LC.createLyteId(this);\n            this.__dc[id] = node;\n            node.__lyteId = id;\n        }\n        \n        node._cx = contextSwitchInfo || node._cx;\n        node._dynamicProperty = node._dynamicProperty || {};\n        let componentName = node.getAttribute(\"component-name\") || (node._attributes ? node._attributes[\"component-name\"] : undefined);\n        let componentClass =  node._attributes ? node._attributes[\"component-class\"] : undefined;\n        let registryInstance = (node._initProperties ? node._initProperties.lyteRegistry : undefined) || (node._attributes ? node._attributes[\"lyte-registry\"] : undefined);\n        let regClass;\n        if(!componentName && !componentClass) {\n            return;\n        }\n        //@Slicer.developmentStart\n        // else if(componentName){\n        //     ComponentError.warn(\"LC016\",componentName);\n        // }\n        //@Slicer.developmentEnd\n        else if(componentClass){\n            componentName = componentClass._compName;\n            regClass = componentClass._registryClass\n        }\n        if(directiveObj){\n            node._childPromise = []\n            directiveObj.checkOngoingPromises(node);\n            node._totalPromise = [];\n        }\n        let component,newComponent = false;\n        if(update) {\n        \tif(keepAlive) {\n        \t\t_LC.ignoreDisconnect = true;\n        \t}\n            if(node._renderedComponent[node._currentComponent]) {\n                var activeComponent = node._renderedComponent[node._currentComponent];\n                if(activeComponent){\n                    if(directiveObj && activeComponent._specialNodes && activeComponent._specialNodes.length>0){\n                        directiveObj.updateRenderedComp(this,activeComponent,node,keepAlive)\n                    }else{\n                        if(keepAlive){\n                            _LC.hDiv.content.appendChild(activeComponent) \n                        }else{\n                            activeComponent.remove();\n                        }\n                        \n                    }\n                }\n            }\n            _LC.ignoreDisconnect = false;\n            if(!keepAlive) {\n                node._dynamicProperty = {};\n            }\n            if(node._renderedComponent[componentName] && keepAlive) {\n                component = node._renderedComponent[componentName];\n            } else {\n                if(registryInstance){\n                    component = registryInstance.render(componentClass,{});\n                }else if(regClass && regClass._instanceList && regClass._instanceList[0]){\n                    component = regClass._instanceList[0].render(componentClass,{});\n                }\n                else{\n                    component = createElement(componentName);\n                }\n                newComponent = true;\n            }\n        }  else {\n            // var flag = false;\n            // if(node._initProperties && node._initProperties.lyteRegistry){\n            //     _LC.setCurrentRegistryIns(node._initProperties.lyteRegistry);\n            //     flag = true;\n            // }\n            // component = createElement(componentName);\n            // if(flag){\n            //     _LC.setCurrentRegistryIns(undefined);\n            // }\n            if(registryInstance){\n                component = registryInstance.render(componentClass,{});\n            }else if(regClass && regClass._instanceList && regClass._instanceList[0]){\n                component = regClass._instanceList[0].render(componentClass,{});\n            }\n            else{\n                component = createElement(componentName);\n            }\n            newComponent = true;\n        }\n        if(!keepAlive && node._currentComponent) {\n            node._renderedComponent[node._currentComponent] = null;\n        }\n        if(newComponent) {\n//          let componentData = {};\n            for(let i=0;i<node.attributes.length;i++) {\n                if(node.attributes[i].name !== \"is\" && node.attributes[i].name !== \"component-name\" && node.attributes[i].name !== \"component-class\" && node.attributes[i].name !== \"lyte-keep-alive\" && !node.attributes[i].name.startsWith(\"@\")) {\n                    component.setAttribute(node.attributes[i].name, node.attributes[i].value);\n                }\n            }\n//          componentData = component._attributes;\n            if(node._attributes) {\n                for(var key in node._attributes) {\n                    // if(key == \"component-data\"){\n                    //     component.setData(node._attributes[key]);\n                    // }\n                \t// else \n                    if(key!== \"component-name\" && key!== \"component-class\") {\n                \t\tcomponent.setData(_LC.String.toCamelCase(key), node._attributes[key]);\n                \t}\n                }\n            }\n            let toAppend = this.renderNodes(node, node._dynamicNodes, node, undefined, establishBindings, undefined, node._tC);\n            component.appendChild(toAppend);\n            if(directiveObj && activeComponent){\n                component._dependentPromise = activeComponent._totalPromise;\n            }\n            component._toRegEvnts = node._toRegEvnts;\n        }\n        if(directiveObj){\n            returnVal = directiveObj.updateDynamicComp(this,update,component,activeComponent,node,newComponent);\n        }else{\n            if(!update) {\n                returnVal = {\"toAppendMain\" : component, \"lastNode\" : node};\n            } else {\n                _LC.ignoreDisconnect = true;\n                _LC.insertBeforeNative(node.parentNode,component, node);\n                _LC.ignoreDisconnect = false;\n            }\n        }\n        component._dynComp = true;\n        node._renderedComponent[componentName] = component;\n        node._currentComponent = componentName;\n\t    component._callee = this;\n        \n\t    component._actions = node._actions;\n        component.setMethods(node._initMethods);\n        component._attributeDetails = node._attributeDetails;\n        component._boundEvents = node._boundEvents;\n        component._cx = node._cx;\n        return returnVal;\n    }\n    // It constructs/updates the for helper. \n    updateForHelper(node, options, contextSwitchInfo, establishBindings, staticTempArr,yieldComp) {\n        let directiveObj = this.getDirectiveObj();\n        directiveObj && directiveObj.instanciateForPromises(node);\n        let app = this.component.getAppOrAddon();\n        if(node.tagName !== \"TEMPLATE\") {\n            Object.keys(node).forEach(function(item) {\n            \tif(item !== \"innerHTML\" && item !== \"innerText\") {\n\t                node._origTemplate[item] = node[item];            \t\n            \t}\n            });\n            // if(Lyte._ie) {\n            // \tvar div = createElement(\"div\");\n            //     div.innerHTML = node._tC;\n            //     node._origTemplate.innerHTML = div.children[0].innerHTML;\n            //     this.constructor.splitTextNodes(node._origTemplate);\n            //     if(node.hasAttribute(\"depth\")) {\n            //         node._origTemplate.setAttribute(\"depth\", node.getAttribute(\"depth\"));    \n            //     }\n            // }\n            let placeHolder = node._origTemplate._placeHolder = document.createTextNode(\"\");\n            node._origTemplate.setAttribute(\"item\", node.getAttribute(\"item\"));\n            node._origTemplate.setAttribute(\"index\", node.getAttribute(\"index\"));\n            \n            if(!_LC.migratedv2(app) && node.hasAttribute(\"unbound\")) {\n                //What if unbound is dynamic attribute ? It will be set in _attributes of node._origTemplate -> So No worries (y)\n                node._origTemplate.setAttribute(\"unbound\", \"true\");\n            }\n            //node.replaceWith(node._origTemplate._placeHolder);\n            _LC.replaceWithPf(node, node._origTemplate._placeHolder);\n            // node = _LC.replaceWithOrigTemplate(node)\n            node = node._origTemplate;\n            node.setAttribute(\"is\", \"for\");\n            _LC.apdNode(node, this);\n            placeHolder._helper = node;\n            \n        } else if(!node._placeHolder){\n            var emptyTextNode;\n            \n                emptyTextNode = document.createTextNode(\"\");\n                \n            //node.replaceWith(emptyTextNode);\n            _LC.replaceWithPf(node, emptyTextNode)\n            node._placeHolder = emptyTextNode;\n            emptyTextNode._helper = node;\n            _LC.apdNode(node, this);\n        }\n        node._sta = node._sta || staticTempArr;\n        let callee = this;\n        node._callee = this;\n        node._attributes = node._attributes || {};\n        if(options.type === \"update\" && node._currentItems === node._attributes.items) {\n            return {};\n        }\n        node._cx = contextSwitchInfo || node._cx;\n        let  indexValue = node.getAttribute(\"index\");\n        if(!indexValue) {\n            node.setAttribute(\"index\", \"index\");\n            indexValue = \"index\";\n        }\n        let itemValue = node.getAttribute(\"item\");\n        if(!itemValue) {\n            node.setAttribute(\"item\", \"item\");\n            itemValue = \"item\";\n        }\n        let initialItemValue = callee.component.data[itemValue],initialIndexValue = callee.component.data[indexValue];\n        let initialItemProp = callee._properties[itemValue],initialIndexProp = callee._properties[indexValue];\n        callee._properties[itemValue] = callee._properties[indexValue] = {};\n        let items = node._attributes.items,content = node.content,dynamicNodes = node._dynamicNodes,lastNode = node;\n        if(!node._items) {\n            node._items = [];\n        }\n        node._dynProps = node._dynProps || {};\n        let lastIndexForIteration;\n        let firstIndexForIteration;\n        let firstIndex = options.firstIndex;\n        let secondIndex = options.secondIndex;\n        let thirdIndex = options.thirdIndex;\n        var totalNodeIndex = firstIndex + secondIndex;\n        var updateIndexProperty = true;\n        var indexPropertyStartIndex = 0;\n        if(options) {\n            switch(options.type) {\n            case \"remove\"  :{\n                lastIndexForIteration = firstIndex;\n                indexPropertyStartIndex = firstIndex;\n                let totalProms = node._totalPromise;\n                for(let i=secondIndex; i>0; i--) {\n                    let ind = firstIndex + i-1;\n                    directiveObj && directiveObj.onGoingForPromise(node,ind)\n                    this.removeHelpersSpecificIndex(node, ind, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);\n                }\n                //ln\n                /*for(let i=(firstIndex)?firstIndex-secondIndex:firstIndex;i<node._items.length;i++) {\n                    let forItem = node._items[i].itemProperty;\n                    if(forItem._helperNodes){\n                        for (var item of forItem._helperNodes){\n                            let ind = item._cx.itemIndex;\n                            item._cx.itemIndex = (ind)? ind- secondIndex : ind;\n                        }\n                    }\n                }*/\n                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {        \n                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex - secondIndex;        \n                }\n                node._items.$splice(firstIndex, secondIndex);\n                node._helpers.$splice(firstIndex, secondIndex);\n                node._forContent.$splice(firstIndex, secondIndex);\n                node._specialNodes && node._specialNodes.$splice(firstIndex, secondIndex);\n                break;\n            }\n            case \"insert\" : {\n                firstIndexForIteration = firstIndex;\n                lastIndexForIteration = secondIndex;\n                indexPropertyStartIndex = firstIndex + secondIndex;\n                if(node._forContent[firstIndex]) {\n                    lastNode = node._forContent[firstIndex][0];\n                }\n                let newArr = [], newObj = [], newArr1 = [];\n                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {\n                    newArr.$push([]);\n                    newObj.$push({});\n                    newArr1.$push([]);\n                }\n                node._helpers.$splice.apply(node._helpers, [firstIndex, 0].$concat(newArr));\n                node._items.$splice.apply(node._items, [firstIndex, 0].$concat(newObj));\n                //ln\n//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {\n//                      let forItem = node._items[i].itemProperty;\n//                      for (var item of forItem._helperNodes){\n//                          item._cx.itemIndex = item._cx.itemIndex + secondIndex;\n//                      }\n//                  }\n                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {\n                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex;\n                }\n                node._forContent.$splice.apply(node._forContent, [firstIndex, 0].$concat(newArr1));\n                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, 0].$concat(newArr1));\n            }\n                break;\n            case \"replace\" : {\n                firstIndexForIteration = firstIndex;\n                lastIndexForIteration = secondIndex;\n                indexPropertyStartIndex = firstIndex + secondIndex;\n                let totalProms = node._totalPromise;\n                directiveObj && directiveObj.onGoingForPromise(node,firstIndex)\n                this.removeHelpersSpecificIndex(node, firstIndex, totalProms, undefined, totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);\n                let toAppendMain = createDocFragment();\n                if(node._forContent[firstIndex+1]) {\n                    lastNode = node._forContent[firstIndex+1][0];\n                }\n                let newArr = [], newObj = [], newArr1 = [];\n                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {\n                    newArr.$push([]);\n                    newArr1.$push([]);\n                    newObj.$push({});\n                }\n                node._helpers.$splice.apply(node._helpers,[firstIndex, 1].$concat(newArr));\n                node._items.$splice.apply(node._items, [firstIndex, 1].$concat(newObj));\n//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {\n//                      let forItem = node._items[i].itemProperty._forItem;\n//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;\n//                  }\n                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {\n                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - 1;\n                }\n                node._forContent.$splice.apply(node._forContent, [firstIndex, 1].$concat(newArr1));\n                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, 1].$concat(newArr1));\n                if(options.secondIndex == 1){\n                    updateIndexProperty = false;\n                }\n                break;\n            }\n            case \"splice\" : {\n                firstIndexForIteration = firstIndex;\n                lastIndexForIteration = secondIndex;\n                indexPropertyStartIndex = firstIndex + secondIndex;\n                let totalProms = node._totalPromise;\n                for(let i=thirdIndex;i>0;i--) {\n                    let ind = i + firstIndex-1;\n                    directiveObj && directiveObj.onGoingForPromise(node,ind)\n                    this.removeHelpersSpecificIndex(node, ind, totalProms, undefined, totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);\n                }\n                let toAppendMain = createDocFragment();\n                if(node._forContent[firstIndex+thirdIndex]) {\n                    lastNode = node._forContent[firstIndex+thirdIndex][0];\n                }\n                let newArr = [], newObj = [], newArr1 = [];\n                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {\n                    newArr.$push([]);\n                    newArr1.$push([]);\n                    newObj.$push({});\n                }\n                node._helpers.$splice.apply(node._helpers,[firstIndex, thirdIndex].$concat(newArr));\n                node._items.$splice.apply(node._items, [firstIndex, thirdIndex].$concat(newObj));\n//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {\n//                      let forItem = node._items[i].itemProperty._forItem;\n//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;\n//                  }\n                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {\n                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - thirdIndex;\n                }\n                node._forContent.$splice.apply(node._forContent, [firstIndex, thirdIndex].$concat(newArr1));\n                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, thirdIndex].$concat(newArr1));\n                if(options.secondIndex == options.thirdIndex){\n                    updateIndexProperty = false;\n                }\n                break;\n            }\n            break;\n            case \"update\" : \n            {\n                let key = node.getAttribute(\"item\");\n//                  this.removeHelpers(node, true);\n                let totalProms = node._totalPromise;\n                for(let i=node._items.length-1;i>=0;i--) {\n                    directiveObj && directiveObj.onGoingForPromise(node,i)\n                    this.removeHelpersSpecificIndex(node, i, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);\n                }\n//                  if(node._attributes.items) {\n//                      for(let i=0;i<node._attributes.items.length && node._items[i];i++) {\n//                          _LC.removeSelectedBindingDeep(node._items[i].itemProperty[key], node._attributes.items[i]);\n//                      }\n//                  }\n                node._items = [];\n        }\n            case \"default\" : \n            {\n                node._forContent = [];\n                if(directiveObj){\n                    node._specialNodes = [];\n                }\n                node._helpers = [];\n                firstIndexForIteration = 0;\n                lastIndexForIteration = items? items.length : 0 ;\n                indexPropertyStartIndex = items? items.length : 0 ;\n            }\n            //@Slicer.developmentStart\n            break;\n            default: \n                ComponentError.error(\"LC009\",\"updateForHelper\")\n            //@Slicer.developmentEnd\n            }\n        }\n        if(!lastNode) {\n            lastNode = node;\n        }\n        if(lastNode != node && node._helpers.length > 0  && (options.type == \"insert\" ||\"replace\"|| \"splice\") ){\n            lastNode = _LC.findLastNodeL(lastNode,totalNodeIndex,node);\n        }\n        let returnVal;\n        var localUnbound = false;\n        var initialUnbound = _LC.unbound;\n        if((node.hasAttribute(\"unbound\") || (node._attributes && node._attributes.unbound && node._attributes.unbound !== \"false\")) && !_LC.migratedv2(app)) {\n            localUnbound = true;\n            _LC.unbound = true;\n        }\n        if((!node._fRender && (node.getAttribute(\"unbound\") == \"lyteFastRender\" || (node._attributes && node._attributes.unbound == \"lyteFastRender\"))) && !_LC.migratedv2(app)) {\n            node._fRender = true;\n        }\n        let unboundDirective = _LC.directive.getTransitionArg(node,\"unbound\");\n        if(unboundDirective){\n            if(unboundDirective == \"lyteFastRender\"){\n                //@Slicer.developmentStart\n                ComponentError.error(\"LC010\", _LC.errorNodeDetails(node))\n                //@Slicer.developmentEnd\n            }else{ // if(unboundDirective !== \"false\")\n                localUnbound = true;\n                _LC.unbound = true;\n            }\n        }\n        let fastDirective = _LC.directive.getTransitionArg(node,\"turbo\");\n        if(fastDirective){\n            if(!node._fRender ){//&& fastDirective !== \"false\"\n                node._fRender = true;\n                localUnbound = true;\n                _LC.unbound = true;\n            }\n        }\n        node._currentItems = items;        \n        if((lastIndexForIteration - firstIndexForIteration) > 0) {\n            if(node._ht && !node._htA) {\n                node.content.append(node._ht.content.cloneNode(true));\n                node._htA = true;\n            }\n        }\n        if(options.type !== \"remove\") {\n            var totalString = \"\";\n            var domArr = [];\n            var toAppendMain = createDocFragment();\n            for(let k = firstIndexForIteration,v=lastIndexForIteration;v>0; k++, v--) {\n                node._helpers[k] = [];\n                if(directiveObj){\n                    node._specialNodes[k] = [];\n                }\n                node._items[k] = {\"_dynamicProperty\" : {}, \"itemProperty\" : {}, \"indexProperty\": {}};\n                callee.component.data[itemValue] = items[k];\n                callee.component.data[indexValue] = k;\n                var cacheData = {};\n                cacheData[itemValue]={}\n                cacheData[itemValue]._data = items[k];\n                cacheData[itemValue]._dyn = [itemValue];\n                cacheData[indexValue]={}\n                cacheData[indexValue]._data = k;\n                cacheData[indexValue]._dyn = [indexValue];\n                callee._properties[itemValue] = {};\n                callee._properties[indexValue] = {};\n                let optns = {\"itemValue\" : itemValue, \"itemIndex\" : k, \"type\" : \"for\", \"node\" : node, \"indexValue\" : indexValue};\n//                  defProp(callee._properties[itemValue], '_forItem', {\n//                      enumerable: false, \n//                      writable: true, \n//                      configurable: true, \n//                      value : optns\n//                  });\n                node._items[k]._cx = optns;\n                let breakCheck = {};\n                let toAppend;\n                if(node._fRender) {\n                    let fastObj = this.getFastObj();\n                    let str = fastObj.renderFast(dynamicNodes, node._sta, this.component, undefined, this);\n                    totalString = totalString + str;\n                    // var template = document.createElement(\"template\");\n                    // template.innerHTML = str;\n                    // toAppend = template.content;\n                } else {\n                    dynamicNodes._cache = cacheData;\n                    toAppend = this.renderNodes(node.hasAttribute(\"depth\") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, breakCheck, node._tC,yieldComp);\n                }\n                //to bind in ssr components\n                \n                let dynProps = Object.keys(node._items[k]._dynamicProperty);\n                for(let d=0;d<dynProps.length;d++) {\n                    let key = dynProps[d];\n                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    \n                }\n                node._items[k].itemProperty = this.getProperty(itemValue);\n                node._items[k].indexProperty = this.getProperty(indexValue);    \n//                  if(options.type !== \"default\") {\n                if(!_LC.unbound) {\n                \t_LC.establishBindings({[itemValue] : node._items[k].itemProperty},{[itemValue]:node._attributes.items[k]});\n                }\n//                  }\n                if(!node._fRender){\n                    node._forContent[k] = Array.from(toAppend.childNodes);\n                } else {\n                    domArr.$push(node._forContent[k] = []);\n                }\n                //Needs to revisit this and make sure it happen within renderNodes function itself;\n//                  if(options.type !== \"update\") {\n                this.executeBlockHelpers(node._helpers[k], node);\n                if(!node._fRender) {\n                    toAppendMain.appendChild(toAppend);\n                }\n                if(breakCheck.stop) {\n                    break;\n                }\n            }\n            if(node._fRender) {\n                var s = document.createElement(\"template\");\n                s.innerHTML = totalString;\n                toAppendMain.appendChild(s.content);\n                _LC.processAction(toAppendMain);\n                var childrenArr;\n                // if(Lyte._ie) {\n                //     childrenArr = [];\n                //     var childNodes = toAppendMain.childNodes;\n                //     for(var i=0;i<childNodes.length;i++) {\n                //         if(childNodes[i].nodeType == 1) {\n                //             childrenArr.$push(childNodes[i]);\n                //         }\n                //     }\n                // } \n                // else {\n                    childrenArr = toAppendMain.children;\n                // }\n                for(var i=0;i<domArr.length;i++) {\n                    domArr[i].$push(childrenArr[i]);\n                }\n                requestAnimationFrame(function() {\n                    requestAnimationFrame(function() {\n                        _LC.callCC();\n                    });\n                });\n            }\n            //Provided so that before appending the component to DOM it is reset to previous value\n            _LC.unbound = initialUnbound;\n            if(options.type === \"default\") {\n                returnVal = {\"toAppendMain\" : toAppendMain, \"lastNode\" : lastNode};\n            } else {\n                if(directiveObj){\n                    var dependentPromises = [];\n                    directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);\n                    directiveObj.insertInDom(this,lastNode._placeHolder,lastNode,toAppendMain,undefined,undefined,dependentPromises);\n                }else{\n                    _LC.insertInDom(lastNode._placeHolder,lastNode,toAppendMain);\n                }\n            }\n            if(!localUnbound && node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && node._removedAttributes.items._multipleProperty && node._removedAttributes.items._multipleProperty[0]) {\n            \t_LC.establishBindings({\"items\" : node._removedAttributes.items._multipleProperty[0].actProp}, {\"items\" : items});\n            }\n        }\n        _LC.unbound = initialUnbound;\n        if(updateIndexProperty){\n            for(let i=indexPropertyStartIndex; i<node._items.length; i++) {\n                if(node._items[i].indexProperty) {\n                    _LC.affectChanges(node._items[i].indexProperty);\n                }\n            }\n        }\n        callee.component.data[itemValue] = initialItemValue;\n        callee.component.data[indexValue] = initialIndexValue;\n        callee._properties[itemValue] = initialItemProp;\n        callee._properties[indexValue] = initialIndexProp;\n        node._currentItems = items;\n        return returnVal;\n    }\n    //It constructs/updates forIn Helper.\n    //updFIH\n    updateForInHelper(node, options, contextSwitchInfo, establishBindings,yieldComp) {\n        let directiveObj = this.getDirectiveObj();\n        directiveObj && directiveObj.instanciateForPromises(node);\n        let app = this.component.getAppOrAddon();\n        if(node.tagName !== \"TEMPLATE\") {\n            Object.keys(node).forEach(function(item) {\n                if(item !== \"innerHTML\" && item !== \"innerText\") {\n\t                node._origTemplate[item] = node[item];            \t\n            \t}\n            });\n            // if(Lyte._ie) {\n            // \tvar div = createElement(\"div\");\n            //     div.innerHTML = node._tC;\n            //     node._origTemplate.innerHTML = div.children[0].innerHTML;\n            //     this.constructor.splitTextNodes(node._origTemplate);\n            //     if(node.hasAttribute(\"depth\")) {\n            //         node._origTemplate.setAttribute(\"depth\", node.getAttribute(\"depth\"));\n            //     }\n            // }\n            let placeHolder = node._origTemplate._placeHolder = document.createTextNode(\"\");\n            node._origTemplate.setAttribute(\"key\", node.getAttribute(\"key\"));\n            node._origTemplate.setAttribute(\"value\", node.getAttribute(\"value\"));\n            if(node.hasAttribute(\"unbound\") && !_LC.migratedv2(app)) {\n                //What if unbound is dynamic attribute ? \n                node._origTemplate.setAttribute(\"unbound\", \"true\");\n            }\n            \n            //node.replaceWith(node._origTemplate._placeHolder);\n            _LC.replaceWithPf(node, node._origTemplate._placeHolder)\n            // node = _LC.replaceWithOrigTemplate(node)\n            node = node._origTemplate;\n            node.setAttribute(\"is\", \"forIn\");\n            _LC.apdNode(node, this);\n            placeHolder._helper = node;\n        } else if(!node._placeHolder){\n            var emptyTextNode;\n            \n                emptyTextNode = document.createTextNode(\"\");\n                \n            //node.replaceWith(emptyTextNode);\n            _LC.replaceWithPf(node, emptyTextNode);\n            node._placeHolder = emptyTextNode;\n            _LC.apdNode(node, this);\n            emptyTextNode._helper = node;\n        }\n        let callee = this;\n        node._callee = this;\n        node._attributes = node._attributes || {};\n        if(options.type === \"update\" && node._currentObject === node._attributes.object) {\n            return {};\n        }\n        contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;\n        node._cx = contextSwitchInfo;\n        let key = node.getAttribute(\"key\");\n        if(!key) {\n            key = \"key\";\n            node.setAttribute(\"key\", \"key\");\n        }\n        let value = node.getAttribute(\"value\");\n        if(!value) {\n            value = \"value\";\n            node.setAttribute(\"value\", \"value\");\n        }\n        let initialKeyValue = callee.component.data[key];\n        let initialValueValue = callee.component.data[value];\n        let initialKeyProp = callee._properties[key];\n        let initialValueProp = callee._properties[value];\n        callee._properties[key] = callee._properties[value] = {};\n        let object = node._attributes.object;\n        let content = node.content;\n        let dynamicNodes = node._dynamicNodes;\n        let lastNode = node;\n        let keysArray = [];\n        if(!node._items) {\n            node._items = {};\n        }\n        node._dynProps = node._dynProps || {};\n        if(options) {\n            switch(options.type) {\n            case \"delete\"  :{\n                let totalProms = node._totalPromise;\n                directiveObj && directiveObj.onGoingForPromise(node,options.property)\n                this.removeHelpersSpecificIndex(node, options.property, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);\n                var delIndex = node._keysArray.indexOf(options.property);\n                if(delIndex > -1) {\n                  node._keysArray.$splice(delIndex,1);\n                }\n                if(node._helpers) {\n                    delete node._helpers[options.property];    \n                }\n                delete node._propBindingObject[options.property];\n            }\n            break;\n            case \"add\" : {\n                keysArray = [options.property];\n                node._keysArray.$push(options.property);\n            }\n            break;\n            case \"update\" : \n            {\n                let totalProms = node._totalPromise;\n                let keyObjArr = node._keysArray;\n                for(let i=keyObjArr.length-1; i>=0; i--){\n                    directiveObj && directiveObj.onGoingForPromise(node,keyObjArr[i])\n                    this.removeHelpersSpecificIndex(node, keyObjArr[i], totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);\n                }\n                node._keysArray = keysArray = object ? Object.keys(object) : [];\n                node._helpers = {};\n                node._items = {};\n                node._propBindingObject = {};\n            }\n            break;\n            case \"default\" : \n            {\n                node._forContent = {};\n                if(directiveObj){\n                    node._specialNodes = {};\n                }\n                node._helpers = {};\n                node._keysArray = keysArray = object? Object.keys(object) : [];\n//                  keysArray = Object.keys(object);\n\n            }\n            //@Slicer.developmentStart\n            break;\n            default: \n                ComponentError.error(\"LC009\",\"updateForInHelper\")\n            //@Slicer.developmentEnd\n\n            }\n        }\n        let returnVal;\n        if(!object) {\n            let toAppendMain = createDocFragment();\n            if(options.type !== \"default\") {\n            \t_LC.insertBeforeNative(lastNode.parentNode,toAppendMain, lastNode);\n            } else {\n                returnVal = {\"toAppendMain\" : toAppendMain, \"lastNode\" : lastNode};\n            }    \n        }\n        let localUnbound = false;\n        let initialUnbound = _LC.unbound;\n        if((node.hasAttribute(\"unbound\") || (node._attributes && node._attributes.unbound)) && !_LC.migratedv2(app)) {\n            localUnbound = true;\n            _LC.unbound = true;\n        }\n        let unboundDirective = _LC.directive.getTransitionArg(node,\"unbound\")\n        if(unboundDirective){\n            localUnbound = true;\n            _LC.unbound = true;\n        }\n        node._currentObject = object;\n        if(keysArray.length && node._ht && !node._htA) {\n            node.content.append(node._ht.content.cloneNode(true));\n            node._htA = true;\n        }\n        if(object && options.type !== \"remove\") {\n            var toAppendMain = createDocFragment();\n            node._propBindingObject = node._propBindingObject || {};\n            keysArray.forEach(function(itemKey, index, array) {\n                node._helpers[itemKey] = [];\n                if(directiveObj){\n                    node._specialNodes[itemKey] = [];\n                }\n                node._items[itemKey] = {\"_dynamicProperty\" : {}, \"itemProperty\" : {}};\n                callee.component.data[key] = itemKey;\n                callee.component.data[value] = object[itemKey];\n                callee._properties[key] = {};\n                callee._properties[value] = {};\n                var cacheData = {};\n                cacheData[key] = {}\n                cacheData[key]._data = itemKey;\n                cacheData[key]._dyn = [key];\n                cacheData[value] = {}\n                cacheData[value]._data = object[itemKey];\n                cacheData[value]._dyn = [value];\n                let optns = {\"itemIndex\" : itemKey, \"itemValue\" : value, \"keyValue\" : key, \"type\" : \"forIn\", \"node\" : node};\n                node._items[itemKey]._cx = optns;\n                dynamicNodes._cache = cacheData;\n                let toAppend = this.renderNodes(node.hasAttribute(\"depth\") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, undefined, node._tC,yieldComp);\n                Object.keys(node._items[itemKey]._dynamicProperty).forEach(function(key) {\n                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    \n                })\n                node._items[itemKey].itemProperty = this.getProperty(value);\n                node._propBindingObject[itemKey] = node._items[itemKey].itemProperty;\n                node._forContent[itemKey] = Array.from(toAppend.childNodes);\n//                    this.updateBlockHelpers(node._helpers[itemKey], optns);\n                this.executeBlockHelpers(node._helpers[itemKey], node);\n                //to bind in ssr components\n                \n                toAppendMain.appendChild(toAppend);\n            }, this); \n//              if(options.type !== \"update\") {\n                if(!_LC.unbound && typeof node._attributes.object =='object' && !Array.isArray(node._attributes.object)) {\n            \t\tmakeSet(node._attributes.object, \"_bindings\");\n                    addBindings(node._attributes.object._bindings,node._propBindingObject);\n                    _LC.establishBindings(node._propBindingObject, node._attributes.object);\n            \t}\n//              }\n\t\t\t\t_LC.unbound = initialUnbound;\n                if(options.type !== \"default\") {\n                    if(directiveObj){\n                        let dependentPromises = [];\n                        directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);\n                        directiveObj.insertInDom(this,lastNode._placeHolder,lastNode,toAppendMain,undefined,undefined,dependentPromises);\n                    }else{\n                        _LC.insertInDom(lastNode._placeHolder,lastNode,toAppendMain);\n                    }\n                } else {\n                    returnVal = {\"toAppendMain\" : toAppendMain, \"lastNode\" : lastNode};\n                }\n\n        }\n        _LC.unbound = initialUnbound; \n        callee.component.data[key] = initialKeyValue;\n        callee.component.data[value] = initialValueValue;\n        callee._properties[key] = initialKeyProp;\n        callee._properties[value] = initialValueProp;\n        node._currentObject = object;\n        return returnVal;\n    }\n    rmCaseBindings(node,templInd,currentInd){\n        let casesList = node._co;\n        for(let i=templInd+1;i<=currentInd;i++){\n            let temp = node._tempList[casesList[i]];\n            if(temp){\n                _LC.removeDynamicNodes(temp,this);\n                node._bindedList[casesList[i]] = false;\n            }\n        }\n    }\n    getCaseTemplate(node,nodeTemp,caseName,caseStr){\n        var dummyTemp;\n        var obj = {};//check\n        if(!node._tempList[caseName]){\n            // if(Lyte._ms){\n            //     dummyTemp = _LC.getContentForIE(node._cases[caseName].templateContent , this.constructor,undefined,obj);\n            //     if(obj._content){\n            //         dummyTemp = obj._content.childNodes[0];\n            //     }\n            // }else{\n                dummyTemp = nodeTemp.content.querySelector(caseStr+_LC.cssEscape(caseName)+'\\']');\n            // }\n            node._tempList[caseName] = dummyTemp;\n        }else{\n            dummyTemp = node._tempList[caseName];\n        }\n        return dummyTemp;\n    }\n    getCaseIndexScope(node,templateCaseNode,casesList,caseName,switchValue,lyteConvertedSwitch){\n        var caseName = templateCaseNode.getAttribute(\"lc-id\");\n        var templInd = casesList.indexOf(caseName);\n        let val = templateCaseNode._attributes.case;\n        var currentInd = casesList.indexOf(node._currentScope);\n        var scope;\n        if(node._currentScope != \"default\"){\n            if(templInd == currentInd){\n                if(val){\n                    if(lyteConvertedSwitch){\n                        return false;\n                    }else if(val==templateCaseNode._prevDataVal){ //second check for lyteconvertedtemp\n                        return false;\n                    }\n                    else if(val == switchValue){\n                        scope  = node._cases[caseName];\n                    }\n                }\n            }\n            else if(templInd > currentInd){\n                return false;\n            }\n            else if(templInd < currentInd){\n                if(val){\n                    this.rmCaseBindings(node,templInd,currentInd);\n                    scope  = node._cases[caseName];\n                    scope.cn = caseName;\n                }else{\n                    return false;\n                }\n            }\n        }else{\n            this.rmCaseBindings(node,templInd,casesList.length-1);//templInd+1\n        }\n        return scope;\n    }\n    getSwitchScope(node,templateCaseNode,scope,nodeTemp,helperNode,contextSwitchInfo,switchValue,lyteConvertedSwitch,idx,id){\n        var caseStr;\n        var casesList = node._co;\n        var currentInd = -1;//casesList.indexOf(node._currentScope);\n        if(templateCaseNode){\n            scope = this.getCaseIndexScope(node,templateCaseNode,casesList,caseName,switchValue,lyteConvertedSwitch);\n            if(scope == false){\n                return false;\n            }\n        }\n        // else{\n        //     currentInd = -1;\n        // }\n        if(!scope){\n            var indexStart = node._currentScope ? currentInd + 1 : 0;\n            for(var i=indexStart; i<casesList.length; i++){\n                var caseName = casesList[i];\n                var dummyTemp;\n                if(node._cases[caseName].dcn){\n                    caseStr = '[lc-id=\\'';\n                    dummyTemp = this.getCaseTemplate(node,nodeTemp,caseName,caseStr);\n                    dummyTemp._parentSwitch = node;\n                    dummyTemp._callee = this;\n                    if(node._bindedList[caseName]){\n                        if((lyteConvertedSwitch && dummyTemp._attributes.case) || (!lyteConvertedSwitch && dummyTemp._attributes.case == switchValue)){\n                            scope  = node._cases[caseName];\n                            scope.cn = caseName;\n                            dummyTemp._prevDataVal = dummyTemp._attributes.case;\n                            if(!templateCaseNode && !lyteConvertedSwitch){\n                                this.rmCaseBindings(node,i,casesList.length);\n                            }\n                            break;\n                        }\n                    }else{\n                        var toBeRemoved = [];\n                        dummyTemp._dynamicProperty = dummyTemp._dynamicProperty || {};\n                        if(lyteConvertedSwitch && helperNode && i==0){\n                            this.bindNode(dummyTemp.attributes.getNamedItem(\"case\"), toBeRemoved,  helperNode , helperNode.getAttribute(\"is\")!=\"switch\" && contextSwitchInfo ? contextSwitchInfo :{}, node._cases[caseName].cdp.a.case,undefined,undefined,undefined,undefined,lyteConvertedSwitch?\"l\":undefined,idx,undefined,id);\n                        }else{\n                            this.bindNode(dummyTemp.attributes.getNamedItem(\"case\"), toBeRemoved, dummyTemp ,{}, node._cases[caseName].cdp.a.case,undefined,undefined,undefined,undefined,lyteConvertedSwitch?\"l\":undefined,idx,undefined,id);\n                        }\n                        // if(this._ssrBind && textNode){\n                        //     textNode.setAttribute( \"placeHolderId\", dummyTemp.getAttribute( 'bindId' ) );\n                        // }\n                        \n                        // debugger;\n                        // if(helperNode){\n                        //     helpId = helperNode.getAttribute(\"bindId\");\n                            \n                        //     obj._helperId = helpId;\n                        //     if(/^(for|forIn)$/.test(helperNode.getAttribute(\"is\"))){\n                        //         obj._forType = this.getssrType(helperNode.getAttribute(\"is\"));\n                        //         obj._forIndex = dynamicN._cx.itemIndex;\n                        //     }\n                        // }\n                        // this.component.data.bindIds.push( obj );\n                        dummyTemp._cx = contextSwitchInfo;\n                        node._bindedList[caseName] = true;\n                        dummyTemp._parentSwitch = node;\n                        let val;\n                        if(dummyTemp.getAttribute(\"case\")=== \"\" || dummyTemp.getAttribute(\"case\")) {\n                            val = dummyTemp.getAttribute(\"case\");\n                        }if(dummyTemp._attributes) {\n                            val = dummyTemp._attributes.case;\n                        }\n                        if((lyteConvertedSwitch && val) || (!lyteConvertedSwitch && val == switchValue)){\n                            scope  = node._cases[caseName];\n                            scope.cn = caseName;\n                            dummyTemp.cn = val;\n                            break;\n                        }\n                    }\n                }else if(!lyteConvertedSwitch){\n                    //might br stattic caseinbetween\n                    caseStr = \"[case='\";\n                    dummyTemp = this.getCaseTemplate(node,nodeTemp,caseName,caseStr);\n                        let val = dummyTemp.getAttribute(\"case\");\n                        if(val == switchValue){\n                            scope  = node._cases[caseName];\n                            scope.cn = caseName;\n                            dummyTemp._prevDataVal = val;\n                            break;\n                        }\n                }\n            }      \n        }  \n        return scope;\n    }\n    //updSH\n    updateSwitchHelper(type,node, contextSwitchInfo, update, establishBindings,yieldComp,templateCaseNode,helperNode,id,idx){\n         var lyteConvertedSwitch = node.getAttribute(\"l-c\");\n         let directiveObj = this.getDirectiveObj();\n         if(directiveObj){\n             directiveObj.checkOngoingPromises(node);\n             directiveObj.instanciateForPromises(node);//af\n         }\n         if(node._ht && !node._htA) {\n             node.content.append(node._ht.content.cloneNode(true));\n             node._htA = true;\n         }\n         if(node.tagName !== \"TEMPLATE\") {\n             Object.keys(node).forEach(function(item) {\n                 if(item !== \"innerHTML\" && item !== \"innerText\") {\n                     node._origTemplate[item] = node[item];\n                 }\n             });\n             // if(Lyte._ie) {\n             // \tvar div = createElement(\"div\");\n             //     div.innerHTML = node._tC;\n             //     node._origTemplate.innerHTML = div.children[0].innerHTML;\n             //     this.constructor.splitTextNodes(node._origTemplate);\n             //     if(node.hasAttribute(\"depth\")) {\n             //         node._origTemplate.setAttribute(\"depth\", node.getAttribute(\"depth\"));    \n             //     }\n             // }\n             let placeHolder = node._origTemplate._placeHolder = document.createTextNode(\"\");\n             //node.replaceWith(node._origTemplate._placeHolder);\n             _LC.replaceWithPf(node, node._origTemplate._placeHolder);\n             node = node._origTemplate;\n             // node = _LC.replaceWithOrigTemplate(node)\n             node.setAttribute(\"is\", _LC.mappy[type]);\n             _LC.apdNode(node, this);\n             placeHolder._helper = node;\n         } else if(!node._placeHolder){\n             var emptyTextNode;\n             \n                 emptyTextNode = document.createTextNode(\"\");\n                 \n             //node.replaceWith(emptyTextNode);\n             _LC.replaceWithPf(node, emptyTextNode);\n             node._placeHolder = emptyTextNode;\n             emptyTextNode._helper = node;\n             _LC.apdNode(node, this);\n         }\n         let isNew = false;\n         let lastNode = node;\n         if(!node._callee) {\n             node._callee = this;\n             isNew = true;\n         }\n         node._bindedList = node._bindedList || {};\n         node._tempList = node._tempList || {};\n         contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;\n         node._cx = contextSwitchInfo;\n         node._dynamicProperty = node._dynamicProperty ? node._dynamicProperty : {};\n         var switchValue;\n         if(node.getAttribute(\"value\")=== \"\" || node.getAttribute(\"value\")) {\n             switchValue = node.getAttribute(\"value\");\n         } else if(node._attributes) {\n             switchValue = node._attributes.value;\n         }\n         if(!lyteConvertedSwitch && !node._hd){\n             if(switchValue) {\n                 switchValue = switchValue.toString();\n             } else {\n                 switch(switchValue) {\n                     case undefined : \n                         switchValue = \"undefined\";\n                         break;\n                     case null : \n                         switchValue = \"null\";\n                         break;\n                     case false: \n                         switchValue = \"false\";\n                         break;\n                     case \"\": \n                         switchValue = '\"\"';\n                         break;\n                     case 0 : \n                         switchValue = '0';\n                 }\n             }\n         }\n         if((!lyteConvertedSwitch && !node._hd) && switchValue === node._currentCase) {\n             return;\n         }\n         let scope,caseStr;\n         node._currentCase = switchValue;\n         var nodeTemp = node._depthTemp || node;\n         if(node._hd){\n             scope = this.getSwitchScope(node,templateCaseNode,scope,nodeTemp,helperNode,contextSwitchInfo,switchValue,lyteConvertedSwitch,idx,id);\n             if(scope){\n                 node._currentCase = scope.cn;\n             }\n         }\n         else{\n             caseStr = '[case=\\''\n             scope = node._cases[switchValue];\n         }\n         if(scope === false || (!scope && node._previousScope == \"default\")){\n             return;\n         }\n         if(node._caseContent && node._caseContent.length) {\n             this.removeHelpers(node, undefined, true,node._totalPromise);//, node._hd ?{start:templInd+1,end:node._currentScope != \"default\"?currentInd:casesList.length-1}:false\n         }\n         node._currentScope = scope && scope.cn;\n         let defaultContent;\n         if(!scope){\n             scope = node._default;\n             node._currentScope = \"default\";\n             defaultContent = nodeTemp.content.querySelector('[default]');\n             if(scope._ht && !defaultContent._htA) {\n                 defaultContent._htA = true;\n                 defaultContent.content.append(scope._ht.content.cloneNode(true));\n             }\n             node._isDefault = true; \n             if(!defaultContent) {\n                 // if(node._caseContent && node._caseContent.length) {\n                 //     this.removeHelpers(node, undefined, true ,node._totalPromise);\n                 // }\n                 // node._previousCase = node._currentCase;\n                 node._caseContent = [];\n                 let emptyTextNode = document.createTextNode(\"\");\n                 node._caseContent.$push(emptyTextNode);\n                 node._currentCaseName = switchValue;\n                 node._helpers = node._helpers || [];\n                 if(update) {\n                     //lastNode.parentNode.insertBefore(emptyTextNode, node);\n                     if(lastNode._placeHolder) {\n                         _LC.insertBeforeNative(lastNode._placeHolder.parentNode,emptyTextNode, lastNode._placeHolder);                    \n                     } else {\n                         _LC.insertBeforeNative(lastNode.parentNode,emptyTextNode, node);\n                     }\n                     return;\n                 } else {\n                     let toAppendMain = createDocFragment();\n                     toAppendMain.append(emptyTextNode);\n                     return {lastNode : lastNode, toAppendMain : toAppendMain};\n                 }\n             }\n         }\n         \n //        if(currentCase) {\n //              if(currentCase.tagName === \"TEMPLATE\" && !currentCase.getAttribute(\"is\")){\n //                  currentCase = currentCase.content;\n //              } else {\n //                  let temp = createElement('template');\n //                  let clone = currentCase.cloneNode(true);\n //                  temp.content.appendChild(clone);\n //                  currentCase.removeAttribute('slot');\n //                  currentCase = temp.content;\n //              }\n //              scope.content = currentCase;\n //        }\n  \n         // if(node._caseContent && node._caseContent.length) {\n         //     this.removeHelpers(node, undefined, true ,node._totalPromise);\n         // }\n         let dummyScope = scope;\n         let additionalContentArr = [];\n         let cnt=0;\n         let dummyCaseName = switchValue;\n         let template;\n         if(defaultContent) {\n             template = defaultContent\n         } else {\n             template = nodeTemp.content.querySelector((scope.dcn ? '[lc-id=\\'' : '[case=\\'') +_LC.cssEscape(scope.cn ? scope.cn : dummyCaseName)+'\\']');\n         }\n         // if(!template._callee){\n         //     template._callee = this;\n         // }\n         let contentArr = [];\n         if(directiveObj){\n             node._specialNodes = [];\n         }\n         let nextCaseName;\n         while(dummyScope) {\n             if(dummyScope._ht && !template._htA) {\n                 template._htA = true;\n                 template.content.append(dummyScope._ht.content.cloneNode(true));\n             }\n             let dynamicNodes = dummyScope.dN;\n             if(nextCaseName && node._cases[nextCaseName].dcn){\n                 caseStr = '[lc-id=\\'';\n                 var tempNode = this.getCaseTemplate(node,nodeTemp,nextCaseName,caseStr);\n                 if(!node._bindedList[nextCaseName]){\n                     var toBeRemoved = [];\n                     tempNode._dynamicProperty = tempNode._dynamicProperty || {};\n                     this.bindNode(tempNode.attributes.getNamedItem(\"case\"), toBeRemoved, tempNode ,{}, node._cases[nextCaseName].cdp.a.case);\n                     tempNode._cx = contextSwitchInfo;\n                     node._bindedList[nextCaseName] = true;\n                     tempNode._parentSwitch = node;\n                 }\n             }\n             let processedContent = this.renderNodes(template, dynamicNodes, node, undefined, establishBindings, undefined, dummyScope.templateContent,yieldComp);\n             \n             contentArr.$push(processedContent);\n             if(dummyScope.additional) {\n                 if(node._cases[dummyScope.additional.next] && node._cases[dummyScope.additional.next].dcn){\n                     caseStr = '[lc-id=\\'';\n                 }else{\n                     caseStr = '[case=\\''\n                 }\n                 if(dummyScope.additional.next) {\n                     nextCaseName = dummyScope.additional.next;\n                     template = node.content.querySelector(caseStr+_LC.cssEscape(dummyScope.additional.next)+'\\']');\n                     dummyScope = node._cases[dummyScope.additional.next];\n                 } else {\n                     template = node.content.querySelector('[default]');\n                     dummyScope = node._default;\n                 }\n             } else {\n                     break;\n             }\n         }\n         node._caseContent = [];\n         let toAppendMain = createDocFragment();\n         for(let i=0;i<contentArr.length;i++) {\n             if(contentArr[i].nodeType == 11){\n //                for(let j=0;j<contentArr[i].childNodes.length;j++) {\n //                    node._caseContent.$push(contentArr[i].childNodes[j]);\n //                }\n                 node._caseContent = node._caseContent.$concat(Array.from(contentArr[i].childNodes));\n             }\n             else{\n                 node._caseContent.$push(contentArr[i]);\n             }\n                 toAppendMain.append(contentArr[i]);\n //            node.parentNode.insertBefore(contentArr[i], node);\n         }\n           this.executeBlockHelpers(node._helpers, node);\n           if(update) {\n               let returnVal;\n               if(toAppendMain.querySelector(\"template[is=break]\")) {\n                   returnVal = \"break\";\n               } else if(toAppendMain.querySelector(\"template[is=continue]\")) {\n                   returnVal = \"continue\";\n               }\n               if(directiveObj){\n                 let dependentPromises = [];\n                 directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);\n                 directiveObj.insertInDom(this,node._placeHolder,node,toAppendMain,node._previousCase ?false:true,undefined,dependentPromises);\n               }else{\n                 _LC.insertInDom(node._placeHolder,node,toAppendMain);\n               }\n\n               node._previousCase = node._currentCase;\n               node._previousScope = node._currentScope;\n               return returnVal;\n           } else {\n                 node._previousCase = node._currentCase;\n                 node._previousScope = node._currentScope;\n               return {\"toAppendMain\" : toAppendMain, \"lastNode\" : node};\n           }\n     }\n\n    dummy(a,b) {\n        let dummy = this.component.constructor._properties[boundValue].observer;\n    }\n\n    callObservers(boundValue, key) {\n        let property = this.component.constructor._properties[boundValue];\n        let observers = property?property.observer: undefined;\n        if(observers) {\n            for(let i=0;i<observers.length;i++) {\n                if(key.indexOf('.') === -1 || observers[i].path === key) {\n                    this[\"_\"+observers[i].functionName].apply(this);\n                }\n            }\n        }\n    }\n\n    // static updateValue(property, path, value) {\n    //     let pathVals = path.split('.');\n    //     let context = property;\n    //     for(let i=0;i<pathVals.length -1;i++) {\n    //         context = context[pathVals[i]];\n    //     }\n    //     context[pathVals[i]] = value;\n    // }\n\n    //    static createDocFragment(template){\n    //        let childNodes = template.cloneNode(true,\"lyte\").childNodes;\n    ////           let childNodes = template.childNodes;\n    //        let frag = document.createDocumentFragment();\n    //        let len = childNodes.length;\n    //        for(let i=0; i<len; i++){\n    //            frag.appendChild(childNodes[0]);\n    //        }\n    //        return frag;\n    //    }\n\n    static createDocFragment1(template) {\n        if(template.content) {\n            return template.content;\n        }\n    \tlet childNodes = template.childNodes;\n    \tlet frag = createDocFragment();\n    \tlet len = childNodes.length;\n    \tfor(let i=0; i<len; i++){\n            frag.appendChild(childNodes[0]);\n        }\n    \treturn frag;\n    }\n    static seperateStyle(componentClass,componentsDiv){\n        componentClass._template.replace(/\\\\'/g,\"'\");\n        let div = createElement(\"div\");\n        div.innerHTML = componentClass._template;\n        while(div.firstChild){\n            if(div.firstChild.nodeName === \"STYLE\") {\n                componentClass._style = div.firstChild.outerHTML;\n                div.firstChild.remove();\n            } else {\n                // div.firstChild.setAttribute(\"lyte-registry\",componentClass._registryClass.name);\n                componentsDiv.appendChild(div.firstChild);\n            }\n        }\n    }\n    static _registerComponent(a,b,componentClass,registry,registryInstance) {\n        let componentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv ,registry.name);\n        let origTemplateValue = componentClass._template;\n        let app = _LC.getAppOrAddon(registryInstance);\n        var clonedDummyTemp;\n        if(componentClass._template && typeof componentClass._template === \"string\"){\n            this.seperateStyle(componentClass,componentsDiv);\n        }else if(componentClass.template && typeof componentClass.template === \"object\"){\n            componentClass._template = componentClass.template._template;\n            componentClass._dynamicNodes = componentClass.template._dynamicNodes;\n            componentClass.template = undefined;\n            this.seperateStyle(componentClass,componentsDiv);\n        }\n        componentClass._template = componentsDiv.querySelector(\"template[tag-name='\"+a+\"']\");\n        componentClass._helperTemplate = document.createElement(\"template\");\n        componentClass._helperTemplate.setAttribute(\"_lyteht\", a );\n        _LC.h1Div.content.appendChild(componentClass._helperTemplate);\n        if(!componentClass._template) {\n            //@Slicer.developmentStart\n            console.error(\"Template not found for the component : '\"+a+\"'\");\n            //@Slicer.developmentEnd\n        \treturn;\n        }\n        if(Compile.needDummyComponentsDiv) {\n            // if(Lyte._ie) {\n            //     let temp = Compile.getTemplateFromString(origTemplateValue);\n            //     // let dummyLyteComponentsDiv = _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name);\n            //     _LC.getComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name)\n            //     dummyLyteComponentsDiv.appendChild(temp);\n            // } else {\n                clonedDummyTemp = componentClass._template.cloneNode(true);   \n            // }\n        }\n        if(componentClass._template && !componentClass._template.content){\n//            var frag = document.createDocumentFragment();\n//            let childNodes = this._template.cloneNode(true,\"lyte\").childNodes;\n//            //let childNodes = this._template.childNodes;\n//            let len = childNodes.length;\n//            for(let i=0; i<len; i++){\n//                frag.appendChild(childNodes[0]);\n//            }\n//            this._template.content = frag;\n        }\n        // var s = Lyte._ie ? componentClass._template : componentClass._template.content;//)?this._template.content:document.createDocumentFragment(this._template);\n        var s = componentClass._template.content; //)?this._template.content:document.createDocumentFragment(this._template);\n        //This is used to split text nodes which contain multiple dynamic values \n        //Eg.\" Name is {{name}} and age is {{age}} \"\n        //This is used to find the dynamicNodes and helper nodes for the given component. \n        if(!componentClass._dynamicNodes){\n            if(Compile.getDynamicNodes) {\n                var returnVal = Compile.getDynamicNodes(a);\n                if(returnVal.errors){\n                    //@Slicer.developmentStart\n                    console.error(\"Error in the component\", returnVal.componentName, returnVal.errors);\n                    //@Slicer.developmentEnd\n                    return false;\n                }else{\n                    componentClass._dynamicNodes = returnVal.dynamicNodes;\n                    if(componentClass._dynamicNodes && componentClass._dynamicNodes.length && componentClass._dynamicNodes[componentClass._dynamicNodes.length-1].type == \"dc\"){\n                        b.dc = componentClass._dynamicNodes.$pop();\n                    }\n                }\n            } \n            //@Slicer.developmentStart\n            else {\n                ComponentError.error(\"LC002\", a);  \n            }\n            //@Slicer.developmentEnd\n\t    } \n        if(componentClass._dynamicNodes) {\n            this.setTemplateAttributes(a, componentClass, clonedDummyTemp);\n            var hasUnbound = this.getFastRenderSupported(componentClass._templateAttributes);\n            let fastRenderClass = registry.getFastObj();\n            // var hasUnbound = b._observedAttributes.indexOf(\"lyteUnbound\") !== -1;\n            if(!hasUnbound && !_LC.migratedv2(app)){\n                hasUnbound = b._observedAttributes.indexOf(\"lyteUnbound\") !== -1;\n            }\n            var newCompile;\n            if(hasUnbound) {\n                if(fastRenderClass){\n                    newCompile = fastRenderClass.getNewCompile(componentClass);\n                }\n                //@Slicer.developmentStart\n                else{\n                    ComponentError.error(\"LC011\")\n                }\n                //@Slicer.developmentEnd\n                // if(Lyte._ie) {\n                //     newCompile = document.createElement(\"div\");\n                //     newCompile.innerHTML = componentClass._template.outerHTML;\n                //     newCompile = newCompile.childNodes[0];\n                // } else {\n                //     newCompile = componentClass._template.cloneNode(true);\n                // }\n            }\n            this.splitTextNodes(s);\n            if(hasUnbound && fastRenderClass) {\n                this.splitTextNodes(newCompile);\n            }\n            doCompile(s, componentClass._dynamicNodes, a, b, newCompile ? newCompile.content : undefined, componentClass, fastRenderClass);\n            // if(Lyte._ed) { \n            //     componentClass._tC = componentClass._template.outerHTML;\n            // } \n            // else if(Lyte._ie) {\n            //     componentClass._tC = s.outerHTML;\n            // }\n        }\n        clonedDummyTemp && _LC.getComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name).appendChild(clonedDummyTemp);\n        componentClass._sta = newCompile ? _LC.processStatic(newCompile) : undefined;\n    }\n    static getFastRenderSupported(templateAttributes){\n        if(templateAttributes && templateAttributes.a){\n            for(let attrName in templateAttributes.a){\n                if(attrName == \"@unbound-supported\" || attrName == \"@turbo-supported\" ){\n                    return true;\n                }\n            }\n        }\n\n    }\n    static setTemplateAttributes(a, componentClass,clonedDummyTemp){\n        componentClass._templateAttributes = {t : \"a\", \"a\" : {}, p: []};\n        var ta = [componentClass._templateAttributes];\n        doCompile(componentClass._template, ta, a, this, undefined, componentClass);\n        componentClass._templateAttributes = ta[0];\n        if(componentClass._templateAttributes && componentClass._templateAttributes.a) {\n            var attributesT = componentClass._template.attributes;\n            try{\n                for(let i=0;i<attributesT.length;i++) {\n                    let attrName = attributesT[i].name;\n                    if(!componentClass._templateAttributes.a[attrName] && attrName !== \"tag-name\" && attrName !== \"use-strict\" && attrName !== \"lyte-registry\" && attrName !== \"__vp\") {\n                        componentClass._templateAttributes.a[attrName] = {\"name\" : attrName, \"staticValue\" :  attributesT[i].value};\n                        componentClass._template.removeAttribute(attrName);\n                        clonedDummyTemp && clonedDummyTemp.removeAttribute(attrName);\n                        i--;\n                    }\n                }    \n            } catch(e) {\n                //@Slicer.developmentStart\n                ComponentError.error(\"LC012\")\n                //@Slicer.developmentEnd\n            }\n        }\n    }\n    //This is used to split text nodes which contain multiple dynamicNodes. \n    static splitTextNodes(node) {\n        if(node && node.childNodes && node.childNodes.length) {\n            for(let i=node.childNodes.length-1;i>=0;i--) {\n                this.splitTextNodes(node.childNodes[i]);\n            }\n        }\n        if(node.tagName === \"TEMPLATE\") { // && !Lyte._ie\n            this.splitTextNodes(node.content);\n        }\n        if(node.nodeType === node.TEXT_NODE) {\n            let nodeValue = node.nodeValue;\n            if(nodeValue){\n                let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|\")[^\\1]*?\\1)[^}]*?)*}}/g); //'\n                if(!mustacheValues) {\n                    return;\n                }\n                let newNodeArray = [];\n                for(let i=0;i<mustacheValues.length;i++) {\n                    let mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);\n                    let mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;\n                    if(mustacheStartIndex) {\n                            newNodeArray.$push(document.createTextNode(nodeValue.substring(0, mustacheStartIndex)));\n                    }\n                    newNodeArray.$push(document.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));\n                    nodeValue = nodeValue.substring(mustacheEndIndex);\n                }\n                if(!(!nodeValue.trim() && node.nextSibling && node.nextSibling.nodeType === 3 && !node.nextSibling.nodeValue.trim())) {\n                    newNodeArray.$push(document.createTextNode(nodeValue));\n                }\n                //Fix for IE Edge issue with higher versions where node.replaceWith is not working when the parent is a doc fragment.\n                if(node.parentNode.nodeName === \"#document-fragment\") {\n                \tfor(let i=0;i<newNodeArray.length;i++) {\n                \t\t_LC.insertBeforeNative(node.parentNode,newNodeArray[i],node);\n                      }\n                    node.remove();\n                } else {\n                \tnode.replaceWith.apply(node, newNodeArray);\n                } \n            }\n        }\n    }\n    //It registers the binding of the node with the properties with which the dynamicNode depends. \n    bindNode(node, toBeRemoved, helperNode, options, nodeInfo, processLast, establishBindings, isTemplate,cache,type,idx,toBeInsMap,bId) {\n        let lyteConvertedSwitch = false;\n        if(type == \"l\"){\n            lyteConvertedSwitch = true;\n            type = \"a\";\n        }\n        let itemValue = options.itemValue;\n        let forIndex = options.itemIndex;\n        let forType = options.type;\n        let indexValue = options.indexValue;\n        let dynamicValue = nodeInfo.dynamicValue;\n        let helperFunc = nodeInfo.helperInfo;\n        let nodeValue, ownerElement = node.ownerElement;\n        let dynamicValuesArray = [];\n        let isDirectiveNode;\n        let directiveObj = this.getDirectiveObj();\n//        if(node.nodeType === 2 && _LC.isCustomElement(node.ownerElement,true) ) {\n//          node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue};\n//        }\n        if(node.nodeType === 2) {\n            node = {nodeName : node.nodeName, ownerElement : node.ownerElement, nodeType : 2, nodeValue : node.nodeValue, _attributeDetails : node._attributeDetails, _isDirectiveNode : nodeInfo._isDirectiveNode};\n            // if(directiveObj){\n            isDirectiveNode = _LC.directive.isDirectiveNode(node)\n            // }\n        }\n        //to get bindings in ssr components\n        \n        node._callee = this;\n        let isHelper = false;\n        if(helperFunc && Object.keys(helperFunc).length) {\n            isHelper = true;\n            if(helperFunc._t){\n                node._sq = true;\n            }\n            let attrName = node.nodeName;\n            nodeValue = node.helperValue = helperFunc;\n            let helperArgs = [];\n            if(helperFunc.name === \"action\"){\n                let actName = helperFunc.args[0];\n                helperFunc.args[0] = actName.startsWith(\"'\")? actName.replace(/'/g,''):  actName;\n                // if(forType) {\n                //     ownerElement._cx = options;\n                // } else if(helperNode) {\n                //     ownerElement._cx = helperNode._cx;\n                // }\n                actName = helperFunc.args.slice(0,1)[0];\n                let args = helperFunc.args.slice(1,helperFunc.args.length), isCustom = false;\n                let attrName = node.nodeName;\n                if(attrName.indexOf(\"-\") != -1){\n                    isCustom = true;\n                }\n                helperArgs = [ownerElement,attrName,isCustom,{name:actName,args:args}];\n                this.processHelper(this, {\"name\" : helperFunc.name, \"args\" : helperArgs}, node);\n                return;\n            } else{\n                if(helperFunc.name === \"method\") {\n                    helperArgs = helperFunc.args;\n                         \n                } else {  \n                    helperArgs = this.processArgs(this,{\"helperInfo\" : helperFunc} ,dynamicValuesArray,undefined,node,false,helperFunc._t ?undefined:cache);\n                }\n            }\n            if(helperFunc._t == \"sq\"){\n                nodeValue = this.processArray(this,{\"name\" : helperFunc.name, \"args\" : helperArgs},dynamicValuesArray,helperFunc.extra,event, node, undefined);\n            }\n            else{\n                nodeValue = this.processHelper(this, {\"name\" : helperFunc.name, \"args\" : helperArgs}, node);\n            }\n            if(helperFunc.name === \"unescape\"){\n//              let test = node.replaceWith.apply(node,nodeValue.childNodes);\n                let obj = {\n                    initialNode : node,\n                    dynamicNodeValue : nodeValue\n                };\n                node = {dynamicPositions : obj, \"_callee\" : node._callee, helperValue : node.helperValue};\n                nodeValue = undefined;\n                processLast.$push(node);\n            }\n        } else {\n            helperFunc = {};\n            node.syntaxValue = dynamicValue;\n            let dynamicValues = [];\n            nodeValue = _LC.get(this.component.data, dynamicValue, dynamicValues,cache);\n            dynamicValuesArray.$push(dynamicValues);\n        }\n        //if(node.nodeType === 2 && ( (typeof nodeValue !== \"string\" && (_LC.isCustomElement(node.ownerElement,true) || typeof nodeValue === \"boolean\") ) || _LC.isControlHelper(node.ownerElement) )) {\n        //\tlet bindedNode = node;\n            //node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue, _callee : this, syntaxValue : node.syntaxValue, helperValue : node.helperValue, _attributeDetails : node._attributeDetails};\n        if(node.nodeType == 2) {\n            let tagName = node.ownerElement.tagName;\n            if(tagName == \"INPUT\" || tagName == \"TEXTAREA\" || (tagName == \"DIV\" && node.ownerElement.hasAttribute(\"contenteditable\") )) {\n                var rA = node.ownerElement._rA = node.ownerElement._rA || [];\n                node.ownerElement._rA.$push(node);\n            }\n            if(!ownerElement._origTemplate) {\n                if(( ownerElement.hasAttribute(\"lyte-for\") || ownerElement.hasAttribute(\"lyte-if\") || ownerElement.hasAttribute(\"lyte-switch\") || ownerElement.hasAttribute(\"lyte-forin\") ) && ownerElement.tagName !== \"TEMPLATE\") {\n                    // if(Lyte._ie) {\n                    //     node.ownerElement = createElement(\"template\");\n                    //     node.ownerElement.setAttribute(\"is\", nodeInfo._depthTemp);\n                    // } else {\n                        node.ownerElement = nodeInfo._depthTemp.cloneNode(true);\n                    // }\n                    ownerElement._origTemplate = node.ownerElement;\n                }\n            } else {\n                node.ownerElement = ownerElement._origTemplate;\n            }\n        //\tnode.ownerElement._attributeDetails[node.nodeName].bindedNode = node;\n        //}\n        }\n        let actMultiProp; \n        if(helperFunc.name !== \"unbound\" && !_LC.unbound) {\n            let dynamicProp;\n            if(helperNode) {\n                dynamicProp = forType? helperNode._items[forIndex]._dynamicProperty : helperNode._dynamicProperty;\n            }\n            let obj, helperId;\n            for(let d=0;d<dynamicValuesArray.length;d++) {\n            \tlet dynamicValues = dynamicValuesArray[d];\n                \n            \tfor(let v=0;v<dynamicValues.length;v++) {\n                    //to get binding in ssr components\n                    var _nes = false;\n                    \n            \t\tlet actProperty = this.getProperty(dynamicValues[v]);\n            \t\tif(helperNode) {\n            \t\t\tlet ind = dynamicValues[v].search(/\\W/);\n            \t\t\tlet boundValue;\n            \t\t\tif(ind !== -1) {\n            \t\t\t\tboundValue = dynamicValues[v].substring(0, ind);\n            \t\t\t} else {\n            \t\t\t\tboundValue = dynamicValues[v];\n            \t\t\t}\n            \t\t\tif(boundValue !== itemValue && boundValue !== indexValue && (!options.node || !options.node._properties || !options.node._properties[boundValue])) {\n            \t\t\t\t//to bind for in ssr\n                            \n                            makeSet(actProperty, \"_helperNodes\");\n            \t\t\t\tactProperty._helperNodes.add(\n            \t\t\t\t\t\thelperNode\n            \t\t\t\t);\n            \t\t\t\tdynamicProp[dynamicValues[v]] ? dynamicProp[dynamicValues[v]].$push(node): (dynamicProp[dynamicValues[v]] = []).$push(node);\n            \t\t\t} \n            \t\t\telse {\n            \t\t\t\tnode._cx = options;\n//            \t\t\t\tif(!actProperty._dynamicNodes) {\n//            \t\t\t\t\tactProperty._dynamicNodes = [];\n//            \t\t\t\t\tdefProp(actProperty, '_dynamicNodes', {\n//            \t\t\t\t\t\tvalue: [],\n//            \t\t\t\t\t\tenumerable: false, \n//            \t\t\t\t\t\twritable: true, \n//            \t\t\t\t\t\tconfigurable: true\n//            \t\t\t\t\t});\n//            \t\t\t\t}\n            \t\t\t\tmakeArray(actProperty, \"_dynamicNodes\");\n                            if(actProperty._dynamicNodes.indexOf(node) == -1){\n            \t\t\t\t    actProperty._dynamicNodes.$push(node);\n                            }\n            \t\t\t\tif(boundValue !== indexValue) {\n            \t\t\t\t\tactMultiProp = actProperty;\n            \t\t\t\t}\n            \t\t\t}\n            \t\t} else {\n//            \t\t\tif(!actProperty._dynamicNodes) {\n//            \t\t\t\tdefProp(actProperty, '_dynamicNodes', {\n//            \t\t\t\t\tvalue : [], \n//            \t\t\t\t\tenumerable: false, \n//            \t\t\t\t\twritable: true,\n//            \t\t\t\t\tconfigurable: true\n//            \t\t\t\t});\n//            \t\t\t}\n            \t\t\tmakeArray(actProperty, \"_dynamicNodes\");\n                        if(actProperty._dynamicNodes.indexOf(node) == -1){\n            \t\t\t    actProperty._dynamicNodes.$push(node);\n                        }\n            \t\t}\n            \t\tif ((ownerElement && (ownerElement.hasAttribute(\"lyte-for\") || ownerElement.hasAttribute(\"lyte-if\") || ownerElement.hasAttribute(\"lyte-switch\") || ownerElement.hasAttribute(\"lyte-forin\") )) || (ownerElement && ownerElement.tagName === \"TEMPLATE\" && /^(for|forIn)$/.test(ownerElement.getAttribute(\"is\")) && !isHelper)) {\n            \t\t\tlet type= ownerElement.getAttribute(\"is\");\n            \t\t\tif( (type=== \"for\" && node.nodeName === \"items\") || (type===\"forIn\" && node.nodeName === \"object\")) {\n            \t\t\t\tif(!actProperty._forHelpers) {\n            \t\t\t\t\tmakeSet(actProperty, \"_forHelpers\");\n            \t\t\t\t}\n                            //to bind for in ssr\n                            \n            \t\t\t\tnode.ownerElement._actualBinding = actProperty;\n            \t\t\t\tactProperty._forHelpers.add(node.ownerElement);\n            \t\t\t}\n            \t\t}\n            \t\tif(establishBindings) {\n            \t\t\t_LC.establishSelectedBinding(actProperty, this.component.data, this );\n            \t\t}\n                    //to get ssr bindings \n                     \n            \t}\n                \n                if(dynamicValues.length > 1 || helperFunc._t) {\n            \t\tnode._multipleProperty = node._multipleProperty || [];\n            \t\tnode._multipleProperty.$push({\"dynamicProp\" : actMultiProp ? undefined : dynamicProp, \"actProp\" : this.getProperty(dynamicValues[0]), \"helperNode\" : helperNode, \"dynamicValues\" : dynamicValues, index:d});\n            \t}\n                \n            }\n        }\n        nodeValue = !typeof nodeValue === \"boolean\" && !typeof nodeValue === \"number\" ? (nodeValue? nodeValue : \"\"): nodeValue;\n        if(isDirectiveNode){\n            _LC.directive.setNodeArgs(node,nodeValue);\n        }\n        else if(node.nodeType === 2) {\n            let parentNode = node._parentNode? node._parentNode : node.ownerElement;\n            if(parentNode.tagName) {\n                let is = parentNode.getAttribute(\"is\");\n            }\n            let isCustomElement = _LC.isCustomElement(parentNode,true);\n            if(isCustomElement && !isDirectiveNode) {\n                 if(parentNode.set) {\n                    parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue);\n                 } else {\n                    parentNode._initProperties = parentNode._initProperties || {};\n                     parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] =nodeValue;\n                }\n            }\n            let origNodeValue = nodeValue;\n            // if(directiveNode){\n            //     node.ownerElement._transitionArgs = origNodeValue;\n            //     node.ownerElement.removeAttribute(node.nodeName);\n            //     node.nodeName = node.nodeName.slice(1,node.nodeName.length);\n            // }\n            //!== \"string\"\n            if(isCustomElement && typeof nodeValue !== \"string\" && !isTemplate) {\n                parentNode._attributes = parentNode._attributes || {};\n                parentNode._attributes[node.nodeName] = nodeValue;\n                if(parentNode.nodeName === \"TEMPLATE\" && isHelper) {\n                    if((parentNode.getAttribute(\"is\") === \"for\" && node.nodeName === \"items\") || (parentNode.getAttribute(\"is\") === \"forIn\" && node.nodeName === \"object\") && !_LC.unbound) {\n                        //node._actualBinding = {\"_forHelpers\" : new Set().add(parentNode)};\n                        node.ownerElement._actualBinding = {\n                            \"_forHelpers\" : new Set().add(parentNode),\n                            \"_createdBinding\" : true\n                        };\n                        if(nodeValue && typeof nodeValue !== \"number\"){\n                            makeSet(nodeValue, \"_bindings\");\n                            addBindings(nodeValue._bindings,node.ownerElement._actualBinding);\n                        }\n                    }\n                }\n                toBeRemoved.$push(node.nodeName);\n            }\n            else {\n                if(typeof nodeValue === \"boolean\") {\n                    parentNode._attributes = node.ownerElement._attributes || {};\n                    parentNode._attributes[node.nodeName] = nodeValue;\n                    if(!nodeValue) {\n//                      node.ownerElement.removeAttribute(node.nodeName);\n                        toBeRemoved.$push(node.nodeName);\n                    } else {\n                        parentNode.setAttribute(node.nodeName, \"\");\n                    }\n                } else {\n                    if(nodeValue && typeof nodeValue === \"object\"){\n                        var res;\n                        if(typeof Record != \"undefined\" && nodeValue instanceof Record){\n                            res = JSON.stringify(nodeValue.$.toJSON())\n                        }\n                        else{\n                            try{\n                                res = JSON.stringify(nodeValue)\n                            }\n                            catch(exp){\n                                //@Slicer.developmentStart\n                                ComponentError.error(\n                                    \"LC013\",\n                                    node.nodeName,\n                                    node.ownerElement.nodeName.toLocaleLowerCase(),\n                                    node.ownerElement.nodeName.toLocaleLowerCase()\n                                )\n                                //@Slicer.developmentEnd\n                            }\n                        }\n                    }\n                    else if(nodeValue== null || nodeValue == undefined){\n                        res = \"\"\n                    }\n                    else{\n                        res = nodeValue;\n                    }\n                    nodeValue = res;\n                    if(_LC.isControlHelper(node.ownerElement)) {\n                    \t parentNode._attributes = node.ownerElement._attributes || {};\n                         parentNode._attributes[node.nodeName] = nodeValue;\n                         toBeRemoved.$push(node.nodeName);\n                    } else {\n                         let locNodeVal = nodeValue === undefined ? \"\" : nodeValue;\n                         //if(node.nodeName === \"style\") {\n                         //   node.ownerElement.setAttribute(\"style\",locNodeVal);\n                         //} else {\n                         //   node.nodeValue = locNodeVal;\n                         //}\n                         node.ownerElement.setAttribute(node.nodeName, locNodeVal);\n                    }\n                    \n                }\n            }\n            if(parentNode.tagName === \"LYTE-YIELD\" /*parentNode.getAttribute(\"is\") === \"insertYield\"*/) {\n                parentNode.component.data[_LC.String.toCamelCase(node.nodeName)] = origNodeValue;\n            }\n            if (/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {\n                        if (node.nodeName === \"value\") {\n                            parentNode.value = (nodeValue === undefined) ? \"\" : nodeValue;\n                        } else if (node.nodeName === \"checked\") {\n                            parentNode.checked = nodeValue;\n                        }\n            }\n            if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {\n                toBeRemoved.$push(node.nodeName);\n            }\n        } \n        else {\n            node.nodeValue = nodeValue === undefined ? '' : nodeValue;\n        }\n\treturn node;\n    }\n\n    debounce(func, threshold) {\n        var timeout;\n        return function debounced() {\n            var obj = this, args = arguments;\n            function delayed() {\n            \tfunc.apply(obj, args);\n                timeout = null;\n            };\n            if (timeout){\n            \tclearTimeout(timeout);\n            }\n            timeout = setTimeout(delayed, threshold || 100);\n            //console.log(timeout,threshold);\n        };\n    }\n    getProperty(key) {\n        var arr = key.match(/([^[\\].]+|\\[\\])/g);\n        let property = this;\n        if(!property._properties[arr[0]]) {\n            property._properties[arr[0]] = {};\n        } \n        property = property._properties[arr[0]];\n        \n        defProp(property, '_path', {enumerable: false, value : arr[0]});\n        for(let i=1;i<arr.length;i++) {\n            if (arr[i].startsWith(\"'\") || arr[i].startsWith('\"')) {//added check\n\t\t\t    arr[i] = arr[i].substring(1, arr[i].length -1);\n\t\t    }\n            if(!property[arr[i]]) {\n                property[arr[i]] = {};\n                defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + \".\" + arr[i]});\n            }\n            property = property[arr[i]];\n        }\n        return property;\n    }\n    //updN\n    updateNode(node, updatePath) {\n        let compInstance = this.component;\n        var del = \"delete\";\n        let multiplePropNode = [];\n        let multipleProp;\n        let nodeHasHelperNode;\n        let isDirectiveNode;\n        if(node.nodeType == 2){\n            isDirectiveNode = _LC.directive.isDirectiveNode(node)\n        }\n        if(node._multipleProperty) {\n        \tfor(var i=0;i<node._multipleProperty.length;i++) {\n        \t\tif(node._multipleProperty[i]  && node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) > 0 ) {\n                    var dynStartIndex = node._sq ? node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) : 1;\n                    multiplePropNode[i] = false;\n                    multipleProp = node._multipleProperty[i];\n\t\t            let nodes;\n                    for(var j=0;j<dynStartIndex;j++){\n                        var pathName = node._sq ? multipleProp.dynamicValues[j] : multipleProp.actProp._path;\n                        if(multipleProp.dynamicProp){\n                            nodeHasHelperNode = true;\n                            if(!node._sq || multipleProp.dynamicProp[multipleProp.dynamicValues[j]]){\n                                multiplePropNode[i] = multipleProp;\n                                nodes = multipleProp.dynamicProp[pathName];\n                                if(nodes  && pathName.indexOf('.') != -1) {\n                                    let index = nodes.indexOf(node);\n                                    if(index != -1){\n                                        nodes.$splice(index, 1);\n                                    }\n                                }\n                                let helperNode = multipleProp.helperNode;\n                                if(nodes.length === 0) {\n                                    if(helperNode.getAttribute(\"is\") === \"if\" || helperNode.getAttribute(\"is\") === \"switch\" || (helperNode.hasAttribute(\"lc-id\") && helperNode.getAttribute(\"is\") === \"case\")) {\n                                        multipleProp.actProp._helperNodes[del](helperNode);\n                                        delete multipleProp.dynamicProp[multipleProp.actProp._path];\n                                    } else {\n                                        delete multipleProp.dynamicProp[multipleProp.actProp._path];\n                                        if(helperNode._items) {\n                                            let removeHelper = true;\n                                            for(let i=0;i<helperNode._items.length;i++) {\n                                                if(helperNode._items[i]._dynamicProperty && helperNode._items[i]._dynamicProperty[pathName]) {\n                                                    removeHelper = false;\n                                                    break;\n                                                }\n                                            }\n                                            if(removeHelper) {\n                                                multipleProp.actProp._helperNodes[del](helperNode);\n                                                //console.log('for helper is removed');\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if(!nodeHasHelperNode) {\n                            if(multiplePropNode[i] == false){\n                                multiplePropNode[i] = [\"dynamicNodes\"];\n                            }else{\n                                multiplePropNode[i].$push(\"dynamicNodes\");\n                            }\n                            var prop = this.getProperty(pathName);\n                            nodes = prop._dynamicNodes;\n                            if(nodes) {\n                                let index = nodes.indexOf(node);\n                                if(index != -1 && pathName!=updatePath && pathName.indexOf('.') != -1){\n                                    nodes.$splice(index, 1);\n                                    if(!nodes.length) {\n                                        delete prop._dynamicNodes;\n                                    }\n                                }\n                            }\n                        }else{\n                            nodeHasHelperNode=false; \n                        }\n                    }\n\t\t        }\n\t\t\t}\n\t\t}\n        if(!node.syntaxValue && !node.helperValue) {\n            return;\n        }\n        let contextSwitchInfo;\n        let isYieldContext;\n        if(node._cx || (node.nodeType === 2 && node.ownerElement._cx)) {\n            contextSwitchInfo = node._cx || node.ownerElement._cx;\n            var contextSwitchArray = [];\n            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo );\n        } else if(node.tagName === \"LYTE-YIELD\" && node._callee._cx) {\n        \tisYieldContext = true;\n        \tcontextSwitchInfo = node._callee._cx;\n        \tvar contextSwitchArray = [];\n        \t_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);\n        }\n        let nodeValue;\n        let dynamicValues = [];\n        var isHelper = false;\n        let helperRetVal;\n        if(node.helperValue){\n            isHelper = true;\n            nodeValue = node.helperValue;\n                    let helperFunc = nodeValue;\n                    if(helperFunc._t){\n                        node._sq = true;\n                    }\n                    let helperArgs = this.processArgs(this,{\"helperInfo\" : helperFunc} ,dynamicValues,undefined,node);    \n                    if(helperFunc._t == \"sq\"){\n                        helperRetVal = this.processArray(this,{\"name\" : helperFunc.name, \"args\" : helperArgs},dynamicValues,helperFunc.extra,undefined, node, undefined);\n                    }else{\n                        helperRetVal = this.processHelper(this,{\"name\" : helperFunc.name, \"args\" : helperArgs}, node);\n                    }\n                    nodeValue = helperRetVal;\n                    if(helperFunc.name === \"unescape\") {\n                        let oldDynamicPosition = node.dynamicPositions;\n                        let oldStartingNode = oldDynamicPosition.startingNode;\n                        let oldChldLen = oldDynamicPosition.length;\n                        while(oldChldLen > 1) {\n                            let next = oldStartingNode.nextSibling;\n                            oldStartingNode.remove();\n                            oldStartingNode = next;\n                            oldChldLen--;\n                        }\n                        let childLen = nodeValue.childNodes.length;\n                        if(!childLen) {\n                            nodeValue.appendChild(document.createTextNode(\"\"));\n                            childLen = 1;\n                        }\n                        let startingNode = nodeValue.childNodes[0];\n                        oldStartingNode.replaceWith.apply(oldStartingNode,nodeValue.childNodes);\n                        let obj = {startingNode : startingNode, length: childLen};\n                        node.dynamicPositions = obj;\n                        nodeValue = undefined;\n                    }\n        } else {\n            let boundValue = node.syntaxValue;\n            let path;\n            if(boundValue.indexOf('.') !== -1 || boundValue.indexOf('[') !== -1) {\n                path = boundValue;\n                boundValue = boundValue.substring(0,boundValue.indexOf('.'));\n            }\n            let value = path ? _LC.get(compInstance.data, path, dynamicValues) : compInstance.data[boundValue]; \n            nodeValue = !typeof value === \"boolean\" && !typeof value === \"number\" ? (value? value : \"\"): value;\n        }\n        let origNodeValue = nodeValue;\n\t\tif(!(dynamicValues[0] instanceof Array)) {\n        \tdynamicValues = [dynamicValues];\n\t\t}\n        \n        if(multiplePropNode) {\n        \tfor(var i=0;i<multiplePropNode.length;i++) {\n        \t\tif(multiplePropNode[i]) {\n                    var ind = node._sq ? node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) : 1;\n\t\t\t\t\tlet multipleProp = node._multipleProperty[i];\n                    let dynamicValIndex = node._multipleProperty[i].index;\n                    for(var j=0;j<ind;j++){\n                        if(node._sq && dynamicValues[dynamicValIndex][j].indexOf('.') == -1){\n                            continue;\n                        }\n                        let prop = this.getProperty(dynamicValues[dynamicValIndex][j]);\n                        let totalProp = this.getProperty(dynamicValues[dynamicValIndex][j].substring(0, dynamicValues[dynamicValIndex][j].indexOf('.')));\n                        var value = this.getData(dynamicValues[dynamicValIndex][j].substring(0, dynamicValues[dynamicValIndex][j].indexOf('.')));                            \n                        if(Array.isArray(multiplePropNode) && multiplePropNode[dynamicValIndex] && multiplePropNode[dynamicValIndex][j] && (multiplePropNode[dynamicValIndex][j] === \"dynamicNodes\")) {\n                            makeArray(prop, \"_dynamicNodes\");\n                            if(prop._dynamicNodes.indexOf(node) == -1){\n                                prop._dynamicNodes.$push(node);\n                            }\n                        } else {\n                            makeSet(prop, \"_helperNodes\");\n                            prop._helperNodes.add(\n                                    multipleProp.helperNode\n                            );\n                            let dynamicProp = multipleProp.dynamicProp;\n                            dynamicProp[prop._path] ? dynamicProp[prop._path].$push(node): (dynamicProp[prop._path] = []).$push(node);\n                        }\n                        if(value != undefined){\n                            _LC.establishBindings(totalProp, value);\n                        }\n                        if(j==0){\n                            if(node.ownerElement && (node.ownerElement.hasAttribute(\"lyte-for\") || node.ownerElement.hasAttribute(\"lyte-if\") || node.ownerElement.hasAttribute(\"lyte-switch\") || node.ownerElement.hasAttribute(\"lyte-forIn\")) || node.ownerElement && node.ownerElement.tagName === \"TEMPLATE\" && /^(for|forIn)$/.test(node.ownerElement.getAttribute(\"is\")) && !isHelper) {\n                                var type = node.ownerElement.getAttribute(\"is\");\n                                if (type === \"for\" && node.nodeName === \"items\" || type === \"forIn\" && node.nodeName === \"object\") {\n                                    if(multipleProp.actProp._forHelpers.has(node.ownerElement)){\n                                        multipleProp.actProp._forHelpers.delete(node.ownerElement);\n                                    }\n                                    if(!multipleProp.actProp._forHelpers.size) {\n                                        delete multipleProp.actProp._forHelpers;\n                                    }\n                                    if (!prop._forHelpers) {\n                                        makeSet(prop, \"_forHelpers\");\n                                    }\n                                    node.ownerElement._actualBinding = prop;\n                                    prop._forHelpers.add(node.ownerElement);\n                                }\n                            }\n                            node._multipleProperty[i].actProp = prop;\n                            node._multipleProperty[i].dynamicValues = dynamicValues[dynamicValIndex];\n                        }\n                    }\n\t        \t}\n\t        }\n\t\t}\n        if(isDirectiveNode){\n            _LC.directive.setNodeArgs(node,origNodeValue);\n        }\n        else if(node.nodeType === 2) {\n        \tlet parentNodes = [];\n            let pN = node._parentNode ? node._parentNode :  node.ownerElement;\n            if(pN.tagName === \"TEMPLATE\" && pN.getAttribute(\"is\") === \"component\" && node.nodeName !== \"component-name\" && node.nodeName !== \"component-class\") {\n            \tlet isKeepAlive = pN.hasAttribute(\"lyte-keep-alive\");\n            \tif(isKeepAlive) {\n            \t\tfor(var key in pN._renderedComponent) {\n            \t\t\tparentNodes.$push(pN._renderedComponent[key]);\n            \t\t}\n            \t} else {\n                    var compName = pN._currentComponent;\n                    if(compName && pN._renderedComponent[compName]){\n                        parentNodes.$push(pN._renderedComponent[compName]);\n                    }\n            \t}\n            }\n            parentNodes.$push(pN);\n            for(let i=0;i<parentNodes.length;i++) {\n            \tlet parentNode = parentNodes[i];\n            \tif(parentNode.set) {\n                    // if(parentNode._dynComp && node.nodeName == \"component-data\"){\n                    //     parentNode.set(nodeValue , undefined, undefined,true);    \n                    // }else{\n                        parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue, undefined, true);\n                    // }\n                    } else {\n                        parentNode._initProperties = parentNode._initProperties || {};\n                        parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] = nodeValue;\n                    }\n                    if(parentNode.tagName === \"LYTE-YIELD\" && parentNode.component.data && node.nodeName && parentNode.component.data[node.nodeName] !== nodeValue /*parentNode.getAttribute(\"is\") === \"insertYield\"*/) {\n                        _LC.set(parentNode.component.data, _LC.String.toCamelCase(node.nodeName), nodeValue,undefined , undefined, parentNode);\n                    }\n                    parentNode._attributes = parentNode._attributes || {};\n                    //!== \"string\"\n                    if(_LC.isCustomElement(parentNode,true) && typeof nodeValue !== \"string\") {\n                        if(node.ownerElement.nodeName === \"TEMPLATE\") {\n                            if(node.helperValue) {\n                            \tif((node.ownerElement.getAttribute(\"is\") ===  \"for\" && node.nodeName === \"items\") || (node.ownerElement.getAttribute(\"is\") ===  \"forIn\" && node.nodeName === \"object\")) {\n                            \t\tlet oldValue = node.ownerElement._attributes[node.nodeName];\n                            \t\tlet newValue = nodeValue;\n                            \t\t_LC.removeSelectedBindingDeep(node.ownerElement._actualBinding, oldValue);\n                            \t\tif(newValue  && typeof newValue !== \"number\") {\n                            \t\t\tmakeSet(newValue, \"_bindings\");\n                                        addBindings(newValue._bindings,node.ownerElement._actualBinding);\n                            \t\t\t_LC.establishBindings(node.ownerElement._actualBinding, newValue);\n                            \t\t}\n                            \t\tif(node.nodeName === \"object\") {\n                            \t\t\t_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);\n                            \t\t}\n                            \t\t//console.log(\"old Value \", oldValue, \" new Value \", newValue);\n                            \t}\n                            }else{\n                                if((node.ownerElement.getAttribute(\"is\") ===  \"for\" && node.nodeName === \"items\") || (node.ownerElement.getAttribute(\"is\") ===  \"forIn\" && node.nodeName === \"object\")) {\n                            \t\tlet oldValue = node.ownerElement._attributes[node.nodeName];\n                            \t\tif(node.nodeName === \"object\") {\n                            \t\t\t_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);\n                            \t\t}\n                            \t}\n                            }\n                            parentNode[\"__\"+node.nodeName] = true;\n                            if(node.nodeName != \"case\"){\n                                parentNode.removeAttribute(node.nodeName);\n                            }\n                        } else {\n                            //Needs revisiting\n                            //parentNode.removeAttribute(node.nodeName);\n                        }\n\n                    } else {\n                        if(typeof nodeValue === \"boolean\") {\n                            parentNode._attributes = parentNode._attributes || {};\n                            parentNode._attributes[node.nodeName] = nodeValue;\n                            if(!nodeValue) {\n                                parentNode.removeAttribute(node.nodeName);\n                            } else {\n                                parentNode.setAttribute(node.nodeName, \"\");\n                            }\n                        } else {\n                            if(nodeValue && typeof nodeValue === \"object\"){\n                                var res;\n                                if(typeof Record != \"undefined\" && nodeValue instanceof Record){\n                                    res = JSON.stringify(nodeValue.$.toJSON())\n                                }\n                                else{\n                                    try{\n                                        res = JSON.stringify(nodeValue)\n                                    }\n                                    catch(exp){\n                                        //@Slicer.developmentStart\n                                        ComponentError.error(\n                                            \"LC013\",\n                                            node.nodeName,\n                                            node.ownerElement.nodeName.toLocaleLowerCase(),\n                                            node.ownerElement.nodeName.toLocaleLowerCase()\n                                        )\n                                        //@Slicer.developmentEnd\n                                    }                                \n                                }\n                            }\n                            else if(nodeValue== null || nodeValue == undefined){\n                                res = \"\"\n                            }\n                            else{\n                                res = nodeValue\n                            }\n                            nodeValue = res;\n                            let locNodeVal = nodeValue === undefined ? \"\" : nodeValue;\n                            // if(node.nodeName === \"style\") {\n                            //     node.ownerElement.setAttribute(\"style\",locNodeVal);\n                            // } else {\n                            //     node.nodeValue = locNodeVal;\n                            // }\n\n                            // if(node instanceof Node) {\n                            //Check safari issue once\n                            let oE = node.ownerElement;\n                            if(oE.hasAttribute(node.nodeName)) {\n                                if(oE.tagName != \"INPUT\" || node.nodeName != \"value\" || !oE.validity.badInput) {\n                                    oE.setAttribute(node.nodeName, locNodeVal);\n                                }\n                            } else {\n                                node.nodeValue = locNodeVal;                              \n                            }\n                        }\n                    }\n                    parentNode._attributes[node.nodeName] = nodeValue;\n                    if(/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {\n                        if(node.nodeName === \"value\") {\n                             let val = (nodeValue === undefined) ? \"\" : nodeValue;\n                             if(parentNode.value !== val) {\n                                parentNode.value = val;\n                             } \n                        } else if(node.nodeName === \"checked\") {\n                            parentNode.checked = nodeValue;\n                        }\n                    }\n                    if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {\n                        parentNode.removeAttribute(node.nodeName);\n                    }\n                    let isStopped = parentNode._isStopped;\n                    let result;\n                    switch(parentNode.getAttribute(\"is\")) {\n                        case \"for\" :\n                            this.updateForHelper(parentNode, {\"type\" : \"update\"});\n                            break;\n                        case \"if\" : \n                            result = this.updateSwitchHelper(\"e\",parentNode, undefined, true, true);\n                            break;\n                        case \"case\" : \n                            result = this.updateSwitchHelper(\"s\",parentNode._parentSwitch, undefined, true, true,undefined,parentNode);\n                            break;\n                        case \"forIn\" : \n                            this.updateForInHelper(parentNode , {\"type\" : \"update\"});\n                            break;\n                        case \"switch\" :\n                            this.updateSwitchHelper(\"s\",parentNode, undefined, true, true);\n                            break;\n                        case \"component\" : \n                            if(node.nodeName === \"component-name\" || node.nodeName === \"component-class\") {\n                                this.updateDynamicComponent(parentNode, \"update\");    \n                            }\n                            break;\n                        default:            \n                    }\n//                 \tlet handleBreakOptions;\n//                 \tif(isStopped &&  isStopped !== result) {\n//                 \t\t//console.log(\"new value is stopped\");\n//                 \t\tif(!result) {\n//                 \t\t\t//console.log(\"new value is not stopped\");\n//                 \t\t\tif(isStopped === \"break\") {\n//                 \t\t\t\thandleBreakOptions = \"SM\"\n//                 \t\t\t} else {\n//                 \t\t\t\thandleBreakOptions = \"SS\"\n//                 \t\t\t}\n//                 \t\t} else if(result === \"break\") {\n//                 \t\t\thandleBreakOptions = \"MS\";\n//                 \t\t\t//console.log(\"old value is continue and new value is break\");\n//                 \t\t} else {\n//                 \t\t\thandleBreakOptions = \"SM\";\n//                 \t\t\t//console.log(\"old value is break and new value is continue\");\n//                 \t\t}\n//                 \t} else if(result === \"break\") {\n//                 \t\thandleBreakOptions = \"MS\";\n//                 \t\t//console.log(\"old value not stopped and new value is break\");\n// //                \t\tthis.handleBreak(parentNode._cx, \"break\");\n//                 \t} else if(result === \"continue\") {\n//                 \t\thandleBreakOptions = \"SS\";\n//                 \t\t//console.log(\"old value not stopped and new value is continue\");\n// //                \t\tthis.handleBreak1(parentNode._cx , \"continue\");\n//                 \t}\n//                 \tif(handleBreakOptions) {\n//                 \t\tthis.handleBreak(parentNode._cx, handleBreakOptions);\n//                 \t}\n            }\n        }\n        else {\n            node.nodeValue = nodeValue === undefined ? '' : nodeValue;\n        }\n        if(contextSwitchInfo) {\n            _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);\n        }\n    }\n\n    // handleBreak(contextSwitchInfo, options) {\n    // \tif(contextSwitchInfo) {\n    // \t\tlet forTemplate = contextSwitchInfo.node;\n    // \t\tlet breakIndex = contextSwitchInfo.itemIndex;\n    // \t\tlet itemValue = forTemplate.getAttribute(\"item\");\n    // \t\tlet forContent = contextSwitchInfo.node._forContent;\n    // \t\tlet endIndex = options[0] === \"M\" ? forContent.length : breakIndex + 1;\n    // \t\tfor(let j=breakIndex;j<endIndex;j++) {\n    // \t\t\tlet currentForContent = forContent[j];\n    // \t\t\tfor(let i=0;i<currentForContent.length;i++) {\n    // \t\t\t\tcurrentForContent[i].remove();\n    // \t\t\t\tif(currentForContent[i]._forContent || currentForContent[i]._caseContent) {\n    // \t\t\t\t\tthis.removeHelpers(currentForContent[i]);\n    // \t\t\t\t}\n    // \t\t\t}\t\n    // \t\t\t\tforContent[j] = [];\n    // \t\t\t\t_LC.removeSelectedBindingDeep(forTemplate._items[j].itemProperty, forTemplate._attributes.items[j]);\n    // \t\t\t\tforTemplate._helpers[j] = [];\n    // \t\t\t\tforTemplate._items[j] = {\"_dynamicProperty\" : {}, \"itemProperty\" : {}, \"indexProperty\": {}};\n    // \t\t}\n    // \t\tlet length = forTemplate._attributes.items.length;\n    // \t\tif(options[1] === \"M\") {\n    // \t\t\tthis.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : length - breakIndex, \"type\" : \"replace\"}, undefined, {});\n    // \t\t} else {\n    // \t\t\tthis.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : 1, \"type\" : \"replace\"}, undefined, {});\n    // \t\t}\n    // \t}\n    // }\n\n    createCustomEvent(eventName, parentNode, actObj){\n        const customEvent = new CustomEvent(eventName);\n        parentNode._actions[eventName] = customEvent;\n        parentNode._actions[eventName].processAction = actObj;\n    }\n\n    isEmptyString(str){\n        return (!(typeof str === \"string\") || str === \"\" );\n    }\n\n    processArgs(scope,dynN,dynamicValues,event, node, newCompile,cache,parentSq){\n        let args = dynN.newHelperInfo && newCompile ? dynN.newHelperInfo.args : dynN.helperInfo.args;\n        if(dynN.helperInfo && dynN.helperInfo._t == \"sq\")   {\n            parentSq = true;\n        }\n        dynamicValues = dynamicValues || [];\n        args = (Array.isArray(args)) ? Array.from(args) : args;\n        for(let i=0; i<args.length; i++){\n            if(args[i] && args[i].type){\n                if(args[i].type == \"sq\"){\n                    this.internalArray(scope, args, i, dynamicValues, event, node, newCompile,parentSq);\n                }else{\n                    this.internalHelpers(scope, args, i, dynamicValues, event, node, newCompile,cache,parentSq);\n                }\n            } else {\n                if(!this.isEmptyString(args[i])) {\n                    if(args[i].startsWith(\"'\") && args[i].endsWith(\"'\")){\n                        args[i] = args[i].substr(1,args[i].length-2);       \n                    } else {\n                        args[i] = args[i].trim();\n                        if(args[i] === \"event\" && event) {\n                            args[i] = event;\n                        } else if(args[i] === \"this\" && node) {\n                            args[i] = node.nodeType === 2 ? node.ownerElement : node;\n                        } else {\n                            let dynamicVals = [];\n                            args[i] = _LC.get(scope.component.data,args[i],dynamicVals,cache);\n                            if(!parentSq || dynamicValues.length == 0){\n                                dynamicValues.$push(dynamicVals);\n                            }else{\n                                if(dynamicVals.length > 1){\n                                    for(let s=0; s<dynamicVals.length; s++){\n                                        dynamicValues[dynamicValues.length-1].$push(dynamicVals[s]);\n                                    }\n                                }else{\n                                    dynamicValues[dynamicValues.length-1].$push(dynamicVals[0]);\n                                }\n                            }\n                        }\n                    }\n                } else if(newCompile) {\n                    if(args[i] instanceof Array) {\n                        args[i] = _LC.getDD(scope.component.data, args[i]);\n                    }\n                }\n            }\n            \n        }\n        return args;\n    }\n\n    internalHelpers(scope,args,i,dynamicValues, event, node, newCompile,cache,parentSq){\n        let helperFunc = args[i].value;\n        var helperVal =  this.processHelper(scope,{\"name\" : helperFunc.name, \"args\" : this.processArgs(scope,{\"helperInfo\" : helperFunc},dynamicValues, event, node, newCompile,cache,parentSq)});\n        args[i] = helperVal;\n    }\n    internalArray(scope, args, i, dynamicValues, event, node, newCompile,parentSq) {\n        var helperFunc = args[i].value;\n        if(!parentSq){\n            dynamicValues.$push([]);\n        }\n        var helperVal =  this.processArray(this,{\"name\" : helperFunc.name, \"args\" : this.processArgs(scope,{\"helperInfo\" : helperFunc},dynamicValues, event, node, newCompile,undefined,true)},dynamicValues, helperFunc.extra ? Array.from(helperFunc.extra):undefined,event, node, newCompile);\n        args[i] = helperVal;\n    }\n    processArray(scope,helperFunc,dynamicValues,extra,event, node, newCompile){\n        var arrVal;\n        dynamicValues = dynamicValues || [];\n        var dynVal = [];\n        var arr = helperFunc.name;\n        var len = helperFunc.args.length;\n        var str=\"\";\n        for(var i=0; i<len; i++){\n            str = str + \"['\"+ helperFunc.args[i] + \"']\"\n        }\n        var fullData = arr+str;\n        if(extra && extra.length){\n            for(var i=0; i<extra.length; i++){\n                if(typeof extra[i] == \"string\"){\n                    fullData += extra[i];\n                }else{\n                    if (extra[i] && extra[i].type) {\n                        if (extra[i].type == \"sq\") {\n                            this.internalArray(scope, extra, i, dynamicValues, event, node, newCompile, true);\n                        } else {\n                            this.internalHelpers(scope, extra, i, dynamicValues, event, node, newCompile, undefined, true);\n                        }\n                        fullData += extra[i];\n                    } \n                }\n            }\n        }\n        if(!helperFunc.name.startsWith('.')){\n            arrVal = _LC.get(scope.component.data, fullData, dynVal);\n            if(dynamicValues.length == 0){\n                dynamicValues.$push(dynVal);\n            }else{\n                dynamicValues[dynamicValues.length-1].$unshift(dynVal[0]);\n            }\n            return arrVal;\n        }else{\n            return fullData;\n        }\n        \n    }\n    processHelper(scope,helperFunc, node){\n        let args = [];\n        let helperName = helperFunc.name;\n        if(!scope.$component.registeredHelpers[helperName]){\n            //@Slicer.developmentStart\n            let app = _LC.getNearestParentApp(this.component);\n            ComponentError.error(app, \"LC003\" , helperFunc.name);\n            //@Slicer.developmentEnd\n            return;\n\t    }\n        switch(helperFunc.name){\n            case \"method\" : \n                args.$push(this, node);\n                break;\n            case \"lbind\" :\n                args.$push(this, node.ownerElement);\n                break;\n            case \"lyteViewPort\" :\n                if(node && node.ownerElement){\n                    args.$push(node.ownerElement);\n                    if(!helperFunc.args.length){\n                        args.$push(false);\n                    }\n                }else{\n                    return true;\n                }\n        }\n        return scope.$component.registeredHelpers[helperFunc.name].apply(scope.component,args.$concat(helperFunc.args));\n        // return _LyteComponent.registeredHelpers[helperFunc.name].apply(this,args.$concat(helperFunc.args));\n    }\n\n    // getActionProperty(prop){\n    //     let hostProp = this._properties;\n    //     let value = (hostProp)?hostProp[prop].value:undefined;\n    //     return value;\n    // }\n\n    // hasInternalBindings(content){\n    //     return content.match(/[(]{1}[^)]+[)]{1}/);\n    // }\n\n    // getArgValues(argNames, properties) {\n    //     let argValueArray = [];\n    //     for(let i=0;i<argNames.length;i++) {\n    //         argValueArray.$push(properties[argNames[i]].value);\n    //     }\n    //     return argValueArray;\n    // }\n\n    createEventListeners(node,actionType,actObj){\n        let self = this;\n        if(!node._callee && node !== this) {\n            node._callee = this;\n        }\n        if(globalDOMEvents.indexOf(actionType) == -1){\n            let infoAttr = actionType.substr(2);\n            let infoAttrVal = node.getAttribute(infoAttr);\n            // var evntListener = function(event) {\n        \t// \tvar toRemove;\n            //     if(!window.event) {\n            //         window.event = event;\n            //         toRemove = true;\n            //     }\n            //     _LC.throwAction.call(self,self,actionType.substr(2),actObj, undefined, undefined, node, event);\n            //     if(toRemove) {\n            //         window.event = undefined;\n            //     }\n            // };\n            if ((ComponentRegistry._registeredCommonClass[node.localName] && !node.component) || (node.tagName === \"TEMPLATE\" && node.getAttribute(\"is\") === \"component\")) {\n            \tnode._toRegEvnts = node._toRegEvnts || {};\n            \tnode._toRegEvnts[actionType.substr(2)] = {\"listener\" : globalEventHandler , \"attrVal\" : this.tagName.toLowerCase()+\" => \"+actObj.name};\n            } else {\n            \tnode.setAttribute(infoAttr, this.tagName.toLowerCase()+\" => \"+actObj.name);\n            \t//Event is not in capture phase because, in capture phase, multiple event listeners in hierarchy are called from parent to child (since registration is done in that order)\n            \tnode.addEventListener(actionType.substr(2), globalEventHandler);\n            }\n            if(node.hasAttribute(actionType)){\n            \tnode[actionType] = undefined;\n            }\n            node.removeAttribute(actionType);\n        }\n    }\n\n    registerParentYield(yieldName){\n        let locYield,parentYield = this._callee._yields[yieldName];\n        if(parentYield){\n            // if(Lyte._ie) {\n            //     locYield = document.createElement(\"div\");\n            //     locYield.innerHTML = parentYield.outerHTML;\n            //     locYield = locYield.childNodes[0];\n            //     this.constructor.splitTextNodes(locYield);\n            // } else {\n                locYield = parentYield.cloneNode(true);\n            // }\n            Object.keys(parentYield).forEach(function(item) {  //eslint-disable-line no-loop-func\n                locYield[item] = parentYield[item];\n            });\n            this._yields[yieldName] = locYield;\n        }\n    }\n\n    getYieldName(node){\n        if(node.getAttribute(\"yield-name\")){\n            return node.getAttribute(\"yield-name\");\n        }else if(node._attributes && node._attributes[\"yield-name\"]){\n            return node._attributes[\"yield-name\"];\n        }\n    }\n\n    registerYields() {\n        this._yields = {};\n        let yields = this.querySelectorAll('template[is=registerYield],template[is=yield]');\n        let lazyYields = [];\n        for(let i=0;i<yields.length;i++) {\n            while(yields[i].hasChildNodes()) {\n                yields[i].content.appendChild(yields[i].childNodes[0]);\n            }\n            let yieldName = this.getYieldName(yields[i]);\n            if(yields[i].hasAttribute(\"from-parent\") && this._callee) {\n                if(this._callee._yields){\n                    this.registerParentYield(yieldName);\n                }\n                else{\n                    lazyYields.push(yields[i]);\n                }\n            } else {\n                this._yields[yieldName] = yields[i];\n            }\n        }\n        if(lazyYields.length && this._callee){\n            var self = this;\n            this.lazyYield = function(){\n                if(self._callee){\n                    for(let j=0;j<lazyYields.length;j++){\n                        let lYield = lazyYields[j];\n                        self.registerParentYield(this.getYieldName(lYield));\n                    }\n                    self._callee.removeEventListener(\"onReady\", self.lazyYield);\n                    delete self.lazyYield;\n                }\n            };\n            this._callee.addEventListener(\"onReady\", this.lazyYield);\n        }\n    }\n\n    connectedCallback() {\n        this._connectedCallback();\n    }\n    _connectedCallback(){\n        if(this.hasAttribute(\"lyte-rendered\") || this._ccCalled || !this._registryClass || !this.$registry.registeredComponents[this.localName]) {\n            return;\n        }\n        let fastRenderProp = this._fR;\n        if(!fastRenderProp) {\n            this._callee = this._callee || this.getCallee(this.parentNode);\n        }\n        this.__h = {};\n        this.__counter = 0;\n        this.__dc = {};\n        if(fastRenderProp) {\n            let methods = fastRenderProp._methods;\n            if(methods) {\n                this.setMethods(methods);\n            }\n            _LC.ccDelay.$push(this);\n            this._ccCalled = true;\n        } else {\n            this.actualConnectedCallback();\n        }\n        let viewObj = this.getViewObj()\n        if(viewObj){\n            viewObj.connectedCallback(this)\n        }\n    }\n    cmpBind(fastRenderProp){\n        let compData = this.component.data;\n        if(!_LC.unbound && !fastRenderProp && !compData.lyteFastRender) {\n            establishObserverBindings.call(this,this.component.constructor._observers,undefined,undefined,undefined,Lyte);\n            establishWatchScope.call(this,this.constructor._deepWatchProperties)\n            //this.establishObserverBindings();\n            makeSet(compData, \"_bindings\");\n            addBindings(compData._bindings,this._properties);\n            _LC.establishBindings(this._properties, compData);\n        }\n    }\n    actualConnectedCallback(){\n        let compData = this.component.data;\n        if(this.component.constructor.dc){\n            this.dc = this.component.constructor.dc.p;\n        }\n        let directiveObj = this.getDirectiveObj();\n        directiveObj && directiveObj.instanciatePromises(this)\n        let fastRenderProp = this._fR;\n        if(fastRenderProp) {\n            this._callee = this._callee || this.getCallee(this.parentNode);\n        }\n        for(let key in this._toRegEvnts) {\n        \tthis.addEventListener(key, this._toRegEvnts[key].listener);\n        \tif(this.hasAttribute(key)) {\n        \t\tthis.setAttribute(key, this.getAttribute(key) + \" ; \"+ this._toRegEvnts[key].attrVal);\n        \t} else {\n        \t\tthis.setAttribute(key, this._toRegEvnts[key].attrVal);\n        \t}\n        }\n        this._toRegEvnts = {};\n        let initialUnbound = _LC.unbound;\n        let ssrBind  = this._ssrData || this.getAttribute(\"ssrbindservernode\");\n        if(ssrBind && !this.component.data.lyteUnbound){\n            this.bindServerData();\n            this.removeAttribute(\"ssrbindservernode\");\n        }\n        let content =  this.afterConnected(fastRenderProp,ssrBind);\n        !ssrBind && this.cmpBind(fastRenderProp);\n\n        _LC.unbound = initialUnbound;\n        var tagName = this.tagName;\n        let dependentPromises = [];\n        directiveObj && directiveObj.getDependentPromises(this,dependentPromises,this._dependentPromise);\n        if(typeof content === \"string\") {\n            if(content) {\n                if(_LC.frSpecial) {\n                    let temp = document.createElement(\"template\");\n                    temp.innerHTML = content;\n                    this.innerHTML = \"\";\n                    this.appendChild(temp.content);\n                } else {\n                    this.innerHTML = content;\n                }\n            }\n            _LC.processAction(this);\n        }\n        else{\n            let viewObj = this.getViewObj()\n            if(viewObj){\n                viewObj.actualConnectedCallback(this,content)\n            }\n            let shadowObj = this.getShadowObj();\n            let shadowDeep,shadowMode,shadowParent;\n            var shadowSupported = _LC.directive.getTransitionArg(this,\"shadow-supported\")\n            if(shadowObj){\n                _LC.directive.setAttrFromRender(this,this._tagDirectives);\n                // if(shadowSupported){\n                    if(this.$registry._defaultDirectives && this.$registry._defaultDirectives.indexOf(\"shadow\") != -1){\n                        var shadowVal = _LC.directive.getTransitionArg(this,\"shadow\")\n                        shadowMode = shadowVal;\n                        this.component.data.lyteShadow = shadowVal; //af??\n                    }\n                    shadowParent = this;\n                    if(this.parentNode.shadowRoot){\n                        Lyte.warn(this.tagName +\" should not be the direct child of a shadow component \"+this.parentNode.tagName)\n                    }\n                    let rtObj = shadowObj.getShadowParent(this,directiveObj);\n                    shadowParent = rtObj.shadowParent;\n                    shadowDeep = rtObj.shadowDeep;\n                // }\n            }\n            if(shadowObj && shadowMode == true){\n                if(shadowSupported){\n                    shadowObj.applyShadow(this,content,shadowParent,dependentPromises);\n                }\n                //@Slicer.developmentStart\n                else{\n                    ComponentError.error(\"LC017\",this.localName)\n                }\n                //@Slicer.developmentEnd\n            }\n            else if(shadowObj && shadowParent){\n                if(shadowMode == undefined && shadowDeep == true && this.constructor._observedAttributes.indexOf(\"lyteShadow\")!=-1){\n                    shadowObj.applyShadow(this,content,shadowParent,dependentPromises);\n                }\n                else{\n                    this._hasShadowParent=true;\n                    this._sw = [];\n                    this.component.data.lyteShadow = false;//need to check\n                    shadowObj.attachStyleToParentShadow(this, shadowParent, content);\n                    if(directiveObj){\n                        directiveObj.appendInDom(this,content,true,true,dependentPromises);\n                    }else{\n                        _LC.appendInDom(this,content);\n                    }\n                }\n            }\n            else{\n                this.component.data.lyteShadow = false;//need to check\n                if(this._compClass._style && Lyte.$.assetsDiv._duplicateStyle.indexOf(tagName) == -1){\n                    var style = _LCSD.stringToStyle(this._compClass._style);\n                    style.setAttribute(\"lyte-id\",\"global-style-\"+tagName);\n                    if(this._ssrBind){\n                        style.setAttribute(\"from-ssrComponent\",tagName);\n                    }\n                    Lyte.$.assetsDiv.appendChild(style);\n                    Lyte.$.assetsDiv._duplicateStyle.$push(tagName);\n                }\n                if(Lyte.$.shadowDiv._compList.indexOf(tagName) == -1){\n                    Lyte.$.shadowDiv._compList.$push(tagName);\n                }\n                if(directiveObj){\n                    directiveObj.appendInDom(this,content,true,true,dependentPromises);\n                }else{\n                    _LC.appendInDom(this,content);\n                }\n            }\n        }\n        if(directiveObj){\n            this._transitionAppend = []\n        }\n        let dataDef = this.component.__data;\n        let attributes = this.attributes;\n        this.__lyteIgnore = true;\n        for(let i=attributes.length-1;i>-1;i--) {\n            let camelCase = _LC.String.toCamelCase(attributes[i].nodeName);\n            if(dataDef[camelCase] && dataDef[camelCase].hideAttr) {\n            this.removeAttribute(attributes[i].nodeName);\n            }\n        }\n        this.__lyteIgnore = false;\n\t    if( this._callee && this._callee.serverCall ){\n            this.serverCall = true;\n        }\n        //to bind in ssr\n        if( this.serverCall && !this.hasAttribute( \"server-rendered\") ){\n            this.setAttribute( \"server-rendered\", \"\");\n            var newData = _LC.sendtoclient.call(this,this,true,this.component.__data);\n            this.setAttribute(\"component-data\", JSON.stringify( newData ) );\n        }\n        if( !this.hasAttribute( \"server-rendered\" ) )\n        {        \n\t        this.setAttribute(\"lyte-rendered\", \"\");\n        }\n        \n        if(!fastRenderProp && !Lyte._ignoreOnReady) {\n            this.dispatchEvent(new CustomEvent(\"onReady\"));\n        }\n        \n        let _config_flag;\n        if( this.component._ssr && this.component._ssr.config ){\n            if( this.component._ssr.config.clientLifeCycleHooks != undefined ){\n                _config_flag = this.component._ssr.config.clientLifeCycleHooks == true || ( typeof this.component._ssr.config.clientLifeCycleHooks == 'object' ? this.component._ssr.config.clientLifeCycleHooks.includes('didConnect') : false );\n            }\n        }\n        let _overrides = this.component._ssr ? this.component._ssr.overrides : undefined;\n        if( !this.hasAttribute( \"server-rendered\" ) || this.serverCall ||  _config_flag ){\n            if( _overrides && _overrides.didConnect && this.serverCall ){\n                _overrides.didConnect.apply( this.component );\n            }else{        \n                this.callback(\"didConnect\");\n            }\n            this.onCallBack(\"didConnect\");\n        }\n    \n        if( this.serverCall == undefined ){\n            this.callback( \"didRender\" );\n        }            \n        if(fastRenderProp) {\n            this.removeAttribute(\"_lyteprop\");\n        }\n    }\n    onCallBack(name){\n        let callbacks = this.component.constructor._callBacks[name];\n        if(callbacks){\n            for(let i=0;i<callbacks.length;i++){\n                try{\n                    callbacks[i].value.call(this.component);    \n                } catch(e) {\n                    //@Slicer.developmentStart\n                    ComponentError.error(e);\n                    //@Slicer.developmentEnd\n                }\n                \n            }\n        }\n    }\n    callback(name){\n        var func = this.component[name];\n        var args;\n        if(func){\n            if(arguments.length > 1) {\n                args = Array.from(arguments);\n                args.$splice(0,1)\n            }\n            try{\n                func.apply(this.component, args || []);    \n            } catch(e) {\n                //@Slicer.developmentStart\n                ComponentError.error(e);\n                //@Slicer.developmentEnd\n            }\n        }\n    }\n    establishObserverBindings() {\n        let observers = this.component.constructor._observers;\n        for(let i=0;i<observers.length;i++) {\n            let props = observers[i].properties;\n            for(let j=0;j<props.length;j++) {\n                let actProp;\n                let isArrayObserver = false;\n                if(props[j].indexOf('.[]') !== -1) {\n                    isArrayObserver = true;\n                    actProp = this.getProperty(props[j].substring(0, props[j].indexOf('.[]')));\n                } else {\n                    actProp = this.getProperty(props[j]);\n                }\n                makeSet(actProp, \"_observers\");\n                actProp._observers.add({callee : this, observer: observers[i], isArrayObserver : isArrayObserver});\n            }\n        }\n    }\n    removeBindings(properties, actualData) {\n        var del = \"delete\";\n        for(let i in properties) {\n            let actData = actualData[i];\n            if(actData && actData._bindings) {\n                actData._bindings[del](properties[i]);\n                //Error while trying to delete _bindings from actData when actData is of type Array\n                /*  if(!actData._bindings.size) {\n                    delete actData._bindings;\n                } */\n            }\n            if(typeof properties[i] === \"object\" && actData) {\n                this.removeBindings(properties[i], actData);\n            }\n        }\n    }\n    actualDisconnected() {\n        var self = this;\n        if(!self.component) {\n            return;\n        }\n        self._cx = null;\n        self._callee = null;\n        self.component.$node = null;\n        self.component.__data = null;\n        self.component.data.__component__ = null;\n        self.component.data = null;\n        self.component = null;\n        self.__dc = self.__dc || {};\n        self.__h =  self.__h || {};\n        for (key in self.__dc) {\n            var helper = self.__dc[key];\n            //helper.remove();\n            if(helper.hasAttribute(\"lyte-keep-alive\")) {\n                var objKeys = Object.keys(helper._renderedComponent);\n                for(var j=0;j<objKeys.length;j++) {\n                    let key = objKeys[j];\n                    if(key !== helper._currentComponent) {\n                        // Will remove from hDiv.\n                        helper._renderedComponent[key].remove();\n                    }\n                }\n            }\n        }\n        for (key in self.__h) {\n            self.__h[key].remove();\n        }\n        self.__h = {};\n        self.__dc = {};\n        let yields = self._yields;\n        for(var key in yields) {\n            yields[key]._callee = null;\n        }\n        self = null;\n    }\n    disconnectedCallback() {\n        this._disconnectedCallback();\n    }\n    _disconnectedCallback(){\n        if(_LC.ignoreDisconnect || !this.component) {\n\t       return;\n        }\n        let shadowObj = this.getShadowObj();\n        let directiveObj = this.getDirectiveObj();\n        shadowObj && shadowObj.destroyRef(this);\n        let viewObj = this.getViewObj()\n        if(viewObj){\n            viewObj.disconnectedCallback(this)\n        }\n        this._destroyed = true;\n        if(this.__toRemoveLazy){\n            for(var __key in this.__toRemoveLazy){\n                var __arr = this.__toRemoveLazy[__key];\n                __arr.forEach(function(id){\n                    Lyte.$.toRemoveFromRequiredServices(id);\n                });\n            }\n            delete this.__toRemoveLazy;\n        }\n        this.component._bindings = null;\n        var scpObj = this.__scpObj;\n        if(scpObj){\n            for(var key in scpObj){\n                var propData = this.component.data[key], id = scpObj[key], idArr = id.split(\"_\");\n                if(propData){\n                    removeNestScp(this.component.data[key], idArr[0], idArr[1], undefined, this);\n                }\n            }\n        }\n        if(!this._fR) {\n            _LC.removeSelectedBindingDeep(this._properties, this.component.data, true);\n        }\n        if(directiveObj){\n            directiveObj.destroyHelperPromises([this.__dc,this.__h]);\n        }\n        var h = this.__h;\n        for (key in h) {\n            if(h[key]._actualBinding){\n                this.removeHelpers(h[key]);\n            }\n        }\n        h = {};\n        for(key in this._properties) {\n            this._properties[key] = {};\n        }\n        this.callback('didDestroy');\n        this.onCallBack('didDestroy');\n        this.component.constructor.activeInstances--;\n        if(!_LC.dcc) {\n            _LC.dcc = [];\n            requestAnimationFrame(function() {\n                requestAnimationFrame(function() {\n                    if(viewObj){\n                        viewObj.actualDisconnected(this)\n                    }\n                    try{\n                        for(var i=0,item;item=_LC.dcc[i];i++) {\n                            item.actualDisconnected();\n                        }\n                    }\n                    catch(e) {\n\n                    }\n                    _LC.dcc = undefined;\n                });\n            });\n        }\n        _LC.dcc.$push(this);\n        directiveObj && directiveObj.destroyPromises(this);\n        if(this.lazyYield){\n            this.removeEventListener(\"onReady\", this.registerParentYield);\n        }   \n        // var self = this;\n        // setTimeout(function() {\n        //     self.actualDisconnected();\n        // },0);\n        // this.constructor.activeInstances--;\n    }\n}\ncustomElementPrototype._V3InsApi = [\"cmpBind\",\"component\",\"actualConstructor\",\"_connectedCallback\",\"actualConnectedCallback\", \"getMethods\",\"hasAction\", \"setActions\", \"setMethods\", \"getCallee\", \"afterConnected\", \"renderComponent\", \"renderFast\", \"formatValue\", \"renderNodes\", \"executeBlockHelpers\", \"updateBlockHelpers\", \"_attributeChangedCallback\" , \"removeHelpersSpecificIndex\", \"removeHelpers\", \"updateYield\", \"updateDynamicComponent\",\"updateForHelper\", \"updateForInHelper\", \"updateSwitchHelper\", \"callObservers\",\"bindNode\",\"debounce\", \"getProperty\", \"updateNode\", \"handleBreak\", \"createCustomEvent\", \"isEmptyString\", \"processArgs\", \"internalHelpers\", \"processHelper\", \"getActionProperty\", \"hasInternalBindings\", \"getArgValues\", \"createEventListeners\", \"registerParentYield\", \"registerYields\", \"onCallBack\", \"callback\", \"establishObserverBindings\", \"removeBindings\", \"actualDisconnected\" ,\"_disconnectedCallback\",\"throwAction\",\"get\",\"set\",\"initializeMethod\"];\ncustomElementPrototype._V3StaticApi = [\"_observers\",\"_callBacks\",\"_properties\",\"activeInstances\",\"_depthTemp\",\"_bindsIds\",\"_ssr\",\"_config\",\"_mixins\",\"_serviceToBeUsed\",\"_actions\",\"_template\",\"_dynamicNodes\",\"_templateAttributes\",\"_observedAttributes\",\"_observedMethodAttributes\",\"_data\",\"_methods\",\"_pendingComponents\",\"splitTextNodes\" ,\"_registerComponent\", \"createDocFragment1\" , \"updateValue\"];\ncustomElementPrototype._v4RegClassApi = [\"_reg\",\"_compName\",\"componentClass\",\"_observedAttributes\"]; //component\ncustomElementPrototype._v4RegProtoApi = [\"setData\", \"getData\", \"setMethods\", \"get\", \"set\", \"_pendingComponents\"];\ncustomElementPrototype.version = {v3 : {component : undefined}};\nltCf._customElementPrototype = customElementPrototype;\nltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();\n// window._customElementPrototype = customElementPrototype;\n// var onObj = function(){\n//     return {\"type\": \"callBack\", \"value\":(this.type === \"observer\") ? this.value:this , \"properties\":arguments, \"observes\":(this.type === \"observer\" ? this: undefined)}\n// }\n// var observesObj = function() {\n//     return {\"type\" : \"observer\", \"value\" : this, \"properties\" : arguments, \"on\":Function.prototype.on}\n// }\n// var computedObj = function() {\n//     return {\"type\" : \"computed\", \"value\" : this, \"properties\" : arguments}\n// }\n// var fnProto = Function.prototype;\n// fnProto.on ? fnProto.lyteOn = onObj : fnProto.on = onObj;\n// fnProto.observes ? fnProto.lyteObserves = observesObj : fnProto.observes = observesObj;\n// fnProto.computed ? fnProto.lyteComputed = computedObj : fnProto.computed = computedObj;\n\n\n// BaseCompiler(Lyte,_LC);\n// if(compConfig.compiler){\n//     compConfig.compiler(_LC);\n// }\n\nLyte.typeCast = _LC.typeCast;\nLyte.getDataType = _LC.getDataType;\n// Lyte.Component._get = _LC.get;\n_LC.chromeBugFix = function() {\n    var version = userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);;\n    version = version ? parseInt(version[2], 10) : 0;\n    if(version > 62) {\n        this.chI = [];\n        document.addEventListener(\"focus\", function(event) {\n            var target = event.target;\n            if(target.tagName === \"INPUT\" || target.tagName === \"TEXTAREA\" || target.tagName === \"DIV\") {\n                if(_LC.chI.indexOf(target) == -1) {\n                    _LC.chI.$push(target);\n                }\n            }\n        } , true);\n        this.chromeBugFix = function() {\n            var tags = _LC.chI;\n            var tagsL = tags.length;\n            var toRemove = [\"_callee\", \"_attributeDetails\", \"_attributes\", \"_removedAttributes\", \"_yields\" , \"_rA\", \"_cx\"];//no i18n\n            var toBeRemoved = [];\n            var keepAliveInputs = [];\n            document.querySelectorAll(\"[lyte-keep-alive]\").forEach(function(item,index){\n                for(var key in item._renderedComponent) {\n                    keepAliveInputs.$push.apply(keepAliveInputs, Array.from(item._renderedComponent[key].querySelectorAll(\"input\")));\n                }\n            });\n            for(var i= tagsL-1, item;item=tags[i];i--) {\n                if((document.compareDocumentPosition(item) % 2) && (keepAliveInputs.indexOf(item) == -1)) {\n                    tags.$splice(i,1);\n                    item.remove();\n                    toBeRemoved.$push(item);\n                    item._rA = item._rA || [];\n                    item._rA.forEach(function(remAttr) { //eslint-disable-line no-loop-func\n                        remAttr.ownerElement = undefined;\n                    });\n                    toRemove.forEach(function(key) {//eslint-disable-line no-loop-func\n                        item[key] = undefined;\n                    });\n                    Array.from(item.attributes).forEach(function(itemVal) {//eslint-disable-line no-loop-func\n                        item.removeAttribute(itemVal.nodeName);\n                    });\n                }\n            }\n        }\n        // Lyte.addEventListener(\"afterRouteTransition\", function() {\n        //     _LyteComponent.chromeBugFix();\n        // });\n        if(!Lyte.Router) {\n            setInterval(function() {\n                // _LC.chromeBugFix();\n                _LC.String.cache_c = {};\n                _LC.String.cache_d = {};\n            },300000)\n        }\n    }\n}\nLyte.$.chromeBugFix = _LC.chromeBugFix;\n\n// _LC._directives = {};\nif(!customElements.get(\"lyte-safari-test-component\")){\n    customElements.define(\"lyte-safari-test-component\", Test, undefined, {v4 : true});\n}\nvar divTest = document.createElement(\"div\");\ndivTest.innerHTML = \"<lyte-safari-test-component t></lyte-safari-test-component>\";\n\nlet _LCSD = _LC.shadow;\n// _LyteComponent.render = _LC.render;\n//Change it in v3.0 - Remove from _LC scope. \n// _LyteComponent.insertBefore = _LC.insertBefore;\n// _LyteComponent.insertAfter = _LC.insertAfter;\n// _LyteComponent.replaceWith = _LC.replaceWith;\n// _LyteComponent.appendChild = _LC.appendChild;\n_LC.tDiv = createElement(\"template\");\n_LC.tDiv.setAttribute(\"id\", \"dummy-templates-div\");\n// _LC.tDiv.setAttribute(\"style\", \"display:none\");\n_LC.hDiv = createElement(\"template\");\n_LC.hDiv.setAttribute(\"id\", \"keep-alive-div\");\n// _LC.hDiv.setAttribute(\"style\", \"display:none\");\n_LC.h1Div = createElement(\"template\");\n_LC.h1Div.setAttribute(\"id\", \"lyte-helper-div\");\n// _LC.h1Div.setAttribute(\"style\", \"display:none\");\n\n// ComponentRegistry.Compile.componentsDiv = \n_LC.lyteComponentsDiv = createElement(\"div\");\n_LC.lyteComponentsDiv.setAttribute(\"id\", \"lyte-components-div\");\n_LC.setComponentsDiv(_LC.lyteComponentsDiv,ComponentRegistry.name);\n\n\n_LC.dummyLyteComponentsDiv = document.createElement(\"div\");\n_LC.dummyLyteComponentsDiv.setAttribute(\"id\", \"dummy-lyte-components-div\");\n_LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,ComponentRegistry.name);\n\n// if(!Lyte._ie) {\nif (document.readyState === \"complete\" || document.readyState === \"interactive\") {     \n    document.body.appendChild(_LC.dummyLyteComponentsDiv);  \n}else{\n    document.addEventListener(\"DOMContentLoaded\", function(){\n        document.body.appendChild(_LC.dummyLyteComponentsDiv);  \n    },true);\n}\n// }\n\nSet.prototype.toArrayLyte = function() {\n    if(this.constructor.name === \"Set\"){\n        return Array.from(this);\n    }\n    else{\n        return Array.from(this._values);\n    }\n}\n//_LC.registerListener(function() {\n//  \n//});\n\nif(document.readyState === \"complete\" || document.readyState === \"interactive\") {\n    onDomContentForLyte();\n} else {\n    document.addEventListener(\"DOMContentLoaded\", function(e){\n        onDomContentForLyte();\n    },true);\n}\n_LC.mappy = {\n    t: \"type\",\n    p: \"position\",\n    dN: \"dynamicNodes\",\n    c: \"cases\",\n    d: \"default\",\n    a: \"attr\",\n    f: \"for\",\n    fI: \"for-in\",\n    e: \"if\",\n    s: \"switch\",\n    i: \"insertYield\",\n    r: \"registerYield\",\n    cM: \"component\",\n    cD: \"componentDynamic\",\n    a: \"attr\",\n    tX: \"text\"\n    // dcn - dynamicCaseName\n    // cn - caseName\n    // hd - hasDynamicCase\n    // hc - hasChildTrans\n    // in - indNew\n    // l-c - lyte-convertion\n    // lc-id - lyte-case-id\n    // lc_id - lyte_case_id\n    // cdp - casesDeepNodes\n    // co - casesOrder\n    // dc - _dChild\n}\n\nfunction createSvgDepth(actualTemplate,type){\n    var svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    for(var s=0; s<actualTemplate.childNodes.length; s++){\n        svg.appendChild(actualTemplate.childNodes[s].cloneNode(true));\n    }\n    var depthTemp = document.createElement(\"template\");\n    depthTemp.setAttribute(\"is\", type);\n    for(var s=0; s<svg.childNodes.length; s++){\n        depthTemp.content.appendChild(svg.childNodes[s]);\n        s--;\n    }\n    return depthTemp;\n}\nfunction createDepth(actualTemplate,type){\n    var depthTemp = document.createElement(\"template\");\n    depthTemp.setAttribute(\"is\", type);\n    depthTemp.innerHTML = actualTemplate.innerHTML;\n    return depthTemp;\n}\nfunction appendDepth(depthTemp,constr){\n    constr.splitTextNodes(depthTemp);\n    constr._depthTemp.content.appendChild(depthTemp);\n}\nfunction setHT(dynN,info,dynNewCompile,constr){\n    var flag  = true;\n    if(dynN.tagName == \"TEMPLATE\") {\n        info._ht = dynN.innerHTML;\n        flag = false;\n    }\n    if(info._ht) {\n        if(flag){\n            dynN.innerHTML = info._ht;\n            constr.splitTextNodes(dynN);\n        }\n        if(dynNewCompile && dynNewCompile.innerHTML !== info._ht) {\n            dynNewCompile.innerHTML = info._ht;\n            constr.splitTextNodes(dynNewCompile);\n        }\n    }\n}\nfunction doCompile(dynamicN, dynamicNodes, componentName, constr, newCompile, componentClass, fastRenderClass) {\n    for(let j=0;j<dynamicNodes.length;j++) {\n        let info = dynamicNodes[j], type = info.t, pos = info.p, helperInfo;\n        let dynN = getDynamicNode(dynamicN,pos);\n        let dynNewCompile;\n        if(newCompile && fastRenderClass) {\n            dynNewCompile = fastRenderClass.getDynNewCompile(newCompile,pos);\n        }\n        switch(type) {\n        case \"tX\" : {\n            dynN.nodeValue = dynN.nodeValue.replace('.{}','____lyteinternal____');\n            var syn = Compile.syntaxCheckWorkerNew(dynN.nodeValue);\n            let mustache = Compile.getMustache(dynN.nodeValue,syn);\n            if(mustache){\n                mustache = mustache.replace('____lyteinternal____','.{}');\n                actObj = Compile.getArray(mustache);  \n            }\n            if(!actObj && mustache){\n                actObj = Compile.getHelper(mustache);  \n            }\n            dynN.nodeValue = dynN.nodeValue.replace('____lyteinternal____','.{}');\n            let dynamic = mustache;\n            if(actObj){\n                info.helperInfo = actObj;\n                dynNewCompile && fastRenderClass.caseTx(dynNewCompile,mustache,info,j);\n           }\n            else if(dynamic){\n                //deepNodes.$push({type: \"text\", position:deepN.slice(), dynamicValue: dynamic});\n                info.dynamicValue = dynamic;\n                info.newDynamicValue = Compile.getDV(dynamic);\n                if(dynNewCompile) {\n                    fastRenderClass.replaceWithPf(dynNewCompile,j)\n                }\n//              LN to do\n//              deepNodes.$push({type: \"text\", position:deepN.slice(), dynamicValue: getDV(dynamic)});                    \n            }\n        }\n        break;\n        case \"i\" : {\n            dynNewCompile && fastRenderClass.caseI(dynNewCompile,info,j);\n        }\n        break;\n        case \"cD\" : {\n            dynNewCompile && fastRenderClass.caseCD(dynNewCompile,info,j);\n        }\n        break;\n        case \"a\" : {\n            let add = false, toBeRemoved = [],toBeAdded = [];\n            let node = dynN;\n            let attr = info.a = info.a || {};\n            for(let i=0;i<node.attributes.length;i++) {\n                if(node.attributes[i].nodeValue.indexOf(\"{{\") !== -1) {\n                    node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('.{}','____lyteinternal____');\n                    var val = node.attributes[i].nodeValue;\n                    var syn = Compile.syntaxCheckWorkerNew(val);\n                    var actObj,actValue,multipleAttr=false;\n                    var splittedMus = val.split(\"{{\");\n                    var splittedMusLen = splittedMus.length;\n                    if(syn.mustache >0){\n                        splittedMusLen = splittedMusLen - syn.mustache;\n                    }\n                    if((splittedMusLen > 2 || !/^{{/.test(val) || !/}}$/.test(val)) && /{{.*}}/.test(val) && !/\\\\{{.*}}/.test(val)){\n                        actObj = Compile.splitMixedText(val);\n                        multipleAttr = true;\n                    }\n                    else{\n                        actValue = Compile.getMustache(val,syn);\n                        if(actValue){\n                            actValue = actValue.replace('____lyteinternal____','.{}');\n                            actObj = Compile.getArray(actValue);  \n                        }\n                        if(!actObj && actValue){\n                            actObj = Compile.getHelper(actValue);  \n                        }\n                    }\n                    node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('____lyteinternal____','.{}');\n                    if( actObj && (actObj.name === \"action\" || actObj.name === \"method\") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|__focus|__focusin|__focusout|__resize|__scroll|__click|__dblclick|__mousedown|__mouseup|__mousemove|__mouseover|__mouseout|__change|__select|__submit|__keydown|__keypress|__keyup|__contextmenu)$/.test(node.attributes[i].name)){\n                            var newActObj;\n                            if(actValue){\n                                newActObj = Compile.getArray(actValue);  \n                            }\n                            if(!newActObj && actValue){\n                                newActObj = Compile.getHelper(actValue,true);  \n                            }\n                            attr[node.attributes[i].name.substr(2)] = {\n                                name:node.attributes[i].name.substr(2),\n                                camelCase : _LC.String.toCamelCase(node.attributes[i].name.substr(2)),\n                                helperInfo: actObj,\n                                newHelperInfo : newActObj,\n                                globalEvent: true\n                            };\n                            let actArgs = deepCopyObject(actObj.args);\n                            let actName = actArgs.$splice(0,1)[0];\n                            actName = actName.startsWith(\"'\")? actName.replace(/'/g,''):  actName;\n                            let actString = getArgString(actName, actArgs);\n                            node.setAttribute(node.attributes[i].name.substr(2),componentName+\" => \"+ actString);\n                            if(dynNewCompile) {\n                                fastRenderClass.setAttribute(dynNewCompile, node.attributes[i].name.substr(2),componentName+\" => \"+ actString)\n                            }\n                            toBeRemoved.$push(node.attributes[i].name);                            \n                    }\n                    else{\n                        if(actObj || actValue) {\n                            let attrToPush = {};\n                            // if(actObj && actObj.name === \"method\"){\n                            //     let actArgs = deepCopyObject(actObj.args);\n                            //     let actName = actArgs.$splice(0,1)[0];\n                            //     actName = actName.startsWith(\"'\")? actName.replace(/'/g,''):  actName;\n                            //     let actString = getArgString(actName, actArgs);\n                            //     node.setAttribute(node.attributes[i].name,componentName+\" => \"+ actString);\n                            // }\n                            if(node.attributes[i].name.startsWith(\"lbind:\")) {\n                                toBeRemoved.$push(node.attributes[i].name);\n                                toBeAdded.$push({\"name\" : node.attributes[i].name.substring(6), \"value\": node.attributes[i].nodeValue});\n                                attrToPush.isLbind = true;\n                                attrToPush.name = node.attributes[i].name.substring(6);\n                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);\n                            }\n                            else {\n                                attrToPush.name = node.attributes[i].name;\n                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);\n                            }\n                            if(actObj) {\n                                if(actObj.name === \"lbind\") {\n                                    attrToPush.dynamicValue = actObj.args[0];\n                                    attrToPush.newDynamicValue = Compile.getDV(actObj.args[0]);\n                                    attrToPush.isLbind = true;\n                                }\n                                else {\n                                    attrToPush.helperInfo = actObj;\n                                    var newActObj;\n                                    if(multipleAttr){\n                                        newActObj = Compile.splitMixedText(val);\n                                    }\n                                    else{\n                                        if(actValue){\n                                            newActObj = Compile.getArray(actValue);  \n                                        }\n                                        if(!newActObj && actValue){\n                                            newActObj = Compile.getHelper(actValue,true);  \n                                        }\n                                    }\n                                    attrToPush.newHelperInfo = newActObj;\n                                }\n                            } \n                            else {\n                                attrToPush.dynamicValue = actValue;\n//                              LN to do\n                                attrToPush.newDynamicValue = Compile.getDV(actValue);\n                            }\n                            add = true;\n                            attr[attrToPush.name] = attrToPush;\n                        }                  \n                    }\n                }\n                if(node.attributes[i].name.startsWith(\"@\")){\n                    let specialAttr;\n                    add = true;\n                    node._special = true;\n                    let attrToPush = {};\n                    attrToPush.name = node.attributes[i].name;\n                    if(attr[attrToPush.name] && attr[attrToPush.name].dynamicValue){\n                        attrToPush.dynamicValue = attr[attrToPush.name].dynamicValue;\n                    }else if(attr[attrToPush.name] && attr[attrToPush.name].helperInfo){\n                        attrToPush.helperInfo = attr[attrToPush.name].helperInfo;\n                    }else{\n                        attrToPush.stringValue = node.attributes[i].nodeValue;\n                        let ndName = node.attributes[i].nodeName\n                        toBeRemoved.push(ndName);\n                        toBeAdded.push({name : \"lyte-directive-\" + ndName.slice(1,ndName.length), value : \"\"});\n                    }\n                    attr[attrToPush.name] = attrToPush;\n                    attrToPush.hookNode  = true;\n                    let hookName = node.attributes[i].name.slice(1,node.attributes[i].name.length);\n                    attrToPush.hookName = hookName;\n                    specialAttr = true;\n                }\n            }\n            if(toBeRemoved.length){\n                for(let i=0; i<toBeRemoved.length;i++){\n                    node.removeAttribute(toBeRemoved[i]);\n                }\n            }\n            if(dynNewCompile) {\n                fastRenderClass.removeAttributeArr(dynNewCompile, toBeRemoved);\n                fastRenderClass.removeAttributeObj(dynNewCompile, attr, j)\n            }\n            if(toBeAdded.length) {\n                for(let i=0;i<toBeAdded.length;i++) {\n                    node.setAttribute(toBeAdded[i].name, toBeAdded[i].value);\n                }\n            }\n        } \n        break;\n        case \"f\" : \n        case \"fI\" : \n        case \"r\" : \n            setHT(dynN,info,dynNewCompile,constr);\n        case \"cM\" : {\n            var actualTemplate = dynN.content;\n            if(!dynNewCompile && (type == \"r\" || dynN.hasAttribute(\"unbound\"))) { //af check\n                if(fastRenderClass){\n                    dynNewCompile = fastRenderClass.cMBefore(dynN, info);\n                }\n            }\n            let depthTemp;\n            let dnNode;\n            let actualTemplateNewCompile = dynNewCompile ? fastRenderClass.cMBefore2(dynNewCompile, info, constr) : undefined;\n            if(info.actualTemplate) {\n                actualTemplate = _LC.getContentForIE(info.actualTemplate, constr, undefined, Lyte._ms? info : undefined);\n            }\n            doCompile(actualTemplate, info.dN, componentName, constr, actualTemplateNewCompile, componentClass, fastRenderClass);\n            if(dynNewCompile){\n                fastRenderClass.cMAfter(actualTemplateNewCompile, info, type, j, dynNewCompile);\n            }\n            // if(Lyte._ms) {\n            //     if(info.actualTemplate) {\n            //         info.templateContent = actualTemplate.outerHTML;\n            //         if(info._content) {\n            //             info.actualTemplate = info._content.innerHTML;\n            //             delete info._content;\n            //         }\n            //     } else {\n            //         info.templateContent = dynN.outerHTML;\n            //     }\n            //     dynN.innerHTML = \"\";  \n            // }\n            if(info.actualTemplate) {\n                depthTemp = type;\n                // if(!Lyte._ie ) {\n                    if(info.svg){\n                        depthTemp = createSvgDepth(actualTemplate,type)\n                    }else{\n                        depthTemp = createDepth(actualTemplate,type)\n                    }\n                    appendDepth(depthTemp,constr);\n                // }\n                if(dynamicNodes[j-1] && (dynamicNodes[j-1].p.toString() === dynamicNodes[j].p.toString())) {\n                    dnNode = dynamicNodes[j-1];\n                } else {\n                    dnNode = dynamicNodes[j];\n                }\n                dnNode._depthTemp = depthTemp;\n            }\n            if(info._ht) {\n                info._ht = dynN.cloneNode(true);\n                componentClass._helperTemplate.content.append(info._ht)\n                dynN.innerHTML = \"\";\n            }\n                //  When a registerYield is present inside another registerYield, in fastRender, we will not be able to get the template using the positions and parentComponent alone, since the insertYield is present inside the insertYield of the parent component. \n                // info.actYield = dynN;\n              }\n        break;\n        case \"e\" : \n        case \"s\" : {\n            let caseStr;\n            setHT(dynN,info,dynNewCompile,constr);\n            let depthTemp;\n            let actualTemplateNewCompile;\n            if(info.actualTemplate) {\n                dynN = _LC.getContentForIE(info.actualTemplate, constr, undefined);\n            }\n            if(dynNewCompile){\n                actualTemplateNewCompile = fastRenderClass.caseES(dynNewCompile, info, constr);\n            }\n            var def = \"default\";\n            // if(Lyte._ms) {\n            // \tvar cases = {};\n            //     var defCase;\n            //     var dynNchildNodes = dynN.childNodes;\n            //     var lyteCaseName = info.hd ? \"lc-id\" : \"case\";\n            //     for(var i=0;i<dynNchildNodes.length;i++) {\n            //       if(dynNchildNodes[i].tagName === \"TEMPLATE\"){\n            //         if(dynNchildNodes[i].getAttribute(lyteCaseName)) {\n            //             cases[dynNchildNodes[i].getAttribute(lyteCaseName)] = dynNchildNodes[i];\n            //         } else if(dynNchildNodes[i].hasAttribute(\"default\")) {\n            //     \t\t  defCase = dynNchildNodes[i];\n            //     \t  }\n            //       }\n            //     }\n            //     for (let key in info.c) {\n            //         if(info.c[key].dcn){\n            //             doCompile(dynN, [info.c[key].cdp], componentName, constr ,undefined ,componentClass, fastRenderClass);\n            //         }\n            //     }\n            //     for (let key in info.c) {\n            //         let contentNewCompile;\n            //         caseStr = info.c[key].dcn ? \"[lc-id='\" : \"[case='\";                    \n            //         content = _LC.getContentForIE(cases[key], undefined, true);\n            //         if(actualTemplateNewCompile) {\n            //             contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector(caseStr+_LC.cssEscape(key)+ \"']\"));\n            //         }\n            //         setHT(content,info.c[key],contentNewCompile,constr);\n\n            //         doCompile(content, info.c[key].dN, componentName, constr, contentNewCompile ? _LC.getContentForIE(contentNewCompile) : undefined, componentClass, fastRenderClass);\n\n            //         cases[key].remove();\n            //         if(actualTemplateNewCompile) {\n            //             info.c[key]._sta = _LC.processStatic(contentNewCompile);\n            //         }\n            //         info.c[key].templateContent = cases[key].outerHTML;\n            //     }\n            //     if (info.d.dN) {\n            //         let contentNewCompile;\n            //         content = _LC.getContentForIE(defCase, undefined, true);\n            //         if(actualTemplateNewCompile) {\n            //             contentNewCompile = actualTemplateNewCompile.querySelector(\"[default]\");\n            //         }\n            //         setHT(content,info.d,contentNewCompile,constr);\n            //         doCompile(content, info.d.dN, componentName, constr, contentNewCompile? _LC.getContentForIE(contentNewCompile) : undefined, componentClass, fastRenderClass);\n\n            //         defCase.remove();\n            //         info.d.templateContent = defCase.outerHTML;\n            //         if(actualTemplateNewCompile) {\n            //             info.d._sta = _LC.processStatic(contentNewCompile);\n            //         }\n            //     }\n            // } else {\n                var dynNContent = dynN.content || dynN;\n            \tfor(let key in info.c) {\n                    caseStr = info.c[key].dcn ? \"[lc-id='\" : \"[case='\";\n                    let contentNewCompile;\n                    if(actualTemplateNewCompile) {\n                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector(caseStr+_LC.cssEscape(key)+ \"']\"));\n                    }\n                    var content = _LC.getContentForIE(dynNContent.querySelector(caseStr+_LC.cssEscape(key)+ \"']\"), undefined, true);\n                    setHT(content,info.c[key],contentNewCompile,constr);\n            \t\tif(info.c[key].dcn){\n                        doCompile(dynNContent, [info.c[key].cdp], componentName, constr ,undefined ,componentClass);\n                    }\n                    doCompile(content.tagName === \"TEMPLATE\" ? content.content : content, info.c[key].dN,componentName, constr, contentNewCompile, componentClass, fastRenderClass);\n                    if(actualTemplateNewCompile) {\n                      info.c[key]._sta = _LC.processStatic(contentNewCompile);\n                    }\n                    if(info.c[key]._ht) {\n                        info.c[key]._ht = content.cloneNode(true);\n                        componentClass._helperTemplate.content.append(info.c[key]._ht)\n                        content.innerHTML = \"\";\n                    }\n            \t}\n            \tif(info.d.dN) {\n                    let contentNewCompile\n                    if(actualTemplateNewCompile) {\n                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector(\"[default]\"));\n                    }\n                    var content = _LC.getContentForIE(dynNContent.querySelector(\"[default]\"), undefined, true);\n                    setHT(content,info.d,contentNewCompile,constr);\n            \t\tdoCompile(content.tagName === \"TEMPLATE\" ? content.content : content, info.d.dN,componentName, constr, contentNewCompile, componentClass, fastRenderClass);\n                    if(actualTemplateNewCompile) {\n                      info.d._sta = _LC.processStatic(contentNewCompile);\n                    }\n                    if(info.d._ht) {\n                        info.d._ht = content.cloneNode(true);\n                        componentClass._helperTemplate.content.append(info.d._ht)\n                        content.innerHTML = \"\";\n                    }\n            \t}\n            \t\n            // }\n\n            if(info.actualTemplate) {\n                depthTemp = type;\n                // if(!Lyte._ie ) {\n                    if(info.svg){\n                        depthTemp = createSvgDepth(dynN.content,type)\n                    }else{\n                        depthTemp = createDepth(dynN,type)\n                    }\n                    appendDepth(depthTemp,constr);\n                // }\n                if(dynamicNodes[j-1] && (dynamicNodes[j-1].p.toString() === dynamicNodes[j].p.toString())) {\n            \t\tdynamicNodes[j-1]._depthTemp = depthTemp;\n            \t} else {\n            \t\tdynamicNodes[j]._depthTemp = depthTemp;\n            \t}\n            }\n\n            if(dynNewCompile) {\n                fastRenderClass.replaceWithPf(dynNewCompile,j)\n            }\n            if(info._ht) {\n                info._ht = dynN.cloneNode(true);\n                componentClass._helperTemplate.content.append(info._ht)\n                dynN.innerHTML = \"\";\n            }\n        }\n        break;    \n        }\n    }\n}\n\n//This is the function where the actual rendering takes place. \n//It takes the template, finds the actual dynamic nodes uwing dynamicNodes argument and then binds each node with the associated\n//property by calling bindNode. \n\nfunction getDynamicNode(content, positions){\n    let dynamicN = content;\n    for(var i=0; i<positions.length; i++){\n        dynamicN = (dynamicN.tagName != \"TEMPLATE\") ? dynamicN.childNodes[positions[i]] : dynamicN.content.childNodes[positions[i]];\n    }\n    return dynamicN;\n}\n\nfunction getArgString(name, array) {\n    let retString;\n    for(let i=0;i<array.length;i++) {\n        if(array[i] && typeof array[i] === \"object\") {\n            array[i] = getArgString(array[i].value.name, array[i].value.args);\n        }\n    }\n    if(name) {\n        retString = name +  \"(\" + array.toString() + \")\";\n    } else {\n        retString = array.toString();\n    }\n    return retString;\n}\n\nvar defHelpers = ComponentRegistry._defaultHelpers;\ndefHelpers[\"unbound\"] = function(value){\n     return value;\n}\ndefHelpers[\"action\"] = function(parentNode,attrName,isCustom,actObj){\n    if(isCustom){\n        parentNode._actions = parentNode._actions? parentNode._actions : {};\n        if(!parentNode._actions[attrName]){\n            this.$node.createCustomEvent(attrName, parentNode, actObj); \n            parentNode.removeAttribute(attrName);\n        }\n    }\n    else{\n        \n        this.$node.createEventListeners(parentNode,attrName,actObj);    \n    }\n};\n\ndefHelpers[\"lbind\"] = function(name){\n\treturn this.getData(name);\n};\n\ndefHelpers[\"method\"] = function(parentComponent, attributeNode, functionName) {\n    var parentComponent = arguments[0];\n    var attributeNode = arguments[1];\n    var functionName = arguments[2];\n    var self = arguments[0].component;\n    var childComponent = attributeNode? attributeNode.ownerElement : null;\n    var attributeName = arguments[1].nodeName;\n    attributeNode = null;\n    var args = Array.prototype.slice.call(arguments, 2);\n    var newFunc = function() {\n        let node = this.$node;\n        let contextSwitchArray = [];\n        _LC.adCx(node, contextSwitchArray);\n        let processedArgs = this.$node.processArgs(this.$node._callee,{\"helperInfo\" : {\"args\" : args}}, [], undefined, this.$node);\n        let functionName1 = processedArgs.$splice(0,1)[0];\n        _LC.rmCx(node, contextSwitchArray);\n        let customArgs = Array.from(arguments);\n        let mainArgs = processedArgs.$concat(customArgs);\n        if(self._methods[functionName1]) {\n            return self._methods[functionName1].apply(self, mainArgs);\n        }\n        //@Slicer.developmentStart\n        ComponentError.error(\"LC005\", functionName, self.$node.tagName);\n        //@Slicer.developmentEnd\n    }\n    if(childComponent) {\n        if(!childComponent.set) {\n            childComponent.setMethods(_LC.String.toCamelCase(attributeName), newFunc);\n        } else {\n            childComponent.component._methods[_LC.String.toCamelCase(attributeName)] = newFunc;\n        }\n    } else {\n        return newFunc;\n    }\n};\n\ndefHelpers[\"unescape\"] = function(value,additionalObject,userInstance){\n    let lyteIns = this.getAppOrAddon();\n    if(_LC.ffr) {\n        return value;\n    }\n    if(lyteIns.Security.ignoreSanitizer){ //af check //take this lyte app instance and proceed\n        let divEle = document.createElement(\"div\");\n        divEle.innerHTML = value;\n        return divEle;\n    }\n    else{\n        if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length >0){\n            if(Object(additionalObject.GLOBAL_TAGS).length>0){\n                var index = additionalObject.GLOBAL_TAGS.indexOf(\"link-to\");\n                if(index != -1){\n                    additionalObject.GLOBAL_TAGS.$splice(index,1);\n                }\n            }\n            if(additionalObject && additionalObject.GLOBAL_ATTRIBUTES && Object.keys(additionalObject.GLOBAL_ATTRIBUTES).length>0){\n                var arr = [\"yield-name\",\"lt-prop-route\", \"lt-prop-dp\", \"lt-prop-fragment\", \"lt-prop-qp\", \"lt-prop\", \"lt-prop-class\", \"lt-prop-id\", \"lt-prop-rel\", \"lt-prop-title\", \"lt-prop-style\", \"lt-prop-target\",\"lt-prop-td\",\"lt-prop-custom\",\"lt-prop-target\",\"lt-prop-id\",\"lt-prop-class\",\"lt-prop-style\",\"lt-prop-rel\",\"lt-prop-title\"];\n                for(var i=0;i<arr.length;i++){\n                    var index =additionalObject.GLOBAL_ATTRIBUTES.indexOf(arr[i]);\n                    if(index != -1){\n                        additionalObject.GLOBAL_ATTRIBUTES.$splice(index,1);\n                    }\n                }\n            }\n        }\n        if(additionalObject && additionalObject.GLOBAL_TAGS){//this if check is inorder to getobserved attributes given in globaltags\n            if(additionalObject.GLOBAL_ATTRIBUTES == undefined){\n                additionalObject.GLOBAL_ATTRIBUTES = [];\n            }\n            var globalTagArr = Array.from(additionalObject.GLOBAL_TAGS);\n            var attr = [];\n            for(var a=0; a<globalTagArr.length; a++){\n                \n                let regComps = ComponentRegistry._registeredCommonClass;\n                if(regComps[globalTagArr[a]]){\n                    attr = regComps[globalTagArr[a]].observedAttributes;\n                }else if(Lyte.registeredCustomComponent[globalTagArr[a]]){\n                    if(Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes){\n                        attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;\n                    }else{\n                        attr = [];\n                    }\n                }\n                for(var i=0; i<attr.length; i++){\n                    if(additionalObject.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){\n                        additionalObject.GLOBAL_ATTRIBUTES.$push(attr[i]);\n                    }\n                }\n            }\n        }\n        var divEle = document.createElement(\"div\");\n        if(userInstance && Object.keys(userInstance).length){\n            if(additionalObject && Object.keys(additionalObject).length){\n                lyteIns.Security.addGlobalObject(userInstance,additionalObject);\n                var clean = userInstance.sanitize(value);\n                lyteIns.Security.removeGlobalObject(userInstance,additionalObject);\n            }\n            else{\n                var clean = userInstance.sanitize(value);\n            }\n        }\n        else{\n            if(additionalObject && Object.keys(additionalObject).length){\n                lyteIns.Security.addGlobalObject(lyteIns.Security._ourSanitizerInstance_,additionalObject);\n                var clean = lyteIns.Security._ourSanitizerInstance_.sanitize(value);\n                lyteIns.Security.removeGlobalObject(lyteIns.Security._ourSanitizerInstance_,additionalObject);\n            }else{\n                var clean = lyteIns.Security._ourSanitizerInstance_.sanitize(value);\n            }\n        }\n        divEle.innerHTML = clean;\n        return divEle;\n    }\n};\ndefHelpers[\"unescape\"] = function(value,additionalObject,userInstance){\n    let lyteIns = this.getAppOrAddon();\n    if(_LC.ffr) {\n        return value;\n    }\n    let divEle = document.createElement(\"div\");\n    if(lyteIns.Security.ignoreSanitizer){ //af check //take this lyte app instance and proceed\n        divEle.innerHTML = value;\n        return divEle;\n    }\n    else{\n        if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length > 0){\n            _LC.Security.initializeConfig(additionalObject);\n            _LC.Security.removeConfig(additionalObject);\n            _LC.Security.addLyteComponents(additionalObject);\n        }\n        let clean;\n        let ins = userInstance && Object.keys(userInstance).length ? userInstance : lyteIns.Security._ourSanitizerInstance_;\n        if(additionalObject && Object.keys(additionalObject).length){\n            clean = _LC.Security.sanitizeWithConfig(value ,additionalObject, ins);\n        }else{\n            clean = ins.sanitize(value);\n        }\n        divEle.innerHTML = clean;\n        return divEle;\n    }\n};\n\ndefHelpers[\"escape\"] = function(value,type){\n    if(type == 'url'){\n        return ZSEC.Encoder.encodeForHTMLAttribute(value);\t\n    }\n    else if(type == 'js'){\n        return ZSEC.Encoder.encodeForJavaScript(value);\n    }\n    else if(type == 'css'){\n        return ZSEC.Encoder.encodeForCSS(value);\t\n    }\n    else{\n        return value;\n    }\n};\n\ndefHelpers[\"debugger\"] = function() {\n    debugger;\n};\n\ndefHelpers[\"log\"] = function() {\n    console.log.apply(window, Array.from(arguments));\n};\n\ndefHelpers[\"ifEquals\"] = function(arg1, arg2) {\n    if(arg1 === arg2) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\ndefHelpers[\"if\"] = function(value, trueValue, falseValue) {\n    if(value) {\n        return trueValue;\n    } else {\n        return falseValue;\n    }\n};\n\ndefHelpers[\"negate\"] = function(arg1) {\n    return !arg1;\n};\n\n\ndefHelpers[\"ifNotEquals\"] = function(arg1, arg2) {\n    if(arg1 === arg2) {\n        return false;\n    } else {\n        return true;\n    }\n};\n\ndefHelpers['concat'] = function(){\n\tvar resp = '';\n\tvar argLength = arguments.length;\n\tfor(var i=0;i<argLength;i++){\n\t\tif(arguments[i] != undefined){\n\t\t\tresp += arguments[i];\n\t\t}\n\t}\n\treturn resp;\n};\n\n\ndefProp(HTMLElement.prototype, 'setData', {\n    configurable : true, \n    writable : true,\n    value : function(arg0, arg1) {\n        this._initProperties = this._initProperties || {};\n        if(typeof arg0 === \"string\") {\n            this._initProperties[arg0] = arg1\n        } else if(typeof arg0 === \"object\") {\n            for(let key in arg0) {\n                this._initProperties[key] = arg0[key];\n            }\n        }\n    }\n});\n\ndefProp(HTMLElement.prototype, 'setMethods', {\n    configurable : true, \n    writable : true,\n    value : function(arg0, arg1) {\n        this._initMethods = this._initMethods || {};\n        if(typeof arg0 === \"string\") {\n            this._initMethods[arg0] = arg1\n        } else if(typeof arg0 === \"object\") {\n            for(let key in arg0) {\n                this._initMethods[key] = arg0[key];\n            }\n        }\n    }\n});\n\ndefHelpers['encAttr'] = function(val) {\n    return ZSEC.Encoder.encodeForHTMLAttribute(encodeURIComponent(val));\n}\n\ndefHelpers['expHandlers'] = function(leftOperand,operator,rightOperand,nextOperand){\n    var argLen = arguments.length;\n    if(operator == '++' ){\n    \tif(rightOperand == \"postfix\"){\n    \t   return (leftOperand++);\n    \t} else if(rightOperand == \"prefix\"){\n    \t\treturn (++leftOperand);\n    \t}\n    } else if(operator == \"--\"){\n    \tif(rightOperand == \"postfix\"){\n    \t   return (leftOperand--);\n    \t} else if(rightOperand == \"prefix\") {\n    \t\treturn (--leftOperand);\n    \t}\n    } else if((operator == \"==\")){\n    \treturn leftOperand == rightOperand;\n    }\n     else if((operator == \"===\")){\n    \treturn leftOperand === rightOperand;\n    }\n    \n    else if((operator == \"!=\")) {\n        return leftOperand != rightOperand;\n    }\n    else if((operator ==\"!==\")) {\n        return leftOperand !== rightOperand;\n    }\n    else if( operator == \"&&\") {\n    \treturn leftOperand && rightOperand;\n    } else if(operator == \"||\") {\n    \treturn leftOperand || rightOperand;\n    } else if(operator == \"+\"){\n        if(argLen > 2){\n        \treturn leftOperand+rightOperand;\n        }\n        return leftOperand;\n    } else if(operator == '-'){\n         if(argLen > 2){\n        \treturn leftOperand-rightOperand;\n        }\n        return (-leftOperand);\n    } else if(operator == '*'){\n    \treturn leftOperand * rightOperand;\n    } else if(operator == \"/\"){\n    \treturn leftOperand / rightOperand;\n    } else if(operator == \"%\"){\n    \treturn leftOperand % rightOperand;\n    } else if(operator == \"<\"){\n    \treturn leftOperand < rightOperand;\n    } else if(operator == \">\") {\n    \treturn leftOperand > rightOperand;\n    } else if(operator == \"<=\") {\n    \treturn leftOperand <= rightOperand;\n    } else if(operator == \">=\") {\n    \treturn leftOperand >= rightOperand;\n    } else if(operator == '|') {\n        return leftOperand | rightOperand;\n    } else if(operator == '&') {\n        return leftOperand & rightOperand;\n    }\n    else if(operator == \"!\" ){\n        return (!leftOperand);\n    } else if(operator == '=') {\n        leftOperand = rightOperand;\n        return leftOperand;\n    } else if(operator == \"+=\") {\n        return leftOperand += rightOperand;\n    } else if(operator == '-=') {\n        return leftOperand -= rightOperand;\n    } else if(operator == \"*=\") {\n        return leftOperand *= rightOperand;\n    } else if(operator == '/=') {\n        return leftOperand /= rightOperand;\n    } else if(operator == '?:') {\n        return (leftOperand ? rightOperand : nextOperand);\n    }\n };\n\nComponentRegistry.registerCustomPropHandler(\"ltProp\");\n\n_LC.shouldIgnoreDisconnect = function() {\n    return _LC.ignoreDisconnect;\n}\n\n_LC.addAction = function(element, eventName, func, context) {\n    element._lyteEvents = element._lyteEvents || {};\n    element._lyteEvents[eventName] = element._lyteEvents[eventName] || []; \n    var ind = element._lyteEvents[eventName].$push({\"func\" : func, \"fromEventListener\" : true, \"context\" : context});\n    return eventName + \"-\" + ind; \n  }\n\nComponentRegistry.prototype.removeAction = function(element, listenerId) {\n    if(!listenerId) {\n        //@Slicer.developmentStart\n        ComponentError.error(\"LC014\")\n        //@Slicer.developmentEnd\n        return;\n    }\n    var split = listenerId.split('-');\n    var eventName = split[0];\n    var index = parseInt(split[1]);\n    if(!element._lyteEvents || !element._lyteEvents[split[0]] || isNaN(index)) {\n        //@Slicer.developmentStart\n        ComponentError.error(\"LC015\")\n        //@Slicer.developmentEnd\n        return;\n    }\n    element._lyteEvents[split[0]][split[1] - 1] = {};\n}\n\n\n_LC.hasLyteEvents = function(element, eventName) {\n    if(element._lyteEvents && element._lyteEvents[eventName]) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n_LC.handleLyteEvents = function(element, event) {\n    var funcs = element._lyteEvents[event.type];\n    var ret;\n    var eventStopped;\n    for(var i=0;i<funcs.length;i++) {\n        if(funcs[i].func) {\n            ret = funcs[i].func.call(funcs[i].context ? funcs[i].context : window, event);\n            if(ret === false || event.cancelBubble) {\n                eventStopped = true;\n                break;\n            } \n        }\n    }\n    if(eventStopped) {\n        event.stopPropagation();\n    }\n    return eventStopped;\n}\n_LC.executeObservers = function(compClass){\n    Lyte._preRegister();\n    let __observers = compClass.observers();\n    Lyte._postRegister();\n    return __observers;\n}\n_LC.chromeBugFix();\n_LC.booleanAttrList = [\"async\",\"autocomplete\",\"autofocus\",\"autoplay\",\"border\",\"challenge\",\"checked1\",\"compact\",\"contenteditable\",\"controls\",\"default\",\"defer\",\"disabled\",\"formNoValidate\",\"frameborder\",\"hidden\",\"indeterminate\",\"ismap\",\"loop\",\"multiple\",\"muted\",\"nohref\",\"noresize\",\"noshade\",\"novalidate\",\"nowrap\",\"open\",\"readonly\",\"required\",\"reversed\",\"scoped\",\"scrolling\",\"seamless\",\"selected\",\"sortable\",\"spellcheck\",\"translate\"]\n\n_LC.core = {};\n_LC.core._constructor = customElementPrototype;\n_LC.core._registerComponent = customElementPrototype._registerComponent;\n_LC.core.registerComponent = _LC.registerComponent;\n_LC.core.executeBlockHelpers = customElementPrototype.prototype.executeBlockHelpers;\n_LC.core.updateForHelper = customElementPrototype.prototype.updateForHelper;\n_LC.core.updateForInHelper = customElementPrototype.prototype.updateForInHelper;\n_LC.core.updateSwitchHelper = customElementPrototype.prototype.updateSwitchHelper;\n\nComponentRegistry.prototype.set = _LC.set;\nComponentRegistry.prototype.get = _LC.get;\n_LC.aF._name = \"arrayUtils\";\n_LC.oF._name = \"objectUtils\";\nUtils.addMethods([_LC.set,_LC.get,_LC.arrayUtils,_LC.objectUtils])\nlet appendChild = _LC.appendChild;\nlet insertAfter = _LC.insertAfter;\nlet insertBeforeFn = _LC.insertBefore\nlet replaceWith = _LC.replaceWith;\nlet render = _LC.render;\nlet shouldIgnoreDisconnect = _LC.shouldIgnoreDisconnect;\n_LC.globalDOMEvents = globalDOMEvents;\n_LC.globalEventHandler = globalEventHandler;\n_LC.changeEventhandler = changeEventhandler;\n_LC.doCompile = doCompile;\n_LC.getDynamicNode = getDynamicNode;\nexport {ComponentRegistry,Component,RawComponent,Helper,arrayUtils,objectUtils,set,appendChild,insertAfter,insertBeforeFn as insertBefore,replaceWith,shouldIgnoreDisconnect,defProp,render,_LC,customElementPrototype,LyteCustomElement};\n","//ignorei18n_start\nimport { Logger } from \"@slyte/core\";\n\nclass ComponentError extends Logger {\n    constructor(){\n        super(...arguments);\n    }\n}\n\nComponentError.errorCodes = {\n    LC001: \"Error while parsing custom prop handler attribute {0} to the component {1}. Check if the value provided is a valid JSON\",\n    LC002: \"{0} Component is not compiled. Please compile using Lyte CLI\",\n    LC003: \"Helper named {0} is not defined\",\n    LC004: \"Action named {0} doesn't exists\",\n    LC005: \"Method named {0} doesn't exists in {1} component\",\n    LC006: \"Error in data passed to component '{0}' for the properties - {1}\",\n    LC007: \"Directive syntax is used but source not loaded\",\n    LC008: \"{0} component not supporting turbo render. please add @turbo-supported in the component's template tag.\",\n    LC009: \"Error in updateForHelper\",\n    LC010: \"Passing lyteFastRender to unbound option in 'for' helper is depricated. So please make use of '@turbo' directive in the node - {0}\",\n    LC011: \"Fast render source not bundled\",\n    LC012: \"Error with templateAttributes.\",\n    LC013: \"Data passed for property '{0}' of '{1}' cannot be serialized. The component '{2}' might not be registered before its use.\",\n    LC014: \"No listenerId provided\",\n    LC015: \"Invalid listenerId / listener is not available\",\n    LC016: \"Deprecation Warning! pass the component class to component-class attribute, instead of passing '{0}' string component name to component-name attribute.\",\n    LC017: \"{0} component not supporting shadow dom rendering. please add @shadow-supported in the component's template tag.\"\n\n};\nComponentError.register();\n\nclass ApiError extends Logger {\n    constructor(){\n        super(...arguments);\n    }\n}\n\nApiError.errorCodes = {\n    LC001: \"Lyte.objectUtils doesn't support {0} function\",\n    LC002: \"Lyte.arrayUtils doesn't support {0} function\",\n    LC003: \"Component not specified in Lyte.Component.render\",\n    LC004: \"Specified outlet {0} doesn't exists - Lyte.Component.render\",\n    LC005: \"Parent Node / reference Node not provided for insertBefore method\",\n    LC006: \"Invalid registry instance passed - Lyte.Component.render\",\n    LC007: \"Uninstantiated registry class passed - Lyte.Component.render\",\n    LC008: \"Unregistered component class passed - Lyte.Component.render\",\n    LC009: \"Sanitizer instance not passed to sanitize api\",\n    LC010: \"Invalid data passed in Lyte.Component.render\"\n\n};\nApiError.register();\n\nclass RegistryError extends Logger {\n    constructor(){\n        super(...arguments);\n    }\n}\n\nRegistryError.errorCodes = {\n    LC001: \"'{0}' registry is not registered with Lyte.\",\n    LC002: \"'{0}' - '{1}' already registered with '{1}' registry.\",\n    LC003: \"'{0}' Component class should extend a ComponentRegistry's Component property directly or extend through base component.\",\n    LC004: \"Registry class extended in the '{0}' '{1}' is not registered with Lyte\",\n    LC005: \"Invalid registry instance '{0}' passed in addRegistries hook of {1}\",\n    LC006: \"Invalid registry instance '{0}'\",\n    LC007: \"'{0}' Registry linked recursively in the app/addon.\",\n    LC008: \"Invalid registry instance '{0}' passed in setDefaultRegisty hook of '{1}'\",\n    LC009: \"Default Registry not found.\",\n    LC010: \"{0} : {1} Not found in any registry.\"\n};\nRegistryError.register();\n\nexport {ComponentError, ApiError, RegistryError};\n//ignorei18n_end","import { Logger } from \"./lyte-error\";\nimport { defProp, extendEventListeners } from \"./lyte-utils\";\n\nclass DataType {\n    static register(opts){\n        this._name = this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');\n        var clsExt = this.extends || this.type;\n        this.type = clsExt;\n        if(clsExt == undefined || DataType.types.indexOf(clsExt) == -1){\n            Logger.error(\"Not a valid field type - \"+clsExt);\n            return;\n        }  \n        if(this.prototype.serialize){\n            this.serialize = this.prototype.serialize;\n        }      \n        if(this.prototype.deserialize){\n            this.deserialize = this.prototype.deserialize;\n        }\n        var rHash = opts.refHash;\n        var currCls = this, \n        appMap = DataType.lyte = DataType.lyte || new Map(),  \n        dtMap,\n        currClsName = currCls.name;\n        if(!appMap.has(rHash)){\n            appMap.set(rHash, new Map());\n        }\n        dtMap = appMap.get(rHash);\n        if(!dtMap.has(currClsName)){\n            dtMap.set(currCls.name, currCls);\n        }\n        DataType.triggerEvent(rHash, currCls);\n    }\n    static registerInApp(parent){\n        var name = this._name = this.name || this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');\n        var clsExt = this.extends || this.type;\n        this.type = clsExt;\n        if(clsExt == undefined || DataType.types.indexOf(clsExt) == -1){\n            Logger.error(\"Not a valid field type - \"+clsExt);\n            return;\n        }  \n        if(this.prototype.serialize){\n            this.serialize = this.prototype.serialize;\n        }      \n        if(this.prototype.deserialize){\n            this.deserialize = this.prototype.deserialize;\n        }\n        var name = this._name = this._name || this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');\n        if(!parent.dataType.hasOwnProperty(name)){\n            parent.dataType[name] = this;\n            if(parent.dataType.triggerEvent){\n                parent.dataType.triggerEvent(\"add\", name, this);\n            }\n        }\n        else{\n            Logger.warn(\"DataType with the same name - \"+ name+ \" already present in the app\");\n        }\n    }\n}\ndefProp(DataType, \"types\", {\n    value: [\"string\", \"object\", \"number\", \"boolean\", \"array\"]\n});\nextendEventListeners(DataType);\nexport { DataType };","import { Lyte } from \"@slyte/core\";\n\nfunction pathFinder (scope,path){\n    if(path){\n        var Json = scope;\n        if(typeof scope == \"object\"){\n            return parsePath(scope,path)\n        }\n    }\n    else{\n        Lyte.error(\"Invalid JsonPath - \" + path)\n    }\n}\nfunction parsePath (scope,path){\n    if(path.includes(\".\")){\n        path=path.replace(/ /g,\"\");\n        var pathArr =path.split(\".\")\n        if(pathArr[0] == \"$\"){\n            pathArr.splice(0,1)\n        }\n    }\n    return GetData(scope,pathArr)\n}\nfunction GetData (scope,path,DeepTraverse){\n    if(DeepTraverse){\n        var arr =[];\n        if(Array.isArray(scope)){\n            path.splice(0,1);\n            for(var i_deep=0; i_deep<scope.length ; i_deep++){\n            var value = deepBranches(scope[i_deep],path,DeepTraverse)\n            if(Array.isArray(value) && value.length ==0){\n                value = undefined;\n            }\n            if(value){\n                arr.push(value)\n            }\n            }\n            return arr;\n        }\n    }\n    else{\n        return deepBranches(scope,path,DeepTraverse)\n    }\n}\nfunction deepBranches (obj,path,DeepTraverse){\n    for(var pathIndex =0 ; pathIndex<path.length; pathIndex ++){\n        var key = path[pathIndex];\n        var nextKey = path[pathIndex+1],_nextKey;\n        if(nextKey){\n            _nextKey = keyParser(nextKey);\n        }\n        if(key.includes(\"[\") && key.includes(\"]\")){\n            var utilScope = key.match(/\\[([^\\]]+)\\]/g)[0]\n            var utilKey = key.match(/^(.+?)\\[/g)\n            if(utilKey){\n                utilKey=utilKey[0].replace(/\\[/g,\"\");\n            }\n            if(!Array.isArray(obj) && utilKey){\n                obj = obj[utilKey];\n            }\n            obj = (!Array.isArray(obj) && utilScope) ? undefined : obj;\n            if(Array.isArray(obj)){\n                if(utilScope && !utilScope.includes(\"@\")){\n                    if(utilScope.includes(\":\")){\n                        utilScope = utilScope.replace(/\\[/g,\"\").replace(/\\]/g,\"\");\n                        var slice = utilScope.split(\":\");\n                        var start = slice[0]==\"\"?undefined:parseInt(slice[0]);\n                        var end = slice[1]==\"\"?undefined:parseInt(slice[1]);\n                        obj = obj.slice(start,end)\n                    }\n                    else if(utilScope.includes(\"*\")){\n                        continue\n                    }\n                    else if(utilScope){\n                        var key = utilScope.match(/\\[(.*?)\\]/)[1]\n                        obj = obj[key]\n                    }\n                }\n            }\n        }\n        else if(key == \"\"){\n            if(_nextKey == undefined){\n                Lyte.error(\"Invalid JsonPath - \" + path + \"expected : Path string should not end with the  '..' \")\n            }\n            obj = GetAllKeys(obj,_nextKey)\n            if(path.length-1 != pathIndex){\n                if(Array.isArray(obj)){\n                    DeepTraverse =1;\n                    var utilScope = nextKey.match(/\\[([^\\]]+)\\]/g)\n                    path.splice(0,pathIndex+1)\n                    if(utilScope!=null){\n                        utilScope = utilScope[0];\n                        utilScope = utilScope.match(/\\[(.*?)\\]/)[1]\n                        obj = separateArray(obj,utilScope);\n                    }\n                    if(path.length>1){\n                        obj = GetData(obj,path,DeepTraverse)\n                        break;\n                    }\n                }\n            }\n            if(nextKey && !nextKey.includes(\"[\") && !nextKey.includes(\"]\")){\n                pathIndex++;\n            }\n        }\n        else if(key == \"*\"){\n            continue;\n        }\n        else{\n            if(path[pathIndex-1] && (path[pathIndex-1] == \"*\" || path[pathIndex-1].includes(\"*\"))){\n                if(Array.isArray(obj)){\n                    var newArray=[];\n                    var ind=0;\n                    for(var arr_index = 0; arr_index<obj.length; arr_index++){\n                        if(obj[arr_index][key]){\n                            newArray[ind] = obj[arr_index][key];\n                            ind++;\n                        }\n                    }\n                    obj=newArray;\n                }\n                else if (typeof obj == \"object\"){\n                    obj = obj[key]\n                }\n            }\n            else{\n                obj = obj[key]?obj[key]:undefined;\n            }\n        }\n\n    }\n    return obj\n}\nfunction keyParser (key){\n    if(key.includes(\"[\") && key.includes(\"]\")){\n        var utilScope = key.match(/\\[([^\\]]+)\\]/g)[0]\n        var utilKey = key.match(/^(.+?)\\[/g) \n        if(utilKey){\n            utilKey=utilKey[0].replace(/\\[/g,\"\");\n            return utilKey;\n        }\n    }\n    return key;\n}\nfunction GetAllKeys (scope,key){\n    var arr= []; \n    getRecurssive(scope,key,arr);\n    return arr\n}\nfunction getRecurssive (scope,key,arr){\n    if(typeof scope == \"object\"){\n        for(var v in scope){\n            if(v == key){\n                arr.push(scope[key])\n            }\n            if(typeof scope[v] == \"object\"){\n                getRecurssive(scope[v],key,arr)\n            }\n        }\n    }\n    else if(Array.isArray(scope)){\n        for( var index = 0 ; index<scope.length ; index++ ){\n            var obj = scope[index];\n            getRecurssive(obj,key,arr);\n        }\n    }\n}\nfunction separateArray (scope,index){\n    var Arr =[];\n    for (var i=0; i< scope.length; i++){\n        if(scope[i][index]){\n            Arr.push(scope[i][index]);\n        }\n    }\n    return Arr;\n}\n\nexport { pathFinder as Jwalk }","import { __scopedInstance } from \"./lyte\";\nimport { Service } from \"./service\";\nimport { _lyteInit, _lyteDidConnect } from \"./lyte-utils.js\";\n// import { resolvePromises } from './rsvp';\n// import { Logger } from './lyte-error';\n/*convert to custom class*/\nclass LyteAddon extends Service {\n    constructor(config){\n        super();\n        this.config = config;\n        _lyteInit(LyteAddon,this);\n        _lyteDidConnect(LyteAddon,this);\n    }\n    static register(options){\n        if(options){\n          if(options._migration){\n            this._migration = options._migration;\n          }\n        }\n    }\n    lookups() {\n        return [];\n    }\n\n    scopedInstance() {\n        return __scopedInstance.apply(this, Array.from(arguments));\n    }\n\n    get __isAddon() {\n        return true;\n    }\n    \n}\n// LyteAddon.prototype.resolvePromises = function(promises) {\n//     return new Promise(function(res, rej) {\n//       resolvePromises(promises).then(function(data) {\n//         res(data);\n//       },function(data) {\n//         rej(data);\n//       })\n//     })\n// }\nLyteAddon._component = {};\n// LyteAddon.error = Logger.error.bind(Logger);\n// LyteAddon.warn = Logger.warn.bind(Logger);\n// LyteAddon.errorCodes = Logger.errorCodes;\n\nexport { LyteAddon };","import { createCustomClass, getClass, getSuperClass } from \"./lyte-utils.js\";\nimport {Lyte} from \"./lyte.js\";\nlet registeredMixin = {};\nlet Mixin = createCustomClass(function(arg1,overrides){\n    class Mixin extends getClass([],arg1) {\n        static register(options){\n            if(this.__lMod) {\n                return super.register.apply(this, Array.from(arguments));\n            }\n            if(options){\n                if(options.hash){\n                    this._hash = options.hash;\n                }\n                if(options.refHash){\n                    this._refHash = options.refHash;\n                    var mobj = Mixin.registeredMixin[options.refHash] = Mixin.registeredMixin[options.refHash] || {};\n                    mobj[this.name] = this;\n                    Mixin.getAppClass(options, this);\n                }\n            }\n        }\n        static getAppClass(options, mixinCls){\n            let registryClass;\n            Lyte._instances.forEach(function(appIns){\n                let appClass = appIns.constructor;\n                if(appClass._hash == options.refHash){\n                    appIns.registeredMixins[mixinCls.name] = mixinCls;\n                }\n            });\n        }\n    }\n    Mixin.registeredMixin = registeredMixin;\n    return overrides(Mixin)\n})\nexport { Mixin };\n","import { deepCopyObject, extendEventListeners } from \"@slyte/core/src/lyte-utils\";\nimport { Service } from \"@slyte/core/src/service\";\n/*convert to custom class */\nclass Utils extends Service {\n    static addMethods(data){\n        if(Array.isArray(data)){\n            data.forEach(function(fn){\n                var name = fn._name ? fn._name : fn.name;\n                if(!Utils.prototype[name]){\n                    Utils.prototype[name] = fn;\n                }\n            });\n        }\n    } \n}\nUtils.addMethods([deepCopyObject, extendEventListeners]);\n\nexport { Utils };","var errorCodes =  {\n  ERR01 : \"Primary key cannot be modified\", \n  ERR02 : \"Mandatory field cannot be empty\", \n  ERR03 : \"Type of value does not match the specified data type\",\n  ERR04 : \"Value is greater than the maximum value allowed\",\n  ERR05 : \"Value is less than the minimum value allowed\", \n  ERR06 : \"Length of string/array is greater than the maximum limit allowed\", \n  ERR07 : \"Length of string/array is less than the minimum limit allowed\",\n  ERR08 : \"String does not match the specified pattern\", \n  ERR09 : \"Values in array are not unique\", \n  ERR10 : \"Value is not equal to the specified constant\", \n  ERR11 : \"Model of related field is not defined\",\n  ERR12 : \"Model of backward relation is not defined\", \n  ERR13 : \"Record not found\", \n  ERR14 : \"Model does not match the related field model\", \n  ERR15 : \"Error in creating a record as a relation\",\n  ERR16 : \"Record with primary key already exists\", \n  ERR17 : \"Value cannot be changed because record has been deleted\", \n  ERR18 : \"Action not defined\", \n  ERR19 : \"Model not defined\",\n  ERR20 : \"Key not specified\", \n  ERR21 : \"'belongsTo' relationship expects a single object/id\", \n  ERR22 : \"Type not specified for polymorphic relation\", \n  ERR23: \"Primary Key value not present\", \n  ERR24: \"Error while relating record\", \n  ERR25: \"Backward relation not present\",\n  L001: \"{0} {1} is already registered\",\n  ERR27 : \"Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'\",\n//   /* move to component */\n//   LC001: \"Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON\",\n//   LC002: \"{0} Component is not compiled. Please compile using Lyte CLI\",\n//   LC003: \"Helper named {0} is not defined\",\n//   LC004: \"Action named {0} doesn't exists\",\n//   LC005: \"Lyte.objectUtils doesn't support {0} function\",\n//   LC006: \"Lyte.arrayUtils doesn't support {0} function\",\n//   LC007: \"Component name not specified in Lyte.Component.render\",\n//   LC008: \"Specified outlet {0} doesn't exists - Lyte.Component.render\",\n//   LC009: \"Method named {0} doesn't exists in {1} component\",\n//   LC010: \"Parent Node / reference Node not provided for insertBefore method\",\n  /* move to data */\n  LD01: \"Primary key value might be missing in the response data that is received, {0}\",\n  LD02: \"{0} - {1} is not registered\",\n  LD03: \"Cannot set the error {0} for {1}\",\n  LD04: \"No such record to merge, {0}\",\n  LD05: \"Model( {0} ) of related property - {1} not found in model - {2}\",\n  LD06: \"Backward relation not present in model( {0} ), for the property {1} of model( {2} )\",\n  LD07: \"{0} type not handled in handleArrayOperations\",\n  LD08: \"{0} {1} will be deprecated from next version {2}\",\n  LD09: \"deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback\",\n  LD10: \"Response data not in a format lyte data store expects\",\n  LD11: \"Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version\",\n  LD12: \"Response ( {0} ) is not in a format, lyte data store expects\",\n  LD13: \"Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of response data. Data - {3}\",\n  LD14: \"Cannot register {0} - {1}, as it already exists.\",\n  LD15: \"Primary key value might be missing in the response data that is received, {0}\",\n  LD16: \"Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge\",\n  LD17: \"Record with the primary key value already exists\",\n  LD18: \"No { 0 } present\",\n  LD19: \"Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version\",\n  LD20: \"Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.\",\n  LD21: \"No such state ( {0} ) saved for the record.\",\n  LD22: \"For create / createRecord, response with a primary key value should be received\",\n  LD23: \"PrimaryKey field {1} in {0} cannot have default value\",\n  LD24: \"Response couldn't be parsed, {0}\",\n  LD25: \"Cannot create record for the data - {0}\",\n  LD26: \"Only one baseKey is allowed for a model\",\n  LD27: \"Record merge failed, since the data passed is invalid - {0}\",\n  LD28: \"Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}\"   \n};\n\nfunction getErrorMessage(code) {\n    var args = Array.from(arguments).slice(1);\n    if(errorCodes[code]) {\n        return errorCodes[code].replace(/{(\\d+)}/g, function(t, i) {\n            return args[i]\n        });\n    } else {\n        return code;\n    }\n}\n\nexport {\n    getErrorMessage, errorCodes\n}","import { Lyte } from \"./lyte\";\nimport { extendEventListeners } from \"./lyte-utils\";\nimport { LyteAddon } from \"./LyteAddon\";\n\n// add function which throws error //ex Lyte.attr function need to be added with checking secind arguments as object ans so it will override the original Lyte.attr function in develepment mode\nclass LyteError extends Error {\n\n}\n\nconst level = 0;\nclass Logger extends Error {\n    static get level(){\n        return level;\n    }\n    constructor(){\n        super(...arguments);\n    }\n    static register(){\n        var context = this;\n        while(context !== Logger){\n            if(!context.hasOwnProperty(\"addEventListener\")){\n                extendEventListeners(context);\n            }\n            context = Object.getPrototypeOf(context);\n        }\n        if(!Logger.triggerEvent){\n            extendEventListeners(Logger);\n        }\n    }\n    static registerErrorCodes(obj, defineProperty){\n        if(obj && typeof obj == \"object\"){\n            for(var key in obj){\n                var message = obj[key];\n                if(defineProperty){\n                    Object.defineProperty(this.errorCodes, key, {\n                        value: message\n                    });\n                }\n                else{\n                    this.errorCodes[key] = message;\n                }\n            }\n        }\n    }\n    static getErrorMessage(code, withCode){\n      var args = Array.from(arguments).slice(1);\n      if(this.errorCodes[code]) {\n          var msg = this.errorCodes[code].replace(/{(\\d+)}/g, function(t, i) {\n              return args[i];\n          });\n          return code+\": \"+msg;\n      } else {\n          return code;\n      }\n    }\n    static setErrorMessage(code, message, defineProperty){\n        if(defineProperty){\n            Object.defineProperty(this.errorCodes, code, {\n                value: message\n            });\n        }\n        else{\n            this.errorCodes[code] = message;\n        }\n    }\n    static error(){\n        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;\n        if(arg0 instanceof Lyte || arg0 instanceof LyteAddon){\n            ins = arg0;\n            args.splice(0,1);\n            if(ins.hasOwnProperty(\"logLevel\")){\n                logLevel = ins.logLevel;\n            }\n        }\n        if(logLevel < 3){\n            errorObj = args[0];\n            var parse = errorObj.stack, \n            context = this;\n            errorObj = parse ? errorObj : new this(this.getErrorMessage.apply(this, args));\n            while(context !== Logger){\n                if (context.hasOwnProperty(\"onerror\")) {\n                    context.onerror.call(context, errorObj, args[1], this, ins);\n                }\n                if(context.hasOwnProperty(\"triggerEvent\")){\n                    context.triggerEvent.call(context, \"error\", errorObj, args[1], this, ins);\n                }\n                context = Object.getPrototypeOf(context);\n            }\n            if (Logger.hasOwnProperty(\"onerror\")) {\n                Logger.onerror.call(Logger, errorObj, args[1], this, ins);\n            }\n            if(Logger.hasOwnProperty(\"triggerEvent\")){\n                Logger.triggerEvent.call(Logger, \"error\", errorObj, args[1], this, ins);\n            }\n            if(ins){\n                if(ins.onerror) {\n                    ins.onerror.call(ins, errorObj, args[1], this, ins);\n                }\n                if(ins.triggerEvent){\n                    ins.triggerEvent.call(ins, \"error\", errorObj, args[1], this, ins);\n                }\n            }\n            var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1\n            if (parse && !safari) {\n                errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));\n            }\n            if(args[1]) {\n                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message, args[1]);\n            } else {\n                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message);    \n            }\n        }\n    }\n    static warn(){\n        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;\n        if(arg0 instanceof Lyte || arg0 instanceof LyteAddon){\n            ins = arg0;\n            args.splice(0,1);\n            if(ins.hasOwnProperty(\"logLevel\")){\n                logLevel = ins.logLevel;\n            }\n        }\n        if(logLevel < 2){\n            var errorObj = args[0];\n            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));\n            console.warn(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace(\"Error: \", \"Warn: \") : errorObj) : errorObj.message);\n        }\n    }\n    static log(){\n        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;\n        if(arg0 instanceof Lyte || arg0 instanceof LyteAddon){\n            ins = arg0;\n            args.splice(0,1);\n            if(ins.hasOwnProperty(\"logLevel\")){\n                logLevel = ins.logLevel;\n            }\n        }\n        if(logLevel == 0){\n            var errorObj = args[0];\n            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));\n            console.log(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace(\"Error: \", \"Log: \") : errorObj) : errorObj.message);        \n        }\n    }\n}\nLogger.errorCodes = {\n    ERR01 : \"Primary key cannot be modified\", \n    ERR02 : \"Mandatory prop cannot be empty\", \n    ERR03 : \"Type of value does not match the specified data type\",\n    ERR04 : \"Value is greater than the maximum value allowed\",\n    ERR05 : \"Value is less than the minimum value allowed\", \n    ERR06 : \"Length of string/array is greater than the maximum limit allowed\", \n    ERR07 : \"Length of string/array is less than the minimum limit allowed\",\n    ERR08 : \"String does not match the specified pattern\", \n    ERR09 : \"Values in array are not unique\", \n    ERR10 : \"Value is not equal to the specified constant\", \n    ERR11 : \"Schema of related field is not defined\",\n    ERR12 : \"Schema of backward relation is not defined\", \n    ERR13 : \"Entity not found\", \n    ERR14 : \"Schema does not match the schema defined in the related field\", \n    ERR15 : \"Error in creating a entity as a relation\",\n    ERR16 : \"Entity with primary key already exists\", \n    ERR17 : \"Value cannot be changed because entity has been deleted\", \n    ERR18 : \"Action not defined\", \n    ERR19 : \"Schema not defined\",\n    ERR20 : \"Key not specified\", \n    ERR21 : \"'one' relationship expects a single object/id\", \n    ERR22 : \"Type not specified for polymorphic relation\", \n    ERR23: \"Primary Key value not present\", \n    ERR24: \"Error while relating entities\", \n    ERR25: \"Backward relation not present\",\n    ERR26: \"Primary key value cannot be undefined or null\",\n    ERR27: \"Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'\",\n    ERR29: \"Property not defined in the object\",\n    ERR30: \"Property's value is not an instanceof the mentioned class\",      \n    L001: \"{0} {1} is already registered\",\n    // /* move to component */\n    // LC001: \"Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON\",\n    // LC002: \"{0} Component is not compiled. Please compile using Lyte CLI\",\n    // LC003: \"Helper named {0} is not defined\",\n    // LC004: \"Action named {0} doesn't exists\",\n    // LC005: \"Lyte.objectUtils doesn't support {0} function\",\n    // LC006: \"Lyte.arrayUtils doesn't support {0} function\",\n    // LC007: \"Component name not specified in Lyte.Component.render\",\n    // LC008: \"Specified outlet {0} doesn't exists - Lyte.Component.render\",\n    // LC009: \"Method named {0} doesn't exists in {1} component\",\n    // LC010: \"Parent Node / reference Node not provided for insertBefore method\",\n};\nextendEventListeners(Logger);\n\nwindow.Logger = Logger;\nexport { Logger };\n","import { Lyte } from \"@slyte/core\";\nimport { errorCodes } from \"@slyte/core/src/errors.js\";\nimport { Service } from \"@slyte/core\";\nimport { Logger } from './lyte-error';\nimport { resolvePromises } from './rsvp';\nconst _keywords = {\n  \"component\" : [\"init\", \"didConnect\", \"didDestroy\", \"constructor\", \"onError\", \"actions\", \"methods\", \"data\"],\n  \"adapter\" : [\"namespace\", \"actionNamespace\", \"host\", \"withCredentials\", \"buildURL\", \"methodForRequest\", \"headersForRequest\", \"reloadRecord\", \"reloadRecord\", \"reloadAll\", \"processRequest\", \"parseResponse\", \"parseRequest\", \"super\"],\n  \"serializer\" : [\"normalize\", \"normalizeResponse\", \"serialize\", \"serializeKey\", \"deserializeKey\", \"extractMeta\", \"payloadKey\", \"serializeRecord\", \"normalizeRecord\", \"super\"],\n  \"route\" : [\"getDependencies\", \"getResources\", \"beforeModel\", \"model\", \"afterModel\", \"redirect\", \"renderTemplate\", \"afterRender\", \"beforeExit\", \"didDestroy\", \"queryParams\", \"title\", \"routeName\", \"component\", \"parent\", \"currentModel\", \"forceFetch\", \"setTitle\", \"setQueryParams\", \"getQueryParams\", \"setDynamicParam\", \"getDynamicParam\", \"removeFromCache\", \"refresh\", \"transitionTo\", \"replaceWith\",\"actions\"]\n};  \n// var arrayUtils =  function() {\n//     let lc = window.CrmComponentRegistry._instanceList[0]._getLyteComponent();\n//     return lc.aF.apply(lc, arguments);\n// };\n// var objectUtils =  function() {\n//     let lc = window.CrmComponentRegistry._instanceList[0]._getLyteComponent();\n//     return lc.oF.apply(lc, arguments);\n// }\n// var set = function(){\n//   return LyteComponent.set.apply(LyteComponent,arguments);\n// }\n// var get = function(){\n//   return LyteComponent.get.apply(LyteComponent,arguments);\n// }\n// var render = function() {\n//   return LyteComponent.render.apply(LyteComponent, arguments);\n// }\n// var modifyTemplate = function(){\n//   return LyteComponent.modifyTemplate.apply(LyteComponent,arguments);\n// }\n// var compileDynamicTemplate = function(){\n//   return LyteComponent.compileDynamicTemplate.apply(LyteComponent,arguments);\n// }\n// var doDomProcessing = function(){\n//   return LyteComponent.doDomProcessing.apply(LyteComponent,arguments);\n// }\n// var getComponentTemplate = function(){\n//   return LyteComponent.getComponentTemplate.apply(LyteComponent,arguments);\n// }\n// var addLyteEventListener = function(){\n//   return Lyte.Component.addLyteEventListener.apply(Lyte.Component,arguments);\n// }\n// var removeLyteEventListener = function(){\n//   return Lyte.Component.removeLyteEventListener.apply(Lyte.Component,arguments);\n// }\nfunction getNearestApp(node){\n    while(node){\n      if(node.component){\n        return node.component.getApp();\n      }\n      node = node.parentElement;\n    }\n    return Lyte._getDefaultAppIns();\n}\nfunction defProp() {\n\tObject.defineProperty.apply(Object, arguments);\n}\n\nfunction defProps() {\n\tObject.defineProperties.apply(Object, arguments);\n}\n\nfunction observes(){\n  var args = Array.from(arguments), \n  func = args.pop(), \n  properties = [];\n  args.forEach(function(observerValue) {\n      let valueDetails = observerValue.split(\"::\"), \n      observerType = valueDetails[0], \n      observerTo = valueDetails[1];\n      switch(observerType){\n          // case \"event\":{\n          //     customCrmComponent._callbacks[observerType].push(observerFunction);\n          // }\n          // break;\n          // case \"action\":\n          // case \"method\":\n          // {\n          //     customCrmComponent._callbacks[observerType].push({[observerTo] : observerFunction});\n          // }\n          // break;\n          default :{\n              properties.push(observerType);\n          }\n      }\n  })\n  if(properties.length){\n    var observerObj = {\n        properties:properties,\n        type:\"observer\",\n        value:func\n    }\n    return observerObj;\n  }\n}\n\nfunction isKeyword(key, scope){\n  var arr = [\"component\", \"adapter\", \"serializer\", \"route\"];\n  if(scope){\n    arr = [scope];\n  }\n  var len = arr.length;\n  for(var i=0;i<len;i++){\n    var keyArr = _keywords[arr[i]];\n    if(keyArr){\n      var res = keyArr.indexOf(key);\n      if(res != -1){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction injectServiceToModules(scp, services){\n  var mdlObj = scp.$.injectServices;\n  for(var mKey in mdlObj){\n    var mdl = mdlObj[mKey];\n    for(var name in services){\n      mdl(name, serv[name], mKey);\n    }\n  }\n}\n\n// function addToInstance(ins) {\n//   if(ins.is != \"app\"){\n//     if(!__instances[ins.is].hasOwnProperty(ins.name))\n//     {\n//       __instances[ins.is][ins.name] = ins;\n//     }\n//     else{\n//       Lyte.warn(\"L001\", ins.is, ins.name);\n//     } \n//   }\n//   else{\n//     if(!__instances[ins.is]){\n//       __instances[ins.is] = ins;\n//     }\n//     else{\n//       Lyte.warn(\"L001\", ins.is, \"\");\n//     }\n//   }\n// }\n\n// function createEngineInstance(engineName,config){\n//   var ins = new Lyte('engine',engineName,config);\n//   ins = Object.assign(ins,__instances.engine[engineName]);\n//   return ins;\n// }\n\nfunction registerErrorCodes(obj, lyte) {\n    Object.assign(errorCodes, obj);\n}\n\n\nfunction isEntity(object){\n  if(object && object.$ && object.$.hasOwnProperty(\"isModified\")) {\n    return true;\n  }\n  return false;\n}\n\nfunction isRecord(object){\n  if(object && object.$ && object.$.hasOwnProperty(\"isModified\")) {\n    return true;\n  }\n  return false;\n}\nfunction getVal(key,target){\n  return target && target.__config && (target.__config[key]?\"true\":(target.__config[key] == false?\"false\":undefined));\n}\nfunction getConfig(key,target){\n  if(!target){\n    target = LyteCls._instances[0].$router.getRouteInstance();\n    return getVal(key,target.$component)||\n          ((!target._callee)?getVal(key,target.$app): getConfig(key,target._callee));\n  }\n  else{\n    return getVal(key,target.component)||\n          getVal(key,target.$component)||\n          ((!target._callee)?getVal(key,target.$app): getConfig(key,target._callee));\n  }\n}\nfunction getCurrentRouterInstance(){\n  return LyteCls._instances[0].$router.getRouteInstance();\n}\n// function getConfig(key,regIns){\n//   var configObj = window.__config;\n//   if(configObj){\n//       return {value:configObj[key],...((regIns)?{regIns:window.__config.getIns}:{})};\n//   }\n// }\n\nfunction triggerEvent() {\n  var args = Array.prototype.slice.call(arguments, 1)\n  var eventName = arguments[0];\n  var stopEvent = false;\n  var s = this.__lyteRegisteredEvents[eventName];\n    if(!s) {\n      s = this.__lyteRegisteredEvents[eventName] = {\"listeners\" : new Map()};\n    } else {\n      var mp = s.listeners, keys = Array.from(mp.keys()), kLen = keys.length;    \n      for(var i=0;i<kLen;i++) { \n        var func = mp.get(keys[i]);\n        if(func) {\n           var ret = func.apply(this, args);\n           if(ret === false) {\n             stopEvent = true;\n             break;\n           }\n        }\n      }\n    }\n    var customEvent = new CustomEvent(eventName, {\"detail\" : args});\n    if(!stopEvent) {\n     document.dispatchEvent(customEvent); \n    } \n }\n\nfunction addEventListener(eventName, func) {\n  if(typeof func !== \"function\") {\n      Lyte.error(\"Second parameter to Lyte.Component.addGlobalEventListener() must be a function\");\n      return;\n  }\n  var s = this.__lyteRegisteredEvents[eventName];\n  if(!s) {\n    s = this.__lyteRegisteredEvents[eventName] = {\"listeners\" : new Map()};\n  }\n  var id = genMapId(s.listeners);\n  var d = s.listeners.set(id, func);\n  return eventName + \"-\" + id;\n}\n\nfunction removeEventListener(id) {\n  if(!id) {\n    Lyte.error(\"listener unique id not specified\");\n    return;\n  }\n   var arr = id.split(\"-\"), evid = arr.pop(), name = arr.join(\"-\");\n   var s = this.__lyteRegisteredEvents[name];\n   if(!s || !s.listeners.get(evid)) {\n     Lyte.error(\"No such listener registered\");\n     return;\n   }\n   s.listeners.delete(evid);\n}\n\nfunction genMapId(map){\n  var id = Math.floor(Math.random()*10000000000 + 1);\n  while(map.get(id)){\n      id = Math.floor(Math.random()*10000000000 + 1)\n  }\n  return id.toString();\n}\n\n// function checkNestedProp (id, path, dtype, wobj, object, property, value, check, fromStore) {\n//   if (dtype && path.length != 0){\n//       var extend;\n//       if(Lyte.Transform[dtype.type]){\n//           extend = true;\n//       }\n//       if (dtype.type == 'array' || (extend && Lyte.Transform[dtype.type].extends == \"array\")) {\n//           if (dtype.items && !isNaN(path[0]) && _typeof(dtype.items) == 'object') {\n//               path = path.slice(1);\n//               checkNestedProp(id, path, dtype.items, wobj, object, property, value, check);\n//           }\n//       } else if (dtype.type == \"object\" || (extend && Lyte.Transform[dtype.type].extends == \"object\")) {\n//           if (dtype.properties){\n//               var k = path[0];\n//               path = path.slice(1);\n//               checkNestedProp(id, path, k == \"\" ? dtype :dtype.properties[k], wobj, object, property, value, check);\n//           }\n//       }\n//   // } else if (dtype.properties && Lyte.isRecord(value) && !check.hasOwnProperty(\"warn\")) {\n//   //     check.warn = { warn: true, message: \"Nested property will not support for the record\" };\n//   } \n//   else {\n//       var err;\n//       if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty(\"warn\")) {\n//           var component = {};component.__data = {};\n//           if (dtype.properties) {\n//               component.__data[property] = dtype.properties[property];\n//           } else {\n//               component.__data[property] = dtype;\n//           }\n//           var cp = validateData(object, property, value, component);\n//           var errKey = wobj.attr ? wobj.attr : wobj.key,_path = wobj.path.split(\".\");\n//           if (cp && (typeof cp === 'undefined' ? 'undefined' : _typeof(cp)) == \"object\" && cp.code) {\n//               cp.value = value;\n//               cp.path = wobj.path !=\"\"?wobj.path:property;\n//               if(wobj.isRec && fromStore && wobj.key ==  undefined && wobj.path!=\"\"){\n//                   errKey = wobj.path.split(\".\")[0]\n//                   _path.shift();\n//                   _path = (_path.length == 1 && _path[0] == property) ? [] : _path;\n//               }\n//               wobj.Error = {};\n//               wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };\n//               wobj.Error[errKey].code = \"ERR34\"\n//               wobj.Error[errKey].message = Logger.errorCodes.ERR34;\n//               err = wobj.Error[errKey].nested;\n//               wobj._cmpErr[errKey].code = \"ERR34\";\n//               wobj._cmpErr[errKey].message = Logger.errorCodes.ERR34 ;\n//               var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [] ;\n//               if(wobj.path !=\"\"){\n//                   _path.forEach(function (k) {\n//                       if (err && !err[k]) {\n//                           err = err[k] = {};\n//                       } else {\n//                           err = err[k];\n//                       }\n//                   });\n//               }\n//               wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;\n//               cmpErrPath.push(wobj.index == undefined && property? wobj.path+\".\"+property : wobj.index !=undefined ? wobj.path+\".\"+wobj.index : wobj.path)\n//               wobj._cmpErr[errKey].path = cmpErrPath;\n//           } else{\n//               if(wobj.isRec && fromStore && wobj.key ==  undefined){\n//                   errKey = wobj.path.split(\".\")[0]\n//                   _path.shift();\n//                   _path = (_path.length == 1 && _path[0] == property) ? [property] : _path;\n//               }\n//               err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;\n//               //var p = object.$.error[property];\n//               if(err){\n//                   var key = wobj.index || property; \n//                   var flag = true,\n//                   p = wobj.path !=\"\"?_path:[property];\n//                   wobj.index ? p.push(wobj.index) : p;\n//                   var prev;\n//                   p.forEach(function (r) {\n//                       if (err[r] && err[r].code) {\n//                           delete err[r];\n//                           if(err && Object.keys(err).length == 0){\n//                               flag = true;\n//                           }\n//                           else{\n//                               flag = false;\n//                           }\n//                       }\n//                       err = err[r];\n//                   });\n//                   if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {\n//                       delete wobj.Error[errKey];\n//                       delete wobj._cmpErr[errKey]\n//                   }\n//               }\n\n//           }\n//           if((check.value && check.value.hasOwnProperty(\"code\") && cp.code) || !check.value){\n//               check.value = cp;\n//           }\n//       }\n//   }\n//   wobj.path && delete wobj.path;\n//   wobj.index && delete wobj.index;\n//   wobj.attr && delete wobj.attr;\n// };\n\nfunction checkNestedProp(id,path,dtype,wobj,object,property,value,check){\n  if(path.length!=0){\n      if(dtype.type == 'array'){\n          if(dtype.items && !isNaN(path[0]) && typeof(dtype.items)=='object'){\n              path= path.slice(1);\n              checkNestedProp(id,path,dtype.items,wobj,object,property,value,check)\n          }\n      }\n      else if( dtype.type == \"object\"){\n          if(dtype.properties && dtype.properties.hasOwnProperty(path[0])){\n              var k = path[0];\n              path = path.slice(1);\n              checkNestedProp(id,path,dtype.properties[k],wobj,object,property,value,check);\n          }\n      }\n  }\n  else{\n      var err;\n      if(dtype.properties || dtype.items){\n          var component={};component.__data={};\n          if(dtype.properties){\n                  component.__data[property]=dtype.properties[property];\n              }\n              else{\n                  component.__data[property]=dtype;\n              }\n          var cp = validateData(object, property, value, component);\n          if(cp && typeof(cp)==\"object\" && cp.code){\n              cp.value=value;\n              cp.path=wobj.path;\n              (wobj.Error && wobj.Error[wobj.key])?(wobj.Error[wobj.key].code && wobj.Error[wobj.key].nested)?wobj.Error[wobj.key].nested:wobj.Error[wobj.key].nested={}:wobj.Error[wobj.key]={code:cp.code,message:cp.message,nested:{}};\n              err = wobj.Error[wobj.key].nested;\n              wobj.path.split('.').forEach(function(k){\n                  if(err && !err[k]){\n                      err=err[k]={};\n                  }\n                  else{\n                      err=err[k];\n                  }\n              })\n              wobj.index?err[wobj.index]=cp:err[property]=cp;\n              (object.$ && object.$.error)?object.$.error=err:object.$={error:err};\n              Object.defineProperty(object,'$',{\n                  enumerable:false,\n                  writable:false\n              });\n          }\n          else if(!cp && object.$ && (object.$.error[property] ||(wobj.index && object.$.error[wobj.index]))){\n              err = wobj.Error[wobj.key].nested||undefined;\n              var key = wobj.index||property;\n              delete object.$.error[key];\n              var f = true,p=wobj.path.split(\".\");\n              (wobj.index)?p.push(wobj.index):p;\n              p.forEach(function(r){\n                  if(err[r] && err[r].code){\n                      f=false;\n                  }\n                  err=err[r];\n              });\n              if(f == true && wobj.Error[wobj.key]){\n                  delete wobj.Error[wobj.key];\n              }\n          }\n          check.value=cp;\n      }\n  } \n}\n\nvar types = [\"string\", \"object\", \"number\", \"boolean\", \"array\", \"component\"];\nfunction prop(type, opts){\n  var obj = {};\n  obj.type = type;\n  obj._type = \"prop\";\n  if(opts == undefined){\n    opts = {};\n  }\n  Object.assign(obj,opts);\n  return obj;\n}\n\nfunction one(name,opts){\n  return defineRelation(name,\"belongsTo\",opts);\n}\n\nfunction many(name,opts){\n  return defineRelation(name,\"hasMany\",opts);\n}\n\nfunction extendEventListeners(scp){\n  if(scp && !scp.hasOwnProperty(\"__lyteRegisteredEvents\")){\n      Object.defineProperties(scp, {\n          __lyteRegisteredEvents : {\n              value : {}\n          },\n          addEventListener : {\n              value : addEventListener\n          },\n          removeEventListener : {\n              value : removeEventListener\n          },\n          triggerEvent : {\n              value : triggerEvent\n          }\n      });\n  }\n}\n\nfunction getSuperClass(obj, getName){\n\tvar cons = obj, isInstance = (typeof obj === \"object\");\n\tif(isInstance){\n\t\tcons = obj.constructor;\n\t}\n\tvar bClass = Object.getPrototypeOf(cons);\n\tif((!(bClass instanceof Function)) || bClass === Service){\n\t\tif(getName){\n\t\t\treturn obj.name;\n\t\t}\n\t\treturn obj;\n\t} \n\treturn getSuperClass(bClass, getName);\n}\n\nfunction isInheritedClass(baseObj, inheritedClass){\n  var cons = baseObj, isInstance = (typeof obj === \"object\");\n  if(isInstance){\n    cons = baseObj.constructor;\n  }\n  var bClass = Object.getPrototypeOf(cons);\n  if((bClass.hasOwnProperty(\"__lyteOrigClass\") && bClass.__lyteOrigClass == inheritedClass) || (bClass == inheritedClass)){\n    return true;\n  }\n  else if((!(bClass instanceof Function)) || bClass === Service){\n    return false;\n  }  \n  return isInheritedClass(bClass, inheritedClass); \n}\n\nfunction newGetSuperClass(obj, getName, toBeCompared, getClass) {\n  var cons = obj, isInstance = (typeof obj === \"object\");\n  if(isInstance){\n    cons = obj.constructor;\n  }\n  var bClass = Object.getPrototypeOf(cons);\n  if(bClass.__lyteOrigClass == toBeCompared){\n    return true;\n  }\n  else if((!(bClass instanceof Function)) || bClass === Service){\n    // return false;\n    if(getName){\n      return obj.name;\n    } else if(getClass){\n      return obj;\n    }\n    return obj;\n  }  \n  return newGetSuperClass(bClass, getName, toBeCompared);    \n}\n\nfunction includeMixins(arr,mainClass){\n  if(arr.length == 0) {\n    return mainClass;\n  } \n  var currentClass = mainClass;\n  for(var i=0;i<arr.length;i++) {\n    var classVar = arr[i];\n    var classFunction = classVar._classFunc;\n    currentClass = classFunction(currentClass, classFunction.overrides,classFunction._proxy);\n  }\n  return currentClass;\n}\nfunction getClass(arr, mainClass,clsObj) {\n  if(arr.length == 0) {\n      return mainClass;\n  }\n  var currentClass = mainClass;\n  for(var i=0;i<arr.length;i++) {\n    var classVar = arr[i];\n    var classFunction = classVar._classFunc;\n    currentClass = classFunction(currentClass, classFunction.overrides,classFunction._proxy);\n  }\n\n  return currentClass;\n}\n\n\nFunction.prototype.tempApply=Function.prototype.apply;\nFunction.prototype.tempCall=Function.prototype.call;\nFunction.prototype.tempBind=Function.prototype.bind;\nvar classObj = {};\nfunction createCustomClass(classDefFunc, fromInside) {\n\n  class LyteModule {\n      constructor() {\n          if(window.ssss1) {\n              this.constructor = window.ssss1;\n              window.ssss1 = undefined;\n          }\n      }\n    static actions(arg1) {\n      return arg1 ? arg1 : {};\n    }\n    static methods(arg1) {\n      return arg1 ? arg1 : {};\n    }\n    static observers(arg1) {\n      return arg1 ? arg1 : {};\n    }\n    data(arg1) {\n      return arg1 ? arg1 : {};\n    }\n   \n  }\n    var dummyObj={};\n\n    var proxy = new Proxy(class {\n        static [Symbol.hasInstance](instance) {  // checks if the object's prototype chain contains the [Symbol.hasInstance] method\n          console.log(\"inside  custom instanceof check\")\n          return instance instanceof dummyObj.arg1._initialCopyClass;\n        }\n      },{\n      \"construct\" : function(a,b,c) {\n        if(c==proxy) {\n          window.ssss1 = dummyObj.retClass;\n          let constr=Reflect.construct(dummyObj.retClass._initialCopyClass, b);\n          if(constr._afterConstructor){\n            constr._afterConstructor();\n          }\n          return constr;\n        } else {\n          return Reflect.construct(dummyObj.arg1, b,c);\n        }\n          \n      }, \n      \"get\" : function(target, prop,value) {\n        if(prop == \"prototype\") {\n          return Reflect.get(...arguments);\n        } else if(prop == \"hasOwnProperty\" ) {\n          return function(prop1) {\n              return dummyObj.arg1.hasOwnProperty(prop1);\n          }  \n        }\n        else if(dummyObj.arg1.hasOwnProperty(prop)) {\n          return dummyObj.arg1[prop];\n        }\n        else if(prop.toString()==='Symbol(Symbol.hasInstance)'){\n          return Reflect.get(target, prop,value);\n        } \n        else {\n          return Reflect.get(dummyObj.arg1, prop,value);\n        }\n      }, \n      \"set\" : function(target, prop, value, receiver) {\n        dummyObj.arg1._updateStaticVal(prop, value, receiver);\n          return true;\n      }, \n      \"getPrototypeOf\": function(target){\n        return Reflect.getPrototypeOf(dummyObj.arg1); \n      },\n      \"defineProperty\": function(target, key, descriptor) {\n        dummyObj.arg1._defineProperty(target,key,descriptor);\n          return true;\n        },\n        \n      \"getOwnPropertyDescriptor\":function(target,prop){\n          if( Object.hasOwn(dummyObj.arg1,prop)){\n            return {\n              value:dummyObj.arg1[prop],\n              enumerable : true,\n              configurable : true,\n              writable : true\n          };\n          }\n          else {\n            return Reflect.getOwnPropertyDescriptor(...arguments)  ;\n          }\n        } ,\n        \"deleteProperty\":function(target,prop,value){\n          return dummyObj.arg1._deleteProperty(target,prop);\n        }\n      });\n  var retClass = classDefFunc(LyteModule, function(arg1,cacheObj) {\n      if(arg1.name[0]=='_'){\n          Object.defineProperty(arg1,\"name\",{value:arg1.name.slice(1)});\n      }\n      dummyObj.arg1 = arg1;\n      arg1._lyteClasses = [];\n    arg1._lyteClasses = [];  //keep track of classes that have been extended from retClass.\n  \n    arg1._updatePrototypeVal = function(prop, value) {\n       arg1.prototype[prop]=value;\n       this._lyteClasses.forEach(function(item){\n        item.prototype[prop]=value;\n       });  \n  }\n  arg1._deleteProperty=function(target,prop){\n    if(arg1[prop]){\n      delete arg1[prop];\n      this._lyteClasses.forEach(function(item){\n        delete item[prop];\n      })\n    }\n    delete arg1.prototype[prop];\n    this._lyteClasses.forEach(function(item){\n      delete item.prototype[prop];\n    });\n  }\n\n  arg1._defineProperty = function(target, prop, descriptor) {\n  Object.defineProperty(arg1,prop,descriptor);\n    this._lyteClasses.forEach(function(item) {\n      if(descriptor==undefined){\n        item.prototype[prop]=undefined;\n      }else{\n        Object.defineProperty(item, prop, descriptor);\n      }\n    });\n\n  }\n\n  arg1._updateStaticVal = function(prop, value, receiver) {\n    //updates the static values of arg1 and all the classes in _lyteClasses with the provided prop and value.\n    // arg1[prop]=value;\n    this[prop] = value;\n    if(cacheObj && cacheObj.hasOwnProperty(prop)){\n      cacheObj[prop]=value;\n    }\n    this._lyteClasses.forEach(function(item) {\n      item[prop] = value;\n    });\n  }\n  arg1._hasOwnProperty=function(target,prop,receiver){\n    return arg1.prototype.hasOwnProperty(prop)\n  }\n\n     let tempProxy=new Proxy({} /*proxy.prototype*/, {\n\n      \"get\" : function(target, prop) {\n        //  if(Object.hasOwn(arg1._initialCopyClass.prototype,prop))\n        //    return arg1.prototype[prop];\n        if(prop === \"deleteProp\") {\n            return function(prop1) {\n                 return arg1._deleteProperty(target, prop1, undefined);\n                 };\n          }\n          else if(prop==\"hasOwnProperty\"){\n            return function(prop1){\n                return arg1._hasOwnProperty(target,prop1);\n            }\n        }\n        else {\n          if(arg1.prototype[prop] && typeof arg1.prototype[prop]==\"function\" ) {\n              arg1.prototype[prop].apply = function() {\n                  let tempArgument=arguments[0];\n                  while(tempArgument){\n                      if(arg1._proxy==tempArgument.constructor){\n                          return arg1._initialCopyClass.prototype[prop].tempApply(tempArgument, arguments[1]);\n                      }\n                      tempArgument=Object.getPrototypeOf(tempArgument);\n                  }\n                return  arg1.prototype[prop].tempApply(arguments[0],arguments[1]);\n              }\n              arg1.prototype[prop].call = function() {\n                  let tempArgument=arguments[0];\n                  while(tempArgument){\n                      if(arg1._proxy==tempArgument.constructor){\n                          return arg1._initialCopyClass.prototype[prop].tempCall(tempArgument, arguments[1]);\n                      }\n                      tempArgument=Object.getPrototypeOf(tempArgument);\n                  }\n                return  arg1.prototype[prop].tempCall(arguments[0],arguments[1]);\n              }\n              arg1.prototype[prop].bind = function() {\n                  let tempArgument=arguments[0];\n                  while(tempArgument){\n                      if(arg1._proxy==tempArgument.constructor){\n                          return arg1._initialCopyClass.prototype[prop].tempBind(tempArgument, arguments[1]);  \n                      }\n                      tempArgument=Object.getPrototypeOf(tempArgument);\n                  }\n                return  arg1.prototype[prop].tempBind(arguments[0],arguments[1]);\n              }\n          }\n            return arg1.prototype[prop];\n      }\n          \n      }, \n      \"set\" : function(target, prop, value) {    \n          arg1._updatePrototypeVal(prop, value);\n          return true;\n      }, \n      \"defineProperty\" : function(target, prop, value) {\n        arg1._defineProperty(target, prop, value);\n      },\n      \"getPrototypeOf\": function(target){\n        return Reflect.getPrototypeOf(arg1); \n      }, \n  })  ;\n   Object.setPrototypeOf(proxy.prototype,tempProxy);                                        \n  return proxy;\n  },proxy);\n  retClass._proxy = proxy;\n  dummyObj.retClass = retClass;\n  classDefFunc._proxy = proxy;\n  \n  // var initialCopyClass = classDefFunc(LyteModule, overrides,proxy);\n  var initialCopyClass=overrides(dummyObj.arg1);\n  function overrides(cls) {\n      if(cls.name[0]=='_'){\n          Object.defineProperty(cls,\"name\",{value:cls.name.slice(1)});\n      }\n      retClass._lyteClasses.push(cls);\n      cls.prototype.__origConstructor = cls;\n      cls.__lyteOrigClass = retClass;\n      if(retClass._lyteClasses.length>1){\n          let baseCls=retClass._lyteClasses[0];\n          let arr=Object.getOwnPropertyNames(retClass._lyteClasses[0]);\n          for(let i=0;i<arr.length;i++){\n              if(!cls.hasOwnProperty(arr[i])){\n                  cls[arr[i]]=baseCls[arr[i]];\n              }\n          }\n      let arr1=Object.getOwnPropertyNames(retClass._lyteClasses[0].prototype);\n          for(let i=0;i<arr1.length;i++){\n              if(!cls.prototype.hasOwnProperty(arr1[i])){\n                  cls.prototype[arr1[i]]=baseCls.prototype[arr1[i]];\n              }\n          }\n      }\n    return cls;\n  }\n\n\n  classDefFunc.overrides = overrides;\n  retClass._classFunc = classDefFunc;\n  initialCopyClass._classFunc=classDefFunc;   //new changes\n  // retClass._initialCopyClass = initialCopyClass; //new changees\n  dummyObj.arg1._initialCopyClass = initialCopyClass;\n  classDefFunc._mainClass = retClass;\n  if(initialCopyClass.name[0]=='_'){\n      Object.defineProperty(initialCopyClass,\"name\",{value:initialCopyClass.name.slice(1)});\n\n  }   \n  return retClass;\n}\n\nfunction getCustomData(scp, fieldVal, fromDb){\n  if(fromDb){\n    if(scp && scp.dataType && scp.dataType.hasOwnProperty(fieldVal)){\n      return scp.dataType[fieldVal];\n    }\n    scp = scp.lyte;\n  }\n  if(scp && scp.dataType && scp.dataType.hasOwnProperty(fieldVal)){\n    return scp.dataType[fieldVal];\n  }\n}\nfunction checkProperty(property, dataVal, key, fieldVal, record, name, scp, errorCodes ,init, field, fromDb){\n  // var errorCodes = scp.errorCodes;\n  var exts = \"extends\";\n  switch(property){\n    case \"type\" : \n      if(typeof fieldVal !== \"string\"){\n        var _fld = getCustomData(scp, fieldVal._name, fromDb);\n        if (_fld && dataVal !== undefined && dataVal !== null) {\n          var _ret = true;\n          if (Array.isArray(dataVal)) {\n              if (_fld.type != \"array\") {\n                  return { code: \"ERR03\", message: errorCodes.ERR03, expected: fieldVal };\n              }\n              if(_fld.hasOwnProperty(\"items\")){\n                  _ret = checkProperty(\"items\", dataVal, key, _fld.items);\n              }\n          }else if(typeof dataVal === \"object\" && _fld.type == \"object\" && _fld.hasOwnProperty(\"properties\")){\n              _ret = checkProperty(\"properties\", dataVal, key, _fld.properties);\n          } \n          else if (fieldVal && _fld.type != typeof(dataVal)) {\n            return { code: \"ERR03\", message: errorCodes.ERR03, expected: fieldVal };\n          }\n          if(_ret !== true){\n              return _ret;\n          }\n        }\n      }\n      else if(dataVal !== undefined && dataVal !== null){\n        if(Array.isArray(dataVal)){\n          if(fieldVal != \"array\"){\n              return {code : \"ERR03\", message : errorCodes.ERR03, expected : fieldVal};\n          }\n        }\n        else if(dataVal && dataVal._compName){\n          if(fieldVal != \"component\"){\n            return {code : \"ERR03\", message : errorCodes.ERR03, expected : fieldVal};\n          }\n        }\n        else if(fieldVal != (typeof dataVal)){\n          return {code : \"ERR03\", message : errorCodes.ERR03, expected : fieldVal};\n        }\n      }\n      break;\n    case \"mandatory\":\n        let validateFlag = fieldVal;\n        if(typeof fieldVal == \"object\"){\n          if(init && fieldVal.skipValidationOnInit == true){\n            validateFlag = false;\n          }\n        }\n        if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === \"\")) {\n          return { code: \"ERR02\", message: errorCodes.ERR02 };\n        }\n      break;\n    case \"maximum\" :\n      if((typeof dataVal == \"number\") && dataVal > fieldVal){\n        return {code : \"ERR04\", message : errorCodes.ERR04, expected : fieldVal};\n      }\n      break;\n    case \"minimum\" :\n      if((typeof dataVal == \"number\") && dataVal < fieldVal){\n        return {code : \"ERR05\", message : errorCodes.ERR05, expected : fieldVal};\n      }\n      break;\n    case \"maxLength\" :\n    case \"maxItems\" :\n      if(dataVal && dataVal.length > fieldVal){\n        return {code : \"ERR06\", message : errorCodes.ERR06, expected : fieldVal};\n      }\n      break;\n    case \"minLength\" :\n    case \"minItems\" :\n      if(dataVal && dataVal.length < fieldVal){\n        return {code : \"ERR07\", message : errorCodes.ERR07, expected : fieldVal};\n      }\n      break;\n      case \"pattern\" :\n        if(typeof fieldVal == \"string\"){\n            var _scp = scp;\n            if(fromDb){\n              _scp = scp.lyte;\n            }\n            if(_scp){ \n              if(_scp.patterns && _scp.patterns.hasOwnProperty(fieldVal)){\n                fieldVal = _scp.patterns[fieldVal];\n              }\n              else{\n                Logger.warn(\"Pattern with name - \"+ fieldVal+\" is not registered\");\n                break;\n              }\n            }\n          }\n          if( typeof dataVal == \"string\" && !(new RegExp(fieldVal).test(dataVal))){\n            return {code : \"ERR08\", message : errorCodes.ERR08, expected : fieldVal};\n          }\n          break;\n      case \"uniqueItems\" :{\n      if(Array.isArray(dataVal) && fieldVal){\n        var newArr = [];\n        for(var i=0; i<dataVal.length; i++){\n          var val = dataVal[i];\n          if(newArr.indexOf(val) != -1){\n            return {code : \"ERR09\", message : errorCodes.ERR09};\n          }\n          newArr.push(val);\n        }         \n      }\n      break;        \n    }\n    case \"constant\" :\n      if(Array.isArray(dataVal)){\n        var resp = dataVal.length==fieldVal.length && dataVal.every(function(v,i) { return v === fieldVal[i]});\n        if(!resp){\n          return {code : \"ERR10\", message : errorCodes.ERR10, expected : fieldVal};\n        }\n      }\n      else if(typeof dataVal == \"object\"){\n        var resp = db.connector.$.compareObjects(dataVal, fieldVal);\n        if(!resp){\n          return {code : \"ERR10\", message : errorCodes.ERR10, expected : fieldVal};\n        }\n      }\n      else if(dataVal && dataVal != fieldVal){\n        return {code : \"ERR10\", message : errorCodes.ERR10, expected : fieldVal};\n      }\n      break;\n    case \"items\" :{\n      if(Array.isArray(dataVal)){\n        for(var i=0; i<dataVal.length; i++){\n          for(var property in fieldVal){\n            var resp = checkProperty(property, dataVal[i], i, fieldVal[property], undefined, undefined, scp, errorCodes, undefined, fieldVal);\n            if(resp != true){\n              resp.path = resp.path ? i + \".\" + resp.path : resp.path;\n              return resp;\n            }\n          }\n        }         \n      }\n      break;        \n    }\n    case \"properties\" :\n      if(typeof dataVal == \"object\" && !Array.isArray(dataVal)){\n        for (var key in dataVal) {\n          if(fieldVal.hasOwnProperty(key)){\n              var fld = fieldVal[key]\n              for (var property in fld) {\n                  var resp = checkProperty(property, dataVal[key], key, fld[property], undefined, undefined, scp, errorCodes, undefined, fld);\n                  if (resp != true) {\n                      resp.path = resp.path ? property + \".\" + resp.path : property.toString();\n                      return resp;\n                  }\n              }\n          }\n          else if(field.exact){\n              return { code : \"ERR29\", message: Lyte.errorCodes.ERR29, property: key };\n          }\n        }\n      }\n      break;\n    case \"validation\" :{\n      var validator = fieldVal;\n      if(validator){\n        var resp =  validator.validate.apply(record, [key, dataVal, name]);\n        if(resp != true){\n          return resp;\n        }\n      }       \n    }\n    break;\n    case \"instanceof\": \n    {\n        if(typeof dataVal === \"object\" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)){\n            return { code: \"ERR30\", message: Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal};\n        }\n    }\n  }\n  return true;\n}\n\nfunction validateData(object, key, value, component,scp ,init) {\n  var definition = component.__data[key];\n  var isError = false;\n  var type = definition ? definition.type : undefined;\n  for(var defKey in definition) {\n    let app = component.getApp ? component.getApp() : undefined;\n    isError =  checkProperty(defKey, value, key, definition[defKey], object, undefined, app, Logger.errorCodes, init, definition);\n    if(isError !== true) {\n      return isError;\n    }\n  }\n  return false;\n}\n\nfunction deepCopyObject(obj){\n  return copyObject(obj, true);\n}\n\nfunction copyObject( obj, internal )  {\n  var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n  var current, copies = [{source : obj, target : targetVal}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];\n  var cloneObject = copies[0].target, targetReferences = [cloneObject];\n  while(current = copies.shift()){\n      keys = Object.keys(current.source);\n      for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){\n          descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);\n          if(!descriptor){\n              continue;\n          }\n          if(!descriptor.value || typeof descriptor.value != \"object\"){\n              Object.defineProperty(current.target, keys[propertyIndex], descriptor);\n              continue;\n          }\n          nextSource = descriptor.value;\n          if(!(descriptor.value instanceof Promise)){\n            descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));\n          }\n          indexOf = sourceReferences.indexOf(nextSource);\n          if(indexOf != -1){\n              descriptor.value = targetReferences[indexOf];\n              Object.defineProperty(current.target, keys[propertyIndex], descriptor);\n              continue;\n          }\n          sourceReferences.push(nextSource);\n          targetReferences.push(descriptor.value);\n          Object.defineProperty(current.target, keys[propertyIndex], descriptor);\n          copies.push({source : nextSource, target : descriptor.value});\n      }\n      if(internal){\n        if(isEntity(current.source)){\n          Object.defineProperty(current.target, \"$\", {\n            value: {}\n          });\n          current.target.$.isNew = current.source.$.isNew;\n          current.target.$.isModified = current.source.$.isModified;\n          current.target.$.isDeleted = current.source.$.isDeleted;\n          current.target.$.pK = current.source.$.pK;\n          current.target.$._attributes = current.source.$._attributes;\n          current.target.$.isCloned = true;\n          if(current.source.$.hasOwnProperty(\"deepNest\")){\n            current.target.$.deepNest = current.source.$.deepNest;\n          }\n          if(current.source.$.hasOwnProperty(\"partialType\")){\n            current.target.$.partialType = current.source.$.partialType;\n          }\n        }\n        if(Array.isArray(current.source)){\n          if(current.source.partial){\n            Object.defineProperty(current.target, \"partial\", {\n              value: current.source.partial\n            });\n          }\n        }\n      }\n  }\n  return cloneObject;\n}\n\nfunction defineRelation(name,type,opts){\n  var relation = {type : \"relation\", relType : type, relatedTo : name};\n  if(opts){\n    relation.opts = opts;\n  }\n  return relation;\n}\n\nfunction establishObserverBindings(observers,fromStore,properties,model,lyteScp) {\n  var scope = this;\n  var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;\n  if(fromStore){\n    scope = fromStore;      \n  }\n  for(var i=0;i<observers.length;i++) {\n    var props = observers[i].properties;\n    var obsAttr = {},obsDuplicate=false;\n    var Jpath={}\n    for(var j=0;j<props.length;j++) {\n      var actProp;\n      var isArrayObserver = false;\n      var isObjectObserver = false;\n      if(typeof props[j] == \"string\"){\n        if(props[j].search(/^\\$\\./g)!=-1){\n         \n          var JsonPath = props[j];\n\n          var CmpPropertyPath = JsonPath.match(/[^\\$.][^\\.]*/g)[0]\n          if(CmpPropertyPath.search(/\\[[0-9*]\\]/g)!=-1){\n            CmpPropertyPath = CmpPropertyPath.split(/\\[[0-9*]\\]/g)[0];\n          }\n          if(watchProps[CmpPropertyPath]==undefined){\n            watchProps[CmpPropertyPath]=[];\n          }\n\n          if(Jpath[CmpPropertyPath] == undefined){\n            Jpath[CmpPropertyPath]=[];\n          }\n          \n          var JSONPATH ;\n          var reg = \"^\\\\$\\\\.\"+CmpPropertyPath+\"\\\\.?\"\n          reg = new RegExp(reg);\n          JSONPATH = props[j].replace(reg,\"$.\")\n          if(!watchProps[CmpPropertyPath].includes(JSONPATH)){\n            watchProps[CmpPropertyPath].push(JSONPATH)\n          }\n          \n          if(!Jpath[CmpPropertyPath].includes(JSONPATH)){\n            Jpath[CmpPropertyPath].push(JSONPATH)\n          }\n\n\n          CmpPropertyPath =CmpPropertyPath+\".*\";\n          if(!obsAttr.hasOwnProperty(CmpPropertyPath)){\n            actProp= getProperty.call(this,CmpPropertyPath,fromStore,properties)\n            obsAttr[CmpPropertyPath]=true;\n            obsDuplicate = false;\n          }\n          else{\n            obsDuplicate = true;\n          }\n        }\n        else if(props[j].indexOf('.[]') !== -1) {\n          isArrayObserver = true;\n          actProp = getProperty.call(this,props[j].substring(0, props[j].indexOf('.[]')),fromStore,properties);\n        }\n        else if(props[j].indexOf('.{}') !== -1) {\n          isObjectObserver = true;\n          let objObbName = props[j].substring(0, props[j].indexOf('.{}'))\n          actProp = this.getProperty(objObbName);\n          Object.defineProperty(actProp, '_objectObservers', {\n            value: true,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n\t\t\t  }\n        else {\n          if(props[j].indexOf('.*') !== -1) {\n            var prop = props[j].split(\".\")[0];\n            var isDeepObs = (!fromStore && this.component.__data[prop] && this.component.__data[prop].watch) || (fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch) ? true : false;\n            if(!isDeepObs){\n              continue;\n            }\n          } \n          actProp = getProperty.call(this,props[j],fromStore,properties);\n        }\n      if(!obsDuplicate){\n        if(!actProp._observers) {\n          Object.defineProperty(actProp, '_observers', {\n            value : new Set(),\n            enumerable: false, \n            writable: true,\n            configurable: true\n          });\n        }\n       actProp._observers.add({callee : scope, observer: observers[i], isArrayObserver : isArrayObserver,isObjectObserver:isObjectObserver });\n      }\n    }else{\n      Lyte.warn.call(lyteScp,\"ERR27\",JSON.stringify(props[j]),observers[i].fnName,this.tagName);\n    }\n  }\n  observers[i].Jpath  = Jpath;\n  obsAttr={};\n}\n}\n// getProperty(key) {\n//   var arr = key.match(/([^[\\].]+|\\[\\])/g);\n// let property = this;\n// if(!property._properties[arr[0]]) {\n//       property._properties[arr[0]] = {};\n//   } \n//   property = property._properties[arr[0]];\n\n// defProp(property, '_path', {enumerable: false, value : arr[0]});\n// for(let i=1;i<arr.length;i++) {\n//       if (arr[i].startsWith(\"'\") || arr[i].startsWith('\"')) {//added check\n//           arr[i] = arr[i].substring(1, arr[i].length -1);\n//       }\n//       if(!property[arr[i]]) {\n//           property[arr[i]] = {};\n//           defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + \".\" + arr[i]});\n//       }\n//     property = property[arr[i]];\n//   }\n//  return property;\n// }\nfunction getProperty(key,fromStore,properties) {\n  var arr = key.match(/([^[\\].]+|\\[\\])/g);\n  let property = this;\n  if(fromStore){\n    property = properties;\n    if(!properties[arr[0]]){\n        properties[arr[0]] = {};\n    }\n    property = properties[arr[0]];\n  }\n  else {                      \n    if(!property._properties[arr[0]]) {\n        property._properties[arr[0]] = {};\n    } \n    property = property._properties[arr[0]];\n  }\n\n  Object.defineProperty(property, '_path', {enumerable: false, value : arr[0]});\n  for(let i=1;i<arr.length;i++) {\n    if (arr[i].startsWith(\"'\") || arr[i].startsWith('\"')) {//added check\n      arr[i] = arr[i].substring(1, arr[i].length -1);\n    }\n    if(!property[arr[i]]) {\n        property[arr[i]] = {};\n        Object.defineProperty(property[arr[i]], '_path', {enumerable: false, value : property._path + \".\" + arr[i]});\n    }\n    property = property[arr[i]];\n  }\n  return property;\n}\n\nlet nestScpId = 1;\nconst nestScp = {};\nconst __nestRef__ = {};\nconst __nestScp__ = new Map();\nfunction establishObjectBinding(data, attr, fromStore, update, storeRecord, watch) {\n  var model, fld, nestObj;\n  var checkAttrs=data.__component__ && data.__component__.component.__data?data.__component__.component.__data[attr]:undefined, db;\n  if (fromStore || storeRecord) {\n      model = (data.$)? (data.$.schema ? data.$.schema : data.$.model) :(storeRecord && storeRecord.$.model)?storeRecord.$.model:undefined;\n      db = model.db;\n      fld = model ? model.fieldList[attr] : undefined;\n      if (!fld) {\n          return;\n      }\n      checkAttrs=fld;\n      watch = fld.watch;\n  }\n  if (update && data._scp && data._scp.size) {\n      var keys = Array.from(data._scp.keys());\n      keys.forEach(function (id) {\n        var _mpObj = data._scp.get(id), \n        mpObj = _mpObj.paths;\n          for (var key in mpObj) {\n              var path = key ? key.split(\".\") : [];\n              path.push(attr);\n              bindObj(data, attr, id, path, new Map(),checkAttrs,watch);\n          }\n      });\n  }\n  if ((!fromStore || fld.watch || fld.properties || fld.items || watch) && data[attr]) {\n      var _scpObj, kmpKey;\n      if (data && data.__component__) {\n          data.__component__.__scpObj || Object.defineProperty(data.__component__, \"__scpObj\", {\n              value: {}\n          });\n          kmpKey = data.__component__;\n          _scpObj = data.__component__.__scpObj;\n      } else if (isEntity(data)) {\n          data.$.__scpObj || Object.defineProperty(data.$, \"__scpObj\", {\n              value: {}\n          });\n          kmpKey = data;\n          _scpObj = data.$.__scpObj;\n      }\n      var obj = _scpObj,\n      id;\n      if (_scpObj) {\n          var __nestScp1Set__ = false, __nestScp2Set__ = false;\n          if (fromStore) {\n              if(data[attr] && !__nestScp__.has(data[attr])){\n                  nestObj = { db: db, model: model._name, attr: attr, pK: data.$.pK };\n                  __nestScp1Set__ = true;\n              }\n              else{\n                // var kmp = __nestScp__[kid] = __nestScp__[kid] || new Map();\n                // data ? kmp.set(data, true) : undefined;\n                var __nId = __nestScp__.get(data[attr])\n                var refMp = __nestRef__[__nId] = __nestRef__[__nId] || new Map();\n                var refMpId = genMapId(refMp);\n                refMp.set(refMpId, true);\n                setRecBindMap(nestScp[__nId], {db:db, model:model._name, attr: attr, pK: data.$.pK});\n                obj[attr] = __nId+\"_\"+refMpId;\n              }\n          } else {\n            if(data[attr] && !__nestScp__.has(data[attr])){\n              // nestObj = { data: data[attr] };\n              nestObj = {\n                data : data[attr],\n                dtype : data.__component__.component.__data[attr],\n                Error:data.__component__.component.data.errors,\n                key:attr\n              };\n                __nestScp2Set__ = true;\n            }\n            else{\n                var __nId = __nestScp__.get(data[attr])\n                var refMp = __nestRef__[__nId] = __nestRef__[__nId] || new Map();\n                var refMpId = genMapId(refMp);\n                refMp.set(refMpId, true);\n                obj[attr] = __nId+\"_\"+refMpId;\n            }\n        }\n        if(nestObj){\n          nestScpId++;\n          var refMp = __nestRef__[nestScpId] = __nestRef__[nestScpId] || new Map();\n          var refMpId = genMapId(refMp);\n          refMp.set(refMpId, true);\n          __nestScp__.set(data[attr], nestScpId);\n          if(__nestScp1Set__){\n              nestScp[nestScpId] = {};\n              if(db){\n                nestScp[nestScpId].db = db;\n              }\n              setRecBindMap(nestScp[nestScpId], nestObj);\n              //     setRecBindMap(model._name, attr, data.$.pK, nestScpId); \n          }\n          if(__nestScp2Set__){   \n            nestScp[nestScpId] = nestObj;                 \n          }\n          nestScp[nestScpId]._data = data[attr];\n          obj[attr] = obj[attr] || nestScpId+\"_\"+refMpId;\n          var path = [];\n          // fromStore ? path.push(attr) : undefined;\n          bindObj(data, attr, nestScpId, path, new Map(), checkAttrs, watch);\n        }\n    }\n}\n};\n\nfunction establishWatchScope(watchProps,model){\n  var scope = this,object;\n  for (var v in watchProps){\n    var property = v;\n    var watch = watchProps[v]\n    if(scope.component && scope.component.__data && scope.component.__data[property]){\n      object = scope.getData(property);\n      watch = scope.component.__data[property].watch ? true : watch;\n      if(typeof object == \"object\"){\n        establishObjectBinding(scope.component.data,v,false,undefined,undefined,watch)\n      }\n      if( nestScp[__nestScp__.get(object)]){\n        nestScp[__nestScp__.get(object)].dtype.watch = watch;\n      }\n    }\n    else{\n      if(model){\n        var fieldList = model.fieldList;\n        if(fieldList[v] && fieldList[v].watch == undefined){\n          fieldList[v].watch = watch ;\n          model._fldGrps.watch[v] = fieldList[v];\n        }\n      }\n    }\n  }\n}\n\nfunction removeNestScp2Bind(mp, mdlObj){\n  var mp = mp.model;\n  if (mp.has(mdlObj.model)) {\n    var mp1 = mp.get(mdlObj.model);\n    if (mp1.has(mdlObj.pK)) {\n        var mp2 = mp1.get(mdlObj.pK);\n        if (mp2.has(mdlObj.attr)) {\n            mp2.delete(mdlObj.attr);\n        }\n        !mp2.size ? mp1.delete(mdlObj.pK) : undefined; \n    }\n    !mp1.size ? mp.delete(mdlObj.model) : undefined;\n  }\n}\n\nfunction setRecBindMap(obj, nestObj){\n  var mp = obj.model = obj.model || new Map(), modelName = nestObj.model, pK = nestObj.pK, attr = nestObj.attr;\n  if(modelName && !mp.has(modelName)){\n    mp.set(modelName, new Map());\n  }\n  mp = mp.get(modelName);\n  if(pK && !mp.has(pK)){\n    mp.set(pK, new Map());\n  }\n  mp = mp.get(pK);\n  if(attr && !mp.has(attr)){\n    mp.set(attr, true);\n  }\n}\n\n\nfunction bindObj(data, key, id, path, mp, checkAttrs, watch) {\n  mp = mp || new Map();\n  var value = key != undefined ? data[key] : data;\n  var cyclic = false;\n  if(!path.length && __nestScp__.get(data) === id){\n    delete nestScp[id].cyclic;\n  }\n  if (path.length > 1 && value && nestScp[id] && nestScp[id].hasOwnProperty(\"data\") && nestScp[id].data === value) {\n    if(mp.get(value)){\n      cyclic = true;\n    }\n    if (checkAndAddBind(value, id, path, cyclic)) {\n      estObjScp(value, id, path, cyclic);\n    }\n    return;\n  }\n  var attrs;\n  if(checkAttrs && (checkAttrs.hasOwnProperty(\"items\")||checkAttrs.hasOwnProperty(\"properties\"))){\n      attrs=checkAttrs.items || checkAttrs.properties;\n  }\n  attrs=watch?undefined:attrs;\n  if (Array.isArray(value)) {\n    if (!mp.get(value)) {\n      mp.set(value, true);\n      value.forEach(function (val, idx) {\n        path.push(idx);\n        if(watch || (checkAttrs && checkAttrs.hasOwnProperty(\"items\") && typeof(checkAttrs.items) == \"object\" )){\n          bindObj(value, idx, id, path, mp,attrs,watch);\n        }  \n        // bindObj(value, idx, id, path, mp);\n        path.pop();\n      });\n    } else {\n      cyclic = true;\n    }\n    if (checkAndAddBind(value, id, path, cyclic)) {\n      var _establish;\n      if(Array.isArray(watch)){\n        _establish = checkEstablishingSCP(value,path,watch)\n      }\n      if(_establish || (typeof watch ==\"boolean\" && watch )){\n          estObjScp(value, id, path, cyclic);\n      }\n    }\n  } else if (value && typeof(value) == \"object\") {\n    var cyclic = false;\n    if (!mp.get(value)) {\n      mp.set(value, true);\n      for (var str in value) {\n        path.push(str);\n        if(watch || (attrs && attrs.hasOwnProperty(str))){\n          bindObj(value, str, id, path, mp,attrs?attrs[str]:undefined,watch);\n        }  \n        // bindObj(value, str, id, path, mp);\n        path.pop();\n      }\n    } else {\n      cyclic = true;\n    }\n    if (checkAndAddBind(value, id, path, cyclic)) {\n      var _establish;\n      if(Array.isArray(watch)){\n        _establish = checkEstablishingSCP(value,path,watch)\n      }\n      if(_establish || (typeof watch ==\"boolean\" && watch ) ){\n          estObjScp(value, id, path, cyclic);\n      }\n    }\n  }\n};\n\nfunction checkAndAddBind(value, id, path, cyclic){\n    if(!value._scp || !value._scp.size){\n        return true;\n    }\n    if(value._scp.size){\n      if(value._scp.has(id)){\n          var _obj = value._scp.get(id);\n          var obj = _obj.paths;\n          if(obj.hasOwnProperty(path.join(\".\"))){\n            if(cyclic){\n              nestScp[id].cyclic = true;\n            }                      \n            return false;\n          }\n      }\n    }\n    return true;\n}   \n\nfunction estObjScp(value, id, path, cyclic){\n  if(!value._scp){\n    Object.defineProperty(value, \"_scp\", {\n      value : new Map(),\n      enumerable : false,\n      configurable : true\n    });\n  }\n  var mp = value._scp;\n  if(!mp.has(id)){\n    mp.set(id, {});\n  }\n  var obj = mp.get(id),\n  path = path ? path.join(\".\") : path;\n  var pathObj = obj.paths = obj.paths || {};\n  pathObj[path] = true;\n  var nestObj = nestScp[id];\n  nestObj.cyclic = true;\n}\n\nfunction cmpObjs(obj1, obj2){\n    if(Object.keys(obj1).length !== Object.keys(obj2).length){\n        return false;\n    }\n    for(var key in obj1){\n        if(!obj2.hasOwnProperty(key)){\n            return false;\n        }\n        var ret = cmpData(obj1[key], obj2[key]);\n        if(ret == false){\n            return false;\n        }\n    }\n    return true;\n}\t\n\n\nfunction cmpData(data1, data2){\n  if(Array.isArray(data1)){\n    if((!Array.isArray(data2)) || data1.length !== data2.length){\n      return false;\n    }\n    var len = data1.length, ret;\n    for(var i=0;i <len; i++){\n      ret = cmpData(data1[i], data2[i]);\n      if(ret == false){\n        return false;\n      }\n    }\n  }\n  else if(data1 && data2 && typeof data1 == \"object\" && typeof data2 == \"object\"){\n    return cmpObjs(data1,data2);\n  }\n  else if(isEntity(data1) && isEntity(data2)){\n    if(data1.$.schema){\n      if( (data1.$.schema._name !== data1.$.schema._name) || (str$.getpKVal(data1) !== str$.getpKVal(data2)) ){\n        return false;\n      }\n    }\n    else{\n      if( (data1.$.model._name !== data1.$.model._name) || (str$.getpKVal(data1) !== str$.getpKVal(data2)) ){\n        return false;\n      }\n    }\n  }\n  else if(data1 !== data2){\n    return false;\n  }\n  return true;\n}\n\nfunction nestScpRmPath(obj, path){\n  if(obj && obj.paths){\n      obj = obj.paths;\n      for(var key in obj){\n          if(key.startsWith(path+\".\")){\n              delete obj[key];\n          }\n      }\n  }\n}\n\nfunction nestScpRemove(data, id, path){\n  var mp = data._scp;\n  if(mp && mp.size){\n      if(path){\n        nestScpRmPath(mp.get(id), path);\n        var _obj = mp.get(id); \n        var obj = _obj ? _obj.paths : undefined;\n        if(obj && !Object.keys(obj).length){\n            mp.delete(id);\n        }  \n      }\n      else{\n          mp.delete(id);\n      }\n      if(!mp.size){\n        delete data._scp;\n      }\n  }\n}\n\nfunction rmNestScp(value, id, mp, data, path){\n  if (Array.isArray(value)) {\n      if (!mp.get(value)) {\n          mp.set(value, true);\n          value.forEach(function (val, idx) {\n              rmNestScp(val, id, mp, undefined, path);\n          });\n      }\n      nestScpRemove(value, id, path);\n  } else if (value && typeof(value) == \"object\") {\n      if (!mp.get(value)) {\n          mp.set(value, true);\n          for (var str in value) {\n              rmNestScp(value[str], id, mp, undefined, path);\n          }\n      }\n      nestScpRemove(value, id, path);\n  }\n}\n\nfunction removeNestScp(value, id, mpId, path, context, mp, data, recObj) {\n  mp = mp || new Map();\n  id = Number.parseInt(id);\n  var obj = nestScp[id], kmp = __nestRef__[id];\n  if(recObj && obj.model){\n    removeNestScp2Bind(obj, recObj);\n  }\n  if(context){\n      if(kmp && kmp.has(mpId)){\n          kmp.delete(mpId);\n      }\n      if(!kmp || (kmp && !kmp.size)){\n          delete __nestRef__[id];\n          if(__nestScp__.has(value)){\n              __nestScp__.delete(value);\n          }\n          rmNestScp(value, id, mp, true, path);\n          if(!data){\n              delete nestScp[id];\n          }\n      }\n  }\n  else{\n    rmNestScp(value, id, mp, true, path);\n  }\n};\n\n//@3055\n// function addStateToMap(event, target, XHR, stateName){\n//   var mp = window.__nodeXHRMap = window.__nodeXHRMap || new Map();\n//   var nodeMap = mp.get(target);\n//   if(!nodeMap){\n//       mp.set(target, new Map());\n//   }\n//   nodeMap = mp.get(target);\n//   var sr = target.lyteState = target.lyteState || [], type = stateName || XHR;\n//   if(sr.indexOf(type) == -1){\n//       sr.push(type);\n//   }\n//   target.setAttribute(\"lyte-state\", \"\");\n//   var evMap = nodeMap.get(event);\n//   if(!evMap){\n//       nodeMap.set(event, []);\n//       evMap = nodeMap.get(event);\n//   }\n//   if(stateName){\n//       evMap.push({state:stateName});\n//       return {target: target, event: event};        \n//   }\n//   else{\n//       evMap.push({isXHR:true, xhr:XHR});\n//       var callback = function(arg){\n//         if(XHR.readyState == 4){\n//             removeStateFromMap(XHR, event, target);\n//             XHR.removeEventListener(\"readystatechange\", callback);\n//         }\n//     }\n//     XHR.addEventListener(\"readystatechange\", callback);\n//   }\n// }\n\n// function removeStateFromMap(type, event, target){\n//   var mp = window.__nodeXHRMap; \n//   var nodeMap = mp.get(target);\n//   if(!nodeMap){\n//       return;\n//   }\n//   var evMap = nodeMap.get(event);\n//   if(!evMap){\n//       return;\n//   }\n//   if(evMap){\n//       var arr = evMap;\n//       var ind = -1;\n//       arr.every(function(itm, idx){\n//           if((itm && itm.isXHR && itm.xhr == type)|| (typeof type == \"string\" && itm.state == type)){\n//               ind = idx;\n//               return false;\n//           }\n//           return true;\n//       });\n//       if(ind != -1){\n//           arr.splice(ind,1);\n//           var sind = target.lyteState.indexOf(type);\n//           target.lyteState.splice(sind, 1);\n//           if(!arr.length){\n//               nodeMap.delete(event);\n//               var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1; \n//               tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;\n//               if(target && target.lyteState && target.lyteState.length == 0){\n//                   target.lyteState = null;\n//                   target.removeAttribute(\"lyte-state\");\n//               } \n//           }\n//           if(!nodeMap.size){\n//               mp.delete(target);\n//           }\n//       }\n//   }\n// }\n\nfunction toBeUsedServices(obj){\n  var serviceToBeUsed = Object.assign({},obj.Lyte.toBeInjectedServices);\n  var arr = obj.services;\n  if(arr){\n    arr.forEach(function(service){\n        if(typeof service == \"string\"){\n            serviceToBeUsed[service] = service;\n        }\n        else if(service && typeof service == \"object\"){\n            for(var key in service){\n                serviceToBeUsed[key] = service[key];\n            }\n        }\n    })\n  }\n  return serviceToBeUsed;\n}\n\nfunction extendService(obj){\n  var servObj = obj.serviceToBeUsed || toBeUsedServices(obj), name;\n  for(var serv in servObj){\n    name = servObj[serv];\n    if(obj.Lyte.registeredServices.hasOwnProperty(name)){\n      obj.scope[serv] = obj.Lyte.registeredServices[name];\n    }else{\n      obj.Lyte.$.requiredServices(serv, name, obj.callback);\n    }\n  }  \n}\n\nfunction extendMixin(obj){\n  var scp = obj.Lyte, self = obj.scope;\n  obj.mixins.forEach(function(item){\n    if(scp.Mixin.exists(item)){\n      var mixin = scp.registeredMixins[item];\n      for(var key in mixin){\n        self[key] = mixin[key];\n      }\n    }\n    else{\n      scp.$.requiredMixins(item, obj.callback);\n    }\n  });\n}\n\nfunction toAddSuper(scp, key, name, self){\n  if(scp.__toAddSuper && scp.__toAddSuper.hasOwnProperty(name)){\n    var addSuper = scp.__toAddSuper[name];\n    for(var i=0; i<addSuper.length; i++){\n      var child = scp[addSuper[i]];\n      if(child && child.is == key){\n        child.$super = self;\n        self.__extendedBy.push(addSuper[i]);\n        var index;\n        if(name != \"application\")\n        {\t\n          if(scp.__toAddSuper.application)\n          {\n            index = scp.__toAddSuper.application.indexOf(child.__name);\n            if(index > -1)\n            {\n              scp.__toAddSuper.application.splice(index,1);\n            }\n          }\n          if(scp.application)\n          {\n            index = scp.application.__extendedBy.indexOf(child.__name);\n            if(index > -1)\n            {\n              scp.application.__extendedBy.splice(index,1);\n            }\n          }\n        }\n      }\n    }\n    delete scp.__toAddSuper[name];\n  }\n}\n\nfunction _get(cacheObj, key) {\n  return cacheObj[key];\n}\nfunction globalsSet(scope,value){\n  let set = this.$utils.set;\n  if(set){\n      return set(this.__gl,scope,value);\n  }\n  else{\n      this.error(\"Globals set will be supported only if component registry is imported in the app\");\n  }\n};\nfunction globalsGet(scope){\n  let get = this.$utils.get;\n  if(get){\n      return get(this.__gl,scope);\n  }\n  else{\n      elf.error(\"Globals get will be supported only if component registry is imported in the app\");\n  }\n};\nfunction arrayUtils(){\n  let arrayUtils = this.$utils.arrayUtils;\n  if(arrayUtils){\n      return arrayUtils.apply(arrayUtils, arguments);\n  }else{\n      this.error(\"arrayUtils will be supported only if component registry is imported in the app\");\n  }\n}\nfunction objectUtils(){\n  let objectUtils = this.$utils.objectUtils;\n  if(objectUtils){\n      return objectUtils.apply(objectUtils, arguments);\n  }else{\n      this.error(\"objectUtils will be supported only if component registry is imported in the app\");\n  }\n}\nfunction _lyteDidConnect(LClass,ins){\n  if(LClass._component.didConnect){\n    LClass._component.didConnect(ins);\n  }\n}\nfunction _lyteInit(LClass,ins){\n  ins.__gl = {};\n  ins.Globals = {};\n  // ins.triggerEvent = triggerEvent;\n  // ins.addEventListener = addEventListener;\n  // ins.removeEventListener = removeEventListener; \n  ins.extendEventListeners = extendEventListeners;\n  extendEventListeners(ins);\n  extendEventListeners(LClass);\n  if(LClass._component.init){\n    LClass._component.init(ins);\n  }\n  // ins.arrayUtils = arrayUtils;\n  // ins.objectUtils = objectUtils;\n  ins.arrayUtils = function() {\n    return arrayUtils.apply(ins ,arguments);\n  }\n  ins.objectUtils = function(){\n      return objectUtils.apply(ins ,arguments);\n  }\n  ins.Globals.set = function(){\n      return globalsSet.apply(ins ,arguments);\n  }\n  ins.Globals.get = function(){\n      return globalsGet.apply(ins ,arguments);\n  }\n  ins.lyteError = Logger;\n  ins.error = Logger.error.bind(Logger);\n  ins.warn = Logger.warn.bind(Logger);\n  ins.errorCodes = Logger.errorCodes;\n  defProp(ins, \"patterns\", {\n    value: {\n      email : new RegExp(/^([A-Za-z0-9._%\\-'+/]+@[A-Za-z0-9.-]+\\.[a-zA-Z]{2,22})$/),\n      url : new RegExp(/(^(ht|f)tp(s?):\\/\\/[0-9a-zA-Z][-.\\w]*(:[0-9])*(\\/?)([a-zA-Z0-9\\-.?,:'/\\\\+=&amp;%$#_[\\]@!()*;~]*)?$)/),\n      ampm : new RegExp(/^(AM|PM|am|pm)$/),\n      hour : new RegExp(/^(0?[0-9]|1[0-9]|2[0-4])$/),\n      minute : new RegExp(/^(0?[0-9]|[1-5][0-9]|60)$/),\n      boolean : new RegExp(/^(true|false|TRUE|FALSE)$/),\n      alphaNumeric : new RegExp(/([a-zA-Z0-9])+/),\n      alphabetsOnly : new RegExp(/([a-zA-Z])+/),\n      numeric : new RegExp(/([0-9])+/),\n      phoneNo : new RegExp(/^[0-9a-zA-Z+.()\\-;\\s]+$/)\n    }\n  });\n  ins.deepCopyObject = function(obj){\n    return copyObject(obj);\n  }\n  ins.prop = function(type, opts){\n    var obj = {};\n    obj.type = type;\n    if(opts == undefined){\n      opts = {};\n    }\n    // if(this.types.indexOf(type) == -1 && !this.Transform.hasOwnProperty(type)){\n    //   throw new Error(\"Not a valid field type - \"+type);\n    // }\n    Object.assign(obj, opts);\n    return obj;\n  }\n  Logger.addEventListener(\"error\", function(){  \n    var arr = Array.from(arguments);\n    if (LClass.onerror) {\n      LClass.onerror.apply(LClass, arr);\n    }\n    if(LClass.triggerEvent){\n      arr.unshift(\"error\");\n      LClass.triggerEvent.apply(LClass, arr);\n    }\n  });\n  ins.types = types;\n  ins.log = function (text, src, color) {\n    if (this.config && this.config.debug) {\n        if(color) {\n            console.log(\"%c\" + text,'color:' + color);\n        } else {\n          console.log(text);      \n        }\n    }\n  };\n  ins.isComponent = function(object) {\n      if(object && object.$node && object.__data) {\n        return true;\n      }\n      return false;\n  }\n  ins.Transform = {};\n  ins.one = one;\n  ins.many = many;\n\n  ins.registerDataType = function(fieldTypeName, properties){\n      var exts = \"extends\";\n      if(ins.Transform.hasOwnProperty(fieldTypeName)){\n        LClass.error(\"Custom Field Type - \"+fieldTypeName+\" -  already exists.\");\n        return;\n      }\n      if(properties[exts] == undefined || ins.types.indexOf(properties[exts]) == -1){\n        LClass.error(\"Not a valid field type - \"+properties[exts]);\n        return;\n      }\n      ins.Transform[fieldTypeName] = properties;\n  }\n  ins.registerPattern = function(patternName, pattern){\n    ins.patterns[patternName] = pattern;\n  }\n  ins.injectResources = function (files, every, completed, options) {\n    var successFiles = [],\n    errorFiles = [],\n    scope = ins;\n    every = every || function () {};\n    completed = completed || function () {};\n    return new Promise(function (resolve,reject) {\n      processRequirements(files, function () {\n        if (options && options.defer) {\n          options.defer({\n            injectJS: injectJS,\n            files: files,\n            errorFiles: errorFiles\n          });\n          resolve();\n        } else {\n          injectJS(files, function () {\n            completed(successFiles, errorFiles);\n            if(errorFiles.length) {\n                reject(successFiles, errorFiles);\n              } else {\n                resolve(successFiles, errorFiles);\n              }\n          });\n        }\n      }.bind(ins));\n    });\n  \n    function injectJS(files, resolve, execFiles) {\n      execFiles = execFiles || []\n      if (!files) {\n        resolve(successFiles, errorFiles);\n      } else {\n        if (!Array.isArray(files)) {\n          files = [files];\n        }\n        if (!files.length) {\n          resolve(successFiles, errorFiles);\n        }\n        var len = -files.length;\n        files.forEach(function (file) {\n          if (typeof file == \"string\") {\n             var fileSplit = file.split('.'),\n            type = fileSplit[fileSplit.length - 1];\n            if (type && type == \"js\" && execFiles.indexOf(file) == -1) {\n              execFiles.push(file);\n              createScript(file, function () {\n                loaded();\n              });\n            } else {\n              loaded();\n            }\n          } else if (Array.isArray(file)) {\n            new Promise(function (r) {\n              injectJS(file, r);\n            }).then(function () {\n              loaded();\n            });\n          } else {\n            len--;\n            new Promise(function (r) {\n              injectJS(file.parent, r);\n            }).then(function () {\n              new Promise(function (r) {\n                injectJS(file.child, r);\n              }).then(function () {\n                loaded();\n              });\n              loaded();\n            });\n          }\n        });\n      }\n  \n      function loaded() {\n        len++;\n        if (len == 0) {\n          resolve(successFiles, errorFiles);\n        }\n      }\n    }\n    \n    function createScript(file, resolve) {\n      var ev = scope.injectResources.respObj[file];\n      if (!scope.injectResources.availableTags[file] || scope.injectResources.availableTags[file].tag.tagName == \"LINK\") {\n        var tag = document.createElement('script');\n        tag.setAttribute('type', \"text/javascript\");\n        ev.getAttributeNames().forEach(function (attr) {\n          if ([\"href\", \"as\", \"rel\"].indexOf(attr) == -1) {\n            tag.setAttribute(attr, ev.getAttribute(attr));\n          }\n        });\n        tag.setAttribute('src', file);\n        tag.onerror = tag.onload = function(event) {\n          if (event.type == \"error\") {\n            errorFiles.push(event)\n          } else {\n            successFiles.push(event)\n          }\n          scope.injectResources.availableTags[file].tag.remove();\n          scope.injectResources.availableTags[file] = { tag: tag, event: { type: event.type == \"error\" ? \"error\" : \"load\"} };\n          resolve();\n        }\n        Lyte.$.assetsDiv.appendChild(tag);\n      } else {\n        resolve();\n      }\n    }\n  \n    function processRequirements(files, resolve) {\n      if (!files) {\n        resolve();\n      } else {\n        if (!Array.isArray(files)) {\n          files = [files];\n        }\n        if (!files.length) {\n          resolve();\n        }\n        var len = -files.length;\n        files.forEach(function (file) {\n          if (typeof file == \"string\") {\n            requestFile.call(scope, file, scope.injectResources.availableTags[file], function () {\n              loaded();\n            });\n          } else if (Array.isArray(file)) {\n            new Promise(function (r) {\n              processRequirements(file, r);\n            }).then(function () {\n              loaded();\n            });\n          } else {\n            len--;\n            new Promise(function (r) {\n              processRequirements(file.parent, r);\n            }).then(function () {\n              loaded();\n            });\n            new Promise(function (r) {\n              processRequirements(file.child, r);\n            }).then(function () {\n              loaded();\n            });\n          }\n        });\n      }\n  \n      function loaded() {\n        len++;\n        if (len == 0) {\n          resolve();\n        }\n      }\n  \n      function requestFile(file, cached, resolve) {\n        if(ins.$.reqFiles[file]) {\n          ins.$.reqFiles[file].push(resolve);\n        } else {\n          var scope = ins;\n          ins.$.reqFiles[file] = [resolve];\n          if (cached && cached.event.type != \"error\") {\n            if (ins.removeFromCache.arr.indexOf(file) != -1) {\n              ins.removeFromCache.arr.splice(scope.removeFromCache.arr.indexOf(file), 1);\n            }\n            fileLoaded.call(cached.tag, file, cached.event, true);\n            resolve();\n          } else {\n            makeRequest(file, function (event) {\n              scope.injectResources.respObj[file] = ins;\n              scope.$.reqFiles[file].forEach(function (resolve) {\n                resolve();\n              });\n              // filesObj[file] = ins;\n              fileLoaded.call(ins, file, event);\n              every.call(ins, event);\n            });\n          }\n        }\n      }\n  \n      function fileLoaded(file, event, cached) {\n        delete scope.$.reqFiles[file];\n        if (!cached) {\n          if (scope.injectResources.availableTags[file]) {\n            scope.injectResources.availableTags[file].tag.remove();\n            delete scope.injectResources.respObj[file];\n          }\n          ins.onerror = ins.onload = undefined;\n          scope.injectResources.availableTags[file] = { tag: ins, event: { type: event.type } };\n        }\n      }\n    }\n  \n    function makeRequest(file, callBack) {\n      var tag,\n          ev = every.internal || {},\n          fileSplit = file.split('.'),\n          type = fileSplit[fileSplit.length - 1];\n      ev.file = file;\n      if (fileSplit.length == 1) {\n        Lyte.error('Type of file is not specified in injectResources.');\n        return;\n      }\n      tag = document.createElement('link');\n      tag.setAttribute('href', file);\n      ev.tag = tag;\n      if (type == 'css') {\n        tag.setAttribute('type', \"text/css\");\n        tag.setAttribute('rel', \"stylesheet\");\n        tag.onerror = tag.onload = function (event) {\n          // if (event.type == \"error\") {\n          //   errorFiles.push(event);\n          // } else {\n          //   successFiles.push(event);\n          // }\n          callBack.call(ins, event);\n        };\n      } else {\n        tag.setAttribute('as', \"script\");\n        tag.setAttribute('rel', \"preload\");\n        tag.onerror = tag.onload = function (event) {\n          // if (event.type != \"error\") {\n          //   tag.status = 200;\n          // }\n          callBack.call(ins, event);\n        };\n      }\n      Lyte.triggerEvent(\"onBeforeInject\", ev);\n      Lyte.$.assetsDiv.appendChild(tag);\n    };\n  };\n  ins.injectResources.availableTags = [];\n  ins.injectResources.respObj = [];\n\n  ins.removeFromCache = function(arr) {\n    var scope = ins;\n    ins.removeFromCache.assign.call(ins,arr);\n    if(ins.removeFromCache.arr.length) {\n      ins.removeFromCache.arr.forEach(function(file) {\n        if(scope.injectResources.availableTags[file]) {\n          scope.injectResources.availableTags[file].tag.remove();\n          delete scope.injectResources.availableTags[file];  \n        }\n      });\n      ins.removeFromCache.arr = [];\n    }\n  }\n  ins.removeFromCache.arr = [];\n  ins.removeFromCache.assign = function(arr) {\n    arr = arr == \"*\" ? Object.keys(ins.injectResources.availableTags) : (Array.isArray(arr) ? arr : [arr]); \n    ins.removeFromCache.arr = ins.removeFromCache.arr.concat(arr);\n    return;\n  }\n  ins.resolvePromises = function(promises) {\n    return new Promise(function(res, rej) {\n      resolvePromises(promises).then(function(data) {\n        res(data);\n      },function(data) {\n        rej(data);\n      })\n    })\n  }\n  // ins.setState = function(str){\n  //   if(!str){\n  //     console.error(\"Please provide a state name\");\n  //   }\n  //   var evnt = window.event;\n  //   if(/^(click|dblclick)$/.test(evnt.type)){\n  //       var target = evnt.target;\n  //       if(getConfig(\"stateHandling\") == true && target && target.getAttribute && target.getAttribute(\"lyte-state-handling\") != \"false\"){\n  //           var state = target.getAttribute(\"lyte-state\");\n  //           if(!state){\n  //               var mp = window.__stateMap = window.__stateMap || new Map();\n  //               var mpobj = mp.get(str);\n  //               if(!mpobj){\n  //                   var obj = addStateToMap(evnt.type, target, undefined, str);\n  //                   mp.set(str, obj);\n  //               }\n  //               else{\n  //                   console.error(\"There is already a open state by the name\",str);\n  //               }\n  //           }\n  //       }        \n  //   }\n  // }\n  // ins.removeState = function(str){\n  //   if(!str){\n  //       console.error(\"Please provide a state name\");\n  //   }\n  //   var mp = window.__stateMap;\n  //   if(mp){\n  //       var obj = mp.get(str);\n  //       if(obj){\n  //           mp.delete(str);\n  //           removeStateFromMap(str, obj.event, obj.target);\n  //       }\n  //   }\n  // }\n\n  // ins.setConfig = function(key, value){\n  //   var configObj = window.__config = window.__config || {};\n  //   configObj[key] = value;\n  // }\n  // ins.getConfig = getConfig;\n}\n\n\nfunction _defineProperty(exportsObj,specsObj){\n  let actualObj = {};\n  let defineProperty = function(obj,property){\n    Object.defineProperty(exportsObj,property,{\n      set : function(newValue){\n        actualObj[property] = newValue;\n      },\n      get : function(){\n        if(!actualObj[property]){\n          actualObj[property] = obj();\n        }\n        return actualObj[property];\n      }\n\n    })\n  }\n  for(let key in specsObj){\n    defineProperty(specsObj[key],key)\n  }\n}\n\nfunction checkEstablishingSCP(value,path,watch){\n  if(Array.isArray(watch)){\n      var _path ='';\n      _path = path.join(\".\")\n      if(checkWatchPath(_path,watch,true) && typeof value != \"object\"){\n          return true\n      }\n      var _key = Object.keys(value);\n      for(var i_scp =0 ; i_scp<_key.length ; i_scp++){\n          var spiePath = _key[i_scp];\n         var finalaUth =  _path == \"\"?spiePath : _path+\".\"+spiePath;\n          if(checkWatchPath(finalaUth,watch,true)){\n              return true\n          }\n      }\n  }\n}\nfunction checkWatchPath(actualPath,watchArr,establishBind){\n  if(typeof watchArr == \"boolean\" && watchArr === true){\n      return true\n  }\n  else if(Array.isArray(watchArr)){\n      for(var i_watch=0; i_watch < watchArr.length ; i_watch++){\n          var path = watchArr[i_watch];\n          path =path.replace(/ /g,\"\");\n          path = path.replace(/\\$\\.\\./g,\"..\");\n          path = path.replace(/\\$\\./g,\"\")\n          var weirdPath = path.search(/\\.\\./g) != -1 || path.search(/\\[|\\\\]|\\{|\\}/g)!=-1 ? true : false || path.includes(\"*\");\n          if(actualPath == path){\n              return true;\n          }\n          else if (weirdPath){\n              if(establishBind){\n                if(path.search(/\\.\\./) != -1 ){\n                  path = path.replace(/\\.\\.\\S+/g,\"..*\")\n                  if(path == \"..*\"){\n                    return true;\n                  }\n                } \n              }\n              path = path.search(/\\[/) == 0? path.replace(\"[\",\"\"):path;\n              path = path.search(/\\.\\.\\[/)==0 ? path.replace(\"..[\",\"..\"):path\n              path = path.replace(/\\.*\\[/g,\".\");\n              path = path.replace(/\\]/g,\"\");\n              var _watchPath = checkWeirdPath(path,actualPath);\n              if(_watchPath){\n                  return true\n              }\n          }\n      }\n  }\n}\nfunction checkWeirdPath(watchPath,actualPath){\n  if(actualPath == watchPath){\n      return true;\n  }\n  else if(watchPath.includes(\"..\") || watchPath.includes(\"*\")) {\n      var cmpPath = watchPath;\n      cmpPath = cmpPath.replace(/\\*/g, \"$$\")\n      cmpPath = cmpPath.replace(/\\.\\./g,\"::\")\n      // cmpPath = cmpPath.replace(\"[\",\"\\\\[\")\n      cmpPath = cmpPath.replace(/\\./g, \"\\\\.\")\n      cmpPath=cmpPath.replace(/\\:\\:/g,\"\\\\.?.*\\\\.?\");\n      cmpPath=cmpPath.replace(/\\$/g,\".*\");\n      var _wildCard = watchPath.split(\".\")\n      var _wClenght = _wildCard.length;\n      if(_wildCard[_wClenght-2] == \"\" && _wildCard[_wClenght-1]!=\"*\"){\n        cmpPath = cmpPath+\"$\";\n      }\n      var regularExp = new RegExp(cmpPath);\n      if(regularExp.test(actualPath)){\n          return true;\n      }\n      return false;\n  }\n}\nfunction removeStateFromMap(type, event, target) {\n  var mp = window.__nodeXHRMap;\n  var nodeMap = mp.get(target);\n  if (!nodeMap) {\n      return;\n  }\n  var evMap = nodeMap.get(event);\n  if (!evMap) {\n      return;\n  }\n  if (evMap) {\n      var arr = evMap;\n      var ind = -1;\n      arr.every(function (itm, idx) {\n          if ((itm && itm.isXHR && itm.xhr == type) || (typeof type == \"string\" && itm.state == type)) {\n              ind = idx;\n              return false;\n          }\n          return true;\n      });\n      if (ind != -1) {\n          arr.splice(ind, 1);\n          var sind = target.lyteState.indexOf(type);\n          target.lyteState.splice(sind, 1);\n          if (!arr.length) {\n              nodeMap.delete(event);\n              var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1;\n              tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;\n              if (target && target.lyteState && target.lyteState.length == 0) {\n                  target.lyteState = null;\n                  target.removeAttribute(\"lyte-state\");\n              }\n          }\n          if (!nodeMap.size) {\n              mp.delete(target);\n          }\n      }\n  }\n}\n\nfunction addStateToMap(event, target, XHR, stateName) {\n  var mp = window.__nodeXHRMap = window.__nodeXHRMap || new Map();\n  var nodeMap = mp.get(target);\n  if (!nodeMap) {\n      mp.set(target, new Map());\n  }\n  nodeMap = mp.get(target);\n  var sr = target.lyteState = target.lyteState || [],\n      type = stateName || XHR;\n  if (sr.indexOf(type) == -1) {\n      sr.push(type);\n  }\n  target.setAttribute(\"lyte-state\", \"\");\n  var evMap = nodeMap.get(event);\n  if (!evMap) {\n      nodeMap.set(event, []);\n      evMap = nodeMap.get(event);\n  }\n  if (stateName) {\n      evMap.push({\n          state: stateName\n      });\n      return {\n          target: target,\n          event: event\n      };\n  } else {\n      evMap.push({\n          isXHR: true,\n          xhr: XHR\n      });\n      var callback = function () {\n          if (XHR.readyState == 4) {\n              removeStateFromMap(XHR, event, target);\n              XHR.removeEventListener(\"readystatechange\", callback);\n          }\n      }\n      XHR.addEventListener(\"readystatechange\", callback);\n  }\n}\n\nexport {\n  /*addToInstance,\n  createEngineInstance, */\n  removeStateFromMap,\n  addStateToMap,\n  types,\n  nestScp,\n  nestScpId,\n  getConfig,\n  getCurrentRouterInstance,\n  registerErrorCodes,\n  isEntity,\n  _defineProperty,\n  triggerEvent,\n  addEventListener,\n  prop,\n  removeEventListener,\n  extendEventListeners,\n  checkProperty,\n  validateData,\n  deepCopyObject,\n  copyObject,\n  defineRelation,\n  establishObserverBindings,\n  getProperty,\n  // getErrorMessage,\n  establishObjectBinding,\n  bindObj,\n  estObjScp,\n  cmpObjs,\n  cmpData,\n  nestScpRemove,\n  removeNestScp,\n  toBeUsedServices,\n  extendService,\n  extendMixin,\n  toAddSuper,\n  isKeyword,\n  injectServiceToModules,\n  observes,\n  getSuperClass,\n  defProp,\n  defProps,\n  newGetSuperClass, \n  getClass, \n  includeMixins,\n  createCustomClass,\n  one,\n  many, \n  _get,\n  // arrayUtils,\n  // objectUtils,\n  // set,\n  // render,\n  // modifyTemplate,\n  // compileDynamicTemplate,\n  // doDomProcessing,\n  // getComponentTemplate,\n  // get,\n  checkNestedProp,\n  getNearestApp,\n  isInheritedClass,\n  globalsSet,\n  globalsGet,\n  arrayUtils,\n  objectUtils,\n  _lyteInit,\n  _lyteDidConnect,\n  checkEstablishingSCP,\n  checkWatchPath,\n  establishWatchScope\n}\n","window.addEventListener('__onBeforeInject__',function(event){\n    let detail = event.detail;\n    let link = detail.link;\n    let path = link.getAttribute('href');\n    let fingerPrintedVal = window.LyteFingerPrint && window.LyteFingerPrint.get(path);\n    if(fingerPrintedVal){\n        path = fingerPrintedVal.file;\n    }\n    link.setAttribute('href',\"\"+path);\n});\nimport { defineRelation, triggerEvent, isEntity, extendEventListeners, /*getConfig,@3055*/ addEventListener, removeEventListener, copyObject, defProps, globalsSet, globalsGet, /*,type, prop, addToInstance*/set,get, arrayUtils, objectUtils,_lyteInit,_lyteDidConnect} from '@slyte/core/src/lyte-utils.js';\nimport { __checkIfService, __handleLookups } from \"./service\";\nimport { resolvePromises } from './rsvp';\nimport { Logger } from './lyte-error';\nimport { Utils } from \"./Utils.js\";\nimport { __getLyte } from \"./service.js\"\nimport { DataType as DataTypeClass } from \"./DataType.js\";\nimport {Mixin} from \"./Mixin.js\";\nvar __instances = { engine : {}, addon: {}};\nvar __componentsMap = {};\nvar __servicesMap = {}; // Map for containing the services needed for every engine\nvar __enginesMap = new Map(); //Map for containing the engines associated with every service\nvar d = document;\n// //change to defProp later\n// Function.prototype.observes = function(){//af\n//   return {\n//     type: \"observer\",\n//     value: this,\n//     properties: arguments,\n//     on: Function.prototype.on\n//   }\n// }\n// Function.prototype.on = function(){\n//   return {\n//     type: \"callBack\",\n//     value: \"observer\" === this.type ? this.value : this,\n//     properties: arguments,\n//     observes: \"observer\" === this.type ? this : void 0\n// }\n// }\nvar currentContext;\nvar currFunc;\n\nfunction __setCurrentFunc(func) {\n    currFunc = func;\n}\n\nfunction __getCurrentFunc() {\n    return currFunc;\n}\nfunction __setCurrentContext(self) {\n    currentContext = self;\n}\n\nfunction __getCurrentContext() {\n    return  currentContext;\n}\n\nfunction toLowerCase(string) {\n    return string.charAt(0).toLowerCase() + string.slice(1)\n}\n\nfunction __scopedInstance(cls, args, func, extendArgs) {\n  var oldcontext = __getCurrentContext();\n  __setCurrentContext(this);\n  var self = this;\n  __setCurrentFunc(function(ins) {\n      __setCurrentFunc();\n      if(extendArgs && extendArgs.length){\n        extendArgs.forEach(function(itm){\n          // let itm__lyte = __getLyte(itm);\n          // itm.__lookups\n          if(itm.__lookups && itm.__lookups.length){\n            __handleLookups(itm.__lookups, self, ins);\n          }\n        });\n      }\n      func(ins);\n  });\n  var ins = Reflect.construct(cls, args);\n  __setCurrentContext(oldcontext);\n  return ins;\n}\n\nclass Lyte {\n  static dataType(type){\n    var self = this;\n    class dataType extends self.DataType {}\n    dataType.type = type;\n    return dataType;\n  }\n\n  lookups() {\n    return [];\n  }\n\n  scopedInstance() {\n    return __scopedInstance.apply(this, Array.from(arguments));\n  }\n  static componentMap(map){\n    Lyte._componentMap = map;\n  }\n  static register(options){\n    if(options){\n      if(options.app == true){\n        Lyte._setDefaultApp(this);\n      }\n      if(options._migration){\n        this._migration = options._migration;\n      }\n      if(options.hash){\n        this._hash = options.hash;\n      }\n      if(options.refHash){\n          this._refHash = options.refHash;\n      }\n    }\n    var DT = this.DataType = (function() {\n      class DataType extends DataTypeClass {\n        static register(){\n          DataTypeClass.registerInApp.apply(this, [DT]);\n        }\n      }\n      return DataType;\n    })();\n    DT.dataType = {};\n    extendEventListeners(DT.dataType);\n    // DT.register = function(){\n    //     DataTypeClass.register.apply(this, [DT]);\n    // }    \n    var hash = options ? options.hash : undefined;\n    if(hash && DataTypeClass && DataTypeClass.app && DataTypeClass.app.has(options.hash)){\n      var dMap = DataTypeClass.app.get(hash);\n      if(dMap.size){\n        dMap.forEach(function(cls, name){\n          DataTypeClass.registerInApp.apply(cls, [DT]);\n          dMap.delete(name);\n        });\n        if(!dMap.size){\n          DataTypeClass.app.delete(hash);\n        }\n        if(!DataTypeClass.app.size){\n          delete DataTypeClass.app;\n        }\n      }\n    }\n    if(hash){\n      DataTypeClass.addEventListener(hash, function(dCls){\n        DataTypeClass.registerInApp.apply(dCls, [DT]);\n        if(DataTypeClass.lyte.has(hash)){\n            var dMap = DataTypeClass.lyte.get(hash); \n            if(dMap.has(dCls.name)){\n              dMap.delete(dCls.name);\n            }\n            if(!dMap.size){\n              DataTypeClass.lyte.delete(hash);\n            }\n            if(!DataTypeClass.lyte.size){\n              delete DataTypeClass.lyte;\n            }\n        }\n      });\n    }\n  }\n  constructor(config) {\n    var self = this;\n    let defApp = Lyte._getDefaultApp();\n    if(!Lyte._getDefaultAppIns() &&  defApp && defApp == this.constructor){\n      Lyte._setDefaultAppIns(this);\n    }\n    Lyte._instances.push(this);\n    // extendEventListeners(this);\n    // this.lyteError = Logger;\n    // this.error = Logger.error.bind(Logger);\n    // this.warn = Logger.warn.bind(Logger);\n    // this.errorCodes = Logger.errorCodes;\n    // this.addEventListener = addEventListener;\n    // this.removeEventListener = removeEventListener;\n    // this.triggerEvent = triggerEvent;\n    var consoleTime = [],\n    wLyte = Lyte;\n    var type = this.is = config.__lp && config.__lp.type ? config.__lp.type :  \"app\";\n    this.config = config;\n    this.version = \"4.0.0\";\n    this.$ = {\n      isApp : type == \"app\",\n      isSubApp : type == \"subApp\",\n      isAddon : type == \"Addon\",\n      reqFiles : {},\n      injectServices : {},\n      modules : {}\n    };\n    extendEventListeners(this.$.modules);\n    this.$.modules.addEventListener(\"add\", function(name, ins){\n      if(!self.$.modules.hasOwnProperty(name)){\n        self.$.modules[name] = [];\n      }\n      self.$.modules[name].push(ins);\n    });\n    defProps(this, {\n      \"__mixins__\":{\n        value: new Map()\n      },\n      \"registeredServices\":{\n        value:{}\n      },\n      \"registeredMixins\":{\n        value:{}\n      },\n      \"_registeredComponents\":{\n        value: {}\n      },\n      \"Service\":{\n        value:{}\n      },\n      \"toBeInjectedServices\": {\n        value:{}\n      },\n      \"toBeRegistered\": {\n        value:{}\n      },\n      \"dataType\":{\n        value:{}\n      }\n    });\n    defProps(this, { \"customValidator\":{\n      value: new Map()\n    } });\n    this.constructor.DataType.dataType.addEventListener(\"add\",function(name, def){\n      self.dataType[name] = def;\n    });\n    var dTypeDef = this.constructor.DataType.dataType;\n    for(var dKey in dTypeDef){\n      this.dataType[dKey] = dTypeDef[dKey];\n    }\n    this.registeredCustomComponent = {};\n    this.updateMixinsInApp();\n    // this.Globals = {}\n    // this.__lyteRegisteredEvents = {};\n    // this.patterns = {\n    //   email : /^([A-Za-z0-9._%\\-'+/]+@[A-Za-z0-9.-]+\\.[a-zA-Z]{2,22})$/,\n    //   url : /(^(ht|f)tp(s?):\\/\\/[0-9a-zA-Z][-.\\w]*(:[0-9])*(\\/?)([a-zA-Z0-9\\-.?,:'/\\\\+=&amp;%$#_[\\]@!()*;~]*)?$)/,\n    //   ampm : /^(AM|PM|am|pm)$/,\n    //   hour : /^(0?[0-9]|1[0-9]|2[0-4])$/,\n    //   minute : /^(0?[0-9]|[1-5][0-9]|60)$/,\n    //   boolean : /^(true|false|TRUE|FALSE)$/,\n    //   alphaNumeric : /([a-zA-Z0-9])+/,\n    //   alphabetsOnly : /([a-zA-Z])+/,\n    //   numeric : /([0-9])+/,\n    //   phoneNo : /^[0-9a-zA-Z+.()\\-;\\s]+$/\n    // };\n    // this.$.requiredMixins  = {};\n    // this.$.requiredServices = {};\n    var self = this;\n    this.time = function(fn) {\n      if(this.config.performance) {\n        var index;\n        if((index = consoleTime.indexOf(fn)) != -1) {\n          consoleTime.splice(index,1);\n          console.timeEnd(fn);\n        } else {\n          consoleTime.push(fn)\n          console.time(fn);\n        }\n      }\n    }\n\n    // this.arrayUtils = arrayUtils;\n    // this.objectUtils = objectUtils;\n    // this.Globals.set = function(){\n    //   return globalsSet.apply(self ,arguments);\n    // }\n    // this.Globals.get = function(){\n    //   return globalsGet.apply(self ,arguments);\n    // }\n    // if(Lyte._component.init){\n    //   Lyte._component.init(this);\n    // }\n    // if(config.compiler){\n    //   config.compiler.compiler(this);\n    // }\n    _lyteInit(Lyte, this);\n    this.Globals._name = \"Globals\";\n    Utils.addMethods([this.Globals])\n\n    if(config && config.engines){\n      for(var engine in config.engines){\n        var dependencies = config.engines[engine];\n        if(dependencies.dependencies.services){\n          __servicesMap[engine] = dependencies.dependencies.services;\n        }\n      }\n    }\n\n    if(type == 'engine' && name){\n      if(__servicesMap[name]){\n        __servicesMap[name].forEach(function(itm){\n          if(config.dependencies && (engServ = config.dependencies.services)){\n            if(itm && typeof itm == 'object'){\n              for(var key in itm){\n                if(engServ.includes(key)){\n                  if(__instances.app.registeredServices.hasOwnProperty(itm[key])){\n                    self.registeredServices[itm[key]] = __instances.app.registeredServices[itm[key]]\n                  }\n                  // else{\n                  //   self.$.requiredServices(key,itm[key],callback.bind(self));\n                  // }\n                self.toBeInjectedServices[key] = itm[key];\n                  if(!__enginesMap.has(itm[key])){\n                    __enginesMap.set(itm[key],[]);\n                  }\n                  __enginesMap.get(itm[key]).push(self.name);\n                }\n              }\n            }else if(itm){\n              if(engServ.includes(itm)){\n                if(__instances.app.registeredServices.hasOwnProperty(itm)){\n                  self.registeredServices[itm] = __instances.app.registeredServices[itm]\n                }\n                // else{\n                //   self.$.requiredServices(itm,itm,callback.bind(self));\n                // }\n                self.toBeInjectedServices[itm] = itm;\n                if(!__enginesMap.has(itm)){\n                  __enginesMap.set(itm,[]);\n                }\n                __enginesMap.get(itm).push(self.name);\n                }\n              }\n            }\n        })\n      }\n    }\n\n    // this.__lyteRegisteredEvents = {};\n\n    this.addEventListener(\"navigationStart\", function(obj){\n      var trans = obj.nextTrans;\n      if(trans && obj.prevTrans){\n          if(window.event && /^(click|dblclick|mouseover|mouseout|mousemove|mousedown|mouseup|contextmenu|keydown|keyup|keypress|submit|reset|focus|blur|input|change|select|load|resize|scroll|unload|beforeunload|DOMContentLoaded|readystatechange|touchstart|touchmove|touchend|touchcancel|play|pause|ended|volumechange|durationchange|ratechange|dragstart|drag|dragenter|dragleave|dragover|drop|dragend)$/g.test(window.event.type)){\n              trans.ev = window.event;\n              if(obj.prevTrans.ev){\n                delete obj.prevTrans.ev;\n              }\n          }\n          else if((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev){\n            trans.ev = obj.prevTrans.ev;\n            delete obj.prevTrans.ev;\n        }\n      }\n    });\n\n    this.addEventListener(\"afterRouteNavigation\", function(obj){\n        if(obj && obj.trans){\n            var mp = window.__transXHRMap;\n            if(obj.trans.state == 409 || obj.trans.state == 308){\n                if(mp){\n                    var mpObj = mp.get(obj.trans);\n                    if(mpObj){\n                        removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);\n                        mp.delete(obj.trans);\n                    }\n                }\n            }\n            else if(obj.trans.state == 200){\n                mp ? mp.delete(obj.trans) : undefined;\n                obj.trans.ev ? delete obj.trans.ev : undefined;\n            }\n        }\n    });\n\n    this.addEventListener(\"afterRouteTransition\",function(obj){\n      if(false) { /* move code to component*/\n        LyteComponent.chromeBugFix();\n      }\n    })\n\n    this.addEventListener(\"beforeRouteNavigation\", function(obj){\n        if(obj && obj.prevTrans && obj.prevTrans.nested){\n            obj.trans.ev = obj.prevTrans.ev;\n            obj.trans.fromPrevTrans = true; // temp check\n        }\n    });\n\n    this.includes = function(modules) {\n      for(var module in modules) {\n        var mod = this[module] = modules[module];\n        mod.lyteInit ? mod.lyteInit(this) : undefined;\n      }\n    }\n    // this.Security = {};\n    // this.Security.$scp = this;\n    // this.Security.createSanitizer = Lyte.Security.createSanitizer;\n    // addToInstance(this);\n    // window.Lte = Lyte.$scp[type][this.name] = this;\n    //window.Lte = Lyte.$scp[type][this.name] = this;\n    if(__instances.app && false) { /* remove this code. Move this to component module */\n      for(var compName in __globalElements.Component.registeredComponents){\n        __componentsMap[compName] = {\n              'is' : __instances.app.is,\n              'name' : __instances.app.name\n        };\n      }\n    }\n\n    // if(false) { /* check code to move to compoennt module*/\n    //   this.Component._registeredComponents = Object.assign(this.Component._registeredComponents , __globalElements.Component._registeredComponents);\n    //   this.Component.registeredComponents = Object.assign(this.Component.registeredComponents , __globalElements.Component.registeredComponents);\n    //   this.Component.registeredHelpers = Object.assign(this.Component.registeredHelpers , __globalElements.Component.registeredHelpers);\n    //   this.Component.customPropRegex =  __globalElements.Component.customPropRegex;\n    //   this.Component.customPropHandlers = Array.from(__globalElements.Component.customPropHandlers);\n    // }\n    // this.$.requiredMixins.component = Lyte.Component.requiredMixins.component;\n    // this.Security = {};\n    // this.Security.$scp = this;\n    // this.Security.createSanitizer = Lyte.Security.createSanitizer;\n\n    if(config && config.init){\n      config.init.apply(this);\n    }\n    Object.defineProperty(this, \"__lyte\", {\n      enumerable : false, \n      writable : true, \n      value : {\"lookupMap\" : new Map()}\n    });\n    extendEventListeners(this.__lyte.lookupMap);\n    __setCurrentContext(this);\n    __handleLookups([Utils], this, this);\n    var lookups = this.lookups();\n    // if(Array.isArray(lookups)){\n    //   lookups.unshift(Utils);\n    // }\n    // else{\n    //   lookups = [Utils];\n    // }\n    __handleLookups(lookups, this, this);\n    __setCurrentContext(undefined)   \n    // if(Lyte.instantiateComponent){\n    //   Lyte.instantiateSecurity(this);\n    // }\n    // if(Lyte._component.didConnect){\n    //   Lyte._component.didConnect(this);\n    // }\n    _lyteDidConnect(Lyte, this);\n  }\n  updateMixinsInApp(){\n    var hash = this.constructor._hash;\n    if(hash){\n      var mObj = Mixin.registeredMixin[hash];\n      if(mObj){\n        for(var key in mObj){\n          let mixinCls = mObj[key];\n          if(this.constructor._hash == mixinCls._refHash){\n            this.registeredMixins[mixinCls.name] = mixinCls;\n          }\n        }\n      }\n    }\n  }\n  static isEntity(obj){\n    isEntity(obj);\n  }\n  get __isApp() {\n    return true;\n  }\n}\n\nLyte._instances = [];\n\nvar fnProto = Function.prototype;\nif(!fnProto.on){\n    fnProto.on = function(){\n        Lyte.warn(\"'.on()' method with the argument '\" + arguments[0] + \"' cannot be executed outside component scope.\");\n        return { \"type\": \"callBack\", \"value\": this.type === \"observer\" ? this.value : this, \"properties\": arguments, \"observes\": this.type === \"observer\" ? this : undefined };\n    };\n}\nif(!fnProto.observes){\n    fnProto.observes = function(){\n        Lyte.warn(\"'.observes()' method with the arguments '\" + arguments[0] + \"' cannot be executed outside component scope.\");\n        return { \"type\": \"observer\", \"value\": this, \"properties\": arguments, \"on\": Lyte._onObj, \"lyteOn\": Lyte._onObj };\n    };\n}\nif(!fnProto.computed){\n    fnProto.computed = function(){\n        Lyte.warn(\"'.computed()' method with the arguments '\" + arguments[0] + \"' cannot be executed outside component scope.\");\n        return { \"type\": \"computed\", \"value\": this, \"properties\": arguments };\n    };\n}\nLyte._onObj = function(){\n  return {\"type\": \"callBack\", \"value\":(this.type === \"observer\") ? this.value:this , \"properties\":arguments, \"observes\":(this.type === \"observer\" ? this: undefined)}\n}\nLyte._observesObj = function() {\n    return {\"type\" : \"observer\", \"value\" : this, \"properties\" : arguments, \"on\": Lyte._onObj, \"lyteOn\" : Lyte._onObj}\n}\nLyte._computedObj = function() {\n    return {\"type\" : \"computed\", \"value\" : this, \"properties\" : arguments}\n}\nLyte._preRegister = function(){\n  Lyte._actualFnProtoOn = Function.prototype.on;\n  Lyte._actualFnProtoObserves = Function.prototype.observes;\n  Lyte._actualFnProtoComputed = Function.prototype.computed;\n  let fnProto = Function.prototype;\n  fnProto.on = fnProto.lyteOn = Lyte._onObj;\n  fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;\n  fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;\n}\nLyte._postRegister = function(){\n  let fnProto = Function.prototype;\n  fnProto.on = Lyte._actualFnProtoOn;\n  fnProto.observes = Lyte._actualFnProtoObserves;\n  fnProto.computed = Lyte._actualFnProtoComputed;\n}\n\nObject.defineProperty(Lyte, \"_singleTonLookupMap\", {\n  enumerable : false, \n  writable : true, \n  value : new Map()\n});\nextendEventListeners(Lyte._singleTonLookupMap);\n// Lyte.prototype.arrayUtils = function(){\n//   if(this.$.modules.component && this.$.modules.component.length){\n//     let lc = this.$.modules.component[0]._getLyteComponent();\n//     return lc.aF.apply(lc, arguments);\n//   }else{\n//     this.error(\"arrayUtils will be supported only if component registry is imported in the app\");\n//   }\n// }\n// Lyte.prototype.objectUtils = function(){\n//   if(this.$.modules.component && this.$.modules.component.length){\n//     let lc = this.$.modules.component[0]._getLyteComponent();\n//     return lc.oF.apply(lc, arguments);\n//   }else{\n//     this.error(\"objectUtils will be supported only if component registry is imported in the app\");\n//   }\n// }\n// extendEventListeners(Lyte);\n// Logger.addEventListener(\"error\", function(){  \n//   var arr = Array.from(arguments);\n//   if (Lyte.onerror) {\n//     Lyte.onerror.apply(Lyte, arr);\n//   }\n//   if(Lyte.triggerEvent){\n//     arr.unshift(\"error\");\n//     Lyte.triggerEvent.apply(Lyte, arr);\n//   }\n// });\n\nwindow.addEventListener(\"getLyteIns\", function(ev){\n  if(ev && ev.detail && ev.detail.init){\n    ev.detail.init(Array.from(Lyte._instances));\n  }\n});\n// Lyte.prototype.Compile = {};\nwindow.LyteCls = Lyte;/* global lyte class */\nLyte.error = Logger.error.bind(Logger);\nLyte.warn = Logger.warn.bind(Logger);\nLyte.errorCodes = Logger.errorCodes;\nLyte.browser = {};\nLyte._component = {};\nLyte.appList = [];\nLyte._setDefaultApp = function(appClass){\n  Lyte._defaultApp = appClass;\n}\nLyte._setDefaultAppIns = function(appIns){\n  Lyte._defaultAppIns = appIns;\n}\nLyte._getDefaultApp = function(){\n  return Lyte._defaultAppIns;\n}\nLyte._getDefaultAppIns = function(){\n  return Lyte._defaultAppIns;\n}\nvar userAgent = navigator.userAgent;\n//temporary fix for IE 11\nif (userAgent.match(/rv:11/)) {\n  Lyte.browser.ie = true;\n  window.action = function () {\n    return;\n  };\n}\nif (userAgent.match('Edge')) {\n  var s = createElement(\"div\");\n  s.innerHTML = \"<template><div>c</div></template>\";\n  if (s.querySelector(\"template\").childNodes.length) {\n    Lyte.browser.ie = true;\n  } else {\n    Lyte.browser.edge = true;\n  }\n  s.remove();\n}\n\nLyte.reg = function(fn,options) {\n  let type = options.type;\n  let name = options.name;\n  if(Lyte.$scp[type][name] && Lyte.$sscp[type][name]){\n    fn(Lyte.$scp[type][name],Lyte.$sscp[type][name]);\n  }\n  else{\n    Lyte.$scp[type][name] = new Lyte(type,name);\n    Lyte.$sscp[type][name] = new Lyte.Store();\n    fn(Lyte.$scp[type][name],Lyte.$sscp[type][name]);\n  }\n}\nLyte.$scp = {app : {}, addon : {}, subApp : {}};\nLyte.$sscp = {app : {},subApp : {}}\n// Lyte.__lyteRegisteredEvents = {};\n// Lyte.addEventListener = addEventListener;\n// Lyte.removeEventListener = removeEventListener;\n// Lyte.triggerEvent = triggerEvent;\nLyte.toBeRegistered = [];\nLyte.nestScp = {};\nLyte.nestScpId = 1;\nLyte.addons = {};\nLyte.registeredCustomComponent = {};\nLyte.$ = {\n  assetsDiv : document.createElement(\"div\"),\n  shadowDiv : document.createElement(\"div\")\n}\nLyte.$.assetsDiv.setAttribute(\"id\", \"lyteAssetsDiv\");\nLyte.$.shadowDiv.setAttribute(\"id\", \"lyteShadowDiv\");\n\nLyte.domContentLoaded = function(callback) {\n  if(d.readyState === \"complete\" || d.readyState === \"interactive\") { \n    callback();\n  } else {\n    window.addEventListener('DOMContentLoaded', function() {\n      callback();\n    });\n  }\n}\n\nLyte.createApplication = function(name, config){\n  var ins = new Lyte(\"app\", name, config);\n  setTimeout(function() {\n    config.includes.forEach(function(module) {\n      module.init && module.init(ins);\n    });\n  },0)\n  if(Lyte.Store) {\n    var sins = new Lyte.Store();\n    Lyte.$sscp.app[name] = sins;\n  }\n  // window.Lte = Lyte.$scp.app[name] = ins;\n  return ins;\n}\n\nLyte.createEngine = function(name, config){\n  var ins = new Lyte(\"engine\", name, config);\n  // var sins = new Lyte.Store();\n  // Lyte.$sscp.engine[name] = sins;\n  Lyte.$scp.engine[name] = ins;\n  return ins;\n}\n\nLyte.createAddon = function(name, config){\n  var ins = new Lyte(\"addon\", name, config);\n  Lyte.$scp.addon[name] = ins;\n  return ins;\n}\n\n// Lyte.prototype.types = [\"string\", \"object\", \"number\", \"boolean\", \"array\"];\n\n// Lyte.prototype.deepCopyObject = function(obj){\n//   return copyObject(obj);\n// }\n\n// Object.defineProperty(Lyte, 'debug', {\n//   set : function(data) {\n//     Lyte._debug = Lyte.prototype.debug = data;\n//     return data;\n//   },\n//   get : function() {\n//     return Lyte._debug;\n//   }\n// });\n\n// Lyte.prototype.log = function (text, src, color) {\n//   if (this.config.debug) {\n//       if(color) {\n//           console.log(\"%c\" + text,'color:' + color);\n//       } else {\n//         console.log(text);      \n//       }\n//   }\n// };\n\n// Lyte.prototype.isComponent = function(object) {\n//   if(object && object.$node && object.__data) {\n//     return true;\n//   }\n//   return false;\n// }\n// Lyte.prototype.Transform = {};\n// Lyte.prototype.prop = function(type, opts){\n//   var obj = {};\n//   obj.type = type;\n//   if(opts == undefined){\n//     opts = {};\n//   }\n//   // if(this.types.indexOf(type) == -1 && !this.Transform.hasOwnProperty(type)){\n//   //   throw new Error(\"Not a valid field type - \"+type);\n//   // }\n//   Object.assign(obj,opts);\n//   return obj;\n// }\n\n// Lyte.prototype.one = function(name,opts){\n//   return defineRelation(name,\"belongsTo\",opts);\n// }\n\n// Lyte.prototype.many = function(name,opts){\n//   return defineRelation(name,\"hasMany\",opts);\n// }\n\n// Lyte.prototype.registerDataType = function(fieldTypeName, properties){\n//   var exts = \"extends\";\n//   if(this.Transform.hasOwnProperty(fieldTypeName)){\n//     this.error(\"Custom Field Type - \"+fieldTypeName+\" -  already exists.\");\n//     return;\n//   }\n//   if(properties[exts] == undefined || this.types.indexOf(properties[exts]) == -1){\n//     this.error(\"Not a valid field type - \"+properties[exts]);\n//     return;\n//   }\n//   this.Transform[fieldTypeName] = properties;\n// }\n\n// Lyte.prototype.registerPattern = function(patternName, pattern){\n//   this.patterns[patternName] = pattern;\n// }\n\n// Lyte.prototype.injectResources = function (files, every, completed, options) {\n//   var successFiles = [],\n//   errorFiles = [],\n//   scope = this;\n//   every = every || function () {};\n//   completed = completed || function () {};\n//   return new Promise(function (resolve,reject) {\n//     processRequirements(files, function () {\n//       if (options && options.defer) {\n//         options.defer({\n//           injectJS: injectJS,\n//           files: files,\n//           errorFiles: errorFiles\n//         });\n//         resolve();\n//       } else {\n//         injectJS(files, function () {\n//           completed(successFiles, errorFiles);\n//           if(errorFiles.length) {\n//               reject(successFiles, errorFiles);\n//             } else {\n//               resolve(successFiles, errorFiles);\n//             }\n//         });\n//       }\n//     }.bind(this));\n//   });\n\n//   function injectJS(files, resolve, execFiles) {\n//     execFiles = execFiles || []\n//     if (!files) {\n//       resolve(successFiles, errorFiles);\n//     } else {\n//       if (!Array.isArray(files)) {\n//         files = [files];\n//       }\n//       if (!files.length) {\n//         resolve(successFiles, errorFiles);\n//       }\n//       var len = -files.length;\n//       files.forEach(function (file) {\n//         if (typeof file == \"string\") {\n//            var fileSplit = file.split('.'),\n//           type = fileSplit[fileSplit.length - 1];\n//           if (type && type == \"js\" && execFiles.indexOf(file) == -1) {\n//             execFiles.push(file);\n//             createScript(file, function () {\n//               loaded();\n//             });\n//           } else {\n//             loaded();\n//           }\n//         } else if (Array.isArray(file)) {\n//           new Promise(function (r) {\n//             injectJS(file, r);\n//           }).then(function () {\n//             loaded();\n//           });\n//         } else {\n//           len--;\n//           new Promise(function (r) {\n//             injectJS(file.parent, r);\n//           }).then(function () {\n//             new Promise(function (r) {\n//               injectJS(file.child, r);\n//             }).then(function () {\n//               loaded();\n//             });\n//             loaded();\n//           });\n//         }\n//       });\n//     }\n\n//     function loaded() {\n//       len++;\n//       if (len == 0) {\n//         resolve(successFiles, errorFiles);\n//       }\n//     }\n//   }\n\n//   function createScript(file, resolve) {\n//     var ev = scope.injectResources.respObj[file];\n//     if (!scope.injectResources.availableTags[file] || scope.injectResources.availableTags[file].tag.tagName == \"LINK\") {\n//       var tag = document.createElement('script');\n//       tag.setAttribute('type', \"text/javascript\");\n//       ev.getAttributeNames().forEach(function (attr) {\n//         if ([\"href\", \"as\", \"rel\"].indexOf(attr) == -1) {\n//           tag.setAttribute(attr, ev.getAttribute(attr));\n//         }\n//       });\n//       tag.setAttribute('src', file);\n//       tag.onerror = tag.onload = function(event) {\n//         if (event.type == \"error\") {\n//           errorFiles.push(event)\n//         } else {\n//           successFiles.push(event)\n//         }\n//         scope.injectResources.availableTags[file].tag.remove();\n//         scope.injectResources.availableTags[file] = { tag: tag, event: { type: event.type == \"error\" ? \"error\" : \"load\"} };\n//         resolve();\n//       }\n//       Lyte.$.assetsDiv.appendChild(tag);\n//     } else {\n//       resolve();\n//     }\n//   }\n\n//   function processRequirements(files, resolve) {\n//     if (!files) {\n//       resolve();\n//     } else {\n//       if (!Array.isArray(files)) {\n//         files = [files];\n//       }\n//       if (!files.length) {\n//         resolve();\n//       }\n//       var len = -files.length;\n//       files.forEach(function (file) {\n//         if (typeof file == \"string\") {\n//           requestFile.call(scope, file, scope.injectResources.availableTags[file], function () {\n//             loaded();\n//           });\n//         } else if (Array.isArray(file)) {\n//           new Promise(function (r) {\n//             processRequirements(file, r);\n//           }).then(function () {\n//             loaded();\n//           });\n//         } else {\n//           len--;\n//           new Promise(function (r) {\n//             processRequirements(file.parent, r);\n//           }).then(function () {\n//             loaded();\n//           });\n//           new Promise(function (r) {\n//             processRequirements(file.child, r);\n//           }).then(function () {\n//             loaded();\n//           });\n//         }\n//       });\n//     }\n\n//     function loaded() {\n//       len++;\n//       if (len == 0) {\n//         resolve();\n//       }\n//     }\n\n//     function requestFile(file, cached, resolve) {\n//       if(this.$.reqFiles[file]) {\n//         this.$.reqFiles[file].push(resolve);\n//       } else {\n//         var scope = this;\n//         this.$.reqFiles[file] = [resolve];\n//         if (cached && cached.event.type != \"error\") {\n//           if (this.removeFromCache.arr.indexOf(file) != -1) {\n//             this.removeFromCache.arr.splice(scope.removeFromCache.arr.indexOf(file), 1);\n//           }\n//           fileLoaded.call(cached.tag, file, cached.event, true);\n//           resolve();\n//         } else {\n//           makeRequest(file, function (event) {\n//             scope.injectResources.respObj[file] = this;\n//             scope.$.reqFiles[file].forEach(function (resolve) {\n//               resolve();\n//             });\n//             // filesObj[file] = this;\n//             fileLoaded.call(this, file, event);\n//             every.call(this, event);\n//           });\n//         }\n//       }\n//     }\n\n//     function fileLoaded(file, event, cached) {\n//       delete scope.$.reqFiles[file];\n//       if (!cached) {\n//         if (scope.injectResources.availableTags[file]) {\n//           scope.injectResources.availableTags[file].tag.remove();\n//           delete scope.injectResources.respObj[file];\n//         }\n//         this.onerror = this.onload = undefined;\n//         scope.injectResources.availableTags[file] = { tag: this, event: { type: event.type } };\n//       }\n//     }\n//   }\n\n//   function makeRequest(file, callBack) {\n//     var tag,\n//         ev = every.internal || {},\n//         fileSplit = file.split('.'),\n//         type = fileSplit[fileSplit.length - 1];\n//     ev.file = file;\n//     if (fileSplit.length == 1) {\n//       Lyte.error('Type of file is not specified in injectResources.');\n//       return;\n//     }\n//     tag = document.createElement('link');\n//     tag.setAttribute('href', file);\n//     ev.tag = tag;\n//     if (type == 'css') {\n//       tag.setAttribute('type', \"text/css\");\n//       tag.setAttribute('rel', \"stylesheet\");\n//       tag.onerror = tag.onload = function (event) {\n//         // if (event.type == \"error\") {\n//         //   errorFiles.push(event);\n//         // } else {\n//         //   successFiles.push(event);\n//         // }\n//         callBack.call(this, event);\n//       };\n//     } else {\n//       tag.setAttribute('as', \"script\");\n//       tag.setAttribute('rel', \"preload\");\n//       tag.onerror = tag.onload = function (event) {\n//         // if (event.type != \"error\") {\n//         //   tag.status = 200;\n//         // }\n//         callBack.call(this, event);\n//       };\n//     }\n//     Lyte.triggerEvent(\"onBeforeInject\", ev);\n//     Lyte.$.assetsDiv.appendChild(tag);\n//   };\n// };\n\n// if(Lyte.browser.ie) { //remove no ie support // af\n//   Lyte.prototype.injectResources = function (files, every, completed) {\n//     var successFiles = [],\n//     errorFiles = []; \n//     every = every || function() {};\n//     completed = completed || function() {};\n//     return new Promise(function(resolve) {\n//       processRequirements(files, resolve);   \n//     }).then(function() {\n//       completed(successFiles,errorFiles);  \n//     });\n\n//     function processRequirements(files, resolve) {\n//       if(!files) {\n//         resolve();\n//       } else {\n//         if(!Array.isArray(files)) {\n//           files = [files];\n//         }\n//         if(!files.length) {\n//           resolve();\n//         }\n//         var len = -(files.length);\n//         files.forEach(function(file) {\n//           if(typeof file == \"string\"){\n//             requestFile.call(scope,file, scope.injectResources.availableTags[file], function() {\n//               loaded();\n//             });  \n//           } else if(Array.isArray(file)) {\n//             new Promise(function(r){\n//               processRequirements(file, r);\n//             }).then(function(){\n//               loaded();\n//             })\n//           } else {\n//             new Promise(function(r){\n//               processRequirements(file.parent, r);\n//             }).then(function(){\n//               new Promise(function(r1){\n//                 processRequirements(file.child, r1)\n//               }).then(function(){\n//                 loaded();\n//               })\n//             })\n//           }\n//         })\n//       }\n\n//       function loaded() {\n//         len++;\n//         if(len == 0) {\n//           resolve();\n//         }\n//       }\n\n//       function requestFile(file,cached,resolve) {\n//         if(this.$.reqFiles[file]) {\n//           this.$.reqFiles[file].push(resolve)\n//         } else {\n//           this.$.reqFiles[file] = [resolve];\n//           if(cached && cached.event.type != \"error\") {\n//             if(this.removeFromCache.arr.indexOf(file) != -1) {\n//               this.removeFromCache.arr.splice(this.removeFromCache.arr.indexOf(file),1);\n//             }\n//             fileLoaded.call(cached.tag,cached.event,true);\n//             resolve();\n//           } else {\n//             makeRequest(file,\n//               function(event) {\n//                 this.$.reqFiles[file].forEach(function(resolve) {\n//                   resolve();\n//                 });\n//                 fileLoaded.call(this,event);\n//                 every.call(this,event);\n//               }\n//             );\n//           }\n//         }\n//       }\n\n//       function fileLoaded(event,cached) {\n//         var file = this.getAttribute('src') || this.getAttribute('href');\n//         delete scope.$.reqFiles[file];\n//         if(!cached) {\n//           if(scope.injectResources.availableTags[file]) {\n//             scope.injectResources.availableTags[file].tag.remove();\n//           }\n//           this.onerror = this.onload = undefined;\n//           scope.injectResources.availableTags[file] = {tag : this, event : {type : event.type}};\n//         }\n//       }\n//     }\n\n//     function makeRequest(file,callBack) {\n//       var tags = { \".js\": 'script', \".css\" : 'link' },\n//       type = file.match(/\\.[a-zA-Z]+(?=\\?|$)/),\n//       tag = document.createElement(tags[type]);\n//       if (!type) {\n//         Lyte.error('Type of file is not specified in injectResources.');\n//         return;\n//       } else if (type == '.css') {\n//         tag.setAttribute('href', file);\n//         tag.setAttribute('type', \"text/css\");\n//         tag.setAttribute('rel', \"stylesheet\");\n//       } else {\n//         tag.setAttribute('src', file);\n//       }\n//       tag.onerror = tag.onload = function (event) {\n//         if(event.type == \"error\") {\n//           errorFiles.push(event);  \n//         } else {\n//           successFiles.push(event);\n//         }\n//         if(callBack) {\n//           callBack.call(this,event);\n//         }\n//       };\n//       var ev = every.internal || {};\n//       ev.file = file;\n//       ev.tag = tag;\n//       Lyte.triggerEvent(\"onBeforeInject\", ev);\n//       Lyte.$.assetsDiv.appendChild(tag);\n//     };\n//   };\n// }\n\n// Lyte.prototype.injectResources.availableTags = [];\n// Lyte.prototype.injectResources.respObj = [];\n\n// Lyte.prototype.removeFromCache = function(arr) {\n//   var scope = this;\n//   this.removeFromCache.assign.call(this,arr);\n//   if(this.removeFromCache.arr.length) {\n//     this.removeFromCache.arr.forEach(function(file) {\n//       if(scope.injectResources.availableTags[file]) {\n//         scope.injectResources.availableTags[file].tag.remove();\n//         delete scope.injectResources.availableTags[file];  \n//       }\n//     });\n//     this.removeFromCache.arr = [];\n//   }\n// }\n\n// Lyte.prototype.removeFromCache.arr = [];\n\n// Lyte.prototype.removeFromCache.assign = function(arr) {\n//     arr = arr == \"*\" ? Object.keys(this.injectResources.availableTags) : (Array.isArray(arr) ? arr : [arr]); \n//     this.removeFromCache.arr = this.removeFromCache.arr.concat(arr);\n//     return;\n// }\n\n// Lyte.prototype.triggerEvent = triggerEvent;\n\n// Lyte.prototype.addEventListener = addEventListener;\n\n// Lyte.prototype.removeEventListener = removeEventListener; \n\n// Lyte.prototype.extendEventListeners = extendEventListeners;\n\n// Lyte.prototype.resolvePromises = function(promises) {\n//   return new Promise(function(res, rej) {\n//     resolvePromises(promises).then(function(data) {\n//       res(data);\n//     },function(data) {\n//       rej(data);\n//     })\n//   })\n// }\n\nLyte.createCustomElement = function(customElementName, definition) {\n  var constructor = definition.constructor;\n  delete definition.constructor;\n  var connectedCallback = definition.connectedCallback;\n  delete definition.connectedCallback;\n  var attributeChangedCallback = definition.attributeChangedCallback;\n  delete definition.attributeChangedCallback;\n  var disconnectedCallback = definition.disconnectedCallback;\n  delete definition.disconnectedCallback;\n\n  this.defProperty = function(obj, key, val) {\n    var obj1 = {};\n    if(val.get) {\n      obj1.get = val.get\n    }\n    if(val.set) {\n      obj1.set = val.set\n    }\n    Object.defineProperty(obj, key, obj1);\n  }\n  class classDef extends HTMLElement {\n    constructor() {\n      super();\n      if(this.isNewComp(customElementName)){\n        this.executeCallbacks(constructor,arguments);\n      }else{\n        this.__lyteIgnore = true;\n      }\n    }\n\n    connectedCallback(){\n      let _LC = Lyte._instances[0].$.modules.component[0]._getLyteComponent();//temp fix\n      if(!_LC.ignoreDisconnect && !this.__lyteIgnore) {\n        this.executeCallbacks(connectedCallback,arguments);\n        this.setAttribute(\"lyte-rendered-ce\", \"\");\n      }\n    }\n    attributeChangedCallback(){\n      if(!this.__lyteIgnore) {\n        this.executeCallbacks(attributeChangedCallback,arguments);\n      }\n    }\n    disconnectedCallback(){\n      let _LC = Lyte._instances[0].$.modules.component[0]._getLyteComponent();//temp fix\n      if(!_LC.ignoreDisconnect && !this.__lyteIgnore) {\n        this.executeCallbacks(disconnectedCallback,arguments);\n      }\n    }\n    executeCallbacks(callBack,argArr){\n      if(callBack) {\n        callBack.apply(this, Array.from(argArr));\n      }\n    }\n    isNewComp(customElementName){\n      if(this.hasAttribute(\"lyte-rendered-ce\")) {\n        return false;\n      }\n      return true;\n    }\n  }\n  var staticDef = definition.static;\n  if(staticDef) {\n    for(var key in staticDef) {\n      if(typeof staticDef[key] === \"object\") {\n        this.defProperty(classDef, key, staticDef[key]);\n      } else {\n        Object.defineProperty(classDef, key, {\n          value : staticDef[key]\n        });\n      }\n    }\n    delete definition.static;\n  }\n  for(var key in definition) {\n    if(typeof definition[key] === \"object\") {\n      this.defProperty(classDef.prototype, key, definition[key]);\n    } else {\n      Object.defineProperty(classDef.prototype, key, { writable: true, value : definition[key]});\n    }\n  }\n  definition.static = staticDef;\n  definition.constructor = constructor;\n  definition.connectedCallback = connectedCallback;\n  definition.attributeChangedCallback = attributeChangedCallback;\n  definition.disconnectedCallback = disconnectedCallback;\n  if (document.readyState === \"complete\" || document.readyState === \"interactive\") {     \n    // document is already ready to go\n    customElements.define(customElementName, classDef);\n  }\n  else{\n    // ***\n    //Change the Lyte to instance\n    Lyte.toBeRegistered.push({name:customElementName, def: classDef});\n  }\n  Lyte.registeredCustomComponent[customElementName] = classDef;\n}\n\nfunction domContentLoaded1() {\n  document.head.appendChild(Lyte.$.assetsDiv);\n  document.head.appendChild(Lyte.$.shadowDiv);\n  let comp = Lyte.toBeRegistered;    \n  if(comp && comp.length){    \n      for(let j=0; j<comp.length;j++){\n          customElements.define(comp[j].name, comp[j].def);    \n      }    \n      Lyte.toBeRegistered = [];    \n  }\n}\n\nif(document.readyState === \"complete\" || document.readyState === \"interactive\") {\n    domContentLoaded1();\n} else {\n    document.addEventListener(\"DOMContentLoaded\", function(e){\n        domContentLoaded1();\n    },true);\n}\n\n//@3055\n// var XHRSend = XMLHttpRequest.prototype.send;\n// XMLHttpRequest.prototype.send = function(){\n//     var event = window.event;  \n//     var type, target = event ? event.target : undefined; \n//     let regIns = getConfig(\"stateHandling\",true)\n//     if(getConfig(\"stateHandling\")){\n//         if(event){\n//             type = event.type;\n//             /^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute(\"lyte-state-handling\") != \"false\" ? addStateToMap(type,target,this) : undefined;\n//         }\n//         else{\n//             var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;\n//             if(router){\n//                 var currentAction = router.transition ? router.transition.ev : undefined;\n//                 if(currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute(\"lyte-state-handling\") != \"false\"){\n//                     var mp = window.__transXHRMap = window.__transXHRMap || new Map();\n//                     mp.set(router.transition, {currentAction : currentAction, XHR:this});\n//                     addStateToMap(currentAction.type, currentAction.target, this);\n//                 }\n//             }\n//         }\n//     }\n//     XHRSend.apply(this, arguments);\n// }\n\n// Lyte.prototype.setState =   function(str){\n//   if(!str){\n//     console.error(\"Please provide a state name\");\n//   }\n//   var evnt = window.event;\n//   if(/^(click|dblclick)$/.test(evnt.type)){\n//       var target = evnt.target;\n//       if(getConfig(\"stateHandling\") == true && target && target.getAttribute && target.getAttribute(\"lyte-state-handling\") != \"false\"){\n//           var state = target.getAttribute(\"lyte-state\");\n//           if(!state){\n//               var mp = window.__stateMap = window.__stateMap || new Map();\n//               var mpobj = mp.get(str);\n//               if(!mpobj){\n//                   var obj = addStateToMap(evnt.type, target, undefined, str);\n//                   mp.set(str, obj);\n//               }\n//               else{\n//                   console.error(\"There is already a open state by the name\",str);\n//               }\n//           }\n//       }        \n//   }\n// }\n\n// Lyte.prototype.removeState = function(str){\n//     if(!str){\n//         console.error(\"Please provide a state name\");\n//     }\n//     var mp = window.__stateMap;\n//     if(mp){\n//         var obj = mp.get(str);\n//         if(obj){\n//             mp.delete(str);\n//             removeStateFromMap(str, obj.event, obj.target);\n//         }\n//     }\n// }\n\n// Lyte.prototype.setConfig = function(key, value){\n//     var configObj = window.__config = window.__config || {};\n//     configObj[key] = value;\n// }\n\n// Lyte.prototype.getConfig = getConfig;  @3055\n\n\n// Lyte.errorCodes = errorCodes;\n// Lyte.registerErrorCodes = registerErrorCodes;\n// Lyte.getErrorMessage = getErrorMessage;\n\nexport { Lyte, __instances, __componentsMap, __getCurrentContext, toLowerCase, __getCurrentFunc, __scopedInstance, __setCurrentContext};\n\n\n","function resolvePromises(promises) {\n    if(typeof promises == \"string\" || promises instanceof Promise) {\n        return promises;\n    } else {\n        if(Array.isArray(promises)) {\n        return promiseArray(promises);\n        } else if(typeof promises == \"object\") {\n        return promiseHash(promises);\n        }    \n    }\n\n    function promiseHash(promiseObj) {\n        var actPromKeys = [],\n        promises = [],\n        promiseKeys = Object.keys(promiseObj);\n        promiseKeys.forEach(function(key) {\n            var value = promiseObj[key];\n        if(value instanceof Promise) {\n            actPromKeys.push(key)\n            promises.push(value);\n        }\n        });\n        if(!promises.length) {\n            return Promise.resolve(promiseObj);\n        } else {\n            var obj = {},promise = new Promise(function(resolve,reject) {\n            Promise.all(promises).then(function(data) {\n                promiseKeys.forEach(function(promiseKey) {\n                if(actPromKeys.indexOf(promiseKey) != -1) {\n                    obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)]\n                } else {\n                    obj[promiseKey] = promiseObj[promiseKey];\n                }\n                });\n            resolve(obj);\n            },function(err) {\n            reject(err);\n            });\n        });   \n        return promise;\n        }\n    }\n    \n    function promiseArray(promiseArray) {\n        var array = [],\n        hasPromise = false;\n        promiseArray.every(function(item,i) {\n            if(item instanceof Promise) { \n                hasPromise = true;\n                return false;\n            }\n            return true\n        });\n        if(!hasPromise) {\n            return Promise.resolve(promiseArray);\n        }\n        var promise = new Promise(function(resolve,reject) {\n            Promise.all(promiseArray).then(function(data) {\n                promiseArray.forEach(function(key,index){\n                    array[index] = data[index];\n                });\n                resolve(array);\n            },function(err) {\n                reject(err);\n                \n            });\n        });   \n        return promise;\n    }\n};\n\nexport {\n    resolvePromises\n}","import { __getCurrentContext, __getCurrentFunc, __setCurrentContext, toLowerCase, Lyte } from \"@slyte/core/src/lyte.js\"\nimport { extendEventListeners } from \"@slyte/core/src/lyte-utils\";\n/*convert to custom class*/\nclass Service { \n    static actions(arg1) {\n      if(super.actions){\n        return super.actions(arg1 ? arg1 : {});\n      }\n      return arg1 ? arg1 : {};\n    }\n    static methods(arg1) {\n      if(super.methods){\n        return super.methods(arg1 ? arg1 : {});\n      }\n      return arg1 ? arg1 : {};\n    }\n    static observers(arg1) {\n      if(super.observers){\n        return super.observers(arg1 ? arg1 : {});\n      }\n      return arg1 ? arg1 : {};\n    }\n    data(arg1) {\n      if(super.data){\n        return super.data(arg1 ? arg1 : {});\n      }\n      return arg1 ? arg1 : {};\n    }\n    constructor() {\n        var context = __getCurrentContext();\n        // if(context){\n        if(context.__isAddon) {\n            if(this.__isAddon){\n                this.$parent = context;\n                this.$app = context.$app;\n            }else{\n                this.$addon = context;\n            }\n            if(toLowerCase(this.constructor.name) !== \"utils\"){\n                this.$utils = context.$utils;\n            }\n        } else {\n            this.$app = context;\n            if(this.__isAddon){\n                this.$parent = context;\n            }\n            if(toLowerCase(this.constructor.name) !== \"utils\"){\n                this.$utils = context.$utils;\n            }\n        }\n        var func = __getCurrentFunc();\n        var lookupMap;\n        if(this.__isAddon){\n            Object.defineProperty(this, \"__lyte\", {\n                enumerable : false, \n                writable : true, \n                value : {\"lookupMap\" : new Map()}\n            });\n            lookupMap = this.__lyte.lookupMap;\n            extendEventListeners(this.__lyte.lookupMap);\n        }\n        else{\n            if(this.$addon){\n                lookupMap = this.$addon.__lyte.lookupMap;\n            }else if(this.$app){\n                lookupMap = this.$app.__lyte.lookupMap;\n            }\n        }\n        if(func) {\n            func(this);\n        }\n        var oldContext = __getCurrentContext();\n        if(this.__isAddon) {\n            __setCurrentContext(this);\n        }\n        \n        if(lookupMap.get(this.constructor)){\n            lookupMap.set(this.constructor,this);\n        }\n        else if(this.constructor.SINGLETON){\n            Lyte._singleTonLookupMap.set(this.constructor,this);\n        }\n\n        var lookups = this.lookups();\n        // if(this.$addon){ //commented since lookups returned array - we are not using or holding it for anny purpose\n        //     this.$addon.__lyte.lookupMap.lookups = lookups;\n        // }else{\n        //     this.$app.__lyte.lookupMap.lookups = lookups;\n        // }\n        __handleLookups(lookups, this.__isAddon ? this : context, this);\n        this.__lookups = lookups;\n        if(this.__isAddon) {\n            __setCurrentContext(oldContext);\n        }\n        // }else{\n            // debugger\n        // }\n    }\n    \n    lookups() {\n        return [];\n    }\n\n    onLookup() {\n        \n    }\n}\nfunction __getLyte(service){\n    return service.$addon ? service.$addon.__lyte : service.__lyte ? service.__lyte : service.$app.__lyte;\n}\nfunction __handleLookups(lookups, app, curr) {\n    if(lookups && lookups.length){\n        var appLookupMap = app.__lyte.lookupMap;\n        var currLookupMap = __getLyte(curr).lookupMap;\n        lookups.forEach(function(item) {\n            if(!item){\n                Lyte.error(\"Invalid class/instance passed in \"+ curr.constructor.name + \"'s lookup hook.\")\n                return\n            }\n            if(typeof item == \"string\") {\n                if(curr) {\n                    if(item.length){\n                        if(appLookupMap.get(item)){\n                            curr[\"$\" + item] = appLookupMap.get(item);\n                            __callOnLookup(curr[\"$\" + item], curr);\n                        }\n                        else{\n                            var id = app.__lyte.lookupMap.addEventListener(item, function(ins){\n                                curr[\"$\" + item] = ins;\n                                __callOnLookup(ins, curr);\n                                app.__lyte.lookupMap.removeEventListener(id);\n                            });\n                        }\n                    }\n                    else{\n                        Lyte.error(\"Lookup cannot be added for empty(undefined) key\");\n                    }\n                }\n            } else {\n                if(__checkIfService(item)) {\n                    instantiateService(item, app, curr);\n                } else if(Object.keys(item).length == 1) {\n                    for(var onlyKey in item){\n                        var val = item[onlyKey];\n                        if(onlyKey.length){\n                            if(/^(utils|node|lg|app|addon)$/.test(onlyKey)){\n                                Lyte.error(\"Lookup cannot be added for the predefined key - \"+ onlyKey);\n                                return;\n                            }\n                            let name = \"$\" + onlyKey;\n                            if(__checkIfService(val)) {\n                                instantiateService(val, app, curr, name);\n                            } else {\n                                if(val && typeof val == \"object\"){\n                                    curr[name] = val;\n                                    __callOnLookup(val, curr);\n                                    if(!appLookupMap.get(onlyKey)){\n                                        appLookupMap.set(onlyKey, val); //how singleton af ?\n                                        appLookupMap.triggerEvent(onlyKey, val);\n                                    }\n                                }\n                                else if(typeof val == \"string\"){\n                                    if(appLookupMap.get(val)){\n                                        curr[name] = appLookupMap.get(val);\n                                        __callOnLookup(curr[name], curr);\n                                    }\n                                    else{\n                                        var id = appLookupMap.addEventListener(val, function(ins){\n                                            curr[name] = ins;\n                                            __callOnLookup(ins, curr);\n                                            appLookupMap.removeEventListener(id);\n                                        });\n                                    }\n                                }\n                                currLookupMap.set(onlyKey, val);\n                            }\n                        }\n                        else{\n                            Lyte.error(\"Lookup cannot be added for empty(undefined) key\");\n                        }\n                    }\n                }\n            }\n            \n        });\n    }\n}\n\nfunction instantiateService(cls, app, curr, name) {\n    name = name || (\"$\" + toLowerCase(cls.name));\n    let appLookupMap = app.__lyte.lookupMap;\n    // let currLookupMap = curr.__lyte.lookupMap;\n    let lookupValue = appLookupMap.get(cls);\n    if(lookupValue) {\n        if(lookupValue instanceof Promise) {\n            lookupValue.then(function(val) {\n                curr[name] = val;\n                __callOnLookup(val, curr);\n            });\n        } else {\n            curr[name] = lookupValue;\n            __callOnLookup(lookupValue, curr);\n        }\n    } else {\n        if(cls.SINGLETON){\n            let singleTonclass = Lyte._singleTonLookupMap.get(cls)\n            if(singleTonclass){\n                curr[name] = singleTonclass;\n                return;\n            }else{\n                Lyte._singleTonLookupMap.set(cls,cls);\n            }\n        }else{\n            appLookupMap.set(cls, cls);\n        }\n        let obj = curr[name] = new cls();\n        __callOnLookup(obj, curr);\n        appLookupMap.triggerEvent(name, obj);\n    }\n}\nfunction __checkIfService(item) {\n    var isService = false;\n    while(item != null) {\n        if(item == Service || item.__lyteOrigClass) {\n            isService = true;\n            break;\n        } else {\n            item = Object.getPrototypeOf(item);\n        }\n    }\n    return isService;\n}\n\nfunction __callOnLookup(service, module) {\n    if(service && service.onLookup) {\n        service.onLookup(module);\n    }\n}\nexport { Service, __checkIfService, __handleLookups ,__getLyte}\n","import { Service } from \"@slyte/core\"\nimport { isInheritedClass, isEntity } from \"@slyte/core/src/lyte-utils.js\";\nimport {  initCB, getFromCB, dbModName } from \"./utils.js\";\nimport { ConnectorError } from \"./dberror.js\";\n/*convert to custom class*/\nclass Connector extends Service {\n    constructor(){\n        super();\n        this.constructor._name = dbModName(this.constructor.name, \"Connector\");\n    }\n    static processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts){\n        return new Promise(function(resolve, reject){\n            if(xhr){\n                var contentType = xhr.getResponseHeader('content-type'),\n                resp,\n                isSuccess = xhr && (xhr.status.toString()[0] == \"2\" || xhr.status.toString()[0] == \"3\") ? true : false,\n                def = db.getSchemaObj(name),\n                cresp;\n                if(Connector.JSON.test(contentType)){\n                    resp = xhr.responseText.length ? JSON.parse(xhr.responseText) : JSON.parse(\"{}\");\n                }\n                else if(Connector.TEXT.test(contentType)){\n                    try {\n                        resp = JSON.parse(xhr.responseText);\n                    }\n                    catch(exp){ \n                        resp = new ConnectorError(\"Cannot parse the data\", xhr);\n                        isSuccess = false;\n                    }\n                }\n                else if(type !== \"triggerAction\"){\n                    resp = xhr.responseText;\n                }\n                else{\n                    resp = new ConnectorError(\"Not an acceptable content-type: \"+contentType, xhr);\n                }\n                argsObj.payLoad = resp;\n                // def = getSchemaObj(db, def);\n                var res = initCB(\n                    db,\n                    \"connector\",\n                    def ? def.connector : undefined,\n                    Connector.PARSERESPONSE,\n                    { argsObj: argsObj, args:[type, name, xhr, resp, urlObj ? urlObj.qP : undefined, key, customData, opts]}\n                );\n                if(res){\n                    cresp = res.data;\n                    resp = argsObj.payLoad = cresp;\n                }\n                if(cresp && cresp instanceof Promise)\n                {\n                    return cresp.then(function(res){\n                        argsObj.payLoad = res;\n                        return resolve(res)\n                    }, function(res){\n                        return reject(res);\n                    })\n                    // return RESTConnector.handleParseResponsePromise(db,cresp,def,type,key,urlObj,xhr,undefined,undefined,undefined,resolve,reject,opts,argsObj);\n                }\n                else{\n                    if(isSuccess){\n                        return resolve(resp)\n                    }\n                    else{\n                        return reject(resp);\n                    }\n                }\n\n            }\n        });\n    }\n\n    static sendXHR(db,name,type,key,urlObj,customData,argsObj,opts){\n        var xhr = new XMLHttpRequest();\n        var prm = new Promise(function(res, rej){\n            argsObj.xhr = xhr;\n            xhr.open(urlObj.method, urlObj.url, true);\n            for(var header in urlObj.headers){\n                xhr.setRequestHeader(header, urlObj.headers[header]);\n            }\n            if(urlObj.data !== undefined && !(urlObj.data instanceof FormData) && ( urlObj.headers && !urlObj.headers.hasOwnProperty(\"Content-Type\") && urlObj.method !== \"GET\")){\n                xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n            }\n            xhr.withCredentials = (urlObj.withCredentials)?true:false;\n            var sch = db.getSchemaObj(name);\n            if(sch && sch.connector){\n                initCB(db, \"connector\", sch.connector, /*RESTConnector.PARSEREQUEST*/ \"parseRequest\", { argsObj: argsObj, args:[type, name, xhr ,urlObj ? urlObj.qP : undefined, key, customData]});\n            }\n            db.emit(\"beforeRequest\", [xhr, name, type, key, urlObj.qP]);\n            xhr.send(urlObj.data);\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState == 4){\n                    db.emit(\"afterRequest\",[xhr, name, type, key, urlObj.qP]);\n                    argsObj.status = xhr.status;\n                    /*RESTConnector.processResponse*/ Connector.processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts).then(function(data){\n                        return res({data:data, xhr:xhr});\n                    }, function(err){\n                        return rej({data:err, xhr:xhr});\n                    });\n                }\n            }\n        });\n        prm.xhr = xhr;\n        return prm;\n    }\n    static getConnector(db, def, argsObj, defless){\n        var defObj = def;\n        def = def.def ? def.def : def\n        if(defless){\n            if(db.Connector.hasOwnProperty(def)){\n\n            }\n        }\n        else if(def && def.Connector && !isInheritedClass(def.Connector, db.constructor.ConnectorCls) && typeof def.Connector == \"function\" ){\n            var parent = Object.getPrototypeOf(def.Connector), parentName = parent ? parent.name :undefined, context;\n            var connec = def.Connector.apply(def, [argsObj]);\n            if(connec){\n                db.lyte.scopedInstance(connec, [db], function(ins){\n                    defObj.connector = ins;\n                }, [db]);\n                context = defObj.connector.__type;\n                db.connector[context] = db.connector[context] || {};\n                db.connector[context][defObj.connector.constructor._name] = defObj.connector;\n            }\n        }\n    }\n    static getSerializer(db, def, argsObj){\n        var defObj = def;\n        def = def.def ? def.def : def\n        if(def && def.Serializer && !isInheritedClass(def.Serializer, db.constructor.SerializerCls) && typeof def.Serializer == \"function\"){\n            var parent = Object.getPrototypeOf(def.Serializer), parentName = parent ? parent.name :undefined, context;\n            var serz = def.Serializer.apply(def, [argsObj]);\n            if(serz){\n                db.lyte.scopedInstance(serz, [db], function(ins){\n                    defObj.serializer = ins;\n                }, [db]);\n                context = defObj.serializer.__type;\n                db.serializer[context] = db.serializer[context] || {};\n                db.serializer[context][defObj.serializer.constructor._name] = defObj.serializer;\n            }\n        }\n    }\n    static getSuccess(db,def,type,key,urlObj,respObj,resolve,reject,response,resObj,from,opts,argsObj){\n        var resp = respObj ? respObj.data : response, \n        // req = respObj ? respObj.xhr : undefined, \n        req,\n        xhr = respObj ? respObj.xhr : undefined,\n        batchIndex, \n        batch, \n        customD = opts.customD, \n        name = def && def._name ? def._name : def,\n        status = xhr ? xhr.status : undefined;\n        if(from != \"idb\"){\n            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;\n            if(resObj){\n                batchIndex = resObj.index;\n                batch = resObj.batch;\n                argsObj.xhr = req = resObj.resp;\n                argsObj.payLoad = resObj.content;\n                var res = initCB(db,\"connector\", def.connector, baseCons.PARSERESPONSE , { argsObj: argsObj, args:[type, name, req, resp, urlObj ? urlObj.qP : undefined, key, customD, opts]});\n                if(res){\n                    resp = res.data;\n                }\n                if(resp instanceof Promise)\n                {\n                    return baseCons.handleParseResponsePromise(db,resp,def,type,key,urlObj,xhr,undefined,batchIndex,batch,resolve,reject,opts,argsObj);\n                }\n                else{\n                    argsObj.payLoad = resp;\n                }\n            }\n            // if(req){\n                argsObj.payLoad = resp;\n            // }\n            return baseCons.findParseRequestPromise(db, resp,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj);\n        }\n        var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,\"batch\",{index:batchIndex,batch:batch}] : from ? [resp, \"idb\"] : [resp];\n        resolve(resArr);\n    }\n    static getFailure(db,def,type,key,urlObj,respObj,resolve,reject,opts,content,code,argsObj,bObj){\n        var customD = opts.customD, \n        name = def && def._name ? def._name : def;\n        var xhr = respObj? respObj.xhr : undefined,\n        response = respObj ? respObj.data : undefined;\n        if(xhr){\n            var resp;         \n            argsObj.payLoad = response;\n            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;\n            var res = initCB(db,\"connector\", def ? def.connector : undefined, baseCons.PARSERESPONSE, { argsObj: argsObj, args:[type, name, xhr, response ,urlObj ? urlObj.qP : undefined, key, customD, opts]});\n            if(res){\n                resp = res.data;\n                argsObj.payLoad = resp;\n            }\n            if(resp instanceof Promise)\n            {\n                return baseCons.handleParseResponsePromise(db,resp,def,type,key,urlObj,xhr,undefined,undefined,undefined,resolve,reject,opts,argsObj);\n            }\n            return reject(xhr);\n        }\n        else if(content){\n            var batch, batchIndex;\n            if(bObj){\n                batchIndex = bObj.index;\n                batch = bObj.batch;\n            }\n            db.$.batchResponse[batch][batchIndex] = {code:code, status:\"requestFailure\", data:content};\n            return reject({code:code,status:\"requestFailure\", data:content});\n        }\n        return reject(respObj.data);\n    }\n    static handleParseResponsePromise(db,response,def,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts,argsObj)\n    {\n        response.then(function(payload){\n            argsObj.payLoad = payload;\n            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;\n            if(type == \"get\")\n            {\n                baseCons.findParseRequestPromise(db, payload,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj);\n            }\n            else\n            {\n                baseCons.otherParseRequestPromise(db, payload,def,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts ? opts.customD : undefined,undefined,argsObj,key);\n            }\n        },function(payload){\t\n            reject(xhr);\n        });\n    }\n    static findParseRequestPromise(db, payload,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj){\n        var options = Object.assign({},opts);\n        delete options.customD;\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer; \n        var resp = baseSerz.getResponse(db,payload,def,type,key,urlObj,xhr, opts ? opts.customD : undefined, options,argsObj);\n        var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,\"batch\",{index:batchIndex,batch:batch}] : [resp];\n        resolve(resArr);\n    }\n    static create(db, name, data, isSingleRecord, customData, qP, mutationName){\n        var type= isSingleRecord ? \"createEntity\": \"create\", \n        def = db.schema[name], \n        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData};\n        Connector.getConnector(db, def, argsObj);\n        Connector.getSerializer(db, def, argsObj);\n        return def.connector.constructor.create.apply(def.connector.constructor, arguments);\n    }\n    static put(db, name, data, record, isSingleRecord,customData, qP, mutationName){\n        var def = db.schema[name], \n        bK = def.bK , \n        isComp = def.isComp, \n        type = (isSingleRecord) ? \"updateEntity\" : \"update\", \n        key = isSingleRecord ? (isComp && bK ? record[bK] : record.$.pK) : undefined, \n        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};\n        Connector.getConnector(db, def, argsObj);\n        Connector.getSerializer(db, def, argsObj);\n        return def.connector.constructor.put.apply(def.connector.constructor, arguments);\n    }\n    static del(db, name, data, isSingleRecord, destroy, customData, qP, mutationName){\n        var def = db.schema[name], \n        bK = def.bK , \n        isComp = def.isComp, \n        type = destroy || \"deleteEntity\", \n        key = isSingleRecord ? (isComp && bK ? data[bK] : data.$.pK) : undefined, \n        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};\n        Connector.getConnector(db, def, argsObj);\n        Connector.getSerializer(db, def, argsObj);\n        return def.connector.constructor.del.apply(def.connector.constructor, arguments);\n    }\n    static otherParseRequestPromise(db,resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,argsObj,key){\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer; \n        var response = baseSerz.genericResponse(db,resp,def,type,data,urlObj,xhr,partialObj,customData,partialRef,argsObj);\n        if(batchIndex != undefined){\n            db.$.batchResponse[batch][batchIndex] = response;\n        }\n        if(type != \"action\" && db.idbIns && def){\n            db.idbIns.updateIDB(db,def._name,type,data,customData,urlObj);\n        }\n        var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;\n        if(baseCons.constructor.returnData == \"new\"){\n            var obj = {};\n            if(xhr && xhr.status){\n                obj.status = xhr.status;\n            }\n            if(obj.status === 204){\n                obj.data = null;\n            }\n            else{\n                obj.data = response;\n            }\n        }\n        resolve(response);\n    }\n    static handleRequest(db,urlObj,name,data,type,changedData,customData,partialObj,key,actionName, partialRef, argsObj){\n        if(urlObj.data && (typeof urlObj.data == \"object\" || isEntity(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){\n            // urlObj.reqData = Lyte.deepCopyObject(urlObj.data);\n            urlObj.data = JSON.stringify(urlObj.data);\n        }\n        var self = this, xhr, key, def = db.schema[name], prmXhr;;\n        var prm = new Promise(function(resolve, reject){\n            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;\n            var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;             \n            var processRequest = getFromCB(db,\"connector\", def ? def.connector : undefined, baseCons.PROCESSREQUEST),sendXHR = true;\n            var makeBatch = db.$.makeBatch;\n            var batchPro = false;\n            if(processRequest){\n                sendXHR = false;\n                var returnPromise = self.callGeneric(db,type,def,urlObj.data,data,customData,urlObj?urlObj.qP:undefined,key,urlObj.url,actionName,urlObj.method,urlObj.headers,argsObj),response;\n                if(returnPromise instanceof Promise){\n                    batchPro = true;\t\t\t\t\t\t\n                    returnPromise.then(function(resp){\n                        resp = (resp == \"\" ? JSON.parse(\"{}\") : JSON.parse(resp));\n                        response = baseSerz.genericResponse(db,resp,def,type,data,urlObj,undefined,partialObj,customData,undefined,argsObj);\n                        resolve(response);\n                    },function(message){\n                        reject(message);\n                    });\n                }\n                else{\n                    sendXHR = true;\n                }\n            }\n            if(makeBatch && !batchPro){\n                baseCons.constructBatch(db,name,type,key,urlObj,customData).then(function(respObj){\n                    var resp = respObj.content; \n                    baseCons.handleSuccess(db, name, type, xhr, data, urlObj, resolve, resp, respObj,undefined,reject,key,customData,actionName,partialRef, argsObj);\n                    // resolve(resp);\n                },function(resObj){\n                    baseCons.handleFailure(db, name, type, xhr, data, urlObj, resolve,resObj.content,undefined,reject,key,customData,resObj.code,actionName, argsObj, resObj);\n                });\n            }\n            else if(sendXHR){\n                var argsXHR = [db,name,type,key,urlObj,customData,argsObj];\n                var xhrPrm = baseCons.sendXHR.apply(baseCons, argsXHR);\n                xhrPrm.then(function(xhrResp){\n                    baseCons.handleSuccess(db, name, type, xhrResp, data, urlObj, resolve, undefined, undefined, partialObj,reject,key,customData,actionName,partialRef,argsObj);\t\t\t\t\t\n                },function(xhrResp){\n                    baseCons.handleFailure(db, name, type, xhrResp, data, urlObj, resolve, undefined,partialObj,reject,key,customData,undefined,actionName,argsObj);\n                });\n                prmXhr = xhrPrm.xhr;\n            }\n        });\t\n        if(prmXhr){\n            prm.xhr = prmXhr;\n        }\n        return prm;\n    }\n    static handleSuccess(db, name, type, xhrResp, data, urlObj, resolve, resp, respObj, partialObj, reject, key, customData, actionName, partialRef, argsObj){\n        var resp = resp ? resp : xhrResp ? xhrResp.data : undefined, \n        req, \n        batchIndex, \n        batch, \n        xhr = xhrResp ? xhrResp.xhr : undefined,\n        req = xhr ? xhr : undefined,\n        def = db.schema[name], \n        opts = { customD : customData };\n        var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;\n        if(respObj){\n            batchIndex = respObj.index;\n            batch = respObj.batch;\n            req = respObj.resp;\n            argsObj.xhr = req;\n            var res = initCB(db,\"connector\", def && def.connector ? def.connector : undefined, baseCons.PARSERESPONSE, { argsObj:argsObj, args:[type, name, req, resp, urlObj ? urlObj.qP : undefined, key,customData,undefined,actionName]});\n            if(res){\n                resp = res.data;\n                if(resp instanceof Promise)\n                {\n                    return baseCons.handleParseResponsePromise(db,resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts,argsObj);\n                }\n                else{\n                    argsObj.payLoad = resp;\n                }\n            }\n        }\n        return this.otherParseRequestPromise(db, resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,argsObj,key);\n    }\n    static handleFailure(db, name, type, xhrResp, data, urlObj, resolve, respObj, partialObj,reject,key,customData,code,actionName,argsObj,bObj){\n        var def = db.schema[name],\n        xhr = xhrResp ? xhrResp.xhr : undefined;\n        if(xhr){\n            var resp, \n            response = xhrResp ? xhrResp.data : undefined;\n            argsObj.payLoad = response;\n        }\n        else if(respObj){\n            var batch, batchIndex;\n            if(bObj){\n                batchIndex = bObj.index;\n                batch = bObj.batch;\n            }\n            db.$.batchResponse[batch][batchIndex] = {code:code, status:\"requestFailure\", data:respObj};\n            reject({code:code, status:\"requestFailure\", data:respObj});\n        }\n        reject(response);\n    }\n}\nConnector.__lMod = \"Connector\";\nConnector.returnData = \"old\";\nConnector.PARSEREQUEST = \"parseRequest\";\nConnector.REQUESTURL = \"requestURL\";\nConnector.REQUESTHEADERS = \"requestHeaders\";\nConnector.REQUESTMETHOD = \"requestMethod\";\nConnector.REFETCHALL = \"refetchAll\";\nConnector.REFETCH = \"refetchEntity\";\nConnector.PROCESSREQUEST = \"processRequest\";\nConnector.PARSERESPONSE = \"parseResponse\";\nConnector.JSON = /application\\/json/;\nConnector.TEXT = /text\\/plain/;\nexport { Connector };\n","import { Dberror, ValidationError } from \"./dberror\";\nimport { Schema as SchemaClass } from \"./Schema.js\";\nimport { cacheQuery, cacheRecordQuery, cB, cbScp, comparePk, _defProp, evAdd, evEmit, evRemove, handleCachedResponse, initCB, insertIntoStore, isDirty, isEmpty, isEmptyArray, isEmptyObj, newRecord, registerField, removeFromStore, rollBackDelete, rollBackNew, toInsertData, unRegCb, unregisterDef, updateFieldValidation, updateJSON, validateRecord, getInd, handleArrOp, compareData, getSchemaObj, getOrigParent } from \"./utils.js\";\nimport { Entity, $Entity } from \"./Entity.js\";\nimport { extendEventListeners, isEntity, getSuperClass, newGetSuperClass, prop } from \"@slyte/core/src/lyte-utils\";\nimport { DataType as DataTypeClass } from \"@slyte/core\";\nimport { Service } from \"@slyte/core/src/service\";\nimport { Connector } from \"./Connector\";\nimport { Serializer } from \"./Serializer\";\n/*convert to custom class*/\nclass Db extends Service {\n    // getConnector(name, type){\n    //     if(type == \"graphql\"){\n    //         return this.GraphqlConnector.connector[name];\n    //     }    \n    //     return this.RESTConnector.connector[name];\n    // }\n    // getSerializer(name, type){\n    //     if(type == \"graphql\"){\n    //         return this.GraphqlSerializer.serializer[name];\n    //     }  \n    //     return this.RESTSerializer.serializer[name];\n    // }\n    registerPattern(key, pattern) {\n        this.patterns[key] = pattern;\n    }\n    static getSchema(name){\n        return this.Schema.schema[name];\n    }\n    static dataType(type){\n        var self = this;\n        class dataType extends self.DataType {}\n        dataType.extends = type;\n        return dataType;\n    }\n    static register(opts){\n        var hash = opts ? opts.hash : this.name;\n        var DT = this.DataType = (function() {\n            class DataType extends DataTypeClass {}\n            return DataType;\n        })();\n        DT.register = function(){\n            DataTypeClass.registerInApp.apply(this, [DT]);\n        }\n        this.DataType.dataType = {};\n        extendEventListeners(this.DataType.dataType);    \n        Object.defineProperty(this, \"Schema\", {\n            value: (function() {\n                class Schema extends SchemaClass {\n                }\n                return Schema;\n            })()\n        });\n        var SM = this.Schema; \n        this.Schema.schema = {};\n        extendEventListeners(this.Schema.schema);\n        if(SchemaClass.db && SchemaClass.db.size && SchemaClass.db.has(hash)){\n            var schMap = SchemaClass.db.get(hash);\n            if(schMap.size){\n                schMap.forEach(function(cls, name){\n                    SchemaClass.registerInDb.apply(cls, [undefined, SM]);\n                    schMap.delete(name);\n                });\n                if(!schMap.size){\n                    SchemaClass.db.delete(hash);\n                }\n                if(!SchemaClass.db.size){\n                    delete SchemaClass.db;\n                }\n            }\n        }\n        SM.register = function(opts){\n            SchemaClass.registerInDb.apply(this, [opts, SM]);\n        }\n        SchemaClass.addEventListener(hash, function(schCls){\n            SchemaClass.registerInDb.apply(schCls, [undefined, SM]);\n            if(SchemaClass.db.has(hash)){\n                var schMap = SchemaClass.db.get(hash); \n                if(schMap.has(schCls.name)){\n                    schMap.delete(schCls.name);\n                }\n                if(!schMap.size){\n                    SchemaClass.db.delete(hash);\n                }\n                if(!SchemaClass.db.size){\n                    delete SchemaClass.db;\n                }\n            }\n        });\n    }\n    constructor(opts){\n        super();\n        var self = this, \n        appIns = this.$app || this.$addon;\n        if(!this.constructor.Connector || !this.constructor.Serializer){\n            Dberror.error(appIns, \"Base Connector / Serializer not defined in Db class\");\n            return;\n        }\n        if(this.includeDbs){\n            var subDbs = this.subDbs = [];\n            var dbs = this.includeDbs();\n            dbs.forEach(function(itm){\n                if(newGetSuperClass(itm, false, self.constructor)){\n                    subDbs.push(itm);\n                }\n            });\n        }\n        if(appIns.$ && appIns.$.modules.triggerEvent){\n            appIns.$.modules.triggerEvent(\"add\", \"db\", this);\n        }\n        _defProp(this,\"Connector\",{});\n        _defProp(this,\"Serializer\",{});\n        _defProp(this,\"connector\",{});\n        _defProp(this,\"serializer\",{});\n        _defProp(this,\"schema\",{});\n        _defProp(this,\"_schema\",new Map());\n        _defProp(this,\"schemaless\",{});\n        _defProp(this,\"dataType\", {});\n        _defProp(this,\"_entity\",Entity);\n        var lIns = this.lyte = appIns;\n        var parent = this.constructor;\n        if(this.constructor.Connector && newGetSuperClass(this.constructor.Connector, false, Connector)){\n            var cparentName = Object.getPrototypeOf(this.constructor.Connector).__lMod, context, defaultConnec;\n            switch(cparentName){\n                case \"RESTConnector\":\n                    context = \"REST\";\n                    break;\n                case \"GraphqlConnector\":\n                    context = \"gql\";\n                    break;\n                case \"Connector\":\n                    defaultConnec = this.constructor.Connector;\n            }\n            if(context){\n                this.Connector[context] = this.Connector[context] || {};\n                this.Connector[context].application = this.constructor.Connector;\n                this.lyte.scopedInstance(this.constructor.Connector, [this], function(ins){\n                    self.connector[context] = self.connector[context] || {}; \n                    self.connector[context].application = ins;\n                    self.applicationConnector = ins;\n                }, [this]);\n            }\n            else if(defaultConnec){\n                var dcparentName = defaultConnec.name, context;\n                switch(dcparentName){\n                    case \"RESTConnector\":\n                        context = \"REST\";\n                        break;\n                    case \"GraphqlConnector\":\n                        context = \"gql\";\n                        break;\n                }\n                if(context){\n                    class applicationConnector extends defaultConnec {\n            \n                    }\n                    applicationConnector.register();\n                    this.Connector[context] = this.Connector[context] || {};\n                    this.Connector[context].application = applicationConnector;\n                    this.lyte.scopedInstance(applicationConnector, [this], function(ins){\n                        self.connector[context] = self.connector[context] || {}; \n                        self.connector[context].application = ins;\n                        self.applicationConnector = ins;\n                    }, [this]);\n                }\n            }\n        }\n        if(this.constructor.Serializer && newGetSuperClass(this.constructor.Serializer, false, Serializer)){\n            var sparentName = Object.getPrototypeOf(this.constructor.Serializer).__lMod, context, defaultSerz;\n            switch(sparentName){\n                case \"RESTSerializer\":\n                    context = \"REST\";\n                    break;\n                case \"GraphqlSerializer\":\n                    context = \"gql\";\n                    break;\n                case \"Serializer\": \n                    defaultSerz = this.constructor.Serializer;\n                    break;\n            }\n            if(context){\n                this.Serializer[context] = this.Serializer[context] || {};\n                this.Serializer[context].application = this.constructor.Serializer;\n                this.lyte.scopedInstance(this.constructor.Serializer, [this], function(ins){\n                    self.serializer[context] = self.serializer[context] || {}; \n                    self.serializer[context].application = ins;\n                    self.applicationSerializer = ins;\n                }, [this]);\n            }\n            else if(defaultSerz){\n                var dsparentName = defaultSerz.name, context;\n                switch(dsparentName){\n                    case \"RESTSerializer\":\n                        context = \"REST\";\n                        break;\n                    case \"GraphqlSerializer\":\n                        context = \"gql\";\n                        break;\n                }\n                if(context){\n                    class applicationSerializer extends defaultSerz {\n        \n                    }\n                    applicationSerializer.register();\n                    this.Serializer[context] = this.Serializer[context] || {};\n                    this.Serializer[context].application = applicationSerializer;    \n                    this.lyte.scopedInstance(applicationSerializer, [this], function(ins){\n                        self.serializer[context] = self.serializer[context] || {}; \n                        self.serializer[context].application = ins;\n                        self.applicationSerializer = ins;\n                    }, [this]);\n                }\n            }\n        }\n        var schemaDef = parent.Schema.schema;\n        for(var key in schemaDef){\n            this.schema[key] = schemaDef[key].create(this, lIns);\n            this._schema.set(schemaDef[key], this.schema[key]);\n        }\n        var dTypeDef = parent.DataType.dataType;\n        for(var dKey in dTypeDef){\n            this.dataType[dKey] = dTypeDef[dKey];\n        }\n        this.entityStrictLock = true; //default for external release\n        if(opts && opts.hasOwnProperty(\"entityStrictLock\")){\n            this.entityStrictLock = opts.entityStrictLock;\n        }\n        parent.Schema.Lyte = parent.DataType.Lyte = lIns;\n        parent.Schema.db = parent.DataType.db = this;\n        // var _Logger = lIns.lyteError || Logger; \n\t\tthis.$ = {\n            toRelate:{},\n            idbQ2:{}\n        };\n        this.cache = {\n            getEntity:function getEntity(def,pKey,isDeleted){\n                var args = arguments, \n                args0 = args[0], \n                isObj = typeof def == \"object\" && def != null,\n                db = self,\n                defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined, \n                _defless;\n                if(isObj){\n                    def = args0.schema, \n                    pKey = args0.pK, \n                    isDeleted = args0.isDeleted;\n                }\n                var isSchema = defless == true && typeof def == \"string\" ? false : (def ? (getSuperClass(def, true) === \"Schema\") : def);\n                def = isSchema ? getSchemaObj(db, def) : def;\n                var name = def && def._name ? def._name : def; \n                if( !def  ){\n                    Dberror.error(appIns,\"LD02\",\"Schema \",name);\n                    return;\n                }\n                else if(defless == true && !isSchema && name){\n                    def = db.schemaless[name];\n                    if(!def){\n                        Dberror.error(appIns,\"LD02\",\"Schema\");\n                        return;\t\n                    }\n                    _defless = true;\n                }    \n                if(isDeleted === true){\n                    var deleted = def._deleted;\n                    var obj = deleted.get(pKey);\n                    if(obj && obj.data){\n                        return obj.data;\n                    }\n                }\n                else{\n                    var isComp = def.isComp; \n                    pKey = (pKey == undefined) ? \"\" : pKey;\n                    if(!isComp && def.data._recMap){\n                        return def.data._recMap.get(pKey.toString());\n                    }\n                    else{\n                        var data = def.data, entity;\n                        if(_defless != true){\n                            entity = data.filter(function(ins){\n                                if(comparePk(ins, pKey)){\n                                    return ins;\n                                }\n                            });\n                        }\n                        else{\n                            entity = data.filter(function(ins){\n                                if(ins[def._pK] === pKey){\n                                    return ins;\n                                }\n                            });\n                        }    \n                        if(entity[0]){\n                            return entity[0];\n                        }\n                    }\n                }\n                return undefined;\n            },\n            getAll: function getAll(def){\n                var args = arguments, \n                args0 = args[0], \n                isObj = typeof def == \"object\" && def != null, \n                db = self,\n                defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined;\n                if(isObj){\n                    def = args0.schema;\n                }\n                var isSchema = defless == true && typeof def == \"string\" ? false : (def ? (getSuperClass(def, true) === \"Schema\") : def);\n                def = isSchema ? getSchemaObj(db, def) : def;\n                var name = def && def._name ? def._name : def;\n                if( !def  ){\n                    Dberror.error(appIns,\"LD02\",\"Schema\");\n                    return;\n                }\n                else if(defless == true && !isSchema && name){\n                    def = db.schemaless[name];\n                    if(!def){\n                        Dberror.error(appIns,\"LD02\",\"Schema \",name);\n                        return;\t\n                    }\n                }    \n                return def.data;\n            }\n        }\n        this.lyte = lIns;\n        this.constructor.Schema.schema.addEventListener(\"add\", function(name, def){\n            self.schema[name] = def.create(self, lIns);\n            self._schema.set(def, self.schema[name]);\n        });\n        this.constructor.DataType.dataType.addEventListener(\"add\", function(name, def){\n            self.dataType[name] = def;\n        });\n    }\n    isEntity(obj){\n        if(obj && obj.$ && obj.$ instanceof $Entity && obj.$.db == this){\n            return true;\n        }\n        return false;\n    }\n    triggerUpdate(def, pkVal, keys, qP, customData){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, pkVal = args0.pK, keys = args0.keys, qP = args0.qP, customData = args0.customData;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return Promise.reject({code : \"ERR19\", message : Dberror.errorCodes.ERR19});\n        }\n        var name = def._name;\n        var ArrayOfKeys,sendData=[],recordsArray=[];\n        ArrayOfKeys = Array.isArray(pkVal)?pkVal:[pkVal]\n        for(var update_Rec = 0; update_Rec<ArrayOfKeys.length ; update_Rec++){\n            var ins = this.cache.getEntity(def.def, ArrayOfKeys[update_Rec])\n            if(ins){\n                var obj = {};\n                var def = ins.$.schema,\n                pK = def._arrPk,\n                fields = keys || Object.keys(def.fieldList);\t\n                fields.forEach(function(item){\n                    obj[item] = ins[item];\n                });\n                pK.forEach(function(item){\n                    obj[item] = ins[item];\n                });\n                sendData.push(obj)\n                recordsArray.push(ins);\n            }\n            else{\n                return Promise.reject(\"No such record found\");\n            }\n        }\n        var isSingleRecord = false;\n        if(!Array.isArray(pkVal)){\n            sendData=sendData[0];\n            recordsArray=recordsArray[0];\n            isSingleRecord=true;\n        }\t\n        return def.connector.constructor.put(this, name, sendData, recordsArray, isSingleRecord, customData, qP);\n    }\n    batch(arg){\n\t\tvar db = this;\n        return new Promise(function(resolve, reject){\n            db.$.makeBatch = true;\n            db.$.batch = db.$.batch || {};\n            db.$.batchPromise = db.$.batchPromise || {};\n            var method, \n            customData,\n            bLen = (db.$.currentBatch === undefined) ? Object.keys(db.$.batch).length : (db.$.currentBatch + 1), \n            batch = db.$.currentBatch = bLen;\n            if(arg && typeof arg == \"function\"){\n                method = arg;\n            }\n            else if(arg && typeof arg == \"object\"){\n                method = arg.method;\n                customData = arg.customData;\n            }\n            try{\n                method();\n            }\n            catch(e){\n                db.$.makeBatch = false;\n                throw e;\n            }\n            db.$.makeBatch = false;\n            var payLoad = { batch:db.$.batch[batch] }, \n            argsObj = { type: \"batch\" }; \n            argsObj.customData = customData;\n            argsObj.payLoad = payLoad;\n            var urlObj = db.applicationConnector.constructor.buildURL(db, \"batch\", \"POST\", undefined, undefined, payLoad, undefined, undefined, customData, undefined, argsObj), \n            batchPl = payLoad.batch;\n            if(isEmpty(batchPl)){\n                if(db.$.cachedBatch && db.$.cachedBatch[batch] && db.$.cachedBatch[batch].length){\n                    var finalRes = handleCachedResponse(db, batch, []);\n                    return resolve(finalRes);\n                }\n                return resolve();\t\t\t\t\t\n            }\n            argsObj.data = payLoad;\n            var res = initCB(db,\"serializer\", undefined, db.applicationSerializer.constructor.SERIALIZE, {args:[\"batch\",payLoad,undefined,customData], argsObj:argsObj});\n            if(res){\n                argsObj.data = payLoad = res.data;\n            }\n            var xhr = new XMLHttpRequest();\n            argsObj.xhr = xhr;\n            xhr.open(\"POST\", urlObj.url, true);\n            for(var header in urlObj.headers){\n                xhr.setRequestHeader(header, urlObj.headers[header]);\n            }\n            xhr.withCredentials = (urlObj.withCredentials)?true:false;\n            xhr.send(JSON.stringify(payLoad));\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState == 4){\n                    argsObj.xhr = xhr;\n                    if(xhr.status.toString()[0] == \"2\" || xhr.status.toString()[0] == \"3\"){\n                        var resp = JSON.parse(xhr.responseText);\n                        db.$.batchResponse = db.$.batchResponse || {};\n                        db.$.batchResponse[batch] = [];\n                        db.applicationConnector.constructor.handleBatchPromise({db:db,response:resp,batch:batch,resolve:resolve, argsObj:argsObj});\n                        setTimeout(function(){\n                            var finalRes = handleCachedResponse(db, batch, db.$.batchResponse[batch]);\n                            resolve(finalRes);\n                            db.$.batchResponse[batch] = [];\n                        },0);\n                    }\n                    else{\n                        db.$.batchResponse[batch] = [];\n                        db.applicationConnector.constructor.handleBatchPromise({db:db,batch:batch,resolve:resolve,fail:true, argsObj:argsObj});\n                        setTimeout(function(){\n                            var finalRes = handleCachedResponse(db, batch, db.$.batchResponse[batch]);\n                            reject(finalRes);\n                        },0);\n                    }\n                }\n            }\t\t\t\t\t\n        });\n    }\n    push(def,data,deserialize,index){\n        var args = arguments, \n        args0 = args[0], \n        isObj = typeof def == \"object\" && def != null,\n        db = this,\n        defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined; \n        if(isObj){\n            def = args0.schema, \n            data = args0.data, \n            deserialize = args0.deserialize;\n            index = args0.index;\n        }\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        def = defless && typeof def === \"string\" ? def : getSchemaObj(this, def);\n        var name = def && def._name ? def._name : def, \n        result = data, \n        len;\n        if(deserialize){\n            data = def.serializer.constructor.buildJSON(db,def,\"pushPayload\",data);\n            var scope = cbScp(db, def.serializer, def.serializer.constructor.DESERIALIZEKEY, \"serializer\");\n            len = data ? Object.keys(data).length : undefined;\n            if(scope){\n                Dberror.warn(this.lyte, \"LD08\", \"deserializeKey\", \"callback\", \"Please use payloadKey callback instead\");\n                if(len > 2){\n                    Dberror.error(this.lyte, \"LD09\");\n                }\n                var keys = Object.keys(data), ind = 0;\n                if(keys.length == 2 && keys[0] == \"meta\"){\n                    ind = 1;\n                }\n                var argsObj = { type: \"pushPayload\", schemaName: name};\n                var deserializeKey = cB(scope, [argsObj]), rec = data[keys[ind]];\n                delete data[keys[ind]];\n                data[deserializeKey] = rec;\n                \n            }\n            result = data[name];\n        }\n        // if(db.idbIns){\n        //     db.idbIns.idbQ2Push(this,name,data,undefined,\"pushPayload\");\n        // }\n        data = insertIntoStore(\n            this,\n            def.def ? def.def : def,\n            result,\n            true,\n            undefined,\n            undefined,\n            index,\n            true\n        );\n        var nData = data || [];\n        if(!Array.isArray(nData)){\n            nData = [nData];\n        }\n        var idb = def && def.hasOwnProperty(\"idb\");\n        nData.forEach(function(itm){\n            if(isEntity(itm)){\n                if(idb){\n                    db.idbIns.idbQ2Push(db,name,itm,undefined,\"pushPayload\");\n                }\n                if(!itm.$.isError){\n                    if(itm.$.inIDB && Object.keys(itm.$.inIDB).length){\n                        db.dbIns.updateRelationsIDB(itm, itm.$.model.relations);\n                    }\n                }\n            }\n        });\n\n        def ? delete def.rel : undefined;\n        return data;\n    }\n    unregisterSchema(data){\t\t\n\t\tvar self = this;\n\t\tif(Array.isArray(data)){\n\t\t\tdata.forEach(function(item){\n\t\t\t\tunregisterDef(self, item);\n\t\t\t});\n\t\t}\n\t\telse{\n\t\t\tunregisterDef(self, data);\n\t\t}\n    }\n    unregisterConnector(data){\n        if(Array.isArray(data)){\n            data.forEach(function(item){\n                unRegCb(this, \"connector\", item);\n            });\n        }\t\n        else{\n            unRegCb(this, \"connector\", data);\n        }\t\t\n    }\n    unregisterSerializer(data){\n        if(Array.isArray(data)){\n            data.forEach(function(item){\n                unRegCb(this, \"serializer\",item);\n            });\n        }\n        else{\n            unRegCb(this,\"serializer\",data);\n        }\n    }\n    addField(def, key, type, options, skipValidation, deserialize){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, key = args0.key, type = args0.prop ? args0.prop : args0.type, options = args0.options, skipValidation = args0.skipValidation, deserialize = args0.deserialize;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        if(key === \"$\"){\n            Dberror.error(this.lyte, \"$ is a reserved key, which cannot be used as the field name\");\n            return;\n        }\n        var fieldType, obs = [];\n        if(type && typeof type == \"object\"){\n            registerField(this,def,key,type,obs);\n            if(type.type == \"relation\"){\n                fieldType = \"relation\"\n            }\n            else{\n                fieldType = \"attr\"; \n            }\n            var deserialize = arguments[4],\n            skipValidation = arguments[3];\n        }\n        else{\n            var field = prop(type,options);\n            registerField(this,def,key,field,obs);\n        }\n        if(fieldType != \"relation\"){\n            if(!skipValidation || deserialize){\n                updateFieldValidation(this, def, key, deserialize, skipValidation);\n            }\n        }\n    }\n    getSchemaObj(name){\n        var schema = this.schema[name];\n        if(!schema && this.subDbs){\n            var len = this.subDbs.length;\n            for(var i=0; i<len; i++){\n                var subDb = this.subDbs[i];\n                if(subDb.schema[name]){\n                    schema = subDb.schema[name];\n                    break;\n                }\n            }\n        }\n        return schema;\n    }\n    getSchema(name){\n        var schema = this.schema[name];\n        if(!schema && this.subDbs){\n            var len = this.subDbs.length;\n            for(var i=0; i<len; i++){\n                var subDb = this.subDbs[i];\n                if(subDb.schema[name]){\n                    schema = subDb.schema[name];\n                    break;\n                }\n            }\n        }\n        return schema && schema.def? schema.def : schema;\n    }\n    hasSchema(name){\n        // return this.schema.hasOwnProperty(name);\n        var hasSchema = this.schema.hasOwnProperty(name);\n        if(!hasSchema && this.subDbs){\n            var len = this.subDbs.length;\n            for(var i=0; i<len; i++){\n                var subDb = this.subDbs[i];\n                if(subDb.schema[name]){\n                    hasSchema = subDb.schema.hasOwnProperty(name);\n                    break;\n                }\n            }\n        }\n        return hasSchema;\n    }\n    getSerializerObj(name, type){\n        // return this.serializer[name];\n        type = type == \"graphql\" ? \"gql\" : type;\n        var sObj = type ? this.serializer[type] : this.serializer.REST;\n        if(sObj){\n            var serializer = sObj[name];\n            if(!serializer && this.subDbs){\n                var len = this.subDbs.length;\n                for(var i=0; i<len; i++){\n                    var subDb = this.subDbs[i];\n                    if(subDb.serializer[name]){\n                        var ssObj = type ? subDb.serializer[type] : subDb.serializer.REST;\n                        serializer = ssObj[name];\n                        break;\n                    }\n                }\n            }\n            return serializer;\n        }\n    }\n    getConnectorObj(name, type){\n        // return this.connector[name];\n        type = type == \"graphql\" ? \"gql\" : type;\n        var cObj = type ? this.connector[type] : this.connector.REST;\n        if(cObj){\n            var connector = cObj[name];\n            if(!connector && this.subDbs){\n                var len = this.subDbs.length;\n                for(var i=0; i<len; i++){\n                    var subDb = this.subDbs[i];\n                    if(subDb.connector[name]){\n                        var scObj = type ? subDb.connector[type] : subDb.connector.REST;\n                        connector = scObj[name];\n                        break;\n                    }\n                }\n            }\n            return connector;\n        }\n    }\n    newEntity(def, opts, skipValidation){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, opts = args0.data, skipValidation = args0.skipValidation;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte, \"LD02\",\"Schema\");\n            return;\n        }\n        // skipValidation = skipValidation == undefined ? true : skipValidation;\n        var name = def._name;\n        return newRecord(this, def, opts, skipValidation);\n    }\n    deleteEntity(def, key){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, key = args0.pK;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        removeFromStore(def, key, undefined);\n    }\n    getEntity(def, key, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, methodType, oprName, variables){\n        var args = arguments, \n        args0 = args[0], \n        isObj = typeof def == \"object\" && def != null,\n        db = this,\n        appIns = this.$app || this.$addon;\n        if(isObj){\n            def = args0.schema, \n            key = args0.pK, \n            queryParams = args0.qP, \n            cQuery = args0.cacheQuery, \n            cacheData = args0.cacheData, \n            customData = args0.customData;\n            drop = args0.drop,\n            forceFetch = args0.forceFetch, \n            index = args0.index;\n            oprName = args0.gqlQuery;\n            variables = args0.gqlVariables;\n        }\n        var name = def ? def._name : undefined;\n        def = typeof def === \"string\" ? def : getSchemaObj(this, def);\n        var connec = def && def.connector ? def.connector.constructor : db.applicationConnector.constructor; \n        var prm = connec.get(this,methodType ? methodType : \"getEntity\",def,key,queryParams,cQuery,customData,cacheData,drop,forceFetch,oprName,variables);\n        var gPrm = prm.then(function(){\n            var data = arguments[0][0], \n            fromCache = arguments[0][1] == \"cache\" ? true : false,\n            xhr = arguments[0][2],\n            status = xhr ? xhr.status : arguments[0][3],\n            batchObj = (arguments[0][1] == \"batch\") ? arguments[0][2] : undefined,\n            fromIDB = (arguments[0][1] == \"idb\") ? true : false,\n            schema = def, \n            defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined, \n            isDefinedSchema = (typeof schema !== \"string\" ? (getSuperClass(schema ? schema.def : undefined, true) === \"Schema\") : false),\n            name = isDefinedSchema ? schema._name : defless ? schema : undefined,\n            toCacheParams = (cQuery && cQuery !== true) ? cQuery : (cQuery === true && queryParams && typeof queryParams == \"object\" && Object.keys(queryParams).length ) ? queryParams : undefined,\n            _defless;\n            \n            if(!isDefinedSchema  && cacheData == undefined){\n                cacheData = false;\n            }\n            else if(defless && !isDefinedSchema && cacheData == true){\n                _defless = true;\n            }  \n            if(cacheData !== undefined && typeof cacheData == \"object\" && cacheData !== null){\n                cacheData = cacheData.hasOwnProperty(\"cache\") ? cacheData.cache : true;\n            }\n            if(cacheData === false){\n                if(!fromCache && toCacheParams){\n                    if(key != undefined){\n                        cacheRecordQuery(db, name, key, toCacheParams, data, status);\n                    }\n                    else{\n                        cacheQuery(db, name, toCacheParams, data, status);\n                    }\n                }\n                if(batchObj != undefined){\n                    db.$.batchResponse[batchObj.batch][batchObj.index] = data;\n                }\n                return data;\n            }\n            if(data){\n                if(!fromCache){\n                    var isEmp;\n                    if(!data || !data.hasOwnProperty(name)){\n                        Dberror.error(db.lyte, \"LD13\", \"get\",name, (\",key-\"+(typeof key == \"object\"? JSON.stringify(key):key)+(queryParams && typeof queryParams == \"object\" ? \", queryParams-\"+JSON.stringify(queryParams)+\"\":\"\")), isEntity(data) ? data: JSON.stringify(data));\n                        return;\n                    }\t\t\t\t\t\t\n                    // if(!fromIDB && db.idbIns){\n                    //     db.idbIns.idbQ2Push(db,name,data,queryParams,methodType ? methodType : \"getEntity\", key); \n                    // }\n                    if(!isEntity(data)){\n                        var payLoad = data[name], pload;\n                        if(key !== undefined){\n                            if(isEmpty(payLoad) || isEmptyObj(payLoad)){\n                                pload = data[name] = {};\n                                isEmp = true;\n                            }\n                            if(typeof payLoad != \"object\" || Array.isArray(payLoad)){\n                                Dberror.warn(db.lyte,\"LD11\");\n                            }\n                        }\n                        else{\n                            if(payLoad === undefined || payLoad === null || isEmptyArray(payLoad)){\n                                pload = data[name] = [];\n                                isEmp = true;\n                            }\n                            else if(!Array.isArray(payLoad)){\n                                Dberror.warn(db.lyte,\"LD19\");\n                            } \n                        }\n                        if(!isEmp){\n                            var defnd = _defless ? \"id\" : undefined,\n                            ind = _defless && index != undefined ? index : defnd;\n                            if(key !== undefined){\n                                pload = insertIntoStore(db, schema.def ? schema.def : schema, payLoad, true, true, undefined, ind);\n                                data[name] = pload;\n                            }\n                            else{\n                                pload = toInsertData(db, schema.def ? schema.def : schema, data,true,ind);\n                                data[name] = pload;\n                            }\n                            var nRec = pload;\n                            if(pload && !Array.isArray(pload)){\n\t\t\t\t\t\t\t\tnRec =[pload];\n\t\t\t\t\t\t\t}\n                            if(!fromIDB && db.idbIns && ((nRec && !nRec.$) || (pload && pload.$ && !pload.$.isError))){\n\t\t\t\t\t\t\t\tif(def && def.hasOwnProperty('idb')){\n\t\t\t\t\t\t\t\t\tdb.idbIns.idbQ2Push(db, name, nRec, queryParams, methodType ? methodType : \"getEntity\", undefined, undefined, customData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnRec.forEach(function(itm){\n\t\t\t\t\t\t\t\t\tif(itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length){\n\t\t\t\t\t\t\t\t\t\tdb.idbIns.updateRelationsIDB(itm, itm.$.model.relations);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n                            if(fromIDB && Array.isArray(nRec) && nRec.length){\n                                nRec.forEach(function(itm){\n                                    db.idbIns.constructor.changeIDBState(db, itm);\n                                });\n                            }\n                        }\n                        if(data.hasOwnProperty(\"meta\")){\n                            if(!isEntity(pload) && !data[name].$){\n                                data[name].$ || _defProp(data[name], \"$\", {});\n                            }\n                            var p$ = pload.$ ? pload.$ : _defProp(pload, \"$\", {});\n                            p$.meta = data.meta;\n                        }\n                    }\n                    if(!fromCache && toCacheParams){\n                        if(key !== undefined){\n                            cacheRecordQuery(db, name, key, toCacheParams, data);\n                        }\n                        else{\n                            cacheQuery(db, name, toCacheParams, data);\t\t\t\t\t\t\t\t\n                        }\n                    }\t\t\t\t\t\t\n                }\n                if(batchObj != undefined){\n                    db.$.batchResponse[batchObj.batch][batchObj.index] = data[name];\n                }\n                if(connec.returnData == \"new\"){\n                    var obj = {};\n                    obj.data = data[name];\n                    if(data.meta){\n                        obj.meta = data.meta;\n                    }\n                    if(status !== undefined){\n                        obj.status = status;\n                    }\n                    return obj;\n                }\n                return data[name];\t\n            }\n            return arguments;\n        }, function(e){\n            return Promise.reject(e);\n        });\n        if(prm.xhr){\n            gPrm.xhr = prm.xhr;\n        }\n        return gPrm;\n    }\n    getAll(def, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, oprName,variables ){\n        return this.getEntity(def, undefined, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, \"getAll\", oprName,variables)\n    }\n    ajax(obj){\n        var defless = this.Connector.REST.application ? this.Connector.REST.application.prototype.schemaless : undefined;\n        if(defless != true){\n            return Promise.reject(\"Schemaless behaviour is not enabled. Please enable it to make db.ajax call for not defined schemas\");\n        }\n        if(!obj.schema){\n            return Promise.reject(\"Schema name is mandatory for db.ajax\");\n        }\n        if(!obj.type){\n            return Promise.reject(obj.type+\" is not a valid HTTP method\");\n        }\n        var def = typeof obj.schema === \"string\" ? this.schema[obj.schema] : undefined;\n        if(def || (getSuperClass(obj.schema) === Object.getPrototypeOf(this.constructor.Schema))){\n            return Promise.reject(obj.schema+\" is a defined schema. db.ajax is supported only for a schema which is not defined\");\n        }\n        var nObj = Object.assign({}, obj);\n        nObj.db = this;\n        return this.applicationConnector.constructor.handleAjax(nObj);\n    }\n    deleteMany(def, pK){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, pK = args0.pK;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        removeFromStore(def, pK, undefined);\n    }\n    dropEntity(def, key){\n        var args = arguments, \n        args0 = args[0], \n        isObj = typeof def == \"object\" && def != null,\n        db = this,\n        defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined, \n        _defless; \n        if(isObj){\n            def = args0.schema, key = args0.pK;\n        }\n        def = defless && typeof def === \"string\" ? def : getSchemaObj(this, def);\n        var parentRel = args[2];\n        var schema = def;\n        if( !def  ){\n            Dberror.error(db.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        else if(defless == true && typeof def == \"string\"){\n            var name = def;\n            schema = db.schemaless[def];\n            if(!schema){\n                Dberror.error(db.lyte,\"LD02\",\"Schema \",name);\n                return;\t\n            }\n            _defless = true;\n        }\n\n        if(key == undefined){\n            Dberror.warn(db.lyte,\"LD18\",\"key\");\n        }\n        var cls = def && def.def ? def.def : def; \n        var data = this.cache.getEntity(cls, key),\n        pkVal;\n        if(_defless == true){\n            var ind = getInd(schema.data, schema._pK, key);\n            if(ind != -1){\n                handleArrOp(this.lyte, schema.data, \"removeAt\", undefined, ind, 1);\n            }\n        }\n        else if(data){\n            pkVal = data.$.pK;\n            removeFromStore(schema, pkVal, true, true, undefined, undefined, true, parentRel);\n            def._deleted.delete(key);\n            var crq = this.schema.cachedRecordQueries;\n            if(crq && crq[name] && crq[name][key]){\n                crq[name][key] = [];\n            }\n            var cqueries = db.schema.cachedQueries;\t\n            if(cqueries){\n                var n=def._name, Nm = cqueries[n];\n                if(Nm && Nm.length){\n                    for(var i=Nm.length-1; i>=0; i--){\n                        var obj = Nm[i];\n                        if(obj && obj.data){\n                            var ind = obj.data[n].indexOf(data);\n                            if(ind != -1){\n                                Nm.splice(i, 1);\n                            }\t\t\t\t\t\t\t\n                        }\n                    }\t\t\t\t\t\n                }\n            }\n        }\n    }\n    dropAll(def, arr){\n        var args = arguments, \n        args0 = args[0], \n        isObj = typeof def == \"object\" && def != null,\n        db = this,\n        defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined, \n        _defless;\n        if(isObj){\n            def = args0.schema, arr = args0.data;\n        }\n        def = defless && typeof def === \"string\" ? def : getSchemaObj(this, def);\n        var name = def ? def._name: undefined, schema = def;\n        if( !def  ){\n            Dberror.error(db.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        else if(defless == true && typeof def == \"string\"){\n            var name = def;\n            schema = db.schemaless[def];\n            if(!schema){\n                Dberror.error(db.lyte,\"LD02\",\"Schema \",name);\n                return;\t\n            }\n            _defless = true;\n        }\n        var keys = [], \n        cls = def && def.def ? def.def : def,\n        data = arr || this.cache.getAll(cls);\n        if(_defless == true){\n            handleArrOp(this.lyte, schema.data, \"removeAt\", undefined, 0, schema.data.length);\n        }\n        else{\n            if(data){\n                for(var i=0; i<data.length; i++){\n                    keys.push(data[i].$.pK);\n                }\t\t\t\t\n            }\n            removeFromStore(schema, keys, true, true, undefined, undefined, true);\n            this.schema[name].dirty = [];\n            this.schema[name]._deleted = new Map();\n            var cq = this.schema.cachedQueries;\n            if(cq && cq[name]){\n                cq[name] = [];\n            }\n\t\t\tvar crq = this.schema.cachedRecordQueries; \n\t\t\tif(crq && crq[name]){\n\t\t\t\tcrq[name] = [];\n\t\t\t}\n        }\n    }\n    triggerAction(def,actionName,customData,qP,method,data){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, actionName = args0.action, qP = args0.qP, customData = args0.customData, method = args0.method, data = args0.data;\n        }\n        def = getSchemaObj(this, def);\n        if(!def){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return Promise.reject({code : \"ERR19\", message : Dberror.errorCodes.ERR19});\n        }\n        var actions = def.actions, action = (actions)?def.actions[actionName]:undefined;\n        if(action){\n            return def.connector.constructor.handleAction(this,actionName,def,this.cache.getAll(def.def),customData,qP,method,data).then(function(data){\n                return data;\n            },function(err){\n                return Promise.reject(err);\n            });\n        }\n        else{\n            return Promise.reject({code : \"ERR18\", message : Dberror.errorCodes.ERR18});\n        }\n    }\n    revert(def){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def=args0.schema;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        var name = def._name;\n        var pK = def._pK, self = this, \n        dirty = Array.from(def.dirty),\n        len = dirty.length;\n        for(var i=0; i<len; i++){\n            var rec = self.cache.getEntity(def.def, dirty[i]);\n            if(rec && rec.$.isDeleted){\n                continue;\n            }\n            else if(rec && rec.$.isNew){\n                rollBackNew(def, rec, pK);\n            }                                \n            else if(rec && rec.$.isModified){\n                rec.$.revertProps(rec.$.getDirtyProps());\n            }\n        }\n        rollBackDelete(def, undefined, true);\n    }\n    create(def, data, customData, qP, toFilterRecords, mutationName){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, data = args0.data, customData = args0.customData, qP = args0.qP, toFilterRecords = args0.toSendData, \n            mutationName = args0.mutationName;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema \");\n            return Promise.reject({code : \"ERR19\", message : Dberror.errorCodes.ERR19});\n        }\n        var name = def._name;\n        if(Array.isArray(data)){\n            var self = this;\n            data.forEach(function(item){\n                var resp = newRecord(self, def, item);\n                if(resp.$.isError){\n                    return Promise.reject(resp);\n                }\n            });\n        }\n        else if(data && typeof data == \"object\"){\n            var self = this;\n            var resp = newRecord(self, def, data);\n            if(resp.$.isError){\n                return Promise.reject(resp);\n            }\t\t\t\t\n        }\n        var dirty = def.dirty, len = dirty.length, created = [], err;\n        for(var i=0; i<len; i++){\n            var rec = this.cache.getEntity(def.def, dirty[i]);\n            if(rec && rec.$.isNew){\n                if(toFilterRecords && toFilterRecords.indexOf(rec) == -1){\n                    continue;\n                }\t\n                err = new ValidationError(def.lyte);\n                validateRecord(this, rec, def.fieldList);\n                if(rec.$.isError && Object.keys(rec.$.error).length > 0){\n                    return Promise.reject(err);\n                }\n                created.push(rec);\n            }\n        }\n        if(created.length){\n            return Connector.create(this, name, created, false, customData, qP, mutationName);\n        }\n        return Promise.resolve();\n    }\n    update(def, customData, qP, toFilterRecords, mutationName){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, qP = args0.qP, customData = args0.customData, toFilterRecords = args0.toSendData, \n            mutationName = args0.mutationName;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return Promise.reject({code : \"ERR19\", message : Dberror.errorCodes.ERR19});\n        }\n        var changed = [], \n        name = def._name,\n        db = def.db,\n        recordsChanged = [],\n        records = toFilterRecords || db.cache.getAll(def.def),\n        rels = def.relations,\n\t\tself = this;\n        records.forEach(function(item){\n            if(item.$.schema === def ){\n                var rec = item,\n                dirty = isDirty(self, rec, rels);\n                if((rec && rec.$.isModified && !rec.$.isNew) || (dirty && dirty.length)){\n                    var obj = updateJSON(self, rec, def, dirty);\n                    changed.push(obj);\n                    recordsChanged.push(rec);\n                }\n            }\n        });\n        if(changed.length){\n            return Connector.put(this, name, changed, recordsChanged,false, customData, qP, mutationName);\n        }\n        return Promise.resolve();\n    }\n    delete(def, key, customData, qP, toFilterRecords, mutationName){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null; \n        if(isObj){\n            def = args0.schema, key = args0.pK, qP = args0.qP, customData = args0.customData, toFilterRecords = args0.toSendData, \n            mutationName = args0.mutationName;\n        }\n        def = getSchemaObj(this, def);\n        if( !def  ){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return Promise.reject({code : \"ERR19\", message : Dberror.errorCodes.ERR19});\n        }\n        var name = def._name;\n        if(key){\n            this.deleteEntity(name, key);\t\t\t\t\n        }\n        var deleted = [];\n        def._deleted.forEach(function(itm, idx){\n            deleted.push(itm.data);\n        });\n        if(toFilterRecords){\n            var newDel = [];\n            toFilterRecords.forEach(function(itm){\n                var ind = deleted.indexOf(itm);\n                if(ind != -1){\n                    newDel.push(itm);\n                }\n            });\n            deleted = newDel;\n        }\n        if(deleted.length){\n            var prm = Connector.del(this, name, deleted,undefined,\"delete\",customData,qP,mutationName);\n            return prm.then(function(resp){\n                return resp;\n            }, function(e){\n                return Promise.reject(e);\n            });\n        }\n        return Promise.resolve();\n    }\n    clearCachedQuery(def, key, cacheQuery){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null, qP; \n        if(isObj){\n            def = args0.schema, key = args0.pK, qP = cacheQuery = args0.cacheQuery;\n            // key = (key == undefined && queryParams && typeof queryParams == \"object\") ? queryParams : key;\n        }\n        else{\n            if( key && typeof key == \"object\"){\n                qP = key;\n                key = undefined;\n            }\n            else if(cacheQuery && typeof cacheQuery == \"object\"){\n                qP = cacheQuery;\n            }\n        }\n        def = getSchemaObj(this, def);\n        // var qP = key && typeof key == \"object\" ? key : queryParams && typeof queryParams == \"object\" ? queryParams : undefined,\n        var cachedQueries = [];\n        if(!qP){\n            if(def && def._name){\n                var cq = this.schema.cachedQueries;\n                var crq = this.schema.cachedRecordQueries;\n                cq && cq.hasOwnProperty(def._name) ? delete cq[def._name] : undefined;\n                crq && crq.hasOwnProperty(def._name) ? ( key ? delete crq[def._name][key] : delete crq[def._name] )  : undefined;\n            }\n            else{\n                this.schema.cachedQueries = [];\n                this.schema.cachedRecordQueries = {};\n            }\n            return;\n        }\n        if(qP){\n            if(key == undefined){\n                var cq = this.schema.cachedQueries;\n                if(cq && cq[def._name]){\n                    cachedQueries = cq[def._name];\n                }\n            }\n            else{\n                var crq = this.schema.cachedRecordQueries;\n                if(crq && crq[def._name] && crq[def._name][key]){\n                    cachedQueries = crq[def._name][key];\n                }\n            }\n            for(var i=0; i<cachedQueries.length; i++){\n                if(compareData(cachedQueries[i].cacheQuery, qP, true)){\n                    cachedQueries.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n    getErrorMessage(code){\n        var args = arguments, args0 = args[0], isObj = typeof code == \"object\" && code != null; \n        if(isObj){\n            code = args0.code;\n        }\n        return Dberror.errorCodes[code];\n    }\n    setErrorMessages(obj){\n        Object.assign(Dberror.errorCodes, obj);\n    }\n    addEventListener(type,func){\n        var args = arguments, args0 = args[0], isObj = typeof type == \"object\" && type != null; \n        if(isObj){\n            type = args0.type, func = args0.func;\n        }\n        return evAdd(this,type,func);\n    }\n    removeEventListener(id){\n        var args = arguments, args0 = args[0], isObj = typeof id == \"object\" && id != null; \n        if(isObj){\n            id = args0.id;\n        }\n        evRemove(this,id);\n    }\n    emit(type,args){\n        var _args = arguments, args0 = _args[0], isObj = typeof type == \"object\" && type != null; \n        if(isObj){\n            type = args0.type, args = args0.args;\n        }\n        evEmit(this,type,args);\n    }\n    getPrimaryKey(def){\n        var args = arguments, args0 = args[0], isObj = typeof def == \"object\" && def != null;\n        if(isObj){\n            def = args0.schema;\n        }\n        def = getSchemaObj(this, def);\n        if(!def){\n            Dberror.error(this.lyte,\"LD02\",\"Schema\");\n            return;\n        }\n        return def._pK;\n    }\n    getDirtyEntities(def , filters , deepNest){\n        var isObj = typeof def == \"object\" ? true : false; \n        if(isObj){\n            var args = arguments[0];\n            def = args.schema;\n            filters = args.filters;\n            deepNest = args.deepNest;\n        }\n        var model = getSchemaObj(this, def);\n        if(!model){\n            Dberror.warn(\"LD02\",\"schema \",def._name);\n            return;\n        }\n        var DirtyKeys = model.dirty,dirtyRecords=[],dirty={isNew :[],isModified :[],isDeleted :[]};\n        for(var i_dirty = 0 ; i_dirty<DirtyKeys.length; i_dirty++){\n            var record = this.cache.getEntity(def,DirtyKeys[i_dirty]);\n            if(record){\n                record.$.isNew?dirty.isNew.push(record):dirty.isModified.push(record);\n            }\n        }\n        if(model._deleted.size){\n            var deletedRecord = model._deleted\n            deletedRecord.forEach(function(value){\n                dirty.isDeleted.push(value.data);\n            })\n        }\n        if(model.dirty || model._deleted.size){\n            if(filters == undefined || filters == true){\n                dirtyRecords=dirtyRecords.concat(dirty.isNew,dirty.isModified,dirty.isDeleted);\n            }\n            if(Array.isArray(filters)){\n                filters.forEach(function(value){\n                    dirtyRecords=dirtyRecords.concat(dirty[value]);\n                })\n            }\n            if(typeof filters == \"string\"){\n                dirtyRecords = dirty[filters];\n            }\n        }\n        if(deepNest){\n            var records =this.cache.getAll(def);\n            records.forEach(function(rec){\n                if(rec.$.isDirty() && !dirtyRecords.includes(rec)){\n                    dirtyRecords.push(rec);\n                }\n            });\n        }\n        return dirtyRecords;\n    }\n}\n\nDb.__lMod = \"Db\";\n\nDb.ConnectorCls = Connector;\n\nDb.SerializerCls = Serializer;\n\nexport { Db, Dberror, ValidationError};\n","import { getFromCB, _defProp, getDefaultVal, establishObsBindings, getpKVal, isDirty, recChk, setData, rllBckRecArr, deleteDeepNest, cmpSet, removeParentNesting, deleteFromArray, genUnRedoStack, rollBackDelete, rollBackNew, removeOnSave, evAdd, evRemove, evEmit, validateRecord, updateJSON, getInd, toJSON, unredoOp, deepCopyStack, deepCopyAttrs, setState, mergeResponse, getSchemaObj, changePersist} from \"./utils.js\";\nimport { Dberror, ValidationError } from \"./dberror\";\nimport { removeFromStore } from './utils';\nimport { deepCopyObject, establishObjectBinding } from \"@slyte/core/src/lyte-utils.js\";\nimport { Connector } from \"./Connector.js\";\n\nclass Entity {\n    constructor(name,data,opts){\n        var def = db.getSchema(name), delayPers = opts ? opts.delayPersistence : getFromCB(db, \"connector\", def.connector, \"delayPersistence\");\n        Object.assign(this, data);\n        Object.defineProperties(this, {\n            $ : {\n                writable : true,\n                value : new $Entity(this, def, delayPers)\n            }\n        });\n        var parent = db.$.saveParent;\n        if(parent && this !== parent){\n            _defProp(this.$, \"parent\", parent);\n        }\n        var defF = def._fldGrps.default;\n        var watchF = def._fldGrps.watch;\n        var hasManyF = def._fldGrps.hasMany;\n        for(var dKey in defF){\n            var dFld = defF[dKey];\n            var fldVal = data[dKey];\n            if(fldVal === undefined || fldVal === \"\"){\n                this[dKey] = getDefaultVal(this, dFld.default);\n            }\n        }\n\n        for( var k in model.fieldList){\n            var field= model.fieldList[k];\n            if(/^(array|object)$/.test(field.type) && (field.properties || field.items)){\n                establishObjectBinding(this,k,true,undefined,undefined,(field && field.watch)?field.watch:undefined);\n            }\n        }\n    \n        // for(var wKey in watchF){\n        //     establishObjectBinding(this, wKey, true);\n        // }\n        for(var hKey in hasManyF){\n            var hFld = hasManyF[hKey];\n            if(this.hasOwnProperty(hKey)){\n                this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];\n            }\n            else if(hFld.relatedTo){\n                var toInit = getFromCB(db,\"serializer\", getSchemaObj(db,hFld.relatedTo).serializer, \"initHasManyRelation\");\n                if(toInit){\n                    this[hKey] = [];\n                }\n            }\n        }\n        var props = def._properties;\n        if(Object.keys(props).length){\n            if(!this._bindings){\n                _defProp(this, '_bindings', new Set(), false, true, true);\n            }\n            this._bindings.add(props);\n            establishObsBindings(this,props);\n        }\n    }\n}\n\nEntity.__lMod = \"Entity\";\nclass $Entity {\n    constructor(ins, def, delayPers, db){\n        // def = getSchemaObj(db, def);\n        this.isModified = false;\n        this.isNew = false;\n        this.isDeleted = false;\n        this.isError = false;\n        this.error = {};\n        this.db = db;\n        this.isUnloaded = false;\n        var pkVal = getpKVal(ins, def);\n        Object.defineProperties(this, {\n            events:{ \n                value : [],\n                writable : true\n            }, \n            validatedOnCreate:{ \n                value : true,\n                writable: true\n            },\n            pK:{\n                value: pkVal,\n                writable: true\n            },\n            schema : {\n                value : def\n            },\n            _attributes : {\n                value : {} ,\n                writable : true\n            },\n            _relationships : {\n                value : {},\n                writable : true\n            },\n            isDirty: {\n                value: function value(){\n                    var result = [];\n                    var ins = this.entity;\n                    if(ins.$.isModified){\n                        return true;\n                    }\n                    result = isDirty(db, ins, this.schema.relations);\n                    if(result.length){\n                        return result;\n                    }\n                    return false;\n                }\n            },\n            undoStack : {\n                value : genUnRedoStack(),\n                writable : true\n            },\n            redoStack : {\n                value : genUnRedoStack(),\n                writable : true\n            },\n            delayPersistence : {\n                value : delayPers\n            },\n            entity: {\n                value: ins\n            }\n        });\n        this.inIDB = false;\n        this.isPersisted = true;\n        this.strictLock = def.db && def.db.entityStrictLock ? def.db.entityStrictLock : false; \n    }\n    get(attr){\n        if(this.db.lyte && this.db.lyte.$utils && this.db.lyte.get){\n            return this.db.lyte.$utils._get(this.entity,attr)\n        }\n        else{\n            if(recChk(this.db.lyte, this.entity)){\n                return this.entity[attr];\n            }\n        }\n    }\n    set(attr, value, opts){\n        if(recChk(this.db.lyte, this.entity)){\n            if(this.isUnloaded){\n                ValidationError.setRecErr(this, this.schema._pK, \"ERR17\");\n            }\n            else{\n                setData(this, attr, value, opts);\n            }\n            return this.entity;\n        }\n    }\n    getDirtyProps(){\n        if(recChk(this.db.lyte, this.entity)){\n            var ret = [];\n            var attributes = this._attributes;\n            if(Object.keys(attributes).length){\n                for(var key in attributes){\n                    ret.push(key);\n                }\n            }\n            return ret;\n        }\n    }\n    revertProps(attr){\n        if(recChk(this.db.lyte, this.entity)){\n            if(!Array.isArray(attr)){\n                attr = [attr];\n            }\n            var ins = this.entity, changed = [], def = this.schema, _attrs = this._attributes;\n            for(var i=0; i<attr.length; i++){\n                var key = attr[i];\n                if(_attrs.hasOwnProperty(key)){\n                    var field = def.fieldList[key], oldVal = _attrs[key];\n                    if(field.type == \"relation\"){\n                        rllBckRecArr(def.db, oldVal && oldVal._changes ? oldVal._changes : oldVal, ins, def, field);\n                        var obj = ins.$.dN && ins.$.dN.hasOwnProperty(key) ? ins.$.dN[key] : new Map();\n                        for(var dnArr of obj){\n                            deleteDeepNest(ins, key, dnArr[0]);\n                        }\n                    }\n                    else{\n                        cmpSet( def.db.lyte, ins, key, oldVal, undefined, true );\n                    }\n                    changed.push(key);\n                    delete _attrs[key];\n                }\n                ValidationError.clrRecErr(this, key);\n            }\n            if(!Object.keys(this._attributes).length){\n                if((!this.hasOwnProperty(\"dN\") || ( this.dN && !Object.keys(this.dN).length )) && !ins.$.isNew){\n                    removeParentNesting(ins, undefined, \"modified\");\n                }\n                cmpSet(def.db.lyte, this, \"isModified\", false);\n                changePersist(this.entity, true);\n                if(!this.isNew){\n                    deleteFromArray(def.dirty, this.get(def._pK));\n                }\n            }\n            if(changed.length > 0){\n                var arr = [ins,changed];\n                this.emit(\"change\", arr);\n                def.emit(\"change\", arr);\n                this.undoStack = genUnRedoStack();\n                this.redoStack = genUnRedoStack();\n            }\n        }\n    }\n    revert(state){\n        if(recChk(this.db.lyte, this.entity)){\n            var def = this.schema, pK = def._pK;\n            if(state){\n                this.revertToState(state);\n            }\n            else {\n                if(this.isModified){\n                    this.revertProps(this.getDirtyProps());\n                    delete this._savedState;\n                }\n                if(this.isDeleted){\n                    // var index = getInd(model._deleted, pK, this.get(pK));\n                    rollBackDelete(def, this.get(pK));\n                }\n                else if(this.isNew){\n                    rollBackNew(def, this.entity, pK);\n                }\t\t\t\n                else if(this.isError){\n                    ValidationError.clrRecErr(this);\n                }\n            }\n            removeOnSave(def.db, this.schema._name, this.entity.$.pK);\n        }\n    }\n    delete(delayPers){\n        if(recChk(this.db.lyte, this.entity)){\n            var def = this.schema, ins = this.entity, \n            delayPers = ( delayPers !== undefined ) ? delayPers : (ins.$.delayPersistence ? ins.$.delayPersistence.delete : false); \n            removeFromStore(def, ins.$.pK, undefined, undefined, delayPers);\n        }\n    }\n    destroy(customData,qP,delayPers){\n        if(recChk(this.db.lyte, this.entity)){\n            this.delete(delayPers);\n            return this.save(customData,qP,\"destroyRecord\");\n        }\n    }\n    addEventListener(type, func){\n        if(recChk(this.db.lyte, this.entity)){\n            return evAdd(this, type, func);\n        }\n    }\n    removeEventListener(id){\n        if(recChk(this.db.lyte, this.entity)){\n            evRemove(this,id);\n        }\n    }\n    emit(type, args){\n        if(recChk(this.db.lyte, this.entity)){\n            evEmit(this,type,args);\n        }\n    }\n    triggerAction(actionName,customData,qP,method,data){\n        if(recChk(this.db.lyte, this.entity)){\n            var def = this.schema, \n\t\t\tdb = def.db,\n\t\t\tactions = def.actions, \n\t\t\taction = (actions) ? actions[actionName] : undefined;\n            if(action){\n                return def.connector.constructor.handleAction(db,actionName,def,this.entity,customData,qP,method,data);\n            }\n            return Promise.reject({code : \"ERR18\", message : Dberror.errorCodes.ERR18, data : actionName});\n        }\n    }\n    save(customData,qP,options,destroy,mutationName){\n        if(recChk(this.db.lyte, this.entity)){\n            var def = this.schema, \n\t\t\tdb = def.db,\n\t\t\tins = this.entity, \n\t\t\tdirty = this.isDirty(), \n\t\t\tvalidateOnSave = options && options.validateOnSave, \n\t\t\tskipValidation = options && options.skipValidation, \n\t\t\tfields = def.fieldList, \n\t\t\tret;\n            if(this.isUnloaded !== true){\n                if(this.isDeleted){\n                    if(!this.isNew){\n                        return Connector.del(db, def._name, ins, true, destroy, customData, qP, mutationName);\n                    }\n                }\n                else if(this.isNew){\n                    var err = this;\n                    if(!skipValidation && (!ins.$.validatedOnCreate || validateOnSave)){\n                        ret = validateRecord(db, this.entity, fields);\n                    }\n                    if(!skipValidation && (ret == false || (err && err.error && Object.keys(err.error).length > 0))){\n                        return Promise.reject(err.error);\n                    }\n                    return Connector.create(db, def._name, ins, true , customData, qP, mutationName);\n                }\n                else if(this.isModified || (dirty && dirty.length) ){\n                    var data = {};\n                    if(!skipValidation && (options && validateOnSave)){\n                        ret = validateRecord(db, this.entity, fields);\n                    }\n                    if(!skipValidation){\n                        if(ret == false || (ins && ins.$ && ins.$.isError)){\n                            return Promise.reject(ins.$.error);\n                        }\n                    }\n                    var data = updateJSON(db, this.entity, def, dirty);\n                    return Connector.put(db, def._name, data, ins, true, customData, qP, mutationName);\n                }\n            }\n            else{\n                Dberror.warn(db.lyte,\"LD29\", typeof ins.$.pK == \"object\" ? JSON.stringify(ins.$.pK) : ins.$.pK, def._name)\n\t\t\t\tvar rejectUnloadRecordSave = getFromCB(db, \"connector\", def.connector, \"rejectUnloadRecordSave\");\n\t\t\t\tif(rejectUnloadRecordSave){\n\t\t\t\t\treturn Promise.reject({code: \"ERR28\", message: Dberror.errorCodes.ERR28, data: ins});\n\t\t\t\t}\n\t\t\t}\n            return Promise.resolve();\n        }\n    }\n    getInitialValues(attr){\n        if(recChk(this.db.lyte, this.entity)){\n            var isAttrPassed = false;\n            if(attr){\n                if(!Array.isArray(attr)){\n                    attr = [attr];\n                }\n                isAttrPassed = true;\n            }\n            else{\n                attr = this.getDirtyProps();\n            }\n            var ret = {}, rec = this.entity, _attrs = this._attributes;\n            for(var i=0; i<attr.length; i++){\n                if(rec[attr] == undefined || !rec[attr[i]].add){\n                    ret[attr[i]] = _attrs[attr[i]];\t\t\t\t\t\n                }\n                else{\n                    ret[attr[i]] = rec[attr[i]].slice(0);\n                    var arr = _attrs[attr[i]] && _attrs[attr[i]]._changes ? _attrs[attr[i]]._changes : [], \n                    isPoly = rec[attr[i]].polymorphic,\n                    pK = !isPoly ? rec[attr[i]].schema._pK : undefined;\n                    for(var j=arr.length-1; j>=0; j--){\n                        if(arr[j]._type == \"added\"){\n                            for(var k=0; k<arr[j].records.length; k++){\n                                var index = getInd(ret[attr[i]], !isPoly ? pK : arr[j].records[k].$.schema._pK, arr[j].records[k].$.pK);\n                                if(index == -1){\n                                    continue;\n                                }\n                                ret[attr[i]].splice(index, 1);\n                            }\n                        }\n                        else if(arr[j]._type == \"removed\"){\n                            for(var k=arr[j].records.length-1; k>=0; k--){\n                                ret[attr[i]].splice(arr[j]._indices[k], 0, arr[j].records[k]);\n                            }\n                        }\n                        else if(arr[j]._type == \"changed\"){\n                            ret[attr[i]] = Array.isArray(arr[j].records) ? Array.from(arr[j].records) : arr[j].records;\n                        }\n                    }\n                }\n            }\n            if(isAttrPassed){\n                return ret[attr[0]];\n            }\n            return ret;\n        }\n    }\n    toJSON(type){\n        if(recChk(this.db.lyte, this.entity)){\n            var db = this.schema.db,addNotDefinedFields,\n            parentRel = arguments[1];\n            if(typeof type == \"object\" && type.hasOwnProperty(\"addNotDefinedFields\")){\n                addNotDefinedFields = type.addNotDefinedFields?true:false\n                type = undefined;\n            }\n            return Object.assign({}, toJSON(db, this.schema._name, this.entity, !type ? true : type, undefined, undefined, parentRel,addNotDefinedFields));\n        }\n    }\n    undo(attr, state){\n        if(recChk(this.db.lyte, this.entity)){\n            var currentState = this.undoStack._order_.length;\n            state = state || (currentState ? currentState - 1 : currentState);\n            // state = state || 0;\n            while(currentState-- > state){\n                unredoOp(1, this, attr);\n            }\n        }\n    }\n    getCurrentState(){\n        if(recChk(this.db.lyte, this.entity)){\n            return this.undoStack._order_.length;\n        }\n    }\n    redo(attr){\n        if(recChk(this.db.lyte, this.entity)){\n            unredoOp(2,this,attr);\n        }\n    }\n    validate(arr){\n        if(recChk(this.db.lyte, this.entity)){\n            var fields = {};\n            var def = this.schema;\n            var fieldList = def.fieldList;\n            if(Array.isArray(arr)){\n                arr.forEach(function(item, index){\n                    if(fieldList[item]){\n                        fields[item] = fieldList[item];\n                    }\n                });\n            }\n            if(Object.keys(fields).length == 0){\n                fields = fieldList;\n            }\n            validateRecord(def.db, this.entity, fields);\t\t\t\t\n        }\n    }\n    saveState(state){\n        if(recChk(this.db.lyte, this.entity)){\n            var fromRel = arguments[1];\n            var parentRel = arguments[2];\n            if(!fromRel){\n                if(!this.isNew && !this.isModified){\n                    Dberror.warn(this.db.lyte,\"LD20\");\n                    return;\n                }\n                var savedState = this._savedState = this._savedState || {};\n                var currentState = state, randomState;\n                while(!currentState){\n                    randomState = Math.floor(Math.random()*100000 + 1);\n                    currentState = !savedState.hasOwnProperty(randomState) ? randomState : currentState;\n                }\n            }\n            var obj = this.toJSON(\"state\", parentRel);\n            _defProp(obj, \"$\", {}, false, true);\n            _defProp(obj.$, \"isSavedState\", true, false, true);\n            _defProp(obj.$, \"pK\", this.entity.$.pK, false, true);\n            var pK = this.schema._arrPk;\n            pK.forEach(function(val){\n                delete obj[val];\n            });\n            var undoStack = this.undoStack;\n            var redoStack = this.redoStack;\n            var _attributes = this._attributes;\n            // var dN = this.entity.$.dN;\n            if(undoStack && Object.keys(undoStack).length){\n                var _order = undoStack._order_;\n                undoStack = obj.$.undoStack = deepCopyStack(undoStack);\n                _defProp(undoStack, \"_order_\", deepCopyObject(_order), false, true);\n            }\n            if(redoStack && Object.keys(redoStack).length){\n                var _order = redoStack._order_;\n                redoStack = obj.$.redoStack = deepCopyStack(redoStack);\n                _defProp(redoStack, \"_order_\", deepCopyObject(_order), false, true);\n            }\t\t\t\n            if(_attributes && Object.keys(_attributes).length){\n                obj.$._attributes = deepCopyAttrs(this.schema, _attributes);\n            }\n            if(!fromRel){\n                this._savedState[currentState] = obj; \n                return currentState;\n            }else{\n                return obj;\t\n            }\n        }\n    }\n    clearState(state){\n        if(recChk(this.db.lyte, this.entity)){\n            if(!state){\n                this._savedState = {};\n                return;\n            }\n            delete this._savedState[state];\n        }\n    }\n    revertToState(state){\n        if(recChk(this.db.lyte, this.entity)){\n            var savedSt = this._savedState\n            var obj = savedSt ? savedSt[state] : undefined;\n            if(!obj){\n                Dberror.warn(this.db.lyte, \"LD21\", state);\n                return;\n            }\n            setState(this, obj);\n            delete this._savedState[state];\n        }\n    }\n    hasSavedState(state){\n        if(recChk(this.db.lyte, this.entity)){\n            return this._savedState && this._savedState.hasOwnProperty(state) ? true : false;\n        }\n    }\n    clone(){\n        if(recChk(this.db.lyte, this.entity)){\n            var parentRel = arguments[0];\n            var obj = this.toJSON(\"clone\", parentRel);\n            return this.schema.db.newEntity(this.schema.def, obj);\n        }\n    }\n    persist(obj){\n        if(recChk(this.db.lyte, this.entity)){\n            var schema = this.schema, \n\t\t\tname = schema._name,\n\t\t\tdb = schema.db, \n\t\t\tins = this.entity, \n\t\t\tpartialObj = {obj:new Map()}, \n            type, \n            dirty;\n            if(this.isNew){\n                type = \"create\";\n                toJSON(db, name, ins, undefined, \"create\", partialObj);\n            }\n            else if(dirty = this.isDirty()){\n                var data = updateJSON(db, ins, this.schema, dirty);\n                toJSON(db, name, data, undefined, undefined, partialObj);\n            }\n            var pObj = partialObj.obj.get(this.pK);\n            mergeResponse(db, ins, this.schema, undefined, this.pK, pObj, true);\n            if(db.idbIns){\n                db.idbIns.updateIDB(db, name, type ? type : ins.$.isDeleted ? \"deleteEntity\" : ins.$.isModified || dirty ? \"updateEntity\" : undefined, ins);\n            }\n        }\n    }\n}\n$Entity.__lMod = \"$Entity\";\n_defProp(Entity, \"strictValueSet\", true);\n_defProp(Entity, \"strictRelSet\", true);\nexport { Entity, $Entity };","import { getFromCB, initCB, addToCachedBatch, cbScp, cB, initPartialObj, toJSON, compareData } from \"./utils.js\";\nimport { RESTSerializer } from \"./RESTSerializer.js\";\nimport { isEntity } from \"@slyte/core/src/lyte-utils\";\nimport { Connector } from \"./Connector.js\";\n/*convert to custom class*/\nclass RESTConnector extends Connector {\n    static register(parent){\n    }\n    constructor(db){\n        super();\n        this.host = window.location.origin ? window.location.origin : window.location.protocol+\"//\"+window.location.host;\n        this.namespace = \"\";\n        this.actionNamespace = \"action\";\n        this.batchNamespace = \"batch\";\n        this.__type = \"REST\";\n        var lIns = db.lyte, \n        name = this.constructor._name;\n        Object.defineProperty(this,'$lg', {\n            value : lIns.__gl\n        });   \n        if(!db.getConnectorObj(name)){\n            db.connector.REST = db.connector.REST || {}; \n            db.connector.REST[this.constructor._name] = this; \n        }\n    }\n\n    // static sendXHR(db,name,type,key,urlObj,customData,argsObj,opts){\n    //     var xhr = new XMLHttpRequest();\n    //     var prm = new Promise(function(res, rej){\n    //         argsObj.xhr = xhr;\n    //         xhr.open(urlObj.method, urlObj.url, true);\n    //         for(var header in urlObj.headers){\n    //             xhr.setRequestHeader(header, urlObj.headers[header]);\n    //         }\n    //         if(urlObj.data !== undefined && ( urlObj.headers && !urlObj.headers.hasOwnProperty(\"Content-Type\") && urlObj.method !== \"GET\")){\n    //             xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n    //         }\n    //         xhr.withCredentials = (urlObj.withCredentials)?true:false;\n    //         initCB(db,\"connector\", name, RESTConnector.PARSEREQUEST, { argsObj: argsObj, args:[type, name, xhr ,urlObj ? urlObj.qP : undefined, key, customData]});\n    //         db.emit(\"beforeRequest\", [xhr, name, type, key, urlObj.qP]);\n    //         xhr.send(urlObj.data);\n    //         xhr.onreadystatechange = function(){\n    //             if(xhr.readyState == 4){\n    //                 db.emit(\"afterRequest\",[xhr, name, type, key, urlObj.qP]);\n    //                 argsObj.status = xhr.status;\n    //                 RESTConnector.processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts).then(function(data){\n    //                     return res({data:data, xhr:xhr});\n    //                 }, function(err){\n    //                     return rej({data:err, xhr:xhr});\n    //                 });\n    //             }\n    //         }\n    //     });\n    //     prm.xhr = xhr;\n    //     return prm;\n    // }\n    static getHost(db, connector){\n        \n    }\n    static buildURL(db,type,method,def,key,snapshot,queryParams,actionName,customData,url,argsObj){\n        var adapter, name;\n        if(def !== undefined){\n            adapter = def.connector, name = def._name;\n        }\n        var schemaless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined;\n        if(typeof def == \"string\" && schemaless){\n            name = def;\n        }\n        var host = getFromCB(db,\"connector\",adapter,\"host\"), \n        url = url || \"\", \n        makeBatch = db.$.makeBatch;\n        argsObj.host = host;\n        if(!url){\n            if(!makeBatch){\n                if(host !== undefined){\n                    url += host;\n                    if(host[host.length-1] != \"/\"){\n                        url+=\"/\";\t\t\t\t\t\n                    }\n                }\n            }\n            var namespace = getFromCB(db,\"connector\",adapter,\"namespace\");\n            if(namespace !== \"\" && namespace[namespace.length-1] != \"/\"){\n                url+=namespace+\"/\";\n                argsObj.namespace = namespace;\n            }\n            else{\n                url+=namespace;\n            }\n            if(type != \"batch\"){\n                if(def.endPoint){\n                    url +=def.endPoint\n                }\n                else{\n                    url+=name;\n                }\n                if(key && typeof key != \"object\"){\n                    url+=\"/\"+key;\n                }\t\n            }\n            if(type == \"action\" && def){\n                var actionNamespace = getFromCB(db,\"connector\",adapter,\"actionNamespace\");\n                if(actionNamespace !== \"\" && actionNamespace[actionNamespace.length-1] != \"/\"){\n                    url+=\"/\"+actionNamespace;\n                }\n                else{\n                    url+=actionNamespace;\n                }\n                // url+=\"/\"+getFromCB(db,\"connector\",adapter,\"actionNamespace\");\n                var actions = def.actions, action = actions[actionName].endPoint ? actions[actionName].endPoint : actionName;\n                url+=\"/\"+action;\n                argsObj.actionName = action;\n            } else if(type == \"batch\"){\n                url+=getFromCB(db,\"connector\",undefined,\"batchNamespace\");\n            }\n        }\n        if(!queryParams){\n            queryParams = {};\n        }\n        var ret = {method : (method)? method : \"\"}, res;\n        argsObj.url = url;\n        argsObj.method = ret.method;\n        argsObj.queryParams = queryParams;\n        res = initCB(db,\"connector\", adapter, RESTConnector.REQUESTHEADERS, { argsObj: argsObj, args:[type, queryParams, customData, actionName, key]});\n        if(res){\n            ret.headers = res.data;\n        }\n        argsObj.headers = ret.headers;\n        argsObj.cachedData = snapshot;\n        res = initCB(db,\"connector\", adapter, RESTConnector.REQUESTURL, { argsObj: argsObj, args:[name, type, queryParams, snapshot, url,actionName,customData, key]});\n        if(res){\n            url = res.data;\n        }\n        argsObj.url = url;\n        res = initCB(db,\"connector\", adapter, RESTConnector.REQUESTMETHOD, { argsObj: argsObj, args:[method, type, queryParams, customData, actionName, key]});\n        if(res){\n            ret.method = res.data;\n        }\n        argsObj.method = method;\n        if(!makeBatch && Object.keys(queryParams).length){\n            url+=\"?\";\n            var index = 0;\n            for(var qKey in queryParams){\n                if(index !== 0){\n                    url+=\"&\";\n                }\n                var res = queryParams[qKey];\n                if(res && typeof res == \"object\"){\n                    res = JSON.stringify(res);\n                }\n                url+=qKey+\"=\"+encodeURIComponent(res);\n                index++;\n            }\n        }\n        if(adapter && adapter.withCredentials == true){\n            ret.withCredentials = true;\n        }\n        ret.url = url;\n        ret.qP = queryParams;\n        return ret;\n    }\n    static get(db, type, def, key, queryParams, cacheQuery, customData, cacheData, unload, forceFetch){\n        var name = def && def._name ? def._name : def, \n        argsObj = { type: type, schemaName : name, queryParams: queryParams, opts:{cacheData:cacheData !== undefined ? cacheData : true, cacheQuery:cacheQuery!== undefined ? cacheQuery : false, unload: unload!==undefined?unload:false, forceFetch: forceFetch!==undefined?forceFetch:false }, customData: customData, key: key}, \n        mdl = def,\n        makeBatch = db.$.makeBatch, \n        defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined;\n        if(defless && typeof def == \"string\"){\n            var defobj = db.schemaless, _name = def; \n\t\t\tdef = defobj[_name] = defobj[_name] || {};\n            def._name = _name;\n        }\n        if(mdl || ( typeof mdl == \"string\"  && defless === true)){\n            RESTConnector.getConnector(db, def, argsObj, defless);\n            RESTConnector.getSerializer(db, def, argsObj, defless);\n            if(unload){\n                if(key !== undefined){\n                    db.dropEntity(def.def, key);\n                }\n                else{\n                    db.dropAll(def.def);\n                }\n            }\n            customData = customData == undefined ? getFromCB(db,\"connector\", mdl.connector, \"customData\") : customData;\n            var urlObj = this.buildURL(db, type, \"GET\", def, key, undefined, queryParams,undefined,customData,undefined,argsObj), \n            self = this,\n            queryParams = urlObj.qP, \n            toCheckParams = (cacheQuery && typeof cacheQuery !== \"boolean\") ? cacheQuery : (queryParams && typeof queryParams == \"object\") ? queryParams : undefined;\n            if(key == undefined && toCheckParams && db.schema.cachedQueries && db.schema.cachedQueries[name] && !forceFetch){\n                var cachedQueries = db.schema.cachedQueries[name], \n                sendData;\n                for(var i=0; i<cachedQueries.length; i++){\n                    var qry = cachedQueries[i];\n                    if(!qry.hasDeletedRecords){\n                        var params = qry.cacheQuery;\n                        if(compareData(params, toCheckParams, true)){\n                            sendData = [qry.data, \"cache\", undefined, qry.status];\n                            break;\n                        }\n                    }\n                }\n                if(sendData){\n                    return new Promise(function(resolve){\n                        if(makeBatch){\n                            addToCachedBatch(db,Array.isArray(sendData) ? sendData[0][name] : sendData);\n                        }\n                        resolve(sendData);\n                    });\n                }\n            }\n            else if(key !== undefined && toCheckParams && db.schema.cachedRecordQueries && db.schema.cachedRecordQueries[name] && db.schema.cachedRecordQueries[name][key] && !forceFetch){\n                var cachedQueries = db.schema.cachedRecordQueries[name][key], \n                sendData;\n                for(var i=0; i<cachedQueries.length; i++){\n                    var params = cachedQueries[i].cacheQuery;\n                    if(compareData(params, toCheckParams, true)){\n                        sendData = [cachedQueries[i].data, \"cache\", undefined, cachedQueries[i].status];\n                        break;\n                    }\n                }\n                if(sendData){\n                    return new Promise(function(resolve){\n                        if(makeBatch){\n                            addToCachedBatch(db,Array.isArray(sendData) ? sendData[0][name] : sendData);\n                        }\n                        resolve(sendData);\n                    });\n                }\n            }\n            else if(!forceFetch){\n                var scope = cbScp(db, def.connector, type == \"getAll\" ? RESTConnector.REFETCHALL : RESTConnector.REFETCH, \"connector\");\n                if(scope){\n                    var data, callRefetch = false;\n                    if(key !== undefined){\n                        data = db.cache.getEntity(mdl.def,key);\t\t\n                        callRefetch = isEntity(data) ? true : false; \t\t\t\t\t\n                    }\n                    else{\n                        data = db.cache.getAll(mdl.def);\n                        callRefetch = data && data.length ? true : false;\n                    }\n                    argsObj.cachedData = data;\n                    if(callRefetch && !cB(scope, [argsObj])){\n                        var toRet = {};\n                        toRet[name] = data;\n                        return new Promise(function(resolve){\n                            if(makeBatch){\n                                addToCachedBatch(db,toRet[name]);\n                            }\n                            resolve([toRet, \"cache\"], \"success\", undefined, true);\n                        });\n                    }\n                }\n            }\n            if(urlObj.method == \"POST\"){\n                var res = initCB(db,\"serializer\", mdl.serializer, RESTSerializer.SERIALIZE, { argsObj: argsObj, args:[type,undefined,undefined,customData,name,queryParams]});\n                if(res){\n                    urlObj.data = res.data;\n                    if(urlObj.data && (typeof urlObj.data == \"object\" || isEntity(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){\n                        // urlObj.reqData = Lyte.deepCopyObject(urlObj.data);\n                        urlObj.data = JSON.stringify(urlObj.data);\n                    }\n                    argsObj.data = urlObj.data;\n                }\n            }\n            var prmXhr;\n            var prm = new Promise(function(resolve, reject){\n                var idbObj = def ? def.idb : undefined, \n                processRequest = getFromCB(db,\"connector\", def ? def.connector : undefined, RESTConnector.PROCESSREQUEST),payLoad, sendXHR = true, \n                batchPro = false, \n                opts = { cacheQuery : cacheQuery, cacheData : cacheData, customD : customData},\n                argsXHR = [db,name,type,key,urlObj,customData,argsObj,opts];\n                if(processRequest){\n                    sendXHR = false;\n                    var returnPromise = self.callGeneric(db,type,def,undefined,undefined,customData, queryParams,key,urlObj.url,undefined,urlObj.method,urlObj.headers,argsObj);\n                    if(returnPromise instanceof Promise){\n                        batchPro = true;\n                        returnPromise.then(function(resp){\n                            resp = (resp == \"\" ? JSON.parse(\"{}\") : JSON.parse(resp));\n                            payLoad = RESTSerializer.getResponse(db,resp,def,type,key,urlObj,undefined,customData,opts,argsObj);\n                            resolve([payLoad]);\n                        },function(message){\n                            reject(message);\n                        });\n                    }\n                    else{\n                        sendXHR = true;\n                    }\n                }\n                if(makeBatch && !batchPro){\n                    RESTConnector.constructBatch.apply(RESTConnector, argsXHR).then(function(resObj){\n                        var payLoad = resObj.content;\n                        RESTConnector.getSuccess(db,def,type,key,urlObj,undefined,resolve,reject,payLoad,resObj,undefined,opts,argsObj);\n                    },function(resObj){\n                        RESTConnector.getFailure(db,def,type,key,urlObj,undefined,resolve,reject,opts,resObj.content,resObj.code,argsObj,resObj);\n                    });\n                }\n                else if(idbObj && db.idbIns){\n                    db.idbIns.getFromIDB(idbObj, name, type, queryParams, key, urlObj).then(function(payLoad){\n                        var res = initCB(db,\"serializer\", def.serializer, RESTSerializer.IDBRESPONSE, { argsObj: argsObj, args:[name, type, queryParams, key, payLoad]});\n                        if(res){\n                            payLoad = res.data;\n                        }\n                        if(payLoad == false){\n                            var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);\n                            xhrPrm.then(function(resp){\n                                RESTConnector.getSuccess(db,def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);\n                            }, function(resp){\n                                RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);\n                            });\t\n                            prmXhr = xhrPrm.xhr;\t\t\t\t\t\t\n                        }\n                        else{\n                            RESTConnector.getSuccess(db, def,type,key,urlObj,undefined,resolve,reject,payLoad,undefined,\"idb\",opts,argsObj);\n                        }\n                    },function(message){\n                        var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);\n                        xhrPrm.then(function(resp){\n                            RESTConnector.getSuccess(db, def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);\n                        }, function(resp){\n                            RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);\n                        });\t\t\n                        prmXhr = xhrPrm.xhr;\t\t\t\t\t\n                    });\n                }\n                else if(sendXHR){\n                    var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);\n                    xhrPrm.then(function(resp){\n                        RESTConnector.getSuccess(db, def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);\n                    },function(resp){\n                        RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);\n                    });\n                    prmXhr = xhrPrm.xhr;\n                }\n            });\n            if(prmXhr){\n                prm.xhr = prmXhr;\n            }\n            return prm;\n        }\n        else {\n            Dberror.error(db.lyte,\"LD02\",\"Schema\",name);\n            return Promise.reject({code : \"ERR19\", message : Dberror.errorCodes.ERR19, data:name});\n        }\n    }\n    static create(db, name, data, isSingleRecord, customData, qP){\n        var type= isSingleRecord ? \"createEntity\": \"create\", \n        def = db.schema[name], \n        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData};\n        customData = customData == undefined ? getFromCB(db,\"connector\", def.connector, \"customData\") : customData;\n        var urlObj = this.buildURL(db, type, \"POST\", def, undefined, data,qP,undefined,customData,undefined,argsObj);\n        qP = urlObj.qP;\n        var partial = initPartialObj(db, name, type, qP, undefined, urlObj.url, customData, argsObj);\n        var changedData = toJSON(db, name, data, undefined, \"create\", partial);\n        RESTSerializer.sendingData(db, name, changedData, urlObj, type, customData, data, argsObj);\n        return this.handleRequest(db, urlObj, name, data, type, changedData, customData, partial.obj, undefined, undefined, partial.ref, argsObj);\n    }\n    static put(db, name, data, record, isSingleRecord,customData, qP){\n        var def = db.schema[name], \n        bK = def.bK , \n        isComp = def.isComp, \n        type = (isSingleRecord) ? \"updateEntity\" : \"update\", \n        partialObj = new Map(), \n        key = isSingleRecord ? (isComp && bK ? record[bK] : record.$.pK) : undefined, \n        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};\n        customData = customData == undefined ? getFromCB(db,\"connector\", def.connector, \"customData\") : customData;\n        var urlObj = this.buildURL(db, type, \"PATCH\", def, key, data, qP, undefined, customData, undefined, argsObj);\n        qP = urlObj.qP;\n        var partial = initPartialObj(db, name, type, qP, key, urlObj.url, customData, argsObj);\n        var updatedData = toJSON(db, name, data, undefined, undefined, partial);\n        RESTSerializer.sendingData(db, name, updatedData, urlObj, type, customData, record, argsObj);\n        return this.handleRequest(db, urlObj, name, record, type, updatedData, customData, partial.obj,key, undefined, partial.ref, argsObj);\n    }\n    static del(db, name, data, isSingleRecord, destroy, customData, qP){\n        var def = db.schema[name], \n        bK = def.bK , \n        isComp = def.isComp, \n        type = destroy || \"deleteEntity\", \n        key = isSingleRecord ? (isComp && bK ? data[bK] : data.$.pK) : undefined, \n        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};\n        customData = customData == undefined ? getFromCB(db,\"connector\", def.connector, \"customData\") : customData;\n        var urlObj = this.buildURL(db, type, \"DELETE\", def, key, data,qP,undefined,customData,undefined,argsObj);\n        qP = urlObj.qP;\n        var partial = initPartialObj(db, name, type, qP, key, urlObj.url, customData, argsObj);\n        var ids = [];\n        if(!isSingleRecord){\n            ids = data.map(function(val){\n                return val.$.pK;\n            });\t\t\t\t\n        }\n        var pkVal = (isSingleRecord) ?  (data ? data.$.pK : undefined) : ids;\n        RESTSerializer.sendingData(db, name, pkVal, urlObj, type, customData, data, argsObj);\n        return this.handleRequest(db, urlObj, name, data, type, pkVal, customData, undefined, key, undefined, undefined, argsObj);\n    }\n    static handleAjax(obj){\n        if(obj.url){\n            if(!obj.schema){\n                Dberror.error(obj.db.lyte,\"Please pass schema param to db.ajax call\");\n                return Promise.reject(\"Please pass schema param to db.ajax call\");\n            }\n        }\n        var argsObj = { type: \"ajax\", schemaName : obj.schema, queryParams: obj.queryParams, customData: obj.customData}\n        var urlObj = RESTConnector.buildURL(obj.db, \"ajax\", obj.type, obj.schema, obj.index, undefined, obj.queryParams, undefined, obj.customData, obj.url, argsObj);\n        urlObj.data = obj.data;\n        var qP = urlObj.qP, res = initCB(obj.db,\"serializer\", obj.schema, RESTSerializer.SERIALIZE, { argsObj: argsObj, args:[\"ajax\",urlObj.data,undefined,obj.customData,obj.schema,qP,undefined]});\n        if(res){\n            argsObj.data = urlObj.data = res.data;\n        }\n        return RESTConnector.handleRequest(obj.db, urlObj, obj.schema, undefined, \"ajax\",undefined,obj.schema,undefined,undefined,undefined,undefined,argsObj);\n    }\n    static handleAction(db,actionName,def,record,customData,qP,method,data){\n        var pkVal;\n        if(record && isEntity(record)){\n            pkVal = record.$.get(def._pK);\t\t\t\t\n        }\n        var name = def._name, \n        type = \"action\", \n        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, actionName:actionName}\n        RESTConnector.getConnector(db, def, argsObj);\n        RESTConnector.getSerializer(db, def, argsObj);\n        customData = customData == undefined ? getFromCB(db,\"connector\", def ? def.connector : undefined, \"customData\") : customData;\n        var urlObj = this.buildURL(db,type, method ? method : \"POST\", def, pkVal, record, qP, actionName, customData, undefined, argsObj);\n        argsObj.data = urlObj.data = data, qP = urlObj.qP;\n        var res = initCB(db,\"serializer\", def.serializer, RESTSerializer.SERIALIZE, { argsObj: argsObj, args:[\"action\",data,record,customData,name,qP,actionName]});\n        if(res){\n            argsObj.data = urlObj.data = res.data;\n        }\n        return this.handleRequest(db, urlObj, def._name, undefined, type,undefined,customData,undefined,undefined,actionName,undefined,argsObj);\n    }\n    static callGeneric(db, type, def, data, record, customData, queryParams, key, url, actionName, method, headers, argsObj){\n        var name = def && def._name ? def._name : def;\n        argsObj.cachedData = record;\n        var res = initCB(db,\"connector\", def.connector, RESTConnector.PROCESSREQUEST, {argsObj:argsObj, args:[type,name,data,record,customData,queryParams,key,url,actionName,method,headers]});\n        return res ? res.data : undefined;\n    }\n    static handleBatchPromise(obj){\n        var response = obj.response,\n        db = obj.db, \n        batch = obj.batch, \n        fail = obj.fail;\n        //callback\n        obj.argsObj.payLoad = response;\n        if(!fail){\n            var res = initCB(db,\"serializer\", undefined, RESTSerializer.NORMALIZE, {argsObj:obj.argsObj, args:[undefined,\"batch\",obj.response]});\n            if(res){\n                response = res.data;\n            }\n    \n            var resp = response.batch_requests;\n            resp.forEach(function(item, index){\n                var pro = db.$.batchPromise[batch][index];\n                var status = item.status.toString();\n                var code = status[0];\n                if(code == \"2\"){\n                    pro.resolve({content:item.content,index:index,batch:batch,resp:item});\n                }\n                else if(code == \"4\" || code == \"5\"){\n                    db.$.batchResponse[batch][index] = undefined;\n                    pro.reject({content:item.content,index:index,batch:batch,resp:item,code:status});\n                }\n            });\n        }\n        else{\n            var prmArr = db.$.batchPromise[batch];\n            prmArr.forEach(function(itm, idx){\n                itm.reject({content:{}, index: idx, batch:batch, code:\"400\",resp:{}})\n            });\n        }\n        // obj.resolve(response);\n        delete db.$.batch[batch];\n        delete db.$.batchPromise[batch];\n    }\n    static constructBatch(db,name,type,key,urlObj,customData){\n        return new Promise(function(resolve, reject){\n            var batch = db.$.currentBatch;\n            var q = db.$.batch[batch] = db.$.batch[batch] || [];\n            var pro = db.$.batchPromise[batch] = db.$.batchPromise[batch] || []; \n            var batchObj = {};\n            batchObj.method = urlObj.method;\n            batchObj.uri = \"/\" + urlObj.url;\n            batchObj.parameters = urlObj.qP;\n            batchObj.content = typeof urlObj.data == \"string\" ? JSON.parse(urlObj.data) : undefined;\n            q.push(batchObj);\n            pro.push({resolve:resolve,reject:reject});\t\n        });\n    }\n}\nRESTConnector.__lMod = \"RESTConnector\";\nRESTConnector.returnData = \"old\";\nRESTConnector.PARSEREQUEST = \"parseRequest\";\nRESTConnector.REQUESTURL = \"requestURL\";\nRESTConnector.REQUESTHEADERS = \"requestHeaders\";\nRESTConnector.REQUESTMETHOD = \"requestMethod\";\nRESTConnector.REFETCHALL = \"refetchAll\";\nRESTConnector.REFETCH = \"refetchEntity\"\nRESTConnector.PROCESSREQUEST = \"processRequest\";\nRESTConnector.PARSERESPONSE = \"parseResponse\";\n\nRESTConnector.JSON = /application\\/json/;\nRESTConnector.TEXT = /text\\/plain/;\nRESTConnector.__extendedBy = [];\nexport { RESTConnector };","import { Serializer } from \"./Serializer\";\n\n/*convert to custom class*/\nclass RESTSerializer extends Serializer {\n    static register(parent){\n        // this.__class = RESTSerializer;\n        // var name = this._name = dbModName(this.name, \"Serializer\");\n    }\n    constructor(db){\n        super();\n        this.__type = \"REST\";\n        var lIns = db.lyte,\n        name = this.constructor._name;\n        Object.defineProperty(this,'$lg', {\n            value : lIns.__gl\n        });\n        this.deserializeEmptyData = true;\n        if(!db.getSerializerObj(name)){\n            db.serializer.REST = db.serializer.REST || {}; \n            db.serializer.REST[name] = this; \n        }\n    }\n}\n\nRESTSerializer.__lMod = \"RESTSerializer\";\n\nRESTSerializer.PROCESSENTITY = \"processEntity\";\n\nRESTSerializer.NORMALIZE = \"normalizePayload\";\n\nRESTSerializer.SERIALIZE = \"serializePayload\";\n\nRESTSerializer.SERIALIZEKEY = \"serializeKey\";\n\nRESTSerializer.NORMALIZEKEY = \"normalizeKey\";\n\nRESTSerializer.SERIALIZEENTITY = \"serializeEntity\";\n\nRESTSerializer.NORMALIZEENTITY = \"normalizeEntity\";\n\nRESTSerializer.DESERIALIZEKEY = \"deserializeKey\";\n\nRESTSerializer.GETMETA = \"getMeta\";\n\nRESTSerializer.IDBRESPONSE = \"idbResponse\";\n\nRESTSerializer.REFERENCEKEY = \"referenceKey\";\n\nRESTSerializer.__extendedBy = [];\n\nexport { RESTSerializer };","import { _defProp, getFromCB, registerField, defArrUtls, defUtls, evAdd, evRemove, evEmit, extendDef, establishObsBindings, schArgs, dbModName, getSchemaObj } from \"./utils.js\";\nimport { $Entity } from \"./Entity.js\";\nimport { getDefaultVal } from './utils';\nimport { establishObjectBinding, establishObserverBindings, extendEventListeners, isInheritedClass , establishWatchScope} from \"@slyte/core/src/lyte-utils.js\";\nimport { Dberror } from \"./dberror.js\";\n\nclass Schema {\n    static observers(arg){\n        return arg;\n    }\n    static actions(arg){\n        return arg;\n    }\n    static prop(type, opts){\n        if(opts && typeof opts !== \"object\"){\n            console.error(\"second param should be a object\");\n        }\n        opts = opts || {};\n        var obj = Object.assign({},opts);\n        obj.type = type;\n        return obj;\n    }\n    static register(opts){\n        var rHash = opts.refHash;\n        var schCls = this, \n        dbMap = Schema.db = Schema.db || new Map(),  \n        schMap,\n        schClsName = schCls.name;\n        if(!dbMap.has(rHash)){\n            dbMap.set(rHash, new Map());\n        }\n        schMap = dbMap.get(rHash);\n        if(!schMap.has(schClsName)){\n            schMap.set(schCls.name, schCls);\n        }\n        Schema.triggerEvent(rHash, schCls);\n    }\n    static registerInDb(opts, parent){\n        this.__class = Schema;\n        var name;\n        if(this.schemaName){\n            name = this._name = this.schemaName;\n        }   \n        else{\n            name = opts && opts.name? opts.name : this.name;\n            name = this._name = dbModName(name, \"Schema\", opts && opts.name ? false : true);\n        }\n        parent = parent || Object.getPrototypeOf(this);\n        if(!parent.schema.hasOwnProperty(name)){\n            parent.schema[name] = this;\n            this.opts = opts;\n            if(parent.schema.triggerEvent){\n                parent.schema.triggerEvent(\"add\", name, this);\n            }\n        }\n        else{\n            Dberror.warn(\"Schema with the same name - \"+ name+ \" already present in the db\");\n        }        \n    }\n    static create(db, lIns){\n        var _this = {}, \n        parent = Object.getPrototypeOf(this);\n        parent = parent !== db.constructor.Schema && parent !== Schema ? parent : undefined;\n        extendEventListeners(_this);\n        Object.defineProperty(_this, \"emit\", {\n            value: function(name, args){\n                var arr = Array.isArray(args) ?  Array.from(args) : [];\n                arr.splice(0, 0, name);\n                _this.triggerEvent.apply(this, arr);\n            }\n        });\n        var name = _this._name = this._name;\n        var delay = this.opts && this.opts.delay ? this.opts.delay : undefined;\n        _this.db = db;\n        _this.Lyte = lIns;\n        _this.__class = Schema;\n        _this.fieldList = {id : {type : \"string\", primaryKey : true, defined : false}};\n        _this.relations = new Map();\n        _this._properties = {};\n        _this._fldGrps = { default : {}, hasMany: {}, watch: {}, inherit:{} ,nested_prop: {}, reverseKey: new Map() , JsonPathWatch : {} };\n        _this.data = [];\n        _this.dirty = [];\n        _this._deleted = new Map();\n        _this.events = {};\n        _this.def = this;\n        _this.endPoint = this.endPoint;\n        _defProp(_this.data, \"_recMap\", new Map());\n\t\t// _defProp(_this, \"db\", db);\n        \n        var obs = [], self = _this, _self = this;\n        function _props(){\n            delete self._pK;\n            delete self._arrPk;\n            var parentProps = {};\n            if(parent && parent.props){\n                parentProps = parent.props(lIns);\n                for(var key in parentProps){\n                    if(parentProps[key].type == \"relation\"){\n                        delete parentProps[key];\n                    }\n                }\n            }\n            var fields = Object.assign(parentProps, _self.prototype.props(lIns));            \n            for(var key in fields){\n                registerField(db,self,key,fields[key],obs);\n            }\n            if(!self._pK){\n                self._pK = 'id';\n            }    \n            self.isComp = false;\n            var splt = self._pK.split(',');\n            if(splt.length > 1){\n                self.isComp = true;\n            }\n            self._arrPk = splt;    \n            // delete _self.prototype.props;    \n        }\n        var self = _this;\n        db.schema[_this._name] = _this;\n        if(this.prototype.props){\n            if(delay){\n                setTimeout(_props,1)\n            }\n            else{\n                _props();\n            }\n        }\n        if(this.prototype.actions){\n            var parentAct = {};\n            if(parent && parent.actions){\n                parentAct = parent.actions() || {};\n            }\n            Object.defineProperty(_this, \"actions\", {\n                value: Object.assign(parentAct, this.prototype.actions() || {})\n            });\n            // _this.actions = Object.assign(parentAct, this.prototype.actions());\n        }\n        if(this.observers){\n            var parentObs = {};\n            if(parent && parent.observers){\n                parentObs = parent.observers() || {};\n            }\n            var obj = Object.assign(parentObs, this.observers() || {});\n            for(var key in obj){\n                obs.push(obj[key]);\n            }\n        }\n        _this.didLoad = _this.didLoad || [];\n        if(this.prototype.didLoad){\n            _this.didLoad.push(this.prototype.didLoad);\n        }\n        if(this.prototype.idb){\n            this.prototype.idb;\n            _this.idb = this.prototype.idb(db);\n        }\n        if(!_this._pK){\n            _this._pK = 'id';\n        }\n        _this.isComp = false;\n        var splt = _this._pK.split(',');\n        if(splt.length > 1){\n            _this.isComp = true;\n        }\n        _this._arrPk = splt;\n        establishObserverBindings(obs,true,_this._properties, _this);\n        establishWatchScope(_this._fldGrps.JsonPathWatch,_this)\n        defArrUtls(_this.data);\n        defUtls(_this.data, _this);\n        if(parent){\n            extendDef.apply(self, [db.getSchemaObj(parent._name), undefined, db]);\n        }\n        else if(this.prototype.polymorphic){\n            var pArr = this.prototype.polymorphic();\n            pArr.forEach(function(itm, idx){\n                extendDef.apply(db.getSchemaObj(itm._name), [self, undefined, db]);\n            });\n        }\n        delete _this.connector;\n        delete _this.serializer;\n        var self = _this;\n        if(this.Connector){\n            if(isInheritedClass(this.Connector, db.constructor.ConnectorCls)){\n                _this.Connector = this.Connector;\n                var cname = dbModName(this.Connector.name, \"Connector\");\n                if(cname === \"application\"){\n                    var aIns;\n                    lIns.scopedInstance(this.Connector, [db], function(ins){\n                        self.connector = ins;\n                        aIns = ins;\n                    }, [db]);\n                    var context = aIns.__type\n                    db.Connector[context] = db.Connector[context] || {};\n                    db.Connector[context][cname] = _self.Connector;\n        \n                    db.connector[context] = db.connector[context] || {}; \n                    db.connector[context].application = aIns;\n                }\n                else{\n                    lIns.scopedInstance(this.Connector, [db], function(ins){\n                        self.connector = ins;\n                    }, [db]);\n                    var context = self.connector.__type;\n                    db.Connector[context] = db.Connector[context] || {};\n                    db.Connector[context][cname] = _self.Connector;\n                }\n    \n                // _this.connector = new this.Connector(lIns); \n            }\n        }\n        else if(db.applicationConnector){\n            self.connector = db.applicationConnector;\n        }\n        if(this.Serializer){\n            if(isInheritedClass(this.Serializer, db.constructor.SerializerCls)){\n                _this.Serializer = this.Serializer;\n                var sname = dbModName(this.Serializer.name, \"Serializer\");\n                if(sname === \"application\"){\n                    var asIns;\n                    lIns.scopedInstance(this.Serializer, [db], function(ins){\n                        self.serializer = ins;\n                        asIns = ins;\n                    }, [db]);\n                    var context = asIns.__type\n    \n                    db.Serializer[context] = db.Serializer[context] || {};\n                    db.Serializer[context][sname] = _self.Serializer;\n        \n                    db.serializer[context] = db.serializer[context] || {}; \n                    db.serializer[context].application = asIns;\n                }\n                else{\n                    lIns.scopedInstance(this.Serializer, [db], function(ins){\n                        self.serializer = ins;\n                    }, [db]);\n                    var context = self.serializer.__type\n                    db.Serializer[context] = db.Serializer[context] || {};\n                    db.Serializer[context][sname] = _self.Serializer;\n                }\n            }\n        }\n        else if(db.applicationSerializer){\n            self.serializer = db.applicationSerializer;\n        }\n        _this.cache = {\n            get : function(){\n                var args = schArgs.apply(self, arguments);\n                return self.db.cache.get.apply(self.db.cache, args);\n            },\n            getAll: function(){\n                var args = schArgs.apply(self, arguments);\n                return self.db.cache.getAll.apply(self.db.cache, args);\n            },\n            drop : function(){\n                var args = schArgs.apply(self, arguments);\n                return self.db.drop.apply(self.db.cache, args);\n            },\n            dropAll : function(){\n                var args = schArgs.apply(self, arguments);\n                return self.db.dropAll.apply(self.db.cache, args);\n            }\n        }\n        delete this.prototype.actions;\n        delete this.prototype.didLoad;\n        delete this.prototype.includes;\n        delete this.prototype.idb;\n        return _this;\n    }\n    constructor(data, opts, db){\n        // super();\n        var def = this.constructor;\n        def = getSchemaObj(db, def);\n        var delayPers = opts && opts.hasOwnProperty(\"delayPersistence\") ? opts.delayPersistence : getFromCB(db,\"connector\", def.connector, \"delayPersistence\");\n        Object.assign(this, data);\n        Object.defineProperties(this, {\n            $ :{\n                writable : true,\n                value : new $Entity(this, def, delayPers, db)\n            }\n        });\n        var parent = db.$.saveParent;\n        if(parent && this !== parent){\n            _defProp(this.$, \"parent\", parent);\n        }\n        var defF = def._fldGrps.default;\n        var watchF = def._fldGrps.watch;\n        var hasManyF = def._fldGrps.hasMany;\n        for(var dKey in defF){\n            var dFld = defF[dKey];\n            var fldVal = data[dKey];\n            if(fldVal === undefined || fldVal === \"\"){\n                this[dKey] = getDefaultVal(this, dFld.default);\n            }\n        }\n        for(var wKey in watchF){\n            establishObjectBinding(this, wKey, true, undefined, undefined, true);\n        }\n        for(var hKey in hasManyF){\n            var hFld = hasManyF[hKey];\n            if(this.hasOwnProperty(hKey)){\n                this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];\n            }\n            else if(hFld.relatedTo){\n                var toInit = getFromCB(db,\"serializer\", getSchemaObj(db, hFld.relatedTo).serializer, \"initHasManyRelation\");\n                if(toInit){\n                    this[hKey] = [];\n                }\n            }\n        }\n        var props = def._properties;\n        if(Object.keys(props).length){\n            if(!this._bindings){\n                _defProp(this, '_bindings', new Set(), false, true, true);\n            }\n            this._bindings.add(props);\n            establishObsBindings(this,props);\n        }\n    }\n    static addEventListener(type, func){\n        return evAdd(this,type,func);\n    }\n    static removeEventListener(id){\n        evRemove(this,id);\n    }\n    static emit(type, args){\n        evEmit(this,type,args);\n    }\n    static on(type,func){\n        return this.addEventListener(type,func);\n    }\n    /**\n     * To get a data from the server.\n     * @param {Object} obj - arguments object.\n     * @param {string} obj.schema - schema.\n     * @param {string} obj.pK - pK.\n     * @return A promise which will be resolved on success and rejected on failure\n    */\n}\n\nSchema.__lMod = \"Schema\";\n\nextendEventListeners(Schema);\n\nexport { Schema };\n","import { Service } from \"@slyte/core/src/service\"\nimport { cbScp, cB, isEmpty, handleResponse, initCB, getSchemaObj, _defProp, dbModName , isDirty } from \"./utils.js\";\nimport { isEntity } from \"@slyte/core/src/lyte-utils\";\n\n/*convert to custom class*/\nclass Serializer extends Service {\n    constructor(){\n        super();\n        this.constructor._name = dbModName(this.constructor.name, \"Serializer\");\n    }\n    static genericResponse(db,resp,def,type,data,urlObj,xhr,partialObj,customData,partialRef,argsObj){\n        var response = resp, \n        name = def && def._name ? def._name : def,\n        status = xhr ? xhr.status : undefined, \n        scope, \n        args, \n        qP = urlObj ? urlObj.qP : undefined, extractMetaCall;\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;\n        scope = cbScp(db, def ? def.serializer : undefined, baseSerz.GETMETA, \"serializer\");\n        if(scope){\n            if(response){\n                var metaRes = cB(scope, [argsObj]);\n                if(!isEmpty(metaRes)){\n                    argsObj.meta = response.meta = metaRes;    \n                }\n                extractMetaCall = true;\n            }\n            else{\n                extractMetaCall = false;\n            }\n        }\n        if(response && type != \"action\" && type != \"ajax\"){\n            response = baseSerz.buildJSON(db, def, type, response, isEntity(data) ? data[db.getSchemaObj(name)._pK] :undefined ,xhr ? xhr.status : undefined, urlObj, customData, qP, argsObj);\n            if( extractMetaCall == false && scope && response ){\n                var metaRes = cB(scope, [argsObj]);\n                if(!isEmpty(metaRes)){\n                    response.meta = metaRes;\n                }\n            }\n            var keys = Object.keys(response);\n            var len = keys.length;\n            /* Internal release\n            scope = cbScp(db, def ? def.serializer : undefined, RESTSerializer.DESERIALIZEKEY, \"serializer\");\n            if(scope){\n                db.lyte.warn(\"LD08\", \"deserializeKey\", \"callback\", \"Please use normalizeKey callback instead\");\n                if(len > 2){\n                    db.lyte.error(\"LD09\");\n                }\n                    var index = 0;\n                    if(keys[0] == \"meta\"){\n                        index = 1;\n                    }\n                    var deserializeKey = cB(scope, [argsObj]), rec = response[keys[index]];\n                    delete response[keys[index]];\n                    response[deserializeKey] = rec;\t\n            } \n            */\t\n            handleResponse(db, data, response, def, type, partialObj, undefined, partialRef);\n        }\n        return response;\n    }\n    static getResponse(db,resp,def,type,key,urlObj,xhr,customData,opts,argsObj){\n        var name = def && def._name ? def._name : def,\n        scope, \n        payLoad, \n        args, \n        qP = urlObj ? urlObj.qP : undefined;\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;\n        var doNormalize = opts.cacheData !== undefined && opts.cacheData !== null && typeof opts.cacheData == \"object\" && opts.cacheData.hasOwnProperty(\"normalize\")  ? opts.cacheData.normalize : true;\n        if(doNormalize){\n            resp = baseSerz.normalizeResponse(db, def, type, resp, key, xhr ? xhr.status : xhr, urlObj,customData,opts,argsObj)\n            payLoad = resp;\n            if(payLoad && typeof payLoad != \"object\"){\n                payLoad = JSON.parse(payLoad);\n                argsObj.payLoad = payLoad;\n            }\n            var res = initCB(db,\"serializer\", def.serializer, baseSerz.GETMETA, { argsObj: argsObj, args:[payLoad,name,type,qP,customData,opts]}), metaRes;\n            if(res){\n                metaRes = res.data;\n                if(!isEmpty(metaRes)){\n                    payLoad.meta = metaRes;\n                    argsObj.meta = payLoad.meta;\n                }\t\n            }\n            var keys = Object.keys(payLoad);\n            var len = keys.length; \n            if(len){\t\t\t\n                res = initCB(db,\"serializer\", def.serializer, baseSerz.NORMALIZEKEY, { argsObj: argsObj, args:[name,type,key,qP,customData,opts]});\n                var plKey;\n                if(res){\n                    plKey = res.data;\n                    if(plKey && plKey != name){\n                        var temp = payLoad[plKey];\n                        payLoad[name] = temp;\n                        delete payLoad[plKey];\n                    }\n                }\n                /* Internal release\n                scope = cbScp(db,def.serializer, RESTSerializer.DESERIALIZEKEY, \"serializer\");\n                if(scope){\n                    db.lyte.warn(\"LD08\", \"deserializeKey\", \"callback\", \"Please use payloadKey callback instead\");\n                    if(len > 2){\n                        db.lyte.error(\"LD09\");\n                    }\n                    var index = 0;\n                    if(len == 2 && keys[0] == \"meta\"){\n                        index = 1;\n                    }\n                    args = [name,type];\n                    var deserializeKey = cB(scope, [argsObj]), rec = payLoad[keys[index]];\n                    delete payLoad[keys[index]];\n                    payLoad[deserializeKey] = rec;\n                }\n                */\n                baseSerz.normalize(\n                    db,\n                    def,\n                    type,\n                    payLoad,\n                    key,\n                    xhr ? xhr.status : xhr,\n                    urlObj.headers,\n                    customData,\n                    opts,\n                    urlObj,\n                    argsObj\n                );\n            }\n            return payLoad;\n        }\n        else{\n            payLoad = resp\n            if(payLoad && typeof payLoad != \"object\"){\n                payLoad = JSON.parse(payLoad);\n                argsObj.payLoad = payLoad;\n            }\n            var res = initCB(db,\"serializer\", def.serializer, baseSerz.GETMETA, { argsObj: argsObj, args:[payLoad,name,type,qP,customData,opts]}), metaRes;\n            if(res){\n                metaRes = res.data;\n                if(!isEmpty(metaRes)){\n                    payLoad.meta = metaRes;\n                    argsObj.meta = payLoad.meta;\n                }\t\n            }\n            return payLoad;\n        }\n    }\n    static sendingData(db,name,data,urlObj,type,customData,snapshot,argsObj,partial){\n        var serializeKey = name, \n        payload = {}, \n        qP = urlObj ? urlObj.qP : undefined, \n        tempObj = {},\n        def = db.schema[name];\n        for (var key in urlObj){\n            tempObj[key] = urlObj[key];\n        }\n        tempObj.type = type;\n        tempObj.schema = name;\n        argsObj.data = data;\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;\n        var res = initCB(db,\"serializer\", def.serializer, baseSerz.SERIALIZEKEY, { argsObj: argsObj, args:[name,type,customData,qP]});\n        if(res){\n            serializeKey = res.data;\n        }\n        data = baseSerz.serializeRecords(db,def,data,snapshot,tempObj,\"serializeEntity\",customData,argsObj,partial);\n        if(!serializeKey){\n            payload = data;\n        }\n        else if(Array.isArray(data) || typeof data == \"object\" || isEntity(data)){\n            payload[serializeKey] = data;\n        }\n        argsObj.data = payload;\n        var res = initCB(db,\"serializer\", def.serializer, baseSerz.SERIALIZE, { argsObj: argsObj, args:[type,payload,snapshot,customData,name,qP]});\n        if(res){\n            argsObj.data = payload = res.data;\n        }   \n        urlObj.data = payload;\n    }\n    static serializeRecords(db,schema,data,records,urlObj,type,customData,argsObj,partial){\n        var defless = db.applicationConnector && db.applicationConnector.__type == \"REST\" ? db.applicationConnector.schemaless : undefined;\n        if(!schema && defless){\n            return data;\n        }\n        var rels = schema.relations;\n        if(!records && type != \"normalizeEntity\"){\n            records = db.cache.getEntity(schema.def, data.$.pK);\n        }\n        var result, \n        baseSerz = schema && schema.serializer ? schema.serializer.constructor : db.constructor.Serializer;\n        if(Array.isArray(data)){\n            result = [];\n            for(var index1=0;index1<data.length;index1++){\n                var record = data[index1];\n                if(record && typeof record === \"object\")\n                {\n                    result.push(baseSerz.serializeSingleRecord(db,schema,record,records ? records[index1]:undefined,urlObj,rels,type,customData,argsObj,partial));\n                }\n                else{\n                    result.push(record);\n                }\n            }\n        }\n        else if(data){\n            result = data;\n            if(data && typeof data === \"object\"){\n                result = baseSerz.serializeSingleRecord(db,schema,data,records,urlObj,rels,type,customData,argsObj,partial)\n            }\n        }\n        return result;\n    }\n    static serializeSingleRecord(db,def,data,record,urlObj,rels,type,customData,argsObj,partial){\n        var partObj;\n        type == \"serializeRecord\" && typeof data == \"object\" && data.$ == undefined ? store.$.defProp(data, \"$\", {}): data;\n        if(typeof partial == \"object\" && record && record.$ && record.$.pK){\n            partObj = partial.get ? partial.get(record.$.pK):partial;\n            if(data.$ && data.$._partialObj){\n                var data$; \n                data$ = Object.assign({}, data.$);\n                data = Object.assign({}, data);\n                store.$.defProp(data, \"$\", data$);\n            }\n            var relDirty =  store.$.isDirty(record,record.$.schema.relations);\n            if(record.$.isModified || (Array.isArray(relDirty) && relDirty.length != 0)){\n                var dirtAttr = record.$.getDirtyAttributes();\n                Array.isArray(relDirty) && dirtAttr.concat(relDirty);\n                var keys = Object.keys(data);\n                !partObj.hasOwnProperty(\"_removedAttr\")?Object.defineProperties(partObj,{_removedAttr : {value : {} }}):undefined; \n                dirtAttr.forEach(function(val){\n                    if(!keys.includes(val) && !record.$.schema._arrPk.includes(val)){\n                        partObj._removedAttr[val] = true;\n                    }\n                })\n            }\n            Object.defineProperties(data.$,{\n                _partialObj:{\n                    value:partObj\n                },\n                _pkVal:{\n                    value:record.$.pK\n                },\n                _model:{\n                    value:model_name\n                },\n                _payloadObj:{\n                    value:data\n                }\n            })\n        }\n        type == \"serializeRecord\" ? store.$.defpayObjUtls(data.$) : undefined;\n        var name = def && def._name ? def._name : def,\n        baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer, \n        scope = cbScp(db,def.serializer,type == \"serializeEntity\" ? baseSerz.SERIALIZEENTITY : baseSerz.NORMALIZEENTITY,\"serializer\");\n        if(scope){\n            var args;\n            var oPLoad = argsObj.payLoad\n            if(type == \"serializeEntity\"){\n                argsObj.entityData = data;\n                argsObj.cachedData = record;\n                args = [argsObj];\n            }\n            else{\n                argsObj.entityData = data;\n                argsObj.entityPayload = data;\n                args = [argsObj];\n            }\n            data = cB(scope,args);\n            argsObj.payLoad = oPLoad;\n        }\n        if(rels){\n            rels.forEach(function(rel, key){\n                var relLen = rel.length;\n                for(var i=0; i<relLen; i++){\n                    var field = rel[i];\n                    var val = data[field.relKey], recs, res, relTo, srz, isPoly;\n                    if(field.type == \"relation\" && val && ( type == \"normalizeEntity\" || ( type == \"serializeEntity\" && field.opts && field.opts.serialize && field.opts.serialize != \"id\"))){\n                        recs = record ? record[field.relKey] : undefined, relTo = getSchemaObj(db, field.relatedTo), srz = field.opts ? field.opts.serialize : undefined;\n                        isPoly = field.opts ? field.opts.polymorphic : undefined\n                        if(field.relType === \"hasMany\"){\n                            if(!Array.isArray(val)){\n                                val = [val];\n                            }\n                            var valLen = val.length, res = [];\n                            for(var index1=0;index1<valLen;index1++){\n                                var _relTo = relTo;\n                                if(isPoly){\n                                    if(type == \"normalizeEntity\"){\n                                        _relTo = val[index1] && val[index1]._type ? val[index1]._type : relTo; \n                                    }\n                                    else if(type == \"serializeEntity\"){\n                                        if(srz == \"record\"){\n                                            _relTo = recs && isEntity(recs[index1]) ? recs[index1].$.schema._name : relTo;\n                                        }\n                                        else if(srz == \"partial\"){\n                                            _relTo =  val[index1] && val[index1].$ ?  val[index1].$.polymorphicType : relTo;\n                                        }\n                                    }\n                                }\t\n                                res.push(baseSerz.serializeRecords(db,relTo,val[index1],undefined,urlObj,type,customData,argsObj));\n                            }\n                            data[field.relKey] = res;\n                        }\n                        else {\n                            var _relTo = relTo;\n                            if(isPoly){\n                                if(type == \"normalizeEntity\"){\n                                    _relTo = data[field.relKey] && data[field.relKey]._type ? data[field.relKey]._type : relTo; \n                                }\n                                else if(type == \"serializeEntity\"){\n                                    _relTo = isEntity(record[field.relKey]) ? record[field.relKey].$.schema._name : relTo;\t\t\t\t\t\t\t\t\t\n                                }\n                            }\t\n                            data[field.relKey] = baseSerz.serializeRecords(db,_relTo,data[field.relKey],record ? record[field.relKey] : undefined,urlObj,type,customData,argsObj);\n                        }\n                    }\t\n                }\n            });\n        }\n        return data;\n    }\n    static buildJSON(db, def, type, payLoad, id, status, urlObj, customData, qP, argsObj){\n        var headers = urlObj ?  urlObj.headers : undefined, \n        realData = payLoad,\n        name = def && def._name ? def._name : def;\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;\n        var res = initCB(db, \"serializer\", def.serializer, baseSerz.NORMALIZE, { argsObj: argsObj, args:[name, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined,customData]});\n        if(res){\n            argsObj.payLoad = realData = res.data;\n            \n        }\n        var changed = false, recs, isGet = type == \"get\";\n        if(!isGet && realData && typeof realData == \"object\"){\n            res = initCB(db,\"serializer\", def.serializer, baseSerz.NORMALIZEKEY, { argsObj: argsObj, args:[name,type,undefined,qP,customData]});\n            if(res){\n                var plKey = res.data;\n                if(plKey && plKey != name){\n                    var temp = realData[plKey];\n                    realData[name] = temp;\t\t\n                    delete realData[plKey];\n                }\t\n            }\n        }    \n        if(isGet || (realData && realData[name])){\n            recs = realData[name], changed = true;\n            // Internal release\n            var scope = cbScp(db, def.serializer, baseSerz.PROCESSENTITY, \"serializer\");\n            if(scope){\n                if(Array.isArray(recs)){\n                    for(var i=0; i<recs.length; i++){\n                        argsObj.entityData = recs[i];\n                        recs[i] = cB(scope, [argsObj]);\n                    }\n                }\t\t\t\t\t\n                else{\n                    argsObj.entityData = recs;\n                    recs = cB(scope, [argsObj]);\n                }\n            }\n            var flUrlObj = type != \"pushPayload\" ? {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, schema :name} : undefined;\n            recs = baseSerz.serializeRecords(db, def, recs, undefined, flUrlObj, baseSerz.NORMALIZEENTITY, customData, argsObj);\n            realData[name] = recs;\n            argsObj.payLoad = realData;\n        }\n        return realData;\n    }\n    static normalizeResponse(db, def, type, payLoad, id, status, urlObj, customData, opts, argsObj){\n        var headers = urlObj ? urlObj.headers : undefined,\n        name = def && def._name ? def._name : def, realData;\n        argsObj.payLoad = realData = payLoad;\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;\n        var res = initCB(db,\"serializer\", def.serializer, baseSerz.NORMALIZE, { argsObj: argsObj, args:[name, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, opts]});\n        if(res){\n            argsObj.payLoad = realData = res.data;\n        }\n        return realData;\n    }\n    static normalize(db,def,type,payLoad,id,status,headers,customData,opts,urlObj,argsObj){\n        var realData = payLoad, \n        changed = false,\n        name = def && def._name ? def._name : def;\n        if(type == \"get\" || realData[name]){\n            realData = realData[name];\n            changed = true;\n        }\n        // Internal release\n        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;\n        var scope = cbScp(db,def.serializer, baseSerz.PROCESSENTITY, \"serializer\");\n        if(scope){\n            if(Array.isArray(realData)){\n                for(var i=0; i<realData.length; i++){\n                    argsObj.entityData = realData[i];\n                    realData[i] = cB(scope, [argsObj]);\n                }\n            }\t\t\t\t\t\n            else{\n                argsObj.entityData = realData;\n                realData = cB(scope, [argsObj]);\n            }\n        }\n        \n        argsObj.payLoad = realData;\n        if(changed){\n            payLoad = {};\n            realData = baseSerz.serializeRecords(db, def, realData, undefined, {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, schema :name}, \"normalizeEntity\", customData, argsObj)\n            payLoad[name] = realData;\n        }\n        argsObj.payLoad = payLoad;\n    }\n}\n\nSerializer.__lMod = \"Serializer\";\n\nexport { Serializer };","import { cmpSet, emit} from \"./utils\";\nimport { Logger } from \"@slyte/core\";\n\nclass Dberror extends Logger {\n    constructor(){\n        super(...arguments);\n    }\n}\n\nDberror.errorCodes = {\n    LD01: \"Primary key value might be missing in the response data that is received, {0}\",\n    LD02: \"Not a valid {0}\",\n    LD03: \"Cannot set the error {0} for {1}\",\n    LD04: \"No such record to merge, {0}\",\n    LD05: \"Model( {0} ) of related property - {1} not found in model - {2}\",\n    LD06: \"Backward relation not present in model( {0} ), for the property {1} of model( {2} )\",\n    LD07: \"{0} type not handled in handleArrayOperations\",\n    LD08: \"{0} {1} will be deprecated from next version {2}\",\n    LD09: \"deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback\",\n    LD10: \"Response data not in a format lyte data store expects\",\n    LD11: \"Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version\",\n    LD12: \"Response ( {0} ) is not in a format, lyte data store expects\",\n    LD13: \"Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of response data. Data - {3}\",\n    LD14: \"Cannot register {0} - {1}, as it already exists.\",\n    LD15: \"Primary key value might be missing in the response data that is received, {0}\",\n    LD16: \"Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge\",\n    LD17: \"Record with the primary key value already exists\",\n    LD18: \"No { 0 } present\",\n    LD19: \"Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version\",\n    LD20: \"Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.\",\n    LD21: \"No such state ( {0} ) saved for the record.\",\n    LD22: \"For create / createRecord, response with a primary key value should be received\",\n    LD23: \"PrimaryKey field {1} in {0} cannot have default value\",\n    LD24: \"Response couldn't be parsed, {0}\",\n    LD25: \"Cannot create record for the data - {0}\",\n    LD26: \"Only one baseKey is allowed for a model\",\n    LD27: \"Record merge failed, since the data passed is invalid - {0}\",\n    LD28: \"Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}\"   \n};\nDberror.register();\n\nclass ValidationError {\n    constructor(lyte, attr, obj, message){\n        Object.defineProperties(this, {\n            $ : {\n                value : {isError : true , error:message?message:{}}\n            }\n        });\n        if(attr){\n            ValidationError.setError(lyte,this,attr,obj);\n        }    \n    }\n\n    static setError(lyte,err,attr,codeObj){\n        if(err.$.hasOwnProperty(\"error\")){\n            if(Array.isArray(attr)){\n                attr.forEach(function(itm){\n                    cmpSet(lyte, err.$.error, itm, codeObj);\n                });\n            }\n            else{\n                cmpSet(lyte, err.$.error,attr,codeObj);\n            }\n        }\n        else{\n            ValidationError.error(lyte,\"LD03\",err,attr);\n        }\n    }\n\n    static setRecErr(ent$, field, code, value){\n        var lyte = ent$.schema.Lyte;\n        cmpSet(lyte, ent$, \"isError\", true);\n        var errObj = code;\n        if(typeof errObj == \"object\"){\n            cmpSet(lyte, ent$.error,field,errObj);\n        }\n        else{\n            if(typeof code == \"string\"){\n                var errMes = ValidationError.errorCodes[code];\n                if(errMes){\n                    errObj = {code : code, message : ValidationError.errorCodes[code]};\n                }\n                else{\n                    errObj = code;\n                }\n            }\n            cmpSet(lyte, ent$.error, field, errObj);\n            if(value){\n                cmpSet(lyte, ent$.error[field],\"value\",value);\n            }\t\t\t\t\n        }\n\t\tvar db = ent$.schema.db;\n        emit(db,\"error\",ent$.entity,field,errObj);\n    }\n\n    static clrRecErr(ent$, field, code){\n        var lyte = ent$.schema.Lyte;\n        var objUtl = lyte.objectUtils;\n        var $err = ent$.error;\n        if(code){\n            if(ent$.error.code == code){\n                if(typeof objUtl != \"undefined\"){\n                    objUtl($err,\"delete\",field);\n                }\n                else{\n                    delete $err[field];                        \n                }\n            }\n        }\n        else if(field){\n            if(typeof objUtl != \"undefined\"){\n                objUtl($err,\"delete\",field);\n            }\n            else{\n                delete $err[field];                       \n            }\n        }\n        else{\n            if(typeof objUtl != \"undefined\"){\n                for(var err in $err){\n                    objUtl($err,\"delete\",err);\n                }\n            }\t\n            else{\n                ent$.error = {};\n            }   \n        }\n        if(Object.keys(ent$.error).length == 0){\n            cmpSet(lyte, ent$, \"isError\", false);\n        }\n    }\n}\n\nValidationError.errorCodes = {\n    ERR01 : \"Primary key cannot be modified\", \n    ERR02 : \"Mandatory prop cannot be empty\", \n    ERR03 : \"Type of value does not match the specified data type\",\n    ERR04 : \"Value is greater than the maximum value allowed\",\n    ERR05 : \"Value is less than the minimum value allowed\", \n    ERR06 : \"Length of string/array is greater than the maximum limit allowed\", \n    ERR07 : \"Length of string/array is less than the minimum limit allowed\",\n    ERR08 : \"String does not match the specified pattern\", \n    ERR09 : \"Values in array are not unique\", \n    ERR10 : \"Value is not equal to the specified constant\", \n    ERR11 : \"Schema of related field is not defined\",\n    ERR12 : \"Schema of backward relation is not defined\", \n    ERR13 : \"Entity not found\", \n    ERR14 : \"Schema does not match the schema defined in the related field\", \n    ERR15 : \"Error in creating a entity as a relation\",\n    ERR16 : \"Entity with primary key already exists\", \n    ERR17 : \"Value cannot be changed because entity has been deleted\", \n    ERR18 : \"Action not defined\", \n    ERR19 : \"Schema not defined\",\n    ERR20 : \"Key not specified\", \n    ERR21 : \"'one' relationship expects a single object/id\", \n    ERR22 : \"Type not specified for polymorphic relation\", \n    ERR23: \"Primary Key value not present\", \n    ERR24: \"Error while relating entities\", \n    ERR25: \"Backward relation not present\",\n    ERR26: \"Primary key value cannot be undefined or null\",\n    ERR27: \"Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'\",\n    ERR29: \"Property not defined in the object\",\n    ERR30: \"Property's value is not an instanceof the mentioned class\"      \n};\n// ValidationError.register();\n\n\nclass ConnectorError extends Dberror {\n    constructor(msg, xhr){\n        super();\n        this.message = msg;\n        this.xhr = xhr;\n    }\n}\nConnectorError.register();\n\nclass SerializerError extends Dberror {\n    constructor(msg, xhr){\n        super();\n        this.message = msg;\n        this.xhr = xhr;\n    }\n}\nSerializerError.register();\n\nexport { ValidationError, Dberror, ConnectorError, SerializerError };","import { Dberror, ValidationError } from \"./dberror\";\nimport { Schema } from \"./Schema.js\";\nimport { cmpData,nestScp,isEntity, deepCopyObject, establishObjectBinding, checkProperty, newGetSuperClass, defProp, removeNestScp } from \"@slyte/core/src/lyte-utils.js\";\nimport { Entity } from \"./Entity.js\";\n// import { isMixin } from \"../../core/src/lyte-utils\";\n\n// function getOrigParent(cls){\n// \tvar prt = Object.getPrototypeOf(cls);\n// \twhile(isMixin(prt)){\n// \t\tprt = Object.getPrototypeOf(prt);\n// \t}\n// \treturn prt;\n// }\n\nfunction changePersist(record, value){\n\tif(!record.$.isUnloaded || record.$.isPeristed !== value){\n\t\tswitch(value){\n\t\t\tcase true: {\n\t\t\t\tif(!record.$.isNew && !record.$.isModified && !record.$.isDeleted){\n\t\t\t\t\tcmpSet(undefined, record.$, \"isPersisted\", true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase false: {\n\t\t\t\tif(record.$.isNew || record.$.isModified || record.$.isDeleted || (record.$.dN && Object.keys(record.$.dN) && Object.keys(record.$.dN).length)){\n\t\t\t\t\tcmpSet(undefined, record.$, \"isPersisted\", false);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction getSchemaObj(db, schema){\n\tvar schemaObj = db._schema.get(schema);\n\tif(!schemaObj && db.subDbs){\n\t\tvar len = db.subDbs.length;\n\t\tfor(var i=0;i<len;i++){\n\t\t\tvar subDb = db.subDbs[i];\n\t\t\tif(subDb._schema.get(schema)){\n\t\t\t\tschemaObj = subDb._schema.get(schema);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn schemaObj;\n}\n\nfunction dbModName(name, type, pascalToCamel){\n\tvar mp = { Schema : /([a-zA-Z0-9])(Schema)$/g, Connector: /([a-zA-Z0-9])(Connector)$/g, Serializer : /([a-zA-Z0-9])(Serializer)$/g };\n\tname = name.replace(mp[type], '$1');\n\treturn pascalToCamel !== false ? name.slice(0, 1).toLowerCase() + name.slice(1) : name;\n}\n\nfunction schArgs(){\n\tvar arg1 = arguments[0], args;\n\tif(typeof arg1 == \"object\"){\n\t\targ1.schema = this;\n\t\targs = [arg1]\n\t}\n\telse{\n\t\targs = Array.from(arguments);\n\t\targs.splice(0,0,this);\n\t}\n\treturn args;\n}\n\nfunction evAdd(scope,type,func){\n\tscope.events = scope.events || {};\n\tscope.events[type] = scope.events[type] || [];\n\tscope.events[type].push({f : func});\n\treturn type+\"-\"+(scope.events[type].length-1);              \n}\n\nfunction evRemove(scope,id){\n\tvar type;\n\tif(id){\n\t\tif(/^(add|remove|change)$/.test(id)){\n\t\t\ttype = id;\n\t\t\t(scope.events && scope.events[type]) ? delete scope.events[type] : undefined;   \n\t\t}\n\t\telse{\n\t\t\tvar arr = id ? id.split(\"-\") : undefined;\n\t\t\tif(arr){\n\t\t\t\tvar listeners = scope.events[arr[0]];\n\t\t\t\tif(listeners && arr[1]){\n\t\t\t\t\tlisteners[arr[1]] = null;\n\t\t\t\t}   \n\t\t\t}            \n\t\t}\n\t}else{\n\t\tvar ev = scope.events;\n\t\tfor(var evType in ev){\n\t\t\t(ev && ev[evType]) ? delete ev[evType] : undefined;\n\t\t}\n\t}\n}\n\nfunction evEmit(scope,type,args){\n\tvar listeners = (scope.events && scope.events[type]) ? scope.events[type] : [];\n\tfor(var i=0; i<listeners.length; i++){\n\t\t(listeners[i]) ? listeners[i].f.apply(null, args) : undefined;\n\t}            \n}\n\nfunction addTo_Del(def, data, ind){\n\tvar deleted = def._deleted = def._deleted || new Map(), \n\tobj = { index : ind , data : data };\n\tdeleted.set(data.$.pK, obj);\n}\n\nfunction genUnRedoStack(){\n\tvar obj = {};\n\t_defProp(obj, \"_order_\", [], false);\n\treturn obj;\n}\n\nfunction deepCopyStack(stack){\n\tif(stack && typeof(stack) == \"object\"){\n\t\tstack = Object.assign({},stack);\n\t\tfor(var attr in stack){\n\t\t\tif(Array.isArray(stack[attr])){\n\t\t\t\tvar arr = stack[attr] = Array.from(stack[attr]);\n\t\t\t\tarr.forEach(function(itm,idx){\n\t\t\t\t\tarr[idx] = Object.assign(itm);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn stack;\n}\n\nfunction deepCopyAttrs(def,obj){\n\tvar fields = def.fieldList, \n\tobj = Object.assign({},obj);\n\tfor(var attr in obj){\n\t\tvar _attr = obj[attr];\n\t\tif(fields[attr] && fields[attr].type == \"relation\" && Array.isArray(_attr)){\n\t\t\t_attr = obj[attr] = Array.from(_attr);\n\t\t\t_attr.forEach(function(itm, idx){\n\t\t\t\t_attr[idx] = Object.assign({}, itm);\n\t\t\t\titm.hasOwnProperty(\"records\") && itm.records ? (itm.records = Array.from(itm.records)) : undefined;\n\t\t\t\titm.hasOwnProperty(\"_indices\") && itm._indices ? (itm._indices = Array.from(itm._indices)) : undefined;\n\t\t\t});\n\t\t}\n\t}\n\treturn obj;\n}\n\nfunction unredoOp(type,rec,attr){\n\tvar stack, revStack;\n\tvar lyte = rec.schema.db.lyte;\n\tif(type == 1){\n\t\tstack = rec.undoStack;\n\t\trevStack = rec.redoStack;\n\t}\n\telse{\n\t\tstack = rec.redoStack;\n\t\trevStack = rec.undoStack;\n\t}\n\tvar attrs=[], obj, revObj = {};\n\tif(attr){\n\t\tif(!Array.isArray(attr)){\n\t\t\tattrs=[attr];\n\t\t}\n\t\telse{\n\t\t\tattrs = attr;\n\t\t}\n\t\tattrs.forEach(function(item){\n\t\t\tif(stack[item].length){\n\t\t\tvar len = stack._order_.length;\n\t\t\tfor (var index=len-1;index>=0;index--){\n\t\t\t\tvar order = stack._order_[index];\n\t\t\t\tvar attrIndex = order.indexOf(item);\n\t\t\t\tif(attrIndex > -1){\n\t\t\t\t\torder.splice(attrIndex,1);\n\t\t\t\t\t\tif(!order.length){\n\t\t\t\t\t\t\tstack._order_.splice(index,1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\telse{\n\t\tattrs = stack._order_ && stack._order_.length ? stack._order_.pop() : attrs;\n\t}\n\tif(attrs.length){\n\t\tfor(var index=0;index<attrs.length;index++){\n\t\t\tvar key=attrs[index], obj = stack[key].pop();\n\t\t\tif(obj._type == \"update\"){\n\t\t\t\tif(obj.hasOwnProperty(\"val\")){\n\t\t\t\t\tsetData(rec,key,obj.val,undefined, revObj);\n\t\t\t\t\t// redoObj[key] = undo;\n\t\t\t\t}\n\t\t\t\telse if(obj.hasOwnProperty(\"records\")){\n\t\t\t\t\tsetData(rec,key,obj.records,undefined, revObj)\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(type == 1 && obj._type == \"propAdd\"){\n\t\t\t\tif(typeof lyte != \"undefined\"){\n\t\t\t\t\trevObj[key] = {_type:\"propDelete\", val:rec.entity[key]};\n\t\t\t\t\tif(obj.hasOwnProperty(\"val\")){\n\t\t\t\t\t\tsetData(rec,key,obj.val,undefined, {});\n\t\t\t\t\t\t// redoObj[key] = undo;\n\t\t\t\t\t}\n\t\t\t\t\tif(lyte.objectUtils){\n\t\t\t\t\t\tlyte.objectUtils(rec.entity, \"delete\", key);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdelete rec.entity[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdelete rec.entity[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(type == 2 && obj._type == \"propDelete\"){\n\t\t\t\trevObj[key] = {_type:\"propAdd\"}\n\t\t\t\tsetData(rec,key,obj.val,undefined, revObj);\n\t\t\t}\n\t\t\telse if(obj._type == \"added\"){\n\t\t\t\trec.entity.$.get(key).remove(obj.records,undefined,revObj);\n\t\t\t}\n\t\t\telse if(obj._type == \"removed\"){\n\t\t\t\trllBckRecArr(rec.schema.db, [obj], rec.entity, rec.schema, rec.schema.fieldList[key])\n\t\t\t\tobj._type = \"added\";\n\t\t\t\trevObj[key] = obj;\n\t\t\t}\n\t\t}\n\t\tvar keys = Object.keys(revObj);\n\t\tfor(var index=0;index<keys.length;index++){\n\t\t\tvar key = keys[index];\n\t\t\trevStack[key] = revStack[key] || [];\n\t\t\trevStack[key].push(revObj[key]);\n\t\t}\n\t\tif(keys.length){\n\t\t\t// rec.redoStack._order_ = rec.redoStack._order_ || [];\n\t\t\trevStack._order_.push(keys);\n\t\t}\n\t}\n}\n\nfunction unregisterDef(db, schema){\n\tschema = getSchemaObj(db, schema);\n\tif(schema){\n\t\tvar name = schema._name;\n\t\tif(schema.data.length){\n\t\t\tdb.dropAll(schema.def);\n\t\t}\n\t\tvar extendedBy = schema.extendedBy;\n\t\tif(extendedBy && Object.keys(extendedBy).length){\n\t\t\tfor(var ext in extendedBy){\n\t\t\t\tunregisterDef(db, db.schema[ext].def);\n\t\t\t}\n\t\t}\n\t\tif(schema.extend){\n\t\t\tvar extend = db.getSchemaObj(schema.extend);\n\t\t\tif(extend){\n\t\t\t\tdelete extend.extendedBy[name];\n\t\t\t}\n\t\t}\n\t\tdelete db.schema[name];  \n\t\tdelete db.constructor.Schema.schema[name];\n\t\tdb._schema.delete(schema.def);\n\t}\n}\n\nfunction updateFieldValidation(db, schema, key, deserialize, ignoreValidation){\n\tvar records = schema.data, \n\tfields = schema.fieldList;\n\trecords.forEach(function(item){\n\t\tvar field = fields[key], \n\t\tisOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty(\"value\") ? true : false, \n\t\toldVal = isOldVal ? item.$.error[key].value : undefined;\n\t\tValidationError.clrRecErr(item.$, key);\n\t\tif(deserialize){\n\t\t\tvar fldTypeName = field.type._name, \n\t\t\tempD = getDsrzEmpData(schema, field, schema._name), \n\t\t\tboolChk = !empD && item[key];\n\t\t\tif((item.hasOwnProperty(key) && (boolChk || empD) && db.dataType[fldTypeName].hasOwnProperty(\"deserialize\"))){\n\t\t\t\titem[key] = db.dataType[fldTypeName].deserialize(item[key],key,schema._name,getpKVal(item,schema));\n\t\t\t}\n\t\t}\n\t\tisOldVal ? validateField(db, item, key, fields[key], undefined, {old:true, value:oldVal}) : validateField(db, item, key, fields[key], undefined)\n\t\tif(!ignoreValidation){\n\t\t\tvar isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty(\"value\") ? true : false;\n\t\t\tvar oldVal = isOldVal ? item.$.error[key].value : undefined;\n\t\t\tValidationError.clrRecErr(item.$, key);\n\t\t\tisOldVal ? validateField(db, item, key, field, undefined, {old:true, value:oldVal}) : validateField(db, item, key, fields[key], undefined)\n\t\t}\n\t\tif(isOldVal && item.$.error && Object.keys(item.$.error) === 0){\n\t\t\titem.$.set(key, oldVal);\n\t\t}\n\t});\n}\n\nfunction handleCachedResponse(db,batch,resp){\n\tvar cached = db.$.cachedBatch = db.$.cachedBatch || {}, \n\tarr = cached[batch] || [], \n\tcount = 0;\n\tarr.forEach(function(item,index){\n\t\tresp.splice((item.ind+count++),0,item.data);\n\t});\n\tdelete cached[batch];\n\treturn resp;\n}\n\nfunction addToCachedBatch(db, data){\n\tvar curr = db.$.currentBatch, \n\tcached = db.$.cachedBatch = db.$.cachedBatch || {}, \n\tcachedB = cached[curr] = cached[curr] || [], \n\tarr = db.$.batch[curr] || [], \n\tind = arr.length;\n\tcachedB.push({ind:ind, data:data});\n}\n\nfunction checkObjAndAddToArr(arr, obj, keys){\n\tvar len = Object.keys(keys).length, res = -1, arrLen = arr.length;\n\tfor(var k=0; k<arrLen; k++){\n\t\tvar item = arr[k];\n\t\tvar i=0;\n\t\tfor(var key in keys){\n\t\t\tif(item[key] == obj[key]){\n\t\t\t\ti++;\n\t\t\t}\t\n\t\t}\n\t\tif(i == len){\n\t\t\tres = k;\n\t\t\tarr.splice(k,1,obj);\n\t\t\treturn;\n\t\t}\n\t}\n\tif(res == -1){\n\t\tarr.push(obj);\n\t}\n\treturn res;\n}\n\nfunction addToRelate(db, name, data, rel, key){\n\tvar relMod = getSchemaObj(db, rel.forward.relatedTo), \n\ttoRelMod = db.$.toRelate[relMod._name] = db.$.toRelate[relMod._name] || new Map();\n\tif(!toRelMod.has(key)){\n\t\ttoRelMod.set(key, []);\n\t}\n\tvar toRel = toRelMod.get(key), \n\tpkVal = data.$.pK, \n\tobj = {schema : name, pkVal : pkVal, key : rel.forward.relKey};\n\ttoRel.push(obj);\n\t// checkObjAndAddToArr(toRel, obj, [\"record\",\"key\"]);\n}\n\nfunction getDefaultVal(rec, defVal){\n\tif(typeof defVal != \"function\"){\n\t\treturn defVal;\n\t}\n\telse{\n\t\treturn defVal.call(rec);\n\t}\n}\n\nfunction deepValueChange(rec, attr, value, changeObj){\n\tvar toEmit = {emit : false, attr : [], oldRec : {}};\n\testAttrs(rec, attr, value, toEmit, changeObj);\n\tcheckAttrs(rec);\n\tchangeCallbck(rec, toEmit);\n}\n\nfunction updateDn(record){\n\tvar schema = record.$.schema, \n\trelations = schema.relations;\n\trelations.forEach(function(rels, key){\n\t\trels.forEach(function(itm){\n\t\t\tvar options = itm.opts, \n\t\t\tattr = itm.relKey, \n\t\t\trelType = itm.relType ;\n\t\t\tif(options && options.deepNest == true){\n\t\t\t\tdeepRelIter(\"updateDN\", schema, record);\n\t\t\t\tif(record.hasOwnProperty(attr)){\n\t\t\t\t\tvar relRec = record[attr];\n\t\t\t\t\tif(relType == \"belongsTo\" && (relRec.$.isModified || (relRec.$.dN && Object.keys(relRec.$.dN).length ))){\n\t\t\t\t\t\tsetDeepNest(record, attr, relRec.$.pK, \"updated\", undefined, relRec)\n\t\t\t\t\t}\n\t\t\t\t\telse if(relType == \"hasMany\" && Array.isArray(relRec)){\n\t\t\t\t\t\trelRec.forEach(function(rec){\n\t\t\t\t\t\t\tif(rec.$.isModified || (rec.$.dN && Object.keys(rec.$.dN).length)){\n\t\t\t\t\t\t\t\tsetDeepNest(record, attr, rec.$.pK, \"updated\", undefined, rec)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction deepRelIter(type, def, record, parentRel){\n\tvar relations = def.relations, db = def.db;\n\trelations.forEach(function(arr, key){\n\t\tarr.forEach(function(rel){\n\t\t\tvar relKey = rel.relKey, isParent;\n\t\t\tvar relType = rel.relType;\n\t\t\tvar dN = rel.opts && rel.opts[type];\n\t\t\tif(parentRel){\n\t\t\t\tvar relDef = getSchemaObj(db, rel.relatedTo);\n\t\t\t\tvar child = getBackwardRel(def,rel, relDef);\n\t\t\t\tif(parentRel == child && def != relDef){\n\t\t\t\t\tisParent = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isParent && record.hasOwnProperty(relKey) && record[relKey] && dN){\n\t\t\t\tvar relData = record[relKey];\n\t\t\t\tif(relType == \"hasMany\" && Array.isArray(relData)){\n\t\t\t\t\trelData.forEach(function(relRec){\n\t\t\t\t\t\tdeepRelOptions(db, relRec, type, rel);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if(relType == \"belongsTo\" && isEntity(relData)){\n\t\t\t\t\tdeepRelOptions(db, relData, type, rel);\n\t\t\t\t}\n\t\t\t}\n\t\t});\t\t\n\t});\n}\n\nfunction deepRelOptions(db, relRec, type, rel){\n\tswitch(type){\n\t\tcase \"rollback\":\n\t\t{\n\t\t\trelRec.$.rollBack(undefined,rel);\n\t\t\tbreak;\n\t\t}\t\n\t\tcase \"unload\":\n\t\t{\n\t\t\tdb.dropEntity(rel.relatedTo, relRec.$.pK, rel);\n\t\t}\t\t\t\t\t\t\t\t\n\t}\n}\n\nfunction handleResults(db, results, partialRef){\n\tif(Array.isArray(results)){\n\t\tresults.forEach(function(itm, idx){\n\t\t\tvar refKey = partialRef.refKey;\n\t\t\tvar refId = itm[refKey], refObj = partialRef.get(refId);\n\t\t\tif(refObj){\n\t\t\t\tmergePartialObj(db, refObj, undefined, itm, true);\n\t\t\t} \n\t\t});\n\t}\n\telse{\n\t\tDberror.warn(db.lyte, \"results expected be a flat structure of type array, instead it was \"+typeof(results));\n\t}\n}\n\nfunction handleResponse(db, data, response, schema, type, partialObj, status, partialRef){\n\tvar pK = schema._pK, \n\tpartial, \n\tobj, \n\tpkVal;\n\tif(response.results && schema._name != \"results\"){\n\t\thandleResults(db,response.results, partialRef);\n\t}\n\tresponse = response[schema._name];\n\tif(Array.isArray(data)){\n\t\tfor(var i=0; i<data.length; i++){\n\t\t\tobj = data[i], pkVal = obj.$.pK;\n\t\t\tpartial = partialObj && obj && pkVal ?  partialObj.get(pkVal) : undefined;\n\t\t\tmergeResponse(db, data[i], schema, Array.isArray(response) ? response[i] : response, pK, partial);\t\n\t\t}\n\t}\n\telse{\n\t\tpkVal = data.$.pK;\n\t\tpartial = partialObj && data && pkVal ?  partialObj.get(pkVal) : undefined;\n\t\tmergeResponse(db, data, schema, response, pK, partial);\t\n\t}\n}\n\nfunction setState(self, obj){\n\tself.dN ? self.dN = {} : undefined;\n\tsetData(self, obj, undefined, undefined, {}, true);\n\tupdateDn(self.entity);\n\tself.undoStack = obj.$.undoStack || genUnRedoStack();\n\tself.redoStack = obj.$.redoStack || genUnRedoStack();\n\tself._attributes = obj.$._attributes || {};\n\tcheckAttrs(self.entity);\n}\n\nfunction validateRelatedRecord(db, record, key, field){\n\tvar fields = getSchemaObj(db, field.relatedTo).fieldList;\n\tif(field && field.opts && record && record.hasOwnProperty(key)){\n\t\tif(field.opts && field.opts.serialize == \"record\"){\n\t\t\tif(field.relType == \"belongsTo\" && isEntity(record[key])){\n\t\t\t\treturn validateRecord(db, record[key], fields);\n\t\t\t}\n\t\t\telse if(field.relType == \"hasMany\"){\n\t\t\t\tif(Array.isArray(record[key])){\n\t\t\t\t\tvar ret = true, \n\t\t\t\t\tresult, \n\t\t\t\t\tself = this;\n\t\t\t\t\trecord[key].forEach(function(item, index){\n\t\t\t\t\t\tif(isEntity(item)){\n\t\t\t\t\t\t\tresult = validateRecord(db, item, fields);\n\t\t\t\t\t\t\tif(result === false){\n\t\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction validateRecord(db, record, fields){\n\tvar result, ret = true, returnVal;\n\tfor(var field in fields){\n\t\treturnVal = validateField(db, record, field, fields[field], result);\n\t\tif(ret === true && returnVal === false){\n\t\t\tret = false;\n\t\t}\n\t}\n\tif(ret === false || (record.$.isError === true && record.$.error && Object.keys(record.$.error).length)){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nfunction validateField(db, record, key, field, result, obj){\n\tvar val = obj && obj.old ? obj.value : record[key], \n\tret, \n\terr = record.$, \n\tclear,\n\tdb = record.$.schema.db,\n\tlyte = record.$.schema.db.lyte,\n\tvalidateOptions = true;\n\tif(field.type == \"relation\"){\n\t\tret = validateRelatedRecord(db, record, key, field);\n\t\tif(ret === false){\n\t\t\tresult = false;\n\t\t\treturn result;\n\t\t}\n\t\tvalidateOptions = false;\n\t}\n\telse if(field.mandatory && !record.$.error.hasOwnProperty(key) && (val === undefined || val === \"\" || (Array.isArray(val) && val.length === 0) )){\n\t\tValidationError.setRecErr(err, key, {code : \"ERR02\", message : Dberror.errorCodes.ERR02, value : val});\n\t}\n\tif(validateOptions){\n\t\tclear = true;\n\t\tif( obj || (record.hasOwnProperty(key) && !record.$.error.hasOwnProperty(key))){\n\t\t\tfor(var property in field){\n\t\t\t\tvar resp = checkProperty(property, val, key, field[property], record, isEntity(record) ? record.$.schema._name : undefined, db, ValidationError.errorCodes, undefined, field, true);\n\t\t\t\tif(resp !== true){\n\t\t\t\t\tif(typeof resp == \"object\"){\n\t\t\t\t\t\tresp.value = val; \n\t\t\t\t\t}\n\t\t\t\t\tValidationError.setRecErr(err,key,resp);\n\t\t\t\t\tclear = false;\n\t\t\t\t\t//err[field] = resp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Entity.strictValueSet === false && obj && clear){\n\t\t\t\tcmpSet( lyte, record, key, val, undefined, true );\n\t\t\t}\n\t\t\tif(clear){\n\t\t\t\tValidationError.clrRecErr(err, key);\n\t\t\t}\t\t\n\t\t}\n\t}\n}\n\nfunction addOnSave(db,name,record,attr,field,pK,relPk){\n\tdb.$.onSave = db.$.onSave || {};\n\tvar saveMod = db.$.onSave[name] = db.$.onSave[name] || {};\n\tvar saveQ = saveMod[record[pK]] = saveMod[record[pK]] || {} \n\tvar recs = record[attr] || [];\n\tif(field.relType == \"belongsTo\"){\n\t\trecs = !Array.isArray(record[attr]) ? [record[attr]] : record[attr]; \n\t}\n\trecs.forEach(function(item){\n\t\tvar q = saveQ[field.relKey] = saveQ[field.relKey] || [];\n\t\tcheckAndAddToArray(q, item[relPk]);\n\t});\n}\n\nfunction removeOnSave(db, name, pkVal){\n\tvar saveMod = db.$.onSave ? db.$.onSave[name] : undefined;\n\tif(saveMod && saveMod[pkVal]){\n\t\tdelete saveMod[pkVal];\n\t}\n}\n\nfunction registerField(db,def,key,field,obs){\n\tvar oldField = def.fieldList[key] ? Object.assign({},def.fieldList[key]) : undefined;\n\tif(key == \"didLoad\"){\n\t\tif(!def.didLoad){\n\t\t\tdef.didLoad = [];\n\t\t}\n\t\tdef.didLoad.push(field);\n\t}\n\telse if(typeof field.type == \"string\"){\n\t\tif(field.primaryKey){\n\t\t\tif(def.fieldList.id && def.fieldList.id.defined == false){\n\t\t\t\tdelete def.fieldList.id;\n\t\t\t}\n\t\t\tif(field.hasOwnProperty(\"default\")){\n\t\t\t\tDberror.warn(db.lyte, \"LD23\",def._name,key);\n\t\t\t\tdelete field.default;\n\t\t\t}\n\t\t\tif(def._pK != undefined){\n\t\t\t\tdef._pK = def._pK + \",\" + key;\n\t\t\t\tdef.isComposite = true; \n\t\t\t}\n\t\t\telse{\n\t\t\t\tdef._pK = key;\n\t\t\t}\n\t\t\tif(field.baseKey){\n\t\t\t\tif(def.bK){\n\t\t\t\t\tDberror.warn(db.lyte, \"LD02\",type,def._name);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdef.bK = key\n\t\t\t}\t\n\t\t}\n\t\tdef.fieldList[key] = field;\n\t\tif(oldField && def._fldGrps){\n\t\t\tif(oldField.hasOwnProperty(\"default\")){\n\t\t\t\tdelete def._fldGrps.default[key];\n\t\t\t}\n\t\t\tif(oldField.hasOwnProperty(\"watch\")){\n\t\t\t\tdelete def._fldGrps.watch[key];\n\t\t\t}\n\t\t}\n\t\tif(field.hasOwnProperty(\"default\")){\n\t\t\tdef._fldGrps.default[key] = field;\n\t\t}\n\t\tif(field.hasOwnProperty(\"watch\") && (field.watch == true || Array.isArray(field.watch)) && /^(array|object)$/.test(field.type)){\n\t\t\tdef._fldGrps.watch[key] = field;\n\t\t}\t\t\n\t}\n\telse if(field._type == \"prop\"){\n\t\tif(newGetSuperClass(field.type,  undefined, def.db.constructor.DataType)){\n\t\t\tfield.is = \"transform\";\n\t\t\tdef.fieldList[key] = field;\n\t\t}\n\t\telse{\n\t\t\tDberror.warn(db.lyte, key+\" in Schema-\"+def._name+\" is not a valid prop\");\n\t\t}\n\t}\n\tif(field.type === \"relation\"){\n\t\tfield.relKey = key;\n\t\tvar relTo;\n\t\tif(typeof field.relatedTo == \"string\"){\n\t\t\tvar fRelToName = dbModName(field.relatedTo, \"Schema\"); \n\t\t\t_relTo = db.constructor.getSchema(field.relatedTo);\n\t\t\tif(_relTo){\n\t\t\t\trelTo = _relTo;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar _id = db.constructor.Schema.schema.addEventListener(\"add\", function(name, newRelTo){\n\t\t\t\t\tif(name == fRelToName){\n\t\t\t\t\t\trelDef(def, key, newRelTo, field);\n\t\t\t\t\t\tdb.constructor.Schema.schema.removeEventListener(_id);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\trelTo = field.relatedTo;\n\t\t}\n\t\tif(relTo){\n\t\t\trelDef(def, key, relTo, field);\n\t\t}\n\t}\t\n}\n\nfunction relDef(def, key, relTo, field){\n\tif(typeof field.relatedTo == \"string\" && relTo && typeof relTo !== \"string\"){\n\t\tfield.relatedTo = relTo;\n\t}\n\tvar relObj = def.fieldList[key];\n\tif(!def.relations.get(relTo)){\n\t\tdef.relations.set(relTo, []);\n\t}\n\tvar rArr = def.relations.get(relTo);\n\tvar chkObj = {};\n\tchkObj.relKey = relObj.relKey; \n\tcheckObjAndAddToArr(rArr, relObj, chkObj);\n\tif(field.relType == \"hasMany\"){\n\t\tdef._fldGrps.hasMany[key] = field;\n\t}\n\tif(field.hasOwnProperty(\"opts\") && field.opts.hasOwnProperty(\"reverseKey\")){\n\t\tdef._fldGrps.reverseKey.set(relTo, field);\n\t}\n}\nfunction unRegCb(db,type,name){\n\tvar callback = db[type][name];\n\tif(!callback){\n\t\tDberror.error(db.lyte,\"LD02\",type,name);\n\t\treturn;\n\t}\n\tvar extendedBy = callback.__extendedBy;\n\tif(extendedBy.length)\n\t{\n\t\tdb[type].__toAddSuper = db[type].__toAddSuper || {};\n\t\tif(!db[type].__toAddSuper[name])\n\t\t{\n\t\t\tdb[type].__toAddSuper[name] = extendedBy.slice();\n\t\t}\n\t\telse\n\t\t{\n\t\t\textendedBy.forEach(function(item){\n\t\t\t\tdb[type].__toAddSuper[name].push(item);\n\t\t\t});\n\t\t}\n\t\textendedBy.forEach(function(item){\n\t\t\tdb[type][item].$super = undefined;\n\t\t});\n\t\tif(db[type].application && name != \"application\")\n\t\t{\t\n\t\t\tvar application = db[type].application;\n\t\t\textendedBy.forEach(function(item){\n\t\t\t\tdb[type][item].$super = application;\n\t\t\t\tdb[type].application.__extendedBy.push(item);\n\t\t\t});\n\t\t}\n\t\tif(!db[type].application)\n\t\t{\n\t\t\tif(!db[type].__toAddSuper.application)\n\t\t\t{\n\t\t\t\tdb[type].__toAddSuper.application = extendedBy.slice();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\textendedBy.forEach(function(item){\n\t\t\t\t\tdb[type].__toAddSuper.application.push(item);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tif(callback.$super){\n\t\tcallback.$super.__extendedBy.splice(callback.$super.__extendedBy.indexOf(name),1);\n\t}\n\tdelete db[type][name];\n}\n\nfunction extendDef(extend, mdl, db){\n\tvar scp = mdl || this,\n\t// scp = getSchemaObj(db, scp),\n\tdb = db || scp.db;\n\tif(!extend){\n\t\treturn;\n\t}\n\tvar parentFields = Object.assign({},extend.fieldList);\n\tfor(var key in parentFields){\n\t\tif(parentFields[key].type == \"relation\"){\n\t\t\tdelete parentFields[key];\n\t\t}\n\t}\n\tvar pkObj = {}, \n\textendParentPks = scp._pK == \"id\" && scp.fieldList.id.defined == false ? true : false;\n\tfor(var key in parentFields){\n\t\tvar fld = parentFields[key], \n\t\tcustPk = extendParentPks && fld.primaryKey && fld.defined != false;\n\t\tif(scp.fieldList.hasOwnProperty(key) && scp._fldGrps){\n\t\t\tvar oldField = scp.fieldList[key];\n\t\t\tif(oldField.hasOwnProperty(\"default\")){\n\t\t\t\tdelete scp._fldGrps.default[key];\n\t\t\t}\n\t\t\tif(oldField.hasOwnProperty(\"watch\")){\n\t\t\t\tdelete scp._fldGrps.watch[key];\n\t\t\t}\n\t\t}\n\t\tif(fld.hasOwnProperty(\"default\")){\n\t\t\tscp._fldGrps.default[key] = fld;\n\t\t}\n\t\tif(fld.hasOwnProperty(\"watch\") && fld.watch == true && /^(array|object)$/.test(fld.type)){\n\t\t\tscp._fldGrps.watch[key] = fld;\n\t\t}\n\t\tif(!fld.primaryKey){\n\t\t\tscp.fieldList[key] = fld;\n\t\t}\n\t\telse {\n\t\t\tpkObj[key] = fld;\n\t\t}\n\t}\n\tvar pkObjKeys = Object.keys(pkObj), pkObjLen = pkObjKeys.length;\n\tif(extendParentPks && pkObjLen){\n\t\tdelete scp.fieldList.id;\n\t\tfor(var key in pkObj){\n\t\t\tscp.fieldList[key] = pkObj[key];\n\t\t}\n\t\tif(pkObjLen == 1){\n\t\t\tscp._pK = pkObjKeys[0];\n\t\t\tscp._arrPk = Array.from(pkObjKeys);\n\t\t}\n\t\telse{\n\t\t\tscp.isComp = true;\n\t\t\tscp._arrPk = Array.from(pkObjKeys);\n\t\t\tscp._pK = scp._arrPk.toString();\n\t\t}\n\t}\n\tvar name = scp._name;\n\tdb.schema[name].extend = extend._name;\n\textend.extendedBy = extend.extendedBy || {};\n\textend.extendedBy[name] = true;\n\t// if(!db.connector[name] && db.connector[extend]){\n\t// \tdb.connector[name] = db.connector[extend];\n\t// }\n\t// if(!db.serializer[name] && db.serializer[extend]){\n\t// \tdb.serializer[name] = db.serializer[extend];\n\t// }\n\tif(extend.actions){\n\t\tvar actions = scp.actions = scp.actions || {};\n\t\tfor(var key in extend.actions){\n\t\t\tif(!actions.hasOwnProperty(key)){\n\t\t\t\tactions[key] = extend.actions[key]; \t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\t\t\t\t\t\n\t}\n}\n\nfunction demoLishObserverBindings(obj,prop,record){\n\tif(!record){\n\t\trecord = obj;\n\t}\n\tfor(var key in prop){\n\t\tif(obj[key] instanceof Object){\n\t\t\tif(record && obj[key]._setterScope){\n\t\t\t\tvar ind = obj[key]._setterScope.indexOf(record);\n\t\t\t\tind != -1 ? obj[key]._setterScope.splice(ind, 1) : undefined;\n\t\t\t}\n\t\t\tif(Object.keys(prop[key]).length){\n\t\t\t\tdemoLishObserverBindings(obj[key],prop[key],obj);\n\t\t\t}\n\t\t}\n\t\tif(obj._setterScope && obj != record){\n\t\t\tvar inx = obj._setterScope.indexOf(record);\n\t\t\tinx != -1 ? obj._setterScope.splice(inx, 1) : undefined;\n\t\t}\n\t}\n}\n\nfunction establishObsBindings(obj,prop,record){\n\tif(!record){\n\t\trecord = obj;\n\t}\n\tfor(var key in prop){\n\t\tif(obj[key] instanceof Object){\n\t\t\tif(!obj[key]._bindings){\n\t\t\t\t_defProp(obj[key], '_bindings', new Set(), false, true, true);\n\t\t\t}\n\t\t\tif(record && !obj[key]._setterScope){\n\t\t\t\t_defProp(obj[key],'_setterScope',[]);\n\t\t\t}\n\t\t\tvar ind = obj[key]._setterScope.indexOf(record);\n\t\t\tind == -1 ? obj[key]._setterScope.push(record) : undefined;\n\t\t\tobj[key]._bindings.add(prop[key]);\n\t\t\tif(Object.keys(prop[key]).length){\n\t\t\t\testablishObsBindings(obj[key],prop[key],obj);\n\t\t\t}\n\t\t}\n\t\tif(!obj._setterScope){\n\t\t\t_defProp(obj, '_setterScope', []);\n\t\t\tobj._setterScope.push(obj);\n\t\t}\n\t}\n}\n\nfunction isEmpty(val){\n\tif(val != undefined && val !== \"\" && val != null){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nfunction isEmptyObj(obj){\n\tif(obj !== null && typeof obj == \"object\" && Object.keys(obj).length == 0){\n\t\treturn true;\n\t}\n\treturn false;\n} \n\nfunction isEmptyArray(arr){\n\tif(Array.isArray(arr) && arr.length == 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction compareData(data1, data2, isQp){\n\tif(!isEmpty(data1) && !isEmpty(data2)){\n\t\tvar data1Type = typeof data1, data2Type = typeof data2;\n\t\tif(data1Type !== data2Type){\n\t\t\treturn false;\n\t\t}\n\t\tswitch(data1Type){\n\t\t\tcase \"string\":\n\t\t\tcase \"number\":\n\t\t\tcase \"boolean\":\n\t\t\tif(data1 === data2){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"object\":\n\t\t\t\treturn compareObjects(data1, data2, isQp);\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction compareObjects(obj1, obj2, qP){\n\tif(!(obj1 instanceof Object) || !(obj2 instanceof Object)){\n\t\treturn false;\n\t}\n\tif(Object.keys(obj1).length != Object.keys(obj2).length){\n\t\treturn false;\n\t}\n\tfor(var key in obj1){\n\t\tvar val1 = obj1[key], val2 = obj2[key];\n\t\tif(qP && Array.isArray(val1) && Array.isArray(val2)){\n\t\t\tif(val1.length != val2.length){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar len = val1.length;\n\t\t\tfor(var i=0; i<len; i++){\n\t\t\t\tvar ret = compareData(val1[i], val2[i], qP);\n\t\t\t\tif(!ret){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(val2 == undefined || !compareData(val1,val2,qP)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction setData(self, attr, value, opts, redoObj, ignoreChange){\n\tvar toEmit = {emit : false, attr : [], oldRec : {}}, \n\tschema = self.schema, \n\tdb = schema.db,\n\t_estObsBind = false, \n\trecord = self.entity, \n\tattrData;\n\tif(record && record.$.isStrict && record.$.isDeleted){\n\t\tDberror.warn(db.lyte, \"LD29\");\n\t\treturn;\n\t}\n\tif(attr && typeof attr === \"object\"){\n\t\tattrData = [];\n\t\topts = value;\n\t\tfor(var key in attr){\n\t\t\tattrData.push(key);\n\t\t\tsetValue(self, key, attr[key], opts, toEmit, ignoreChange);\n\t\t\tschema && schema._properties && schema._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;\n\t\t}\n\t}\n\telse{\n\t\tattrData = attr;\n\t\tsetValue(self, attr, value, opts, toEmit, ignoreChange);\n\t\tschema && schema._properties && schema._properties.hasOwnProperty(attr) ? _estObsBind = true : undefined;\n\t}\n\tself.emit(\"set\", [self.entity, attrData]);\n\tself.schema.emit(\"set\", [schema._name, self.entity, attrData]);\n\tdb.emit(\"set\", [schema._name, self.entity, attrData]);\n\tif(_estObsBind){\n\t\testablishObsBindings(record, schema._properties);\n\t}\n\tif( !ignoreChange && toEmit.emit){\n\t\tchangeCallbck(record, toEmit, redoObj)\n\t}\n\treturn record;\n} \n\nfunction changeCallbck(record, toEmit, redoObj){\n\tvar db = record.$.schema.db;\n\tvar arr = [record, toEmit.attr], \n\tself = record.$;\n\tself.emit(\"change\", arr);\n\tself.schema.emit(\"change\", arr);\n\tdb.emit(\"change\", [self.schema._name,self.entity, toEmit.attr]);\n\tif(redoObj){\n\t\tfor(var key in toEmit.oldRec){\n\t\t\tredoObj[key] = toEmit.oldRec[key];\n\t\t}\n\t}\n\telse{\n\t\tfor(var index=0;index<toEmit.attr.length;index++){\n\t\t\tvar key = toEmit.attr[index];\n\t\t\tself.undoStack[key] = self.undoStack[key] || [];\n\t\t\tself.undoStack[key].push(toEmit.oldRec[key]);\n\t\t}\n\t\t// self.undoStack._order_ = self.undoStack._order_ || _defProp(self.undoStack, \"_order_\", [], false, true);\n\t\tself.undoStack._order_.push(toEmit.attr); \n\t}\n}\n\nfunction setValue(self,attr,value,opts,toEmit,ignoreChange,deepChange){\n\tvar schema = self.schema, \n\tdb = schema.db,\n\tlyte = db.lyte,\n\tpK = schema._pK, \n\trecord = self.entity, \n\t_attrs = record.$._attributes;\n\tif(attr === \"$\"){\n\t\treturn;\n\t}\n\tif(attr != schema._pK){\n\t\tvar field = schema.fieldList[attr], watch = field && field.opts ? field.opts.watch == true : undefined;\n\t\tvar serz = field && field.opts ? field.opts.hasOwnProperty(\"serialize\") : undefined;\n\t\tif(!field){\n\t\t\tcmpSet( lyte, record, attr, value, undefined, true );\n\t\t\treturn;\n\t\t}\n\t\telse if(field.mandatory && (value == undefined || value == null || value === \"\")){\n\t\t\tValidationError.setRecErr(self, attr, {code : \"ERR02\", message : Dberror.errorCodes.ERR02, value : value});\n\t\t}\n\t\telse if(field.relType){\n\t\t\tvar relType = field.relType;\n\t\t\tvar rel ={},relRec, oldVal, relMod = getSchemaObj(db, field.relatedTo), bDef = relMod, bPk = bDef._pK, relPk = relMod._pK, isComp = relMod.isComp, bPkType = isComp ? \"object\" : relMod.fieldList[bPk].type, relRec;\n\t\t\tvar isComp = relMod.isComp, bPk = relMod._pK, bPkType = isComp ? \"object\" : relMod.fieldList[bPk].type, isPoly = field && field.opts ? field.opts.polymorphic : undefined;;\n\t\t\tgetRelations(db, schema, field.relKey, relMod, rel);\n\t\t\t// var oldRecVal = record[attr], oldRecId, newRecId;\n\t\t\t// if(oldRecVal && isEntity(oldRecVal)){\n\t\t\t// \toldRecId = oldRecVal.$.pK;\n\t\t\t// }\n\t\t\t// if(value && isEntity(value)){\n\t\t\t// \tnewRecId = value.$.id;\n\t\t\t// }\n\n\t\t\tif(record[attr] && relType == \"hasMany\"){\n\t\t\t\toldVal = [];\n\t\t\t\trecord[attr].forEach(function(item){\n\t\t\t\t\toldVal.push(item);\n\t\t\t\t});\n\t\t\t\tif(record[attr] === value){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(Array.isArray(value) && value.length === record[attr].length){\n\t\t\t\t\tvar valLen = value.length,j=0, val;\n\t\t\t\t\tfor(var i=0;i<valLen;i++){\n\t\t\t\t\t\tval = value[i];\n\t\t\t\t\t\tif(isEntity(val)){\n\t\t\t\t\t\t\trelRec = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(val && typeof val == bPkType){\n\t\t\t\t\t\t\t\trelRec = db.cache.getEntity((val._type) ? val._type : field.relatedTo, val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(isEntity(relRec) && relRec === record[attr][i]){\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j && j == valLen){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// oldVal = record[attr].slice(0);\n\t\t\t\t// oldVal1 = record[attr].mapBy(relMod._pK);\n\t\t\t\taddOnSave(db, schema._name, record, attr, field, pK, relPk);\n\t\t\t\t// toDemolishLink(schema, record, rel.forward);\n\t\t\t\tvar relData = Array.from(record[attr]);\n\t\t\t\trelData.forEach(function(rec){\n\t\t\t\t\tdemolishLink(db, rec, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);\n\t\t\t\t\tif(rel.backward !== null){\n\t\t\t\t\t\tdemolishLink(db, record, schema._pK, rec, rel.backward.relKey, rel.forward);\n\t\t\t\t\t}\n\t\t\t\t\t_attrsForRel(record, attr, \"removed\", rec);\n\t\t\t\t});\n\t\t\t\t// // record[attr].splice(0, record[attr].length);\n\t\t\t\t// if(record[attr].length){\n\t\t\t\t// \thandleArrOp(lyte, record[attr], \"removeAt\", undefined, 0, record[attr].length);\n\t\t\t\t// }\n\t\t\t\t// _attrsForRel(record, attr, \"removed\", oldVal, 0);\n\t\t\t\t// if(!_attr.size){\n\t\t\t\t// \tdelete record.$._attributes[attr];\n\t\t\t\t// }\n\t\t\t}\n\t\t\telse if(record[attr] && isEntity(record[attr]) && relType == \"belongsTo\"){\n\t\t\t\toldVal = record[attr];\n\t\t\t\tif(isEntity(value)){\n\t\t\t\t\trelRec = value;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(value && typeof value == bPkType){\n\t\t\t\t\t\trelRec = db.cache.getEntity((value._type) ? value._type : field.relatedTo, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(isEntity(relRec) && relRec === record[attr]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// oldVal = this.createCopy(record[attr]);\n\t\t\t\taddOnSave(db, schema._name, record, attr, field, pK, relPk);\n\t\t\t\t// oldVal1 = record[attr][relMod._pK];\n\t\t\t\t// toDemolishLink(schema, record, rel.forward);\n\t\t\t\tvar relRef = record[attr];\n\t\t\t\tdemolishLink(db, relRef, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);\n\t\t\t\tif(rel.backward !== null){\n\t\t\t\t\tdemolishLink(db, record, schema._pK, relRef, rel.backward.relKey, rel.forward);\n\t\t\t\t}\n\t\t\t\t_attrsForRel(record, attr, \"removed\", relRef);\n\t\t\t\t// record[attr] = undefined;\n\t\t\t\tcmpSet(lyte, record, attr, {}, opts, true);\n\t\t\t\t// _attrsForRel(record, attr, \"removed\", oldVal);\n\t\t\t}\n\t\t\tif(relType == \"hasMany\" && isEmpty(value)){\n\t\t\t\tvar partial = record[attr] && record[attr].partial ? record[attr].partial : undefined;  \n\t\t\t\tcmpSet(lyte, record, attr, [], opts, true);\n\t\t\t\tpartial ? defProp(record[attr], \"partial\", { value : partial }) : undefined;\n\t\t\t\testablishObsBindings(record, record.$.schema._properties);\n\t\t\t\tdefArrUtls(record[attr]);\n\t\t\t\tdefPolyUtls(record[attr]);\n\t\t\t\tdefUtls(record[attr], relMod, record, attr);\t\n\t\t\t}\n\n\t\t\tif(!Array.isArray(value)){\n\t\t\t\tvalue = [value];\n\t\t\t}\n\t\t\telse if(relType == \"belongsTo\"){\n\t\t\t\trevertToOldVal(record, attr, oldVal, rel);\n\t\t\t\tValidationError.setRecErr(self, attr, \"ERR21\", value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar err = [];\n\t\t\tfor(var i=0; i<value.length; i++){\n\t\t\t\tif(isEmpty(value[i]) || (relType == \"belongsTo\" && isEmptyObj(value[i])) || (relType == \"hasMany\" && isEmptyArray(value[i]))){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar relRecord = value[i], relMod1 = (value[i] && value[i]._type) ? value[i]._type : field.relatedTo;\n\t\t\t\trelMod1 = getSchemaObj(db, relMod1);\n\t\t\t\tif(!isComp && value[i] && typeof value[i] === bPkType){\n\t\t\t\t\trelRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);\n\t\t\t\t\tif(relRecord == undefined){\n\t\t\t\t\t\taddToRelate(db, schema._name, record, rel, value[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(!Entity.strictRelSet && relRecord && relRecord.$ && relRecord.$.isError){\n\t\t\t\t\t\terr.push({code : \"ERR15\", message : Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(value[i] && typeof value[i] == \"object\"){\n\t\t\t\t\tif(!Entity.strictRelSet && relRecord.$ && relRecord.$.isError){\n\t\t\t\t\t\terr.push({code : \"ERR15\", message : Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!isEntity(relRecord)){\n\t\t\t\t\t\tif(isPoly && value[i] && value[i]._type){\n\t\t\t\t\t\t\trelRecord = db.cache.getEntity(db.getSchema(value[i]._type), getpKVal(value[i], db.getSchema(value[i]._type)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(isComp){\n\t\t\t\t\t\t\trelRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);\n\t\t\t\t\t\t\tif(!relRecord){\n\t\t\t\t\t\t\t\trelRecord = newRecord(db, relMod1, value[i], opts ? opts.skipValidation : undefined);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(value[i].$ && value[i].$.isSavedState){\n\t\t\t\t\t\t\trelRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i].$.pK);\n\t\t\t\t\t\t\t// if(!relRecord){\n\t\t\t\t\t\t\t// \t//to check \t\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tsetState(relRecord.$, value[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\trelRecord = newRecord(db, relMod1, value[i],opts?opts.skipValidation:undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!Entity.strictRelSet && relRecord.$.isError){\n\t\t\t\t\t\t\terr.push({code : \"ERR15\", data : value[i], message : Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar changed = establishLink(db, rel.forward, rel.backward, record, relRecord , undefined, undefined);\n\t\t\t\tif(changed != true){\n\t\t\t\t\terr.push({code : changed, data : value[i], message : Dberror.errorCodes[changed]});\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t_attrsForRel(record, attr, \"added\", relRecord);\n\t\t\t\t\t// if(!_attr.size){\n\t\t\t\t\t// \tdelete record.$._attributes[attr];\n\t\t\t\t\t// }\n\t\t\t\t\taddOnSave(db, schema._name, record, attr, field, pK, relPk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(err.length && (err.length == value.length)){\n\t\t\t\trevertToOldVal(record, attr, oldVal, rel);\n\t\t\t\tif(field.relType == \"belongsTo\"){\n\t\t\t\t\tValidationError.setRecErr(self, attr, err[0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tValidationError.setRecErr(self, attr, err);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(err.length > 1){\n\t\t\t\t\tValidationError.setRecErr(self, attr, err);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tValidationError.clrRecErr(self, attr);\n\t\t\t\t}\n\t\t\t\tif(!ignoreChange || serz){\n\t\t\t\t\ttoEmit.emit = true;\n\t\t\t\t\ttoEmit.attr.push(attr);\n\t\t\t\t\tvar obj = {}; obj.records = oldVal; obj._type = \"update\";\n\t\t\t\t\ttoEmit.oldRec[attr] = obj;\n\t\t\t\t\tvar _attr = _attrs[attr] = _attrs[attr] || new Map();\n\t\t\t\t\tvar _changes = _attr._changes = _attr._changes || []; \n\t\t\t\t\t_changes.push({_type:\"changed\", records:oldVal});\n\t\t\t\t\tcmpRelInitVal(record, attr, bDef);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(value !== record[attr]){\n\t\t\t\t// if(field && field.type !== Lyte.getDataType(value) && (value !== undefined  || field.type === \"boolean\")) {\n\t\t\t\t// \tvalue = Lyte.typeCast(value, field.type);\n\t\t\t\t// }\n\t\t\t\tvar clear = true;\n\t\t\t\tif(!opts || (opts && opts.skipValidation !== true)){\t\t\n\t\t\t\t\tfor(var property in field){\n\t\t\t\t\t\tvar resp = checkProperty(property, value, attr, field[property], record, schema._name, db, ValidationError.errorCodes, undefined, field, true);\n\t\t\t\t\t\tif(resp != true){\n\t\t\t\t\t\t\tif(typeof resp == \"object\"){\n\t\t\t\t\t\t\t\tresp.value = value;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\tValidationError.setRecErr(self, attr, resp);\n\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\tif(Entity.strictValueSet === false){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ignoreChange){\n\t\t\t\t\testAttrs(record, attr, value, toEmit, deepChange, opts, clear);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(watch && /^(array|object)$/.test(field.type)){\n\t\t\t\t\t\testablishObjectBinding(record, attr, true, undefined, undefined,watch);\n\t\t\t\t\t}\n\t\t\t\t\tcmpSet(lyte,record,attr,value,opts,true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(value === record[attr] && record.$.isError && record.$.error[attr]){\n\t\t\t\tvar valid = true;\n\t\t\t\tfor(var property in field){\n\t\t\t\t\tvar resp = checkProperty(property, value, attr, field[property], record, schema._name, db, ValidationError.errorCodes, undefined, field, true);\n\t\t\t\t\tif(resp != true){\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(valid){\n\t\t\t\t\tValidationError.clrRecErr(self,attr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcheckAttrs(record);\n\t}\n\telse{\n\t\tif(record[attr] !== value){\n\t\t\tValidationError.setRecErr(self, attr, \"ERR01\", value);\n\t\t}\n\t}\n}\n\nfunction estAttrs(record, attr, value, toEmit, deepChange, opts, clear){\n\tvar _attrs = record.$._attributes, \n\tschema = record.$.schema, \n\tattribute = _attrs[attr], \n\tisAttrPres = _attrs.hasOwnProperty(attr);\n\tif( !isAttrPres){\n\t\t_attrs[attr] = deepChange ? deepChange.data : createCopy(record[attr]);\n\t}\n\telse if((( deepChange && cmpData(isAttrPres ? attribute : deepChange.data, record[attr])) || (value && typeof value == \"object\" && ( !deepChange && compareObjects(attribute, value))) || (attribute == value))){\n\t\tdelete _attrs[attr];\n\t}\n\tvar hasAttr = record.hasOwnProperty(attr), \n\toldAttrVal = deepChange ? deepChange.data : record[attr];\n\tif(!deepChange){\n\t\tvar isPropPresent = schema._properties && schema._properties.hasOwnProperty(attr), propObj = {};\n\t\tif(isPropPresent){\n\t\t\tpropObj[attr] = schema._properties[attr];\n\t\t\tdemoLishObserverBindings(record, propObj);\n\t\t}\n\t\tcmpSet(schema.db.lyte,record,attr,value,opts,true);\n\t}\n\tif(clear){\n\t\tValidationError.clrRecErr(record.$, attr);\n\t}\n\tvar obj = {};\n\tobj._type = \"update\";\n\tobj.val = oldAttrVal;\n\tif(!hasAttr){\n\t\tobj._type = \"propAdd\";\n\t}\n\ttoEmit.emit = true;\n\ttoEmit.attr.push(attr);\n\ttoEmit.oldRec[attr] = obj;\n}\n\nfunction checkAttrs(record){\n\tvar schema = record.$.schema;\n\tif( Object.keys(record.$._attributes).length ){\n\t\t// changeModified(schema.db.lyte, record, true, record.$.pK, true);\n\t\tif(!record.$.isNew){\n\t\t\tcmpSet(schema.db.lyte, record.$, \"isModified\", true);\n\t\t\tchangePersist(record, false);\n\t\t}\n\t\taddDeepNest(record);\n\t\tcheckAndAddToArray(schema.dirty, record[schema._pK]);\n\t}\n\telse{\n\t\t// changeModified(schema.db.lyte, record, false);\n\t\tcmpSet(schema.db.lyte, record.$, \"isModified\", false);\n\t\tchangePersist(record, true);\n\t\tif(!record.$.isNew && (!record.$.hasOwnProperty(\"dN\") || (record.$.dN && !Object.keys(record.$.dN).length))){\n\t\t\tvar ignorePartial = record.$.isNew ? true : false;\n\t\t\tremoveParentNesting(record, ignorePartial);                  \n\t\t}\n\t\tif(!record.$.isNew){\n\t\t\tdeleteFromArray(schema.dirty, record.$.pK);\n\t\t}\n\t}\n}\n\nfunction checkForCorrectRelation(db,rel,record){\n\tvar relatedTo = rel.relatedTo;\n\tif(!isEntity(record)){\n\t\treturn false;\n\t}\n\tif(rel.opts && rel.opts.polymorphic){\n\t\treturn (record.$.schema.extend ? rel.relatedTo === db.getSchema(record.$.schema.extend) : false);\n\t}\n\treturn (rel && record ? relatedTo === record.$.schema.def : false);\n}\n\nfunction partialData(rec, prop, relRec, type, polymorphicType,partRemoveOnly){\n\tvar arr = rec[prop];\n\tif(!arr || !Array.isArray(arr)){\n\t\treturn true;\n\t}\n\tif(!arr.partial){\n\t\tdefPar(arr);\n\t}\n\tvar partial = arr.partial; \n\t// = arr.partial || new Map();\n\tif(!partial.get(relRec)){\n\t\tpartial.set(relRec, {});\n\t}\n\tvar revert = false, \n\tobj = partial.get(relRec), \n\tobjType = obj.type;\n\tif(type == \"delete\"){\n\t\tpartial.delete(relRec);\n\t\trevert = true;\n\t}\n\telse{\n\t\tswitch(objType){\n\t\t\tcase \"added\":{\n\t\t\t\tif(type == \"removed\"){\n\t\t\t\t\tpartial.delete(relRec);\n\t\t\t\t\trevert = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"removed\":{\n\t\t\t\tif(type == \"added\"){\n\t\t\t\t\tif(rec[prop]._recMap){\n\t\t\t\t\t\tvar relRec = rec[prop]._recMap.get(relRec.$.pK);\n\t\t\t\t\t} \n\t\t\t\t\tif(!relRec || (isEntity(relRec) && !relRec.$.isDirty())){\n\t\t\t\t\t\tpartial.delete(relRec);\n\t\t\t\t\t\trevert = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvar obj = partial.get(relRec);\n\t\t\t\t\t\tobj.type = \"modified\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"modified\":\n\t\t\tcase \"updated\":{\n\t\t\t\tif(type == \"added\"){\n\t\t\t\t\t//this case mostly won't come. if at all it comes, break\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:{\n\t\t\t\tif(!partRemoveOnly){\n\t\t\t\t\tvar pObj = { type : type };\n\t\t\t\t\tpolymorphicType ? pObj.polymorphicType = polymorphicType : undefined;\n\t\t\t\t\tpartial.set(relRec, pObj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(revert && !partial.size){\n\t\tdeleteDeepNest(rec, prop, relRec);\n\t\treturn true;\n\t}\n}\n\nfunction removeDeepNest(record){\n\tif(!isEntity(record)){\n\t\treturn;\n\t}\n\tvar bool1 = record.$.dN && Object.keys(record.$.dN).length;\n\tif(bool1){\n\t\trecord.$.dN = {};\n\t\tvar schema = record.$.schema, \n\t\trelations = schema.relations;\n\t\trelations.forEach(function(rels, key){\n\t\t\trels.forEach(function(item){\n\t\t\t\tvar opts = item.opts;\n\t\t\t\tif(opts && (opts.deepNest == true || opts.serialize == \"partial\")){\n\t\t\t\t\tvar data = record[item.relKey];\n\t\t\t\t\tif(Array.isArray(data)){\n\t\t\t\t\t\tdata.forEach(function(itm){\n\t\t\t\t\t\t\tif(isEntity(itm)){\n\t\t\t\t\t\t\t\tremoveDeepNest(itm);\n\t\t\t\t\t\t\t\tif(!itm.$.isNew && !itm.$.isModified && (!itm.$.dN || ( itm.$.dN && Object.keys(itm.$.dN).length == 0 ))){\n\t\t\t\t\t\t\t\t\tremoveParentNesting(itm);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if(isEntity(data)){\t\n\t\t\t\t\t\tremoveDeepNest(data);\n\t\t\t\t\t\tif(!data.$.isNew && !data.$.isModified && (!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0))){\n\t\t\t\t\t\t\tremoveParentNesting(data);\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\t\t\t\t\t\n\t\t});\n\t}\n}\n\nfunction addDeepNest(record, extended,type,parentRel,ignoreRel, mp , processOnlySrzPart){\n\tvar relatedRecord, \n\tmp = mp || new Map(),\n\tdb = record.$.schema.db,\n\tschema = extended ? db.schema[record.$.schema.extend] : record.$.schema, \n\tpK = record.$.pK,\n\ttype = type || \"updated\",\n\trelations = schema.relations;\n\trelations.forEach(function(rels, key){\n\t\trels.forEach(function(item){\n\t\t\tvar inv , deep, part, serz, bMod = getSchemaObj(db , item.relatedTo);\n\t\t\tinv = getBackwardRel(schema,item,bMod);\n\t\t\tif(bMod){\n\t\t\t\tif(!item.relKey || (inv === item)){\n\t\t\t\t\trelatedRecord = getRelatedRecord(record,getSchemaObj(db, item.relatedTo),item.dummy ? item.dummy: item.relKey);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trelatedRecord = record[item.relKey];\n\t\t\t\t}\n\t\t\t\tif(relatedRecord){\n\t\t\t\t\tvar mppass = false, nmp , ignoreDn;\n\t\t\t\t\tif(inv !== parentRel){\t\t\n\t\t\t\t\t\tif(!mp.get(inv)){\n\t\t\t\t\t\t\tnmp = mp.set(inv, new Map());\n\t\t\t\t\t\t\tmppass = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnmp = mp.get(inv);\t\t\t\n\t\t\t\t\t\tif(mppass || !nmp.get(relatedRecord)){\n\t\t\t\t\t\t\tnmp.set(relatedRecord, true);\n\t\t\t\t\t\t\tif(inv && inv.opts){\n\t\t\t\t\t\t\t\tdeep = inv.opts.deepNest;\n\t\t\t\t\t\t\t\tpart = inv.opts.serialize == \"partial\" ? true : false; \n\t\t\t\t\t\t\t\tserz = inv.opts.serialize ? true : false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((type == \"updated\" && serz == \"id\")){\n\t\t\t\t\t\t\t\tignoreDn = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((!processOnlySrzPart || ( processOnlySrzPart && part)) && !ignoreDn){\n\t\t\t\t\t\t\t\tif(deep == true){\n\t\t\t\t//\t\t\t\t\tif(deep || part){\n\t\t\t\t\t\t\t\t\tmakeDirty(relatedRecord, type, inv, pK, item, record, mp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(serz && record && relatedRecord && (!ignoreRel || !(ignoreRel && ignoreRel.schema === item.relatedTo && inv.relKey === ignoreRel.relKey))){\n\t\t\t\t\t\t\t\t\tvar data = relatedRecord;\n\t\t\t\t\t\t\t\t\tif(inv.relType == \"hasMany\"){\n\t\t\t\t\t\t\t\t\t\tif(Array.isArray(data)){\n\t\t\t\t\t\t\t\t\t\t\tdata.forEach(function(item){\n\t\t\t\t\t\t\t\t\t\t\t\tpartialData(item, inv.relKey, record , /^(added|removed)$/.test(type) ? type : \"modified\");\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(isEntity(data)){\n\t\t\t\t\t\t\t\t\t\t\tpartialData(data, inv.relKey, record, /^(added|removed)$/.test(type) ? type : \"modified\");\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tif(Array.isArray(data)){\n\t\t\t\t\t\t\t\t\t\t\tdata.forEach(function(item){\n\t\t\t\t\t\t\t\t\t\t\t\tif(type == \"added\" && item && item.$ && item.$.partial && item.$.partial[inv.relKey] && item.$.partial[inv.relKey].has(pK)){\n\t\t\t\t\t\t\t\t\t\t\t\t\tdelete item.$.partial;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(isEntity(data)){\n\t\t\t\t\t\t\t\t\t\t\tif(type == \"added\" && data && data.$ && data.$.partial && data.$.partial[inv.relKey] && data.$.partial[inv.relKey].has(pK)){\n\t\t\t\t\t\t\t\t\t\t\t\tdelete data.$.partial;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//partialData(record[item.relKey], inv.relKey, pK , \"modified\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\t\t\n\t});\n\tif(schema.extend){\n\t\taddDeepNest(record, true);\n\t}\n}\n\nfunction makeDirty(records, type, rel, pK, parentRel, relRec, mp){\n\tif(!(rel.opts.serialize =='id' && type ==\"updated\")){\n\t\tvar relKey = rel.relKey;\n\t\tif(Array.isArray(records)){\n\t\t\trecords.forEach(function(item){\n\t\t\t\tsetDeepNest(item, relKey, pK, type, parentRel, relRec, mp);\n\t\t\t});\n\t\t}\n\t\telse if(isEntity(records)){\n\t\t\tsetDeepNest(records, relKey, pK, type, parentRel, relRec, mp);\n\t\t}\n\t}\n}\n\nfunction setDeepNest(item, relKey, pK, type, parentRel, relRec, mp){\n\tvar deepN = item.$.dN = item.$.dN || {}, \n\tdeepRel = deepN[relKey] = deepN[relKey] || new Map();\n\tif(!deepRel.has(relRec)){\n\t\tdeepRel.set(relRec, {});\n\t}\n\tvar obj = deepRel.get(relRec);\n\tswitch(obj.type){\n\t\tcase \"added\": {\n\t\t\tif(type == \"removed\"){\n\t\t\t\tdeleteDeepNest(item, relKey, relRec);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"removed\": {\n\t\t\tif(type == \"added\"){\n\t\t\t\tdeleteDeepNest(item, relKey, relRec);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault : {\n\t\t\tobj.type = type;\n\t\t\tchangePersist(item, false);\n\t\t\taddDeepNest(item, undefined, undefined, parentRel, undefined, mp);\t\t\n\t\t}\n\t}\n}\n\nfunction deleteDeepNest(rec, key, relRec){\n\tvar deepNest = rec.$.dN;\n\tif(deepNest){\n\t\tif(deepNest[key] && relRec === undefined){\n\t\t\tdelete deepNest[key];\n\t\t}\n\t\telse if(deepNest[key] && deepNest[key].get(relRec)){\n\t\t\tdeepNest[key].delete(relRec);\n\t\t\tif(!deepNest[key].size){\n\t\t\t\tdelete deepNest[key];\n\t\t\t}\n\t\t}\n\t\tif(!Object.keys(deepNest).length){\n\t\t\tdelete rec.$.dN;\n\t\t\tif(!rec.$.isModified && !rec.$.isNew){\n\t\t\t\tremoveParentNesting(rec);\n\t\t\t}\n\t\t\tchangePersist(rec, true);\n\t\t}\n\t}\n}\n\nfunction getRelatedRecord(ins,def,key){\n\tif(ins){\n\t\tvar relationship = ins.$._relationships;\n\t\tif(relationship[def._name] && relationship[def._name][key]){\n\t\t\treturn relationship[def._name][key];\n\t\t}\n\t}\n}\n\nfunction removeParentNesting(rec, ignorePartial, type){\n\tvar schema = rec.$.schema, \n\tdb = schema.db,\n\tpkVal = rec.$.pK, \n\trels = schema.relations;\n\trels.forEach(function(relations, key){\n\t\trelations.forEach(function(item){\n\t\t\tvar inv, deep, part, invRecs;\n\t\t\t//getRelations(schema, item.relKey, db.schema[item.relatedTo], rel);\n\t\t\tvar bMod = item.relatedTo, _bDef = getSchemaObj(db, bMod);\n\t\t\tif(bMod){\n\t\t\t\tinv = getBackwardRel(schema, item, _bDef);\n\t\t\t\t//inv = rel.backward;\n\t\t\t\tif(inv && inv.opts){\n\t\t\t\t\tdeep = inv.opts.deepNest;\n\t\t\t\t\tpart = inv.opts.hasOwnProperty(\"serialize\");\n\t\t\t\t\tif(!item.relKey || (item == inv)){\n\t\t\t\t\t\tinvRecs = getRelatedRecord(rec,_bDef,item.dummy?item.dummy:item.relKey);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tinvRecs = rec[item.relKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if(deep == true){\n\t\t\t\t// \tif(Array.isArray(invRecs)){\n\t\t\t\t// \t\tinvRecs.forEach(function(item){\n\t\t\t\t// \t\t\tif(isEntity(item)){\n\t\t\t\t// \t\t\t\tdeleteDeepNest(item, inv.relKey, rec);\n\t\t\t\t// \t\t\t}\n\t\t\t\t// \t\t});\n\t\t\t\t// \t}\n\t\t\t\t// \telse if(isEntity(invRecs)){\n\t\t\t\t// \t\tdeleteDeepNest(invRecs, inv.relKey, rec);\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t\tif(part && !ignorePartial){\n\t\t\t\t\tif(invRecs && !Array.isArray(invRecs)){\n\t\t\t\t\t\tinvRecs=[invRecs];\n\t\t\t\t\t}\n\t\t\t\t\tif(Array.isArray(invRecs)){\n\t\t\t\t\t\tinvRecs.forEach(function(invItm){\n\t\t\t\t\t\t\tif(invItm instanceof bMod){\n\t\t\t\t\t\t\t\tif(inv.relKey){\t\n\t\t\t\t\t\t\t\t\tif(inv.relType == \"belongsTo\" && invItm && invItm.$){\n\t\t\t\t\t\t\t\t\t\tif(invItm.$.partial && invItm.$.partial[inv.relKey] && invItm.$.partial[inv.relKey].has(rec)){\n\t\t\t\t\t\t\t\t\t\t\tinvItm.$.partial[inv.relKey].delete(rec);\n\t\t\t\t\t\t\t\t\t\t\tif(!invItm.$.partial[inv.relKey].size){\n\t\t\t\t\t\t\t\t\t\t\t\tdelete invItm.$.partial[inv.relKey]; \n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdeep ? deleteDeepNest(invItm, inv.relKey, rec ) : undefined;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if(inv.relType == \"hasMany\"){\n\t\t\t\t\t\t\t\t\t\tvar invArr = invItm[inv.relKey];\n\t\t\t\t\t\t\t\t\t\tif(Array.isArray(invArr)){\n\t\t\t\t\t\t\t\t\t\t\tif(invArr.partial && invArr.partial.has(rec)){\n\t\t\t\t\t\t\t\t\t\t\t\tvar _ptype = invArr.partial.get(rec).type;\n\t\t\t\t\t\t\t\t\t\t\t\tif(type == \"modified\"){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(/^(modified|updated)$/.test(_ptype)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinvArr.partial.delete(rec);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}   \n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\tinvArr.partial.delete(rec);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tdeep ? deleteDeepNest(invItm, inv.relKey, rec) : undefined;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\t\t\n\t});\n}\n\nfunction cmpRelInitVal(record, attr, bDef ){\n\tvar arr = record.$.getInitialValues(attr), \n\tchanged = true, \n\t_attrs = record.$._attributes, \n\tbPk = bDef._pK, \n\tfield = record.$.schema.fieldList[attr], \n\tsrz = field && field.opts ? field.opts.serialize : undefined, \n\tcmpInd = (srz == \"id\" || srz == \"record\"); \n\tif(arr && Array.isArray(record[attr]) && arr.length == record[attr].length && cmpInd){\n\t\tchanged = false;\n\t\tfor(var i=0; i<arr.length; i++){\n\t\t\tif(!comparePk(record[attr][i], arr[i])){\n\t\t\t\tchanged = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar size = _attrs[attr].size;\n\tif((!changed && size == 0 && cmpInd) || (srz == \"partial\" && size == 0)){\n\t\tdelete _attrs[attr];\n\t}\n}\n\nfunction _attrsForRel(record, attr, type, arr, index){\n\tvar _attrs = record.$._attributes, \n\t_attr,\n\tdb = record.$.schema.db; \n\t_attr = _attrs[attr] = _attrs[attr] || new Map();\n\tif(arr && !Array.isArray(arr)){\n\t\tarr = [arr];\n\t}\n\tarr.forEach(function(itm){\n\t\tvar _attrObj = _attr.get(itm), currType = _attrObj ? _attrObj._type : undefined;\n\t\tswitch(currType){\n\t\t\tcase \"added\": {\n\t\t\t\tif(type == \"removed\"){\n\t\t\t\t\t_attr.delete(itm);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase \"removed\":{\n\t\t\t\tif(type == \"added\"){\n\t\t\t\t\t_attr.delete(itm);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tvar obj = { _type : type };\n\t\t\t\tif(index){\n\t\t\t\t\tobj.index = index;\n\t\t\t\t}\n\t\t\t\t_attr.set(itm, obj);\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction establishToRelated(record, relArr){\n\tvar bSchema = record.$.schema, \n\trel = {},\n\tdb = bSchema.db;\n\trelArr.forEach(function(item){\n\t\tvar rec = db.cache.getEntity(db.getSchemaObj(item.schema).def, item.pkVal);\n\t\tif(rec){\n\t\t\tvar fSchema = rec.$.schema;\n\t\t\tgetRelations(db, fSchema, item.key, bSchema, rel);\n\t\t\testablishLink(db, rel.forward, rel.backward, rec, record, undefined, true);\n\t\t}\n\t});\n}\n\nfunction add(value,type,opts,redoObj){\n\tvar record = this.entity, \n\tschema = record.$.schema,\n\tdb = schema.db,\n\tattr = this.key, \n\tfield = schema.fieldList[attr], \n\trel = {}, \n\toldArr, \n\tserz = field.opts ? field.opts.hasOwnProperty(\"serialize\") : undefined;\n\tgetRelations(db, schema, field.relKey, getSchemaObj(db, field.relatedTo), rel);\n\tif(!Array.isArray(value)){\n\t\tvalue = [value];\n\t}\n\tvar relMod = getSchemaObj(db, rel.forward.relatedTo);\n\tvar pK = relMod._pK, err = [], arr = [], isComp = relMod.isComp;\n\tif(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){\n\t\toldArr = record.$.getInitialValues(attr);\n\t}\n\tfor(var i=0; i<value.length; i++){\n\t\tvar rec = value[i];\n\t\tif(isComp){\n\t\t\tif(typeof rec == \"object\" && Object.keys(rec).length === relMod._arrPk.length){\n\t\t\t\tif(this.polymorphic && !type){\n\t\t\t\t\terr.push({code : \"ERR22\", data : value[i], message : Dberror.errorCodes.ERR22});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trec = db.cache.getEntity(this.polymorphic && type ? (typeof type == \"string\" ? db.getSchema(type) : type) : rel.forward.relatedTo, rec);\t\n\t\t\t}\n\t\t}\n\t\tif((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof rec) || (isComp && typeof rec == \"object\" && Object.keys(rec).length === relMod._arrPk.length) ){\n\t\t\tif(this.polymorphic && !type){\n\t\t\t\terr.push({code : \"ERR22\", data : value[i], message : Dberror.errorCodes.ERR22});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trec = db.cache.getEntity(this.polymorphic && type ? (typeof type == \"string\" ? db.getSchema(type) : type) : rel.forward.relatedTo, rec);\n\t\t}\n\t\telse if(typeof rec == \"object\" && !isEntity(rec)){\n\t\t\tif(this.polymorphic){\n\t\t\t\tvar pType;\n\t\t\t\tif(rec._type){\n\t\t\t\t\tpType = typeof rec._type == \"string\" ?  db.getSchemaObj(rec._type) : rec._type\n\t\t\t\t}\n\t\t\t\telse if(type){\n\t\t\t\t\tpType = typeof type == \"string\" ?  db.getSchemaObj(type) : type\n\t\t\t\t}\n\t\t\t\tif(!pType){\n\t\t\t\t\terr.push({code : \"ERR22\", data : value[i], message : Dberror.errorCodes.ERR22});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trec = newRecord(db, pType, rec, opts?opts.skipValidation:undefined);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trec = newRecord(db,getSchemaObj(db,field.relatedTo), rec, opts?opts.skipValidation:undefined);\n\t\t\t}\n\t\t}\n\t\tvar polyType = this.polymorphic && type ? type : ((rec && rec._type) ?rec._type: undefined);\n\t\tif(rec == undefined){\n\t\t\terr.push({code : \"ERR13\", data : value[i], message : Dberror.errorCodes.ERR13});\n\t\t}\n\t\telse if(!Entity.strictRelSet && rec.$ && rec.$.isError){\n\t\t\terr.push({code : \"ERR15\", data : value[i], message : Dberror.errorCodes.ERR15, error : rec});\n\t\t}\n\t\telse if(isEntity(rec) && !hasDuplicateRelation(rec, record[attr], pK, polyType, relMod)){\n\t\t\tvar resp = establishLink(db, rel.forward, rel.backward, record, rec);\n\t\t\tif(resp != true){\n\t\t\t\terr.push({code : resp, data : value[i], message : Dberror.errorCodes[resp]});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr.push(rec);\n\t\t\t}\n\t\t}\n\t}\n\tif(arr.length){\n\t\tif(serz){\n\t\t\tvar obj = {_type:\"added\", records: arr};\n\t\t\t_attrsForRel(record, attr, \"added\", arr);\n\t\t\tif(redoObj){\n\t\t\t\tredoObj[attr] = obj; \n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar stackObj = {};\n\t\t\t\tstackObj[attr] = obj;\n\t\t\t\trecord.$.undoStack[attr] = record.$.undoStack[attr] || [];\n\t\t\t\trecord.$.undoStack[attr].push(obj);\n\t\t\t\t// record.$.undoStack._order_ = record.$.undoStack._order_ || [];\n\t\t\t\trecord.$.undoStack._order_.push([attr]);\n\t\t\t}\n\t\t\tvar _attrs = record.$._attributes, _attr = _attrs[attr];\n\t\t\tif(_attr){\n\t\t\t\tvar _changes = _attr._changes = _attr._changes || [];\n\t\t\t\t_changes.push(obj);\n\t\t\t}\n\t\t\tcmpRelInitVal(record, attr, relMod);\n\t\t\tif(Object.keys(_attrs).length > 0){\n\t\t\t\t// changeModified(db.lyte, record, true)\n\t\t\t\tif(!record.$.isNew){\n\t\t\t\t\tcmpSet(db.lyte, record.$, \"isModified\", true);\n\t\t\t\t\tchangePersist(record, false);\n\t\t\t\t}\n\t\t\t\tcheckAndAddToArray(schema.dirty, record[schema._pK]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdelete record.$._attributes[attr];\n\t\t\t\tif(!Object.keys(record.$._attributes).length){\n\t\t\t\t\t// changeModified(db.lyte, record, false, record.$.pK)\n\t\t\t\t\tcmpSet(db.lyte, record.$, \"isModified\", false);\n\t\t\t\t\tchangePersist(record, true);\n\t\t\t\t\t// record.$.isModified = false;\n\t\t\t\t\t// delete _attrs[attr];\n\t\t\t\t\tif(!record.$.isNew){\n\t\t\t\t\t\tdeleteFromArray(schema.dirty, record.$.pK);\n\t\t\t\t\t\tif(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){\n\t\t\t\t\t\t\tremoveParentNesting(record);\n\t\t\t\t\t\t}\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\temit(db, \"change\", record, [attr]);\n\t\t}\n\t}\n\tif(err.length > 0){\n\t\tValidationError.setRecErr(record.$, attr, err);\n\t}\n\telse{\n\t\tValidationError.clrRecErr(record.$, attr);\n\t}\n\treturn record;\n}\n\nfunction remove(key,type,redoObj){\n\tvar record = this.entity, \n\tschema = record.$.schema, \n\tdb = schema.db,\n\tlyte = db.lyte,\n\tattr =  this.key, \n\tfield = schema.fieldList[attr], \n\trel = {},\n\toldArr, \n\tserz = field.opts ? field.opts.hasOwnProperty(\"serialize\") : undefined;\n\tgetRelations(db, schema, field.relKey, getSchemaObj(db, field.relatedTo), rel);\n\tif(!Array.isArray(key)){\n\t\tkey = [key];\n\t}\n\tvar relMod = getSchemaObj(db, rel.forward.relatedTo), \n\tpK = relMod._pK, \n\tisComp = relMod.isComp, \n\terr = [], \n\trelatedRecord, \n\tarr = [], \n\tindices = [];\n\tif(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){\n\t\toldArr = record.$.getInitialValues(attr);\n\t}\n\tfor(var i=0; i<key.length; i++){\n\t\tvar rec = key[i], polyType;\n\t\tif((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof key[i]) || (isComp && typeof rec == \"object\" && Object.keys(rec).length === relMod._arrPk.length)){\n\t\t\tif(this.polymorphic == true && !type){\n\t\t\t\terr.push({code : \"ERR22\", data : key[i], message : Dberror.errorCodes.ERR22});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trelatedRecord = db.cache.getEntity((type)?(typeof type == \"string\" ? db.getSchema(type) : type):rel.forward.relatedTo,key[i]);\n\t\t\tpolyType = type;\n\t\t}\n\t\telse if(isEntity(key[i])){\n\t\t\trelatedRecord = key[i];\n\t\t\tpolyType = type ? type : ((relatedRecord && relatedRecord._type) ? relatedRecord._type : undefined);\n\t\t}\n\t\tif(relatedRecord){\n\t\t\tvar index = getIndex(record[attr], pK, relatedRecord.$.get(pK),polyType);\n\t\t\tdemolishLink(db, relatedRecord, pK, db.cache.getEntity(schema.def, record.$.pK), rel.forward.relKey, undefined, undefined, undefined, true);\n\t\t\tif(rel.backward != null){\n\t\t\t\tdemolishLink(db, record, schema._pK, db.cache.getEntity((polyType)?(typeof polyType == \"string\" ? db.getSchema(polyType) : polyType):rel.forward.relatedTo, relatedRecord.$.pK), rel.backward.relKey, rel.forward);\n\t\t\t}\n\t\t\tarr.push(relatedRecord);\n\t\t\tindices.push(index);\n\t\t}\n\t}\n\tif(arr.length){\n\t\tif(serz){\n\t\t\tvar obj = {_type:\"removed\", records: arr, _indices : indices};\n\t\t\t_attrsForRel(record, attr, \"added\", arr);\n\t\t\tif(redoObj){\n\t\t\t\tredoObj[attr] = obj; \n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar stackObj = {};\n\t\t\t\tstackObj[attr] = obj;\n\t\t\t\t// record.$.undoStack.push(stackObj);\n\t\t\t\trecord.$.undoStack[attr] = record.$.undoStack[attr] || [];\n\t\t\t\trecord.$.undoStack[attr].push(obj);\n\t\t\t\t// record.$.undoStack._order_ = record.$.undoStack._order_ || [];\n\t\t\t\trecord.$.undoStack._order_.push([attr]); \n\t\t\t}\n\t\t\tvar _attrs = record.$._attributes, _attr = _attrs[attr];\n\t\t\tif(_attr){\n\t\t\t\tvar _changes = _attr._changes = _attr._changes || [];\n\t\t\t\t_changes.push(obj);\n\t\t\t}\n\t\t\t// if(!_attr.size){\n\t\t\t// \tdelete record.$._attributes[attr];\n\t\t\t// }\n\t\t\tcmpRelInitVal(record, attr, relMod);\n\t\t\tif(Object.keys(_attrs).length > 0){\n\t\t\t\t// changeModified(lyte, record, true);\n\t\t\t\tif(!record.$.isNew){\n\t\t\t\t\tcmpSet(lyte, record.$, \"isModified\", true);\n\t\t\t\t\tchangePersist(record, false);\n\t\t\t\t}\n\t\t\t\tcheckAndAddToArray(schema.dirty, record[schema._pK]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdelete record.$._attributes[attr];\n\t\t\t\tif(!Object.keys(record.$._attributes).length){\n\t\t\t\t\t// changeModified(lyte, record, false, record.$.pK)\n\t\t\t\t\tcmpSet(lyte, record.$, \"isModified\", false);\n\t\t\t\t\tchangePersist(record, true);\n\t\t\t\t\t// record.$.isModified = false;\n\t\t\t\t\t// delete _attrs[attr];\n\t\t\t\t\tif(!record.$.isNew){\n\t\t\t\t\t\tdeleteFromArray(schema.dirty, record.$.pK);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){\n\t\t\t\t\t\t\tremoveParentNesting(record);\n\t\t\t\t\t\t}\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\temit(db, \"change\", record, [attr]);\n\t}\n\tif(err.length > 0){\n\t\tValidationError.setRecErr(record.$, attr, err);\n\t}\n\telse{\n\t\tValidationError.clrRecErr(record.$, attr);\n\t}\n}\n\nfunction filter(record,filObj,len){\n\tvar j=0;\n\tfor(var key in filObj){\n\t\tif(record[key] === filObj[key]){\n\t\t\tj++;\n\t\t}\n\t}\n\tif(j === len){\n\t\treturn true;\n\t}\n}\n\nfunction filterBy(obj){\n\tvar len = Object.keys(obj).length, j = 0, arr = [];\n\tfor(var i=0; i<this.length; i++){\n\t\tif(filter(this[i],obj,len)){\n\t\t\tarr.push(this[i]);\n\t\t}\n\t}\n\tif(!arr.filterBy){\n\t\tdefArrUtls(arr);\n\t\tdefUtls(arr,this.schema);\n\t}\n\treturn arr;\n}\n\nfunction checkAndAddToArray(arr,value){\n\tif(!checkPresenceInArray(arr,value)){\n\t\tarr.push(value);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nfunction deleteFromArray(arr,value){\n\tvar ind = arr.indexOf(value);\n\tif(ind != -1){\n\t\tarr.splice(ind,1);\n\t}\n}\n\nfunction genPk(pK, opts, fields){\n\tvar pkType;\n\tpK.forEach(function(item){\n\t\tpkType = fields[item].type;\n\t\tvar random = opts[item] = Math.floor(Math.random()*100000 + 1);\n\t\tif(pkType == \"string\"){\n\t\t\topts[item] = random.toString();                    \n\t\t}\n\t});\n}\n\nfunction generateRandomPk(def, opts, pK, fields){\n\tgenPk(pK, opts, fields);\n\twhile(isDuplicateRecord(def, opts, pK.toString())){\n\t\tgenPk(pK, opts, fields);\n\t}            \n}\n\nfunction isDuplicateRecord(def,obj){\n\tvar data = def.data, pK = def._pK, isComp = def.isComposite;\n\tif(data.length){\n\t\tif(!isComp && def.data._recMap){\n\t\t\tvar pkVal = obj[pK];\n\t\t\tif(pkVal!=undefined){\n\t\t\t\treturn def.data._recMap.get(pkVal ? pkVal.toString() : pkVal) !== undefined;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn data.some(function(record){\n\t\t\t\tif(compareObjects( getpKVal(obj, def), getpKVal(record) )){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction pkPresence(opts, pK){\n\tvar result = true;\n\tpK.forEach(function(item){\n\t\tif(!opts.hasOwnProperty(item) || !opts[item] ){\n\t\t\tresult = false;\n\t\t\treturn;\n\t\t}\n\t});\n\treturn result;\n}\n\nfunction updateJSON(db, record, def, dirty){\n\tvar data = {},\n\tarrPk = def._arrPk,\n\tdirtyAttr = record.$._attributes;\n\tfor(var field in dirtyAttr){\n\t\tdata[field] = record[field];\n\t}\n\tvar attrs = dirty;\n\tif(dirty == true){\n\t\tattrs = isDirty(db, record, def.relations) || [];\n\t}\n\tfor(var i=0;i<attrs.length;i++){\n\t\tdata[attrs[i]] = record[attrs[i]];\n\t}\n\tarrPk.forEach(function(item){\n\t\tdata[item] = record[item];\n\t});\n\treturn data;\n}\n\nfunction isDirty(db, record, relations, parent, fMod){\n\tvar result = [];\n\trelations.forEach(function(red_def, rel){\n\t\tfor(var j=0;j<red_def.length;j++){\n\t\t\tvar rel = red_def[j];\n\t\t\tif(rel.opts && rel.opts.serialize){\n\t\t\t\tvar key = rel.relKey, \n\t\t\t\ttype = rel.relType, \n\t\t\t\trecords = record[key],\n\t\t\t\tbMod = rel.relatedTo;\n\t\t\t\tif(parent && bMod){\n\t\t\t\t\tvar child = getBackwardRel(fMod,rel,getSchemaObj(db, rel.relatedTo));\n\t\t\t\t\tif(parent == child && fMod != rel.relatedTo){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rel.opts.serialize == \"record\"){\n\t\t\t\t\tvar res = isRelDirty(db, rel, records, rel);\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tresult.push(key);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(rel.opts.serialize == \"partial\"){\n\t\t\t\t\tif(type == \"hasMany\"){\n\t\t\t\t\t\tif(records && records.partial && records.partial.size){\n\t\t\t\t\t\t\tresult.push(key);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((isEntity(records) && records.$.isModified) || (record && record.$ && record.$.partial && record.$.partial.hasOwnProperty(key))){\n\t\t\t\t\t\t\tresult.push(key);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rel.opts.deepNest == true){\t\n\t\t\t\t\tif(record.$.dN && record.$.dN[key]){\n\t\t\t\t\t\tresult.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t});\n\treturn result;\n}\n\nfunction isRelDirty(db, rel, records, parent){\n\tvar type = rel.relType;\n\tvar fMod = rel.relatedTo;\n\tvar fDef = getSchemaObj(db, fMod);\n\tvar relations = fDef.relations; \n\tif(!isEmpty(records)){\n\t\tif(type == \"hasMany\" && Array.isArray(records) && records.length){\n\t\t\tvar len = records.length;\n\t\t\tfor(var i=0; i<len; i++){\n\t\t\t\tif(records[i].$.isModified == true){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var j=0; j<len; j++){\n\t\t\t\tvar rec = records[j];\n\t\t\t\tvar arr = isDirty(db, rec, relations, parent, fDef);\n\t\t\t\tif(arr.length){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(type == \"belongsTo\" && isEntity(records)){\n\t\t\tif(records.$.isModified == true){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar arr = isDirty(db, records, relations, parent, fDef);\n\t\t\tif(arr.length){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction polymorphicToJSON(db,rel,data){\n\tvar opts = rel.opts;\n\tif(opts && opts.polymorphic){\n\t\tif(Array.isArray(data)){\n\t\t\tvar res = [];\n\t\t\tdata.forEach(function(item){\n\t\t\t\tres.push(polyToJSON(db,item));\n\t\t\t});\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\treturn polyToJSON(db,data);\n\t\t}\n\t}\n}\n\nfunction polyToJSON(db, data){\n\t// var type = data ? data._type : undefined;\n\tvar polyMod = data.$.schema;\n\tif(!polyMod.hasOwnProperty(\"fieldList\") && polyMod._name){\n\t\tpolyMod = db.getSchema(polyMod._name);\n\t} \n\tvar pK = polyMod ? polyMod._pK : undefined, \n\tpoly = {}, \n\tpkVal = data.$.pK;\n\n\tif(typeof pkVal == \"object\"){\n\t\tpoly = Object.assign({}, pkVal);\n\t}\n\telse{\n\t\tpoly[pK] = pkVal;\n\t}\n\t// poly._type = data._type;\n\tpoly._type = data._type ? data._type : data.$.model._name;\n\treturn poly;\n}\n\nfunction removeBackwardRel(val,rel,pK,pkVal,wholeRelKey){\n\tif(wholeRelKey){\n\t\tdelete val[rel.backward.relKey];\n\t\treturn; \n\t}\n\tif(rel.backward != null){\n\t\tvar rec = val[rel.backward.relKey];\n\t\tif(Array.isArray(rec)){\n\t\t\tfor(var i=0; i<rec.length; i++){\n\t\t\t\tif(comparePk(rec[i],pkVal)){\n\t\t\t\t\trec.splice(i,1);\n\t\t\t\t\tif(rec.length == 0){\n\t\t\t\t\t\tdelete val[rel.backward.relKey];\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if(rec && isEntity(rec) && comparePk(rec, pkVal)){\n\t\t\tdelete val[rel.backward.relKey];\n\t\t}\n\t}\n}\n\nfunction checkPresenceInArray(arr,value){\n\treturn arr && arr.some(function(val){\n\t\treturn val === value;\n\t});\n}\n\nfunction idbSerialize(db, data, rel, def, bDef, pkVal, expose){\n\tvar relTo = rel.forward.relatedTo, \n\tpK = def._pK, \n\tbPk = bDef._pK;\n\tif(Array.isArray(data)){\n\t\tdata.forEach(function(item, index){\n\t\t\tif(isEntity(item) && item.$.inIDB){\n\t\t\t\tdata[index] = item[bPk];\t\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse if(!checkPresenceInArray(db.$.recStack[relTo._name],item[bPk])){\n\t\t\t\tremoveBackwardRel(item, rel, pK, pkVal, true);\n\t\t\t\tremoveSelfCircularReference(db, bDef._name, item, expose);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdata[index] = item[bPk];\t\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t});\n\t}\n\telse if(data && isEntity(data)){\n\t\tif(isEntity(data) && data.$.inIDB){\n\t\t\tobj[relKey] = data[bPk];\n\t\t}\n\t\telse if(!checkPresenceInArray(db.$.recStack[relTo._name],data[bPk])){\n\t\t\tremoveBackwardRel(data, rel, pK, pkVal, true);\n\t\t\tremoveSelfCircularReference(db, bDef._name, data,expose);\n\t\t}else{\n\t\t\tobj[relKey] = data[bPk];\n\t\t}\n\t}\n}\n\nfunction idSerialize(db, obj, rel, expose, partialObj, partialRef){\n\tvar opts = rel.forward.opts, \n\tpolymorphic = opts ? opts.polymorphic : undefined, \n\trelKey = rel.forward.relKey,\n\trelKey = rel.forward.relKey, \n\ttoJSON,\n\tclone, \n\tsaveState;\n\tif(opts){\n\t\ttoJSON = opts.toJSON, clone = opts.clone, saveState = opts.saveState;\n\t}\n\tvar data = obj[relKey], \n\tschema = rel.backward.relatedTo, \n\tbDef = rel.forward.relatedTo, \n\tpkVal = getpKVal(obj,getSchemaObj(db, schema)), \n\tmodName;\n\tif(Array.isArray(data)){\n\t\tif(polymorphic){\n\t\t\tobj[relKey] = polymorphicToJSON(db,rel.forward,data);\n\t\t}\n\t\telse{\n\t\t\tvar arr = [];\n\t\t\tif(partialObj){\n\t\t\t\tvar partial = partialObj[relKey] = partialObj[relKey] || [], anyNew = false;\n\t\t\t}\n\t\t\tdata.forEach(function(item){\n\t\t\t\tif(item.$.isNew && expose != true && expose != \"state\"){\n\t\t\t\t\tanyNew = true;\n\t\t\t\t\trSerialize(db, item, rel, bDef, schema._pK, pkVal, expose, partial, partialRef);\n\t\t\t\t\tarr.push(item);\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(partial){\n\t\t\t\t\t\tvar pObj = {}, pType = \"related\";\n\t\t\t\t\t\tif(item.$.isDeleted){\n\t\t\t\t\t\t\tpType = \"removed\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_defProp(pObj, \"$\", {});\n\t\t\t\t\t\tvar nPartial = \tpObj.$, nDef = getSchemaObj(db, rel.forward.relatedTo);\n\t\t\t\t\t\tObject.defineProperties(nPartial, {\n\t\t\t\t\t\t\tpkVal : {\n\t\t\t\t\t\t\t\tvalue : item.$.pK\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype : {\n\t\t\t\t\t\t\t\tvalue : pType\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tschema : {\n\t\t\t\t\t\t\t\tvalue : nDef\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trecord : {\n\t\t\t\t\t\t\t\tvalue : db.cache.getEntity(nDef.def, item.$.pK)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\t\t\n\t\t\t\t\t\tif(item.$.isDeleted){\n\t\t\t\t\t\t\tpObj.$.onlyDetach = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpartial.push(pObj);\n\t\t\t\t\t}\n\t\t\t\t\tif(!item.$.isDeleted){\n\t\t\t\t\t\tif(expose == true && toJSON){\n\t\t\t\t\t\t\tarr.push(item.$.toJSON(undefined, rel.backward));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(expose == \"state\" && saveState){\n\t\t\t\t\t\t\tarr.push(item.$.saveState(undefined, true, rel.backward));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(expose == \"clone\" && clone){\n\t\t\t\t\t\t\tarr.push(item.$.clone(rel.backward));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tarr.push(item.$.pK && typeof item.$.pK == \"object\" ? Object.assign({}, item.$.pK) : item.$.pK);\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tobj[relKey] = arr;\n\t\t}\n\t}\n\telse if(data && isEntity(data)){\n\t\tif(data.$.isNew && expose != true && expose != \"state\"){\n\t\t\tvar partial;\n\t\t\tif(partialObj){\n\t\t\t\tpartial = partialObj[relKey] = partialObj[relKey] || {};\n\t\t\t}\n\t\t\tpartial = rSerialize(db, data, rel, bDef, schema._pK, pkVal, expose, partial, partialRef);\n\t\t\tpartialObj[relKey] = partial;\n\t\t}\n\t\telse{\n\t\t\tif(polymorphic){\n\t\t\t\tobj[relKey] = polymorphicToJSON(db,rel.forward,data);\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse if(!data.$.isDeleted){\n\t\t\t\tif(expose == true && toJSON){\n\t\t\t\t\tobj[relKey] = data.$.toJSON(undefined, rel.backward);\n\t\t\t\t}\n\t\t\t\telse if(expose == \"state\" && saveState){\n\t\t\t\t\tobj[relKey] = data.$.saveState(undefined, true, rel.backward);\n\t\t\t\t}\n\t\t\t\telse if(expose == \"clone\" && clone){\n\t\t\t\t\tobj[relKey] = data.$.clone(rel.backward);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tobj[relKey] = (data.$.pK && typeof data.$.pK == \"object\" ? Object.assign({}, data.$.pK) : data.$.pK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction recordSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef){\n\tvar pK = def._pK;\n\tif(Array.isArray(val)){\n\t\tif(val.length == 0){\n\t\t\tdelete obj[key];\n\t\t\treturn 0;\n\t\t}\n\t\tval = Array.from(val);\n\t\tvar partial = partialObj[key] = partialObj[key] || [];\n\t\tfor(var j=0; j<val.length; j++){\n\t\t\tif(val[j] && isEntity(val[j])){\n\t\t\t\trSerialize(db, val[j], rel, bDef, pK, pkVal, expose, partial, partialRef);\n\t\t\t\tif(val[j].$.isDeleted){\n\t\t\t\t\tpartial[j] && partial[j].$ ? partial[j].$.onlyDetach = true : undefined; \n\t\t\t\t\tval.splice(j,1);\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if(val && isEntity(val)){\n\t\tvar partial = partialObj[key] = partialObj[key] || {};\n\t\tpartial = rSerialize(db, val, rel, bDef, pK, pkVal, expose, partial, partialRef);\n\t\t// if(val.$.isDeleted){\n\t\t// \tdebugger\n\t\t// }\n\t\tpartialObj[key] = partial;\n\t}\n}\n\nfunction rSerialize(db, data, rel, bDef, pK, pkVal, expose, partialObj, partialRef){\n\tvar relTo = rel.forward.relatedTo, \n\tpartial, \n\tdef = rel.backward.relatedTo, \n\tpolymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined; \n\tremoveBackwardRel(data, rel, pK, pkVal);\n\tif(partialObj){\n\t\tvar partial = {}, \n\t\tpType = data.$.isNew ? \"added\" : data.$.isModified ? \"modified\" : data.$.isDeleted ? \"removed\" : \"related\", modName;\n\t\tif(polymorphic){\n\t\t\tmodName = data.$.schema._name;\n\t\t\tdata.$.polymorphicType = modName;\n\t\t\tbDef = db.schema[modName];\n\t\t}\n\t\t_defProp(partial, \"$\", {});\n\t\tvar nPartial = \tpartial.$, \n\t\tnDef = polymorphic ? db.schema[modName] : getSchemaObj(db, relTo);\n\t\tObject.defineProperties(nPartial, {\n\t\t\tpkVal : {\n\t\t\t\tvalue : data.$.pK\n\t\t\t},\n\t\t\ttype : {\n\t\t\t\tvalue : pType\n\t\t\t},\n\t\t\tschema : {\n\t\t\t\tvalue : nDef\n\t\t\t},\n\t\t\trecord : {\n\t\t\t\tvalue : db.cache.getEntity(nDef.def, data.$.pK)\n\t\t\t}\n\t\t});\n\t\tif(Array.isArray(partialObj)){\n\t\t\tpartialObj.push(partial);\n\t\t}\n\t}\n\tremoveSelfCircularReference(db, bDef._name, data, expose, undefined, partial, partialRef);\n\treturn partial;\n}\n\nfunction partialSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef){\n\tvar field = rel.forward, \n\tpK = def._pK, \n\trelTo = rel.forward.relatedTo,\n\tpolymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;\n\tif(field.relType == \"hasMany\"){\n\t\tif(val && val.partial){\n\t\t\tvar part = val.partial,\n\t\t\tbpK = bDef._pK;\n\t\t\tif(partialObj){\n\t\t\t\tpartial = partialObj[key] = partialObj[key] || [];\n\t\t\t\t_defProp(partial, \"partial\", true);\n\t\t\t}\n\t\t\tif(part){\n\t\t\t\tvar pObj, \n\t\t\t\tpKey, \n\t\t\t\tnewPartial,\n\t\t\t\tresult = [], \n\t\t\t\tself = this, \n\t\t\t\trelRec;\n\t\t\t\tpart.forEach(function(value , partKey){\n\t\t\t\t\tpObj = value, relRec = partKey, pKey = partKey.$.pK , newPartial;\n\t\t\t\t\tif(/^(added|modified)$/.test(pObj.type)){\n\t\t\t\t\t\tvar pType = \"related\",\n\t\t\t\t\t\tind = getIndex(val, bpK, pKey, undefined, getSchemaObj(db, relTo));\n\t\t\t\t\t\tif(ind != -1){\n\t\t\t\t\t\t\tvar rec = val[ind], updVal, rec$;\n\t\t\t\t\t\t\tvar polyType;\n\t\t\t\t\t\t\tif(rec && rec.$){\n\t\t\t\t\t\t\t\trec$ = Object.assign({}, rec.$);\n\t\t\t\t\t\t\t\trec = Object.assign({}, rec);\n\t\t\t\t\t\t\t\t_defProp(rec, '$', rec$);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tupdVal = rec;\n\t\t\t\t\t\t\tif(polymorphic && rec){\n\t\t\t\t\t\t\t\tpolyType =  rec._type ? rec._type : rec.$.schema._name;\n\t\t\t\t\t\t\t\tbDef = db.schema[polyType];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar record = db.cache.getEntity(bDef.def, pKey);\n\t\t\t\t\t\t\tremoveBackwardRel(rec, rel, pK, pkVal);\n\t\t\t\t\t\t\tif(rec.$.isNew){\n\t\t\t\t\t\t\t\tpType = \"added\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rec.$.isModified){\n\t\t\t\t\t\t\t\tpType = \"modified\";\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar valDir = isDirty(db, record, bDef.relations);\n\t\t\t\t\t\t\t\tupdVal = updateJSON(db, rec, bDef, valDir);\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tvar valDir = isDirty(db, record, bDef.relations);\n\t\t\t\t\t\t\t\tupdVal = updateJSON(db, rec, bDef, valDir);\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(partial){\n\t\t\t\t\t\t\t\tvar newPart = {};\n\t\t\t\t\t\t\t\t_defProp(newPart, \"$\", {});\n\t\t\t\t\t\t\t\tvar newPart$ = newPart.$,\n\t\t\t\t\t\t\t\tnewPartDef = polymorphic ? polyType : relTo;\n\t\t\t\t\t\t\t\tObject.defineProperties(newPart$, {\n\t\t\t\t\t\t\t\t\tpkVal : {\n\t\t\t\t\t\t\t\t\t\tvalue : pKey\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttype : {\n\t\t\t\t\t\t\t\t\t\tvalue : pType\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tschema : {\n\t\t\t\t\t\t\t\t\t\tvalue : polymorphic ? db.schema[polyType] : getSchemaObj(db, relTo)\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trecord : {\n\t\t\t\t\t\t\t\t\t\tvalue :  db.cache.getEntity(newPartDef, pKey)\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// if(partialRef){\n\t\t\t\t\t\t\t\t// \tvar refId = \"rec\"+(++partialRef.size), refKey = partialRef.refKey;\n\t\t\t\t\t\t\t\t// \tupdVal[refKey] = refId;\n\t\t\t\t\t\t\t\t// \tpartialRef.set(refId, newPart);\n\t\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\t\tpartial.push(newPart);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremoveSelfCircularReference(db, bDef._name, updVal, expose, undefined, newPart, partialRef);\t\t\t\n\t\t\t\t\t\t\t// var resObj = {type: pObj.type, data: updVal};\n\t\t\t\t\t\t\tif(isEntity(updVal)){\n\t\t\t\t\t\t\t\tupdVal.$.partialType = pObj.type;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t_defProp(updVal, \"$\", {});\n\t\t\t\t\t\t\t\t_defProp(updVal.$, \"partialType\", pObj.type);\n\t\t\t\t\t\t\t\tif(!updVal.$.hasOwnProperty(\"pK\")){\n\t\t\t\t\t\t\t\t\t_defProp(updVal.$, \"pK\", pKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(polymorphic){\n\t\t\t\t\t\t\t\tupdVal.$.polymorphicType = polyType;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult.push(updVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(pObj.type == \"removed\"){\n\t\t\t\t\t\tvar dObj = {};\n\t\t\t\t\t\tif(pKey && typeof pKey == \"object\"){\n\t\t\t\t\t\t\tObject.assign(dObj, Object.assign({},pKey));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdObj[bpK] = pKey;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar record = db.cache.getEntity(bDef.def, pKey) || db.cache.getEntity(bDef.def, pKey, true);\n\t\t\t\t\t\tif(partial){\n\t\t\t\t\t\t\tvar newPart = {}; \n\t\t\t\t\t\t\t_defProp(newPart, \"$\", {});\n\t\t\t\t\t\t\tvar newPart$ = newPart.$;\n\t\t\t\t\t\t\tObject.defineProperties(newPart$, {\n\t\t\t\t\t\t\t\tpkVal : {\n\t\t\t\t\t\t\t\t\tvalue : pKey\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttype : {\n\t\t\t\t\t\t\t\t\tvalue : \"removed\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tschema : {\n\t\t\t\t\t\t\t\t\tvalue : polymorphic && pObj.polymorphicType ? db.schema[pObj.polymorphicType] : getSchemaObj(db, relTo) \n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trecord: {\n\t\t\t\t\t\t\t\t\tvalue : record\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif(partialRef){\n\t\t\t\t\t\t\t\tvar sz = partialRef.size,\n\t\t\t\t\t\t\t\trefId = \"rec\"+(++sz), refKey = partialRef.refKey;\n\t\t\t\t\t\t\t\tdObj[refKey] = refId;\n\t\t\t\t\t\t\t\tpartialRef.set(refId, newPart);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpartial.push(newPart);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_defProp(dObj, \"$\", {});\n\t\t\t\t\t\tdObj.$.partialType = \"removed\";\n\t\t\t\t\t\tif(polymorphic && pObj.polymorphicType){\n\t\t\t\t\t\t\tdObj.$.polymorphicType = pObj.polymorphicType;\n\t\t\t\t\t\t} \n\t\t\t\t\t\tif(!dObj.$.hasOwnProperty('pK')){\n\t\t\t\t\t\t\tdObj.$.pK = pKey;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// result.push({type:\"removed\", data: dObj})\n\n\t\t\t\t\t\tresult.push(dObj);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(result.length){\n\t\t\t\t\tval = obj[key] = result;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdelete obj[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdelete obj[key];\n\t\t}\n\t}\n\telse if(field.relType == \"belongsTo\" && val && isEntity(val)){\n\t\tvar polyType;\n\t\tif(polymorphic && val){\n\t\t\tpolyType =  val._type ? val._type : val.$.schema._name;\n\t\t\tbDef = db.schema[polyType];\n\t\t}\n\t\tremoveBackwardRel(val, rel, pK, pkVal);\n\t\tvar updVal = val, valDir;\n\t\tif(val.$.isNew){\n\t\t\tremoveBackwardRel(val, rel, pK, pkVal);\n\t\t}\n\t\telse{\n\t\t\tvalDir = isDirty(db, val, bDef.relations);\n\t\t\tupdVal = updateJSON(db, val, bDef, valDir);\n\t\t}\n\t\tif(partialObj){\n\t\t\tvar partial = partialObj[key] = partialObj[key] || {};\n\t\t\tvar pType = val.$.isNew ? \"added\" : val.$.isModified ? \"modified\" : \"related\";\n\t\t\t_defProp(partial, \"$\", {});\n\t\t\tvar partial$ = partial.$;\n\t\t\tvar partMod = polymorphic ? db.schema[polyType] : getSchemaObj(db, relTo);\n\t\t\tObject.defineProperties(partial$, {\n\t\t\t\tpkVal : {\n\t\t\t\t\tvalue : val.$.pK\n\t\t\t\t},\n\t\t\t\ttype : {\n\t\t\t\t\tvalue : pType\n\t\t\t\t},\n\t\t\t\tschema : {\n\t\t\t\t\tvalue : partMod\n\t\t\t\t},\n\t\t\t\trecord : {\n\t\t\t\t\tvalue : db.cache.getEntity(partMod.def, val.$.pK)\n\t\t\t\t}\n\t\t\t});\n\t\t\t// if(partialRef){\n\t\t\t// \tvar refId = \"rec\"+(++partialRef.size), refKey = partialRef.refKey;\n\t\t\t// \tupdVal[refKey] = refId;\n\t\t\t// \tpartialRef.set(refId, partial);\n\t\t\t// }\n\t\t}\n\t\tif(polymorphic){\n\t\t\tupdVal.$ || _defProp(updVal, \"$\", {});\n\t\t\tupdVal.$.polymorphicType = polyType;\n\t\t}\n\t\tremoveSelfCircularReference(db, bDef._name, updVal, expose, undefined, partial, partialRef);\n\t\tval = obj[key] = updVal;\n\t}\n}\n\nfunction removeSelfCircularReference(db, name, obj, expose, type, partialObj, partialRef, parentRel,addNotDefinedFields){\n\tvar def = db.schema[name], \n\tfieldList = def.fieldList,\n\tpkVal = getpKVal(obj,def),  \n\trecord = db.cache.getEntity(def.def, pkVal), \n\tpartObj = isEntity(record) ? record.$.partial : undefined, \n\tpolymorphicType = obj && obj.$ ? obj.$.polymorphicType : undefined, \n\trefId;\n\tdb.$.recStack[name] = db.$.recStack[name] || []; \n\tvar ret = checkAndAddToArray(db.$.recStack[name], pkVal)\n\tif(partialRef){\n\t\tvar sz = partialRef.size,\n\t\trefObj = {};\n\t\trefId = \"rec\"+(++sz);\n\t\t_defProp(refObj, \"$\", {pkVal: record.$.pK, schema :record.$.schema});\n\t\tpartialRef.set(refId, refObj);\n\t}\n\tvar unlinkedKeys = getFromCB(db,\"serializer\",def.serializer,\"serializeEmptyRelation\");\n\tfor(var key in obj){\n\t\tvar field = fieldList[key], \n\t\textMod, \n\t\tswap = false, \n\t\trelTo, \n\t\tbDef, \n\t\trelType;\n\t\tvar removePk = ((expose == \"clone\" || type == \"create\" || (isEntity(obj) && obj.$.isNew)) && def._pK == key) ? true: false;\n\t\tif(field && (field == parentRel || (removePk && expose != true && expose != \"state\"))){\n\t\t\tdelete obj[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif(!field){\n\t\t\tif(polymorphicType){\n\t\t\t\textMod = db.getSchemaObj(polymorphicType);\n\t\t\t\tfield = extMod.fieldList[key];\n\t\t\t\tswap = true;\n\t\t\t}\n\t\t\tif(!addNotDefinedFields){\n\t\t\t\tdelete obj[key];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(field && field.type != \"relation\" && !expose  && db.dataType[field.type] && db.dataType[field.type].serialize && obj.hasOwnProperty(key)){\t\t\t\n\t\t\tobj[key] = db.dataType[field.type].serialize(obj[key],key,record);\n\t\t\tcontinue;\n\t\t}\n\t\tif(partObj && partObj.hasOwnProperty(key)){\n\t\t\tvar partPload = {},\n\t\t\t_bDef = getSchemaObj(db, field.relatedTo),\n\t\t\tbPk = _bDef._pK,\n\t\t\tdoCont = false;\n\t\t\tpartObj[key].forEach(function(item, partPk){\n\t\t\t\tpartPload[bPk] = partPk.$.pK;\n\t\t\t\t_defProp(partPload, \"$\", {});\n\t\t\t\t_defProp(partPload.$, \"partialType\", \"removed\");\n\t\t\t\t_defProp(partPload.$, \"pK\", partPk.$.pK);\n\t\t\t\tif(partialObj){\n\t\t\t\t\tvar partial = partialObj[key] = partialObj[key] || {};\n\t\t\t\t\t_defProp(partial, \"$\", {});\n\t\t\t\t\tvar partial$ = partial.$;\n\t\t\t\t\tObject.defineProperties(partial$, {\n\t\t\t\t\t\tpkVal : {\n\t\t\t\t\t\t\tvalue : partPk.$.pK\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttype : {\n\t\t\t\t\t\t\tvalue : \"removed\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tschema : {\n\t\t\t\t\t\t\tvalue : _bDef\n\t\t\t\t\t\t},\n\t\t\t\t\t\tparent : {\n\t\t\t\t\t\t\tvalue : record\n\t\t\t\t\t\t},\n\t\t\t\t\t\trecord: {\n\t\t\t\t\t\t\tvalue: db.cache.getEntity(field.relatedTo, partPk.$.pK)\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && field.opts && /^(id|record)$/.test(field.opts.serialize)){\n\t\t\t\t\tobj[key] = null;\n\t\t\t\t\tdoCont = true;\n\t\t\t\t}\n\t\t\t\telse if(field.opts.serialize == \"partial\"){\n\t\t\t\t\tobj[key] = partPload;\n\t\t\t\t\tdoCont = true;\n\t\t\t\t}\n\t\t\t\tif(field && field.opts && /^(id|record)$/.test(field.opts.serialize)){\n\t\t\t\t\tObject.defineProperties(partial$, {\n\t\t\t\t\t\tonlyDetach:{\n\t\t\t\t\t\t\tvalue: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\trelKey: {\n\t\t\t\t\t\t\tvalue: key\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\t\t\n\t\t\tif(doCont){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif((expose == true || expose == \"clone\" || expose == \"state\") && obj[key] && typeof obj[key] == \"object\" && field && field.type != \"relation\"){\n\t\t\tobj[key] = deepCopyObject(obj[key]);\n\t\t\tcontinue;\n\t\t}\n\t\tif(obj[key] && field && field.type == \"relation\"){\n\t\t\trelTo = field.relatedTo;\n\t\t\trelType = field.relType;\n\t\t\tbDef = getSchemaObj(db, relTo);\n\t\t\tif(bDef == undefined){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar relKey = field.relKey, rel = {};\n\t\t\tif(swap){\n\t\t\t\tgetRelations(db, extMod, field.relKey, bDef, rel);\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tgetRelations(db, def, relKey, bDef, rel);\n\t\t\t}\n\t\t\tvar opts = field.opts;\n\t\t\tvar serialize = opts ? opts.serialize : undefined, val = obj[relKey];\n\t\t\tif(expose == \"idb\"){\n\t\t\t\tidbSerialize(db, val, rel, def, bDef, pkVal, expose);\n\t\t\t}\n\t\t\telse if(expose || serialize == \"id\"){\n\t\t\t\tidSerialize(db, obj, rel, expose, partialObj, partialRef);\n\t\t\t}\n\t\t\telse if(serialize === \"record\"){\n\t\t\t\tvar ret = recordSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef);\n\t\t\t\tif(ret == 0){\n\t\t\t\t\tif(relType === \"hasMany\" && (unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && Array.isArray(record[key]) && record[key].partial && record[key].partial.size){\n\t\t\t\t\t\tvar emptyArr = true;\n\t\t\t\t\t\trecord[key].partial.forEach(function(pobj){\n\t\t\t\t\t\t\tif(pobj.type !== \"removed\"){\n\t\t\t\t\t\t\t\temptyArr = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif(emptyArr){\n\t\t\t\t\t\t\tobj[key] = [];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(serialize === \"partial\"){\n\t\t\t\tpartialSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef)\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdelete obj[relKey];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tval = obj ? obj[relKey] : undefined;\n\t\t\tif( val && (relType == \"hasMany\" && Array.isArray(val) && val.length == 0) || (relType == \"belongsTo\" && typeof val == \"object\" && Object.keys(val).length == 0)) {\n\t\t\t\tif((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && relType == \"hasMany\" && field.opts && /^(id|record)$/.test(field.opts.serialize)){\n\t\t\t\t\tobj[relKey] = [];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdelete obj[relKey];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif(partialRef){\n\t\tvar refKey = partialRef.refKey;\n\t\tobj[refKey] = refId;\n\t}\n}\n\nfunction getpKVal(ins, schema){\n\tvar schema = schema ? schema : ins.$.schema, \n\tarr = schema._arrPk;\n\tif(arr.length == 1){\n\t\treturn ins[arr[0]];\n\t}\n\telse{\n\t\tvar obj = {};\n\t\tarr.forEach(function(item){\n\t\t\tobj[item] = ins[item];\n\t\t});\n\t}\n\treturn obj;\n}\n\nfunction toJSONObj(db, schema, data, expose, type, partial, parentRel, addNotDefinedFields){\n\tvar copyObj, \n\tpkVal, \n\tname = schema._name, \n\tpK = schema._pK;\n\tif(expose == true || expose == \"state\" || expose == \"clone\"){\n\t\tcopyObj = Object.assign({},data);\n\t}\n\telse{\n\t\tcopyObj = deepCopyObject(data)\n\t}\n\tif(isEntity(copyObj)){\n\t\tpkVal = copyObj.$.pK;\n\t}\n\telse{\n\t\tpkVal = db.cache.getEntity(schema.def, getpKVal(copyObj, schema)).$.pK;\n\t}\n\tvar partialObj = partial ? partial.obj : undefined, partialMp;\n\tif(partialObj && !partialObj.has(pkVal)){\n\t\tpartialObj.set(pkVal,{});\n\t\tpartialMp = partialObj.get(pkVal); \n\t}\n\tremoveSelfCircularReference(db, name, copyObj,expose,type, partialMp, partial && partial.ref ? partial.ref : undefined, parentRel,addNotDefinedFields);\n\tif(expose == \"idb\"){\n\t\tdb.idbIns.removeNotNeededKeys(db, name, copyObj);\n\t}\n\treturn copyObj;\n}\n\nfunction toJSON(db,name,obj,expose,type,partialObj,parentRel,addNotDefinedFields){\n\tvar copyObj, \n\tdef = db.schema[name];\n\tdb.$.recStack = {};\n\tif(Array.isArray(obj)){\n\t\tvar arr = [];\n\t\tfor(var i=0; i<obj.length; i++){\n\t\t\tcopyObj = toJSONObj(db, def, obj[i], expose, type, partialObj, parentRel,addNotDefinedFields);\n\t\t\tarr.push(copyObj);\n\t\t}\n\t\treturn arr;\n\t}\n\telse if(obj && (typeof obj === \"object\" || isEntity(obj))){\n\t\tcopyObj = toJSONObj(db, def, obj, expose, type, partialObj, parentRel,addNotDefinedFields);\n\t}\n\tdb.$.recStack = {};\n\treturn copyObj;\n}\n\nfunction createCopy(data){\n\tif(Array.isArray(data)){\n\t\tif(data.save){\n\t\t\tvar arr = [];\n\t\t\tfor(var i=0; i<data.length; i++){\n\t\t\t\tvar rec = deepCopyObject(data[i]);\n\t\t\t\tarr.push(rec);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n\telse if(data && ( isEntity(data) || typeof data == \"object\")){\n\t\treturn deepCopyObject(data);\n\t}\n\treturn data;\n}\n\nfunction initPartialObj(db, name, type, qP, key, url, customData, argsObj){\n\tvar partial = { obj : new Map() };\n\t// rKey = \"recId\", \n\t// refKey, \n\t// res,\n\t// def = db.schema[name];\n\t// partial.ref = new Map();\n\t// res = initCB(db,\"serializer\", def.serializer, def.serializer.constructor.REFERENCEKEY, { argsObj: argsObj, args:[name,type,qP,key,url,customData]});\n\t// refKey = res ? res.data : undefined;\n\t// if(!isEmpty(refKey)){\n\t// \trKey = refKey;\n\t// }\n\t// partial.ref.refKey = rKey;\n\treturn partial;\n}\n\nfunction recChk(lyte, rec){\n\tif(isEntity(rec)){\n\t\tif(rec.$.isUnloaded !== true){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tDberror.error(lyte, rec+ \"has been dropped. So no operations can be performed over this entity\");\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction initCB(db, type, ins, key, obj){\n\tvar args = obj.args, ret = {}, _appC, _appS;\n\tobj.argsObj ? obj.argsObj.callback = key : undefined;\n\tif(ins){\n\t\tif(ins[key]){\n\t\t\tret.data = ins[key].apply(ins, obj.argsObj ? [obj.argsObj] : obj.args);\n\t\t\t// if(db.debug){\n\t\t\t// \tDberror.log(key+\" of \"+ type+\"-\"+ins.constructor.name+ \" called\", \"#008000\")\n\t\t\t// }\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse{\n\t\tvar appC = db.applicationConnector, appS = db.applicationSerializer;\n\t\tif(type == \"connector\" && appC){\n\t\t\tif(appC[key]){\n\t\t\t\tret.data = appC[key].apply(appC, obj.argsObj ? [obj.argsObj] : obj.args);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\telse if(type == \"serializer\" && appS){\n\t\t\tif(appS[key]){\n\t\t\t\tret.data = appS[key].apply(appS, obj.argsObj ? [obj.argsObj] : obj.args);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction cB(callback,args){\n\treturn callback.func.apply(callback.context, args.concat(callback.name));\n}\n\nfunction cbScp(db, ins, key, type){\n\tif(ins){\n\t\tif(ins[key]){\n\t\t\treturn { func : ins[key], context: ins, name:key};\n\t\t}\n\t}\n\telse{\n\t\tvar appC = db.applicationConnector, appS = db.applicationSerializer;\n\t\tif(type == \"connector\" && appC && appC[key]){\n\t\t\treturn { func : appC[key], context: appC, name:key };\n\t\t}\n\t\telse if(type == \"serializer\" && appS && appS[key]){\n\t\t\treturn { func : appS[key], context: appS, name:key};\n\t\t}\n\t}\n}\n\nfunction getFromCB(db, type, ins, key){\n\tvar _appC, _appS, appC = db.applicationConnector, appS = db.applicationSerializer;\n\tif(ins){\n\t\treturn ins[key];\n\t}\n\telse{\n\t\t// var appC = db.applicationConnector, appS = db.applicationSerializer;\n\t\tif(type == \"connector\"){\n\t\t\tif(appC){\n\t\t\t\treturn appC[key];\n\t\t\t}\n\t\t}\n\t\telse if(type == \"serializer\" && appS){\n\t\t\tif(appS){\n\t\t\t\treturn appS[key];\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction comparePk(ins, pkVal){\n\tvar pK = ins.$.pK, \n\tpkType = typeof pK;\n\tif(pkType == \"string\" || pkType == \"number\"){\n\t\treturn pK === pkVal;\n\t}\n\telse if(typeof pK == \"object\"){\n\t\tvar len = Object.keys(pK).length, i=0;\n\t\tfor(var key in pK){\n\t\t\tif(pK[key] === pkVal[key]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn len === i;\n\t}\n}\n\nfunction newRecord(db, def, opts, skipValidation){\n\tvar lyte = db.lyte;\n\tif(opts == undefined){\n\t\topts = {};\n\t}\n\tif(opts && typeof opts !== \"object\"){\n\t\tDberror.warn(db.lyte, \"LD25\", opts);\n\t\tvar err = new ValidationError(db.lyte, undefined, undefined, db.lyte.getErrorMessage(\"LD25\", opts));\n\t\treturn err;\n\t}\n\tvar fields = def.fieldList, \n\trecord = {}, \n\terrorObj = new ValidationError(db.lyte), \n\tpK = def._arrPk;\n\tif(!pkPresence(opts, pK)){\n\t\tgenerateRandomPk(def, opts, pK, fields)\n\t}\n\telse if(isDuplicateRecord(def, opts, pK)){\n\t\tValidationError.setError(lyte, errorObj, pK, {code : \"ERR16\", message : Dberror.errorCodes.ERR16})\n\t}\n\tfor(var field in fields){\n\t\tvar fieldKeys = fields[field];\n\t\tif(fieldKeys.relType == \"hasMany\"){\n\t\t\trecord[field] = [];\n\t\t}\n\t\tvar val = opts[field];     \n\t\tvar fldType = fieldKeys.type;\n\t\tif(fldType != \"relation\"){\n\t\t\tif(val === undefined || val === \"\"){\n\t\t\t\tif(fieldKeys.hasOwnProperty(\"default\")){\n\t\t\t\t\tval = record[field] = getDefaultVal(record, fieldKeys.default);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if(fldType !== Lyte.getDataType(val) && (val !== undefined  || fldType === \"boolean\")) {\n\t\t\t// \tval = Lyte.typeCast(val, fldType);\n\t\t\t// }\t\t\n\t\t\tif(!skipValidation){\n\t\t\t\tfor(var property in fieldKeys){\n\t\t\t\t\tvar resp = checkProperty(property, val, field, fieldKeys[property], record, def._name, db, ValidationError.errorCodes, undefined, fieldKeys, true);\n\t\t\t\t\tif(resp != true){\n\t\t\t\t\t\tif(typeof resp == \"object\"){\n\t\t\t\t\t\t\tresp.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tValidationError.setError(lyte, errorObj,field,resp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}    \n\t}\n\tfor(var opt_key in opts){\n\t\trecord[opt_key] = opts[opt_key];\n\t}\n\trecord = new def.def(record, {}, db);\n\tcmpSet(lyte, record.$, \"isNew\", true);\n\tchangePersist(record, false);\n\t// record.$.isNew = true;\n\tvar relations = def.relations;\n\trelations.forEach(function(relation, key){\n\t\tfor(var i=0; i<relation.length; i++){\n\t\t\tvar relObj = relation[i];\n\t\t\tvar relKey = relObj.relKey;\n\t\t\tvar polymorphic = relObj.opts ? relObj.opts.polymorphic : undefined; \n\t\t\tif(record && record[relKey]){\n\t\t\t\tvar optsRelVal = opts[relKey];\n\t\t\t\trecord[relKey] = undefined;\n\t\t\t\tvar fieldKeys = relation[i], rel = {}, resp = getRelations(db, def, fieldKeys.relKey, getSchemaObj(db, fieldKeys.relatedTo), rel),ingore=false;\n\t\t\t\tif(resp != true){\n\t\t\t\t\tValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : resp, data : relation, message : Dberror.errorCodes[resp]});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar bDef = getSchemaObj(db, fieldKeys.relatedTo), bPk = bDef._pK , isComp = bDef.isComp, bPkType = !isComp ? bDef.fieldList[bDef._pK].type : undefined;\n\t\t\t\tif(!Array.isArray(optsRelVal)){\n\t\t\t\t\toptsRelVal = [optsRelVal];\n\t\t\t\t}\n\t\t\t\telse if(relation[i].relType == \"belongsTo\"){\n\t\t\t\t\tValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : \"ERR21\", data : optsRelVal, message : Dberror.errorCodes.ERR21});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\terrorObj[fieldKeys.relKey] = [];\n\t\t\t\tfor(var j=0; j<optsRelVal.length; j++){\n\t\t\t\t\tvar relRecord = undefined, relMod = getSchemaObj(db, fieldKeys.relatedTo), ind;\n\t\t\t\t\tif(optsRelVal[j] && isEntity(optsRelVal[j])){\n\t\t\t\t\t\trelRecord = optsRelVal[j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(isComp && typeof optsRelVal[j] == \"object\"){\n\t\t\t\t\t\tvar ind = getIndex(bDef.data, bPk, getpKVal(optsRelVal[j], bDef));\n\t\t\t\t\t\tif(ind != -1){\n\t\t\t\t\t\t\trelRecord = bDef.data[ind];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(polymorphic){\n\t\t\t\t\t\t\t\tif(optsRelVal[j] && optsRelVal[j].hasOwnProperty(\"_type\")){\n\t\t\t\t\t\t\t\t\trelMod =  optsRelVal[j]._type;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tValidationError.setError(lyte, errorObj, fieldKeys.relKey, {code : \"ERR22\", data : optsRelVal[j], message : Dberror.errorCodes.ERR22});\n\t\t\t\t\t\t\t\t\tcontinue;\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trelRecord = newRecord(db, relMod, optsRelVal[j]);\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(optsRelVal[j] && typeof optsRelVal[j] == bPkType.toLowerCase()){\n\t\t\t\t\t\trelRecord = db.cache.getEntity(relMod.def, optsRelVal[j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(optsRelVal[j] && typeof optsRelVal[j] == \"object\"){\n\t\t\t\t\t\tif(polymorphic){\n\t\t\t\t\t\t\tif(optsRelVal[j] && optsRelVal[j].hasOwnProperty(\"_type\")){\n\t\t\t\t\t\t\t\trelMod =  optsRelVal[j]._type;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tValidationError.setError(lyte, errorObj, fieldKeys.relKey, {code : \"ERR22\", data : optsRelVal[j], message : Dberror.errorCodes.ERR22});\n\t\t\t\t\t\t\t\tcontinue;\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trelRecord = newRecord(db, relMod, optsRelVal[j]);\n\t\t\t\t\t\t// ingore = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(relRecord && relRecord.$ && relRecord.$.isError){\n\t\t\t\t\t\tValidationError.setError(lyte, errorObj, fieldKeys.relKey,{code : \"ERR15\", data : optsRelVal[j], message : Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(relRecord && relRecord.$ && !relRecord.$.isError){\n\t\t\t\t\t\tresp = establishLink(db, rel.forward, rel.backward, record, relRecord, undefined, ingore);\n\t\t\t\t\t\tif(resp != true){\n\t\t\t\t\t\t\tValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : resp, data : optsRelVal[j], message : Dberror.errorCodes[resp]});\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(errorObj[fieldKeys.relKey].length == 0){\n\t\t\t\t\tdelete errorObj[fieldKeys.relKey];\n\t\t\t\t}\n\t\t\t\tif(relation[i].relType == \"hasMany\"){\n\t\t\t\t\tvar fieldkey = relKey;\n\t\t\t\t\tif(record[fieldkey] == undefined){\n\t\t\t\t\t\trecord[fieldkey] = [];\n\t\t\t\t\t}\n\t\t\t\t\tif(!record[fieldkey].add){\n\t\t\t\t\t\tif(polymorphic){\n\t\t\t\t\t\t\t_defProp(record[fieldkey], \"polymorphic\", true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefArrUtls(record[fieldkey]);\n\t\t\t\t\t\tdefUtls(record[fieldkey], relation[i].relatedTo,record,fieldkey);\n\t\t\t\t\t\tdefPolyUtls(record[fieldkey]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t});\n\tif(errorObj && errorObj.$ && Object.keys(errorObj.$.error).length > 0){\n\t\treturn errorObj;\n\t}\n\tvar toRel = db.$.toRelate[def._name], pkVal = record.$.pK;\n\tif(toRel && toRel.has(pkVal)){\n\t\testablishToRelated(record, toRel.get(pkVal));\n\t\ttoRel.delete(pkVal);\n\t}\n\tif(def.didLoad){\n\t\tvar callBack = def.didLoad;\n\t\tfor(var i=0;i<callBack.length;i++){\n\t\t\tcallBack[i].apply(record);\t\t\t\t\n\t\t}\n\t}\n\thandleArrOp(lyte, def.data,\"push\",record);\n\tcheckAndAddToArray(def.dirty, record.$.pK);\n\tdef.emit(\"add\",[record]);\n\tdb.emit(\"add\",[def._name,record]);\n\tif(skipValidation){\n\t\trecord.$.validatedOnCreate = false;\n\t}\n\treturn record;\n}\n\nfunction getIndex(data,pKey,pkVal,type,def){\n\tvar isComp = def ? def.isComp : (pKey.split(',').length > 1 ? true : false); \n\tif(!isComp){\n\t\treturn getInd(data, pKey, pkVal, type)\n\t}\n\telse{\n\t\treturn getCompInd(data, pkVal, type, def)\n\t}\n}\n\nfunction getCompInd(data,pkVal,type,def){\n\tfor(var i=0;data && i<data.length;i++){\n\t\tvar rec = data[i];\n\t\tif(type && data[i]._type !== type){\n\t\t\tcontinue;\n\t\t}\n\t\tif(compareObjects(getpKVal(rec,def), pkVal)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction getInd(data,pKey,pkVal,type){\n\tfor(var i=0;data && i<data.length;i++){\n\t\tvar rec = data[i];\n\t\tif(type && rec._type !== type){\n\t\t\tcontinue;\n\t\t}\n\t\tif(rec[pKey] == pkVal){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction isDuplicateEntity(def,obj){\n\tvar data = def.data, pK = def._pK, isComp = def.isComposite;\n\tif(data.length){\n\t\tif(!isComp && def.data._recMap){\n\t\t\tvar pkVal = obj[pK];\n\t\t\treturn def.data._recMap.get(pkVal ? pkVal.toString() : pkVal) !== undefined;\n\t\t}\n\t\telse{\n\t\t\treturn data.some(function(record){\n\t\t\t\tif(compareObjects( getpKVal(obj, def), getpKVal(record) )){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction compareRecords(a,b,pK,type,def){\n\tvar pK = def._arrPk;\n\tif(isEntity(a) && isEntity(b) && pK.length){\n\t\tif(type && a._type && type !== a._type){\n\t\t\treturn false;\n\t\t}\n\t\tvar pkLen = pK.length;\n\t\tfor(var i=0;i<pkLen;i++){\n\t\t\tvar itm = pK[i];\n\t\t\tif(a[itm] && b[itm] && a[itm] !== b[itm]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction hasRecordInArray(array,record,pK,type,isComp){\n\tif(isEntity(record) && pK){\n\t\tvar len = array.length;\n\t\tfor(var i=0; i<len; i++){\n\t\t\tvar itm = array[i];\n\t\t\tif(type && itm._type !== type){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(isComp){\n\t\t\t\tif(compareRecords(itm, record, pK, undefined, record.$.schema)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif((type && itm._type && type === record._type && itm[pK] === record[pK]) || (itm[pK] === record[pK])){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction hasDuplicateRelation(toRelate,relation,pK,type,def){\n\tvar isComp = def.isComp;\n\tif(Array.isArray(relation)){\n\t\tif(!isComp && !relation.isPolymorphic && relation._recMap){\n\t\t\treturn relation._recMap.get(toRelate[pK]);\n\t\t}\n\t\telse{\n\t\t\treturn hasRecordInArray(relation, toRelate, pK, type, isComp);\n\t\t}\n\t}\n\telse if(relation && isEntity(relation)){\n\t\treturn compareRecords(toRelate, relation, pK, type, def);\n\t}\n\treturn false;\n}\n\nfunction toInsertData(db, def, payLoad, saveParent, index){\n\t// var def = db.schema[name];\n\tvar name = def._name ? def._name : def;\n\tvar data = insertIntoStore(db, def, payLoad[name],saveParent,true, undefined, index);\n\tdef ? delete def.rel : undefined;\n\treturn data;\n}\n\nfunction insertIntoStore(db,schemaCls,data,saveParent,stack,partialObj,index, checkRelData){\n\tvar ret;\n\tif(Array.isArray(data)){\n\t\tret = [];\n\t\tfor(var i=0; i<data.length; i++){\n\t\t\tret[i] = insertIntoStore(db, schemaCls, data[i], saveParent, stack, partialObj, index);\n\t\t\tif(ret[i] && ret[i].$ && ret[i].$.isError){\n\t\t\t\tif(!ret.$){\n\t\t\t\t\t_defProp(ret, \"$\", {}, true, true ,true); \n\t\t\t\t} \n\t\t\t\t// ret.$.isError = true;y\n\t\t\t\tcmpSet(db.lyte, ret.$, \"isError\", true);\n\t\t\t}\n\t\t}\n\t}\n\telse if(data && typeof data == \"object\" && Object.keys(data).length){\n\t\t// var cDef = db.getSchemaObj(name);\n\t\tvar cDef = getSchemaObj(db, schemaCls);\n\t\tif(cDef){\n\t\t\tif(data._type && cDef.extendedBy){\n\t\t\t\tcDef = (cDef.extendedBy[data._type]) ? db.getSchemaObj(data._type) : undefined;\n\t\t\t\t// cDef = getSchemaObj(db, cDef);\n\t\t\t}\n\t\t\tif(isEntity(data))\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif(checkRelData && data && cDef){\n\t\t\t\tvar rels = cDef.relations;\n\t\t\t\tif(rels){\n\t\t\t\t\trels.forEach(function(relArr, key){\n\t\t\t\t\t\trelArr.forEach(function(rel){\n\t\t\t\t\t\t\tvar key = rel.relKey,\n\t\t\t\t\t\t\ttype = rel.relType;\n\t\t\t\t\t\t\tif(type == \"hasMany\" && data.hasOwnProperty(key) && Array.isArray(data[key]) && data[key].length){\n\t\t\t\t\t\t\t\tvar arr = data[key], newArr = [];\n\t\t\t\t\t\t\t\tarr.forEach(function(itm){\n\t\t\t\t\t\t\t\t\tif(isEntity(itm)){\n\t\t\t\t\t\t\t\t\t\tnewArr.push(itm.$.pK);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tnewArr.push(itm);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tdata[key] = newArr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(type == \"belongsTo\" && data.hasOwnProperty(key) && isEntity(data[key])){\n\t\t\t\t\t\t\t\tdata[key] = data[key].$.pK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isDuplicateEntity(cDef, data, cDef._pK)){\n\t\t\t\tvar rec = new cDef.def(data, {}, db);\n\t\t\t\tcDef.data.push(rec);\n\t\t\t\tvar toRel = db.$.toRelate[cDef._name], pkVal = rec.$.pK;\n\t\t\t\tif(saveParent){\n\t\t\t\t\tdb.$.saveParent = rec;\n\t\t\t\t}\n\t\t\t\tret = validateAndPush(db,cDef,rec,partialObj);\n\t\t\t\tif(toRel && toRel.has(pkVal)){\n\t\t\t\t\testablishToRelated(rec, toRel.get(pkVal));\n\t\t\t\t\ttoRel.delete(pkVal);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret = validateAndMerge(cDef,data,partialObj);\n\t\t\t\tif(ret && ret.data){\n\t\t\t\t\tret = ret.data;\n\t\t\t\t}\n\t\t\t\telse if(ret && ret.type){\n\t\t\t\t\tArray.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]\n\t\t\t\t\tDberror[result.type].apply(Dberror, result.args || [db.lyte]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(saveParent){\n\t\t\t\tdb.$.saveParent = undefined;\n\t\t\t}\n\t\t\tif(stack){\n\t\t\t\tdb.$.recStack = {};\n\t\t\t}\n\t\t}\n\t\telse if(typeof schemaCls == \"string\"){\n\t\t\tvar defobj = db.schemaless, \n\t\t\tdef = defobj[schemaCls] = defobj[schemaCls] || {};\n\t\t\tif(index){\n\t\t\t\tif(!typeof index == \"string\"){\n\t\t\t\t\tDberror.error(db.lyte,\"Index should be a string\");\n\t\t\t\t}\n\t\t\t\tif(def._pK){\n\t\t\t\t\tif(def._pK !== index){\n\t\t\t\t\t\tDberror.error(db.lyte,\"\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdef._pK = index;\n\t\t\t\tdef._arrPk = [index];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdef._pK = index = \"id\";\n\t\t\t\tdef._arrPk = [index];\n\t\t\t}\n\t\t\tdef.data = def.data || [];\n\t\t\tdefProp(def.data,\"schemaless\", {value:true});\n\t\t\tdefProp(def.data, \"pK\", {value:def._pK});\n\t\t\tvar ind = getInd(def.data, index, data[index]);\n\t\t\tif(ind == -1){\n\t\t\t\thandleArrOp(db.lyte, def.data, \"push\", data);\n\t\t\t}\n\t\t\telse{\n\t\t\t\thandleArrOp(db.lyte, def.data, \"replaceAt\", data, ind);\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\t}\n\treturn ret;\n}\n\nfunction validateAndPush(db,def,data,partialObj){\n\tif(!def.rel){\n\t\tdef.rel = {};\n\t}\n\tvar pkVals = def._arrPk, pkValsLen = pkVals.length, index;\n\tfor(var i=0; i<pkValsLen; i++){\n\t\tvar item = pkVals[i];\n\t\tif(!data.hasOwnProperty(item)){\n\t\t\tindex = def.data.indexOf(data);\n\t\t\tdef.data.splice(index,1);\t\n\t\t\treturn new ValidationError(db.lyte, item, {code : \"ERR23\", data : data, message : Dberror.errorCodes.ERR23});\n\t\t}\n\t\telse if(data[item] == undefined || data[item] == null){\n\t\t\tindex = def.data.indexOf(data);\n\t\t\tdef.data.splice(index,1);\t\n\t\t\treturn new ValidationError(db.lyte, item, {code : \"ERR26\", data : data, message : Dberror.errorCodes.ERR26});\n\t\t}\n\t}\n\tvar mapPk = (( data.$.pK == undefined || typeof data.$.pK == \"object\") ? data.$.pK : data.$.pK.toString());\n\tdef.data._recMap.set(mapPk, data);\n\tdata = validateJSON(db, def, data, undefined, undefined, partialObj);\n\tvar index = def.data.indexOf(data); //have to check if the removal of these lines, doesn't affect any\n\tdef.data.splice(index, 1);\n\thandleArrOp(db.lyte,def.data,\"push\",data);\n\tif(def.didLoad){\n\t\tvar callBack = def.didLoad;\n\t\tfor(var i=0;i<callBack.length;i++){\n\t\t\tcallBack[i].apply(data);\t\n\t\t}\n\t}\n\tdef.emit(\"add\",[data]);\n\tdb.emit(\"add\",[def._name,data]);\n\treturn data;\n}\n\nfunction validateJSON(db,def,data,keys,toValidate,partialObj){\n\tvar validate = (toValidate) ? toValidate.toValidate : undefined;\n\tvar fields = (validate && Object.keys(validate).length) ? validate : def.fieldList;\n\tvar extended = def.extend ? true : false;\n\tfor(var key in data){\n\t\tif(keys && keys.indexOf(key) == -1){\n\t\t\tcontinue;\n\t\t}\n\t\tvar fld = fields[key];\n\t\tif(fld){\n\t\t\tif(fld.type == \"relation\" && data[key]){\n\t\t\t\tvar partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;\n\t\t\t\tvar resp = handleRelation(db, key, def, fld, data, partialAdd, partialObj);\n\t\t\t\tif(resp != true){\n\t\t\t\t\treturn new ValidationError(db.lyte, key, {code : resp, data : data, message : Dberror.errorCodes[resp]});\n\t\t\t\t}\n\t\t\t\tif(fld.relType == \"hasMany\" && !data[key].add){\n\t\t\t\t\tdefArrUtls(data[key]);\n\t\t\t\t\tdefPolyUtls(data[key]);\n\t\t\t\t\tdefUtls(data[key],fld.relatedTo,data,key);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(fld.type){\n\t\t\t\tvar fieldKeys = fld;\n\t\t\t\tif(data[key] === undefined && fieldKeys.default){\n\t\t\t\t\tdata[key] = getDefaultVal(data, fieldKeys.default);\n\t\t\t\t}\n\t\t\t\tvar empD = getDsrzEmpData(def, fld, def._name);\n\t\t\t\tvar boolChk = !empD && data[key]\n\t\t\t\tif(data.hasOwnProperty(key) && (boolChk || empD) && db.dataType.hasOwnProperty(fieldKeys.type) && db.dataType[fieldKeys.type].hasOwnProperty(\"deserialize\")){\n\t\t\t\t\tdata[key] = db.dataType[fieldKeys.type].deserialize(data[key],key,def._name,getpKVal(data,def));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(extended){\n\t\t\t\tvar extMod = db.getSchemaObj(def.extend);\n\t\t\t\tvar extKey = extMod.fieldList[key];\n\t\t\t\tif(extKey && extKey.type == \"relation\"){\n\t\t\t\t\tvar partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;\n\t\t\t\t\tvar resp = handleRelation(db, key, extMod, extKey, data, partialAdd);\n\t\t\t\t\tif(resp != true){\n\t\t\t\t\t\treturn new ValidationError(db.lyte, key, {code : resp, data : data, message : Dberror.errorCodes[resp]});\n\t\t\t\t\t}\n\t\t\t\t\tif(extKey.relType == \"hasMany\" && !data[key].add){\n\t\t\t\t\t\tdefArrUtls(data[key]);\n\t\t\t\t\t\tdefPolyUtls(data[key]);\n\t\t\t\t\t\tdefUtls(data[key],extMod,data,key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction handleRelation(db,key,def,field,data,partialAdd, partialObj){\n\tvar rel = {},\n\tmRel = def.rel = def.rel || {};\n\tif (!mRel.hasOwnProperty(key)){\n\t\tvar relResp = getRelations(db, def,key,getSchemaObj(db, field.relatedTo),rel);\t\n\t\tif(relResp !== true){\n\t\t\treturn relResp;\n\t\t}\n\t\tmRel[key] = rel;\n\t}\n\telse{\n\t\trel = mRel[key];\n\t}\n\treturn solveRelation(db, rel, def, getSchemaObj(db, field.relatedTo), key, data, partialAdd, partialObj);\n}\n\nfunction getRelations(db,fDef,key,bDef,rel){\n\tif(bDef == undefined){\n\t\tDberror.error(\"LD05\",fDef.fieldList[key].relatedTo,key,fDef._name)\n\t\treturn \"ERR11\";\n\t}\n\trel.forward = fDef.fieldList[key];\n\trel.backward = getBackwardRel(fDef,rel.forward,bDef);\n\tif(rel.backward === undefined){\n\t\tvar temp_backward = {type: \"relation\",relatedTo:fDef.def, dummy:rel.forward.relKey, relKey:undefined};\n\t\tif(!bDef.relations.get(fDef.def)){\n\t\t\tbDef.relations.set(fDef.def, []);\n\t\t}\n\t\tvar bArr = bDef.relations.get(fDef.def);\n\t\tbArr.push(temp_backward);\n\t\trel.backward = temp_backward;\n\t}\n\treturn true;\n}\n\nfunction getBackwardRel(fDef,rel,bDef){\n\tvar inverse, \n\tpolymorphic, \n\tdb = fDef.db;\n\tif(rel.opts){\n\t\tinverse = rel.opts.reverseKey;\n\t\tpolymorphic = rel.opts.polymorphic;\n\t\tif(inverse === null){\n\t\t\treturn undefined;\n\t\t}\n\t\tif(polymorphic){\n\t\t\tvar extDefs = bDef.extendedBy;\n\t\t\tif(extDefs){\n\t\t\t\tfor(var key in extDefs){\n\t\t\t\t\tvar extDef = db.getSchemaObj(key);\n\t\t\t\t\t// extDef = getSchemaObj(db, extDef);\n\t\t\t\t\tif(extDef.relations.get(fDef.def)){\n\t\t\t\t\t\tbDef = extDef;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar relatedTo;\n\tif(inverse && inverse != \"\"){\n\t\trelatedTo = inverse;\n\t}\n\telse{\n\t\tvar bRel = bDef.relations.get(fDef.def);\n\t\tvar extFDef = db.getSchemaObj(fDef.extend), checkPoly;\n\t\tif(!bRel && extFDef && bDef.relations.get(extFDef.def)){\n\t\t\tbRel = bDef.relations.get(extFDef.def);\n\t\t\tcheckPoly = true;\n\t\t}\n\t\trelatedTo = (bRel && bRel.length == 1 && (bRel[0].opts && bRel[0].opts.reverseKey && bRel[0].opts.reverseKey !== rel.relKey ? false : true ) && (!checkPoly || (checkPoly && bRel[0].opts && bRel[0].opts.polymorphic))) ? bRel[0].relKey : undefined;\n\t}\n\tif(!relatedTo){\n\t\tvar bRels = bDef.relations.get(fDef.def);\n\t\tvar extFDef_1 = db.getSchemaObj(fDef.extend);\n\t\tif(!bRels && extFDef_1 && bDef.relations.get(extFDef_1.def) && bDef.relations.get(extFDef_1.def).opts && bDef.relations.get(extFDef_1.def).opts.polymorphic){\n\t\t\tbRels = bDef.relations.get(extFDef_1.def);\n\t\t}\n\t\tif(rel.dummy && bRels){\n\t\t\tfor(var i=0;i<bRels.length;i++){\n\t\t\t\tif(bRels[i] && bRels[i].relKey && bRels[i].relKey == rel.dummy)\n\t\t\t\t{\n\t\t\t\t\t relatedTo = bRels[i].relKey;\n\t\t\t\t\t break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(bRels){\n\t\t\tfor(var i=0;i<bRels.length;i++){\n\t\t\t\tif(bRels[i] && bRels[i].opts && bRels[i].opts.reverseKey && bRels[i].opts.reverseKey === rel.relKey){\n\t\t\t\t\trelatedTo = bRels[i].relKey;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(bRels[i] && bRels[i].dummy && bRels[i].dummy == rel.relKey)\n\t\t\t\t{\n\t\t\t\t\t relatedTo = bRels[i];\n\t\t\t\t\t break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(relatedTo && relatedTo.dummy){\n\t\treturn relatedTo;\n\t}\n\tif(relatedTo && fDef._fldGrps.reverseKey.has(rel.relatedTo) && !rel.dummy){\n\t\tif(relatedTo && fDef.relations.get(rel.relatedTo) && fDef.relations.get(rel.relatedTo).length>1 && !inverse){\n\t\t\tif((!bDef.fieldList[relatedTo].opts) || bDef.fieldList[relatedTo].opts && !bDef.fieldList[relatedTo].opts.reverseKey){\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}\n\treturn relatedTo?bDef.fieldList[relatedTo]:undefined;\t\t\t\n}\n\nfunction solveRelation(db,rel,fDef,bDef,key,data,partialAdd,partialObj){\n\tvar forward = rel.forward, \n\tpartial = partialObj ? partialObj[key] : undefined, \n\tpartialRel = partial && partial.partial, \n\tval = [];\n\tif(partialAdd){\n\t\tval = partialAdd;\n\t}\n\telse if(!partialRel){\n\t\tif(data[key] && (data[key].add || isEntity(data[key]) ) ){\n\t\t\treturn true;\n\t\t}\n\t\tif(!Array.isArray(data[key])){\n\t\t\tdata[key] = [data[key]];\n\t\t}\n\t\telse if(forward.relType == \"belongsTo\"){\n\t\t\treturn \"ERR21\";\n\t\t} \n\t\tval = data[key].splice(0, data[key].length);\n\t\tif(forward.relType == \"belongsTo\"){\n\t\t\tdata[key] = undefined;\t\t\t\t\n\t\t}                \n\t}\n\telse if(Array.isArray(data[key])){\n\t\tvar val = data[key].splice(0, data[key].length);\n\t}\n\tfor(var i=0; i<val.length; i++){\n\t\tvar ret;\n\t\tret = createAndRelate(db, fDef, bDef, data, key, val[i], rel, partial);\n\t\tif(ret != true){\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction createAndRelate(db, fDef, bDef, data, key, val, rel, partial){\n\tif(!rel.backward){\n\t\tif(rel.forward.relatedTo === fDef){\n\t\t\trel.backward = rel.forward;\n\t\t}\n\t\tif(rel.backward === undefined){\n\t\t\treturn \"ERR12\";\n\t\t}\n\t}\n\tvar pK = fDef._pK, \n\tisComp = bDef.isComp, \n\tisPoly = rel.forward && rel.forward.opts ? rel.forward.opts.polymorphic : undefined,\n\trelatedRecord, \n\tnewPartial = partial && partial.hasOwnProperty(val[pK]) ? partial[val[pK]] : partial;\n\tif(!isComp && typeof val == bDef.fieldList[bDef._pK].type){\n\t\trelatedRecord = db.cache.getEntity(bDef.def, val);\n\t}\n\telse if(typeof val == \"object\" && !isEntity(val)){\n\t\trelatedRecord = insertIntoStore(db, bDef.def, val, undefined, undefined, newPartial);\t\t\t\t\t\n\t}\n\tif(relatedRecord && relatedRecord.$ && relatedRecord.$.isError){\n\t\tcmpSet(db.lyte, data.$, \"isError\", true);\n\t\tvar errObj = {code:\"ERR24\", message: Dberror.errorCodes.ERR24, data: data, error: relatedRecord.$.error};\n\t\tcmpSet(db.lyte, data.$.error, key, errObj );\n\t}\n\telse if(relatedRecord){\n\t\tif(!hasDuplicateRelation(relatedRecord, data[key], bDef._pK, isPoly ? val._type : undefined, bDef)){\n\t\t\testablishLink(db, rel.forward, rel.backward, data, relatedRecord, undefined, true, false);\t\t\t\t\t\t\t\n\t\t}\n\t}\n\telse{\n\t\taddToRelate(db, fDef._name, data, rel, val);\n\t}\n\treturn true;\n}\n\nfunction singleEstablishLink(forward,data,relatedRecord){\n\tvar relation = relatedRecord.$._relationships , fName = data.$.schema._name , fRelKey = forward.relKey ;\n\trelation[fName] = relation[fName] || {};\n\trelation[fName][fRelKey] = relation[fName][fRelKey] || [];\n\tif(!hasDuplicateRelation(data,relation[fName][fRelKey],data.$.schema._pK, undefined, data.$.schema)){\n\t\trelation[fName][fRelKey].push(data);\n\t}\n}\t\n\nfunction establishLink(db,forward,backward,data,relatedRecord,index,ignorePartial, isDuplicate,partRemoveOnly){\n\tif(!relatedRecord){\n\t\treturn \"ERR13\";\n\t}\n\tif( !checkForCorrectRelation(db, forward, relatedRecord) ){\n\t\treturn \"ERR14\";\n\t}\n\tvar fRelKey = forward.relKey, \n\tlyte = db.lyte,\n\tisPoly = forward.opts && forward.opts.polymorphic, \n\ttype = isPoly ? relatedRecord._type : undefined,\n\tignoreRel = {};\n\tif(forward.relType == \"belongsTo\"){\n\t\tif(data[fRelKey] !== relatedRecord){\n\t\t\tcmpSet( lyte, data, fRelKey, relatedRecord, undefined, true );\n\t\t}\n\t\tif(data.$.partial && Object.keys(data.$.partial).length && data.$.partial[fRelKey]){\n\t\t\tdelete data.$.partial[fRelKey];\n\t\t}\n\t}\n\telse if(forward.relType === \"hasMany\"){\n\t\tif(!data[fRelKey]){\n\t\t\tcmpSet(lyte,data,fRelKey,[],undefined,true);\n\t\t}\n\t\tif(!data[fRelKey].schema){\n\t\t\tvar relDef = relatedRecord.$.schema;\n\t\t\tif(isPoly && type){\n\t\t\t\t_defProp(data[fRelKey], \"polymorphic\", true);\n\t\t\t\trelDef = db.getSchemaObj(relDef.extend);\n\t\t\t}\n\t\t\testablishObsBindings(data,data.$.schema._properties);\n\t\t\tdefArrUtls(data[fRelKey]);\n\t\t\tdefPolyUtls(data[fRelKey]);\n\t\t\tdefUtls(data[fRelKey],relDef,data,fRelKey);\n\t\t}\n\t\tvar mdl = forward ? getSchemaObj(db, forward.relatedTo) : undefined;\n\t\tif( isDuplicate == false || !hasDuplicateRelation(relatedRecord, data[fRelKey], (forward?mdl._pK : undefined),type, mdl) ){\n\t\t\tif(index != undefined){\n\t\t\t\thandleArrOp(db.lyte, data[fRelKey], \"insertAt\", relatedRecord, index);\n\t\t\t\t// if(typeof Lyte.arrayUtils != \"undefined\"){\n\t\t\t\t// \tLyte.arrayUtils(data[fRelKey],\"insertAt\",index,relatedRecord);\t\t\t\t\t\t\n\t\t\t\t// }\n\t\t\t\t// else{\n\t\t\t\t// \tdata[fRelKey].splice(index, 0, relatedRecord);\n\t\t\t\t// }\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\thandleArrOp(db.lyte, data[fRelKey],\"push\",relatedRecord);\n\t\t\t}\n\t\t}\n\t\tvar ret;\n\n\t\tif((!ignorePartial || partRemoveOnly)&& forward.opts && forward.opts.serialize){\n\t\t\tret = partialData(data, fRelKey, relatedRecord, \"added\",undefined,partRemoveOnly);\n\t\t\tignoreRel.relKey = fRelKey;\n\t\t\tignoreRel.model = data.$.schema._name;\n\t\t}\n\t}\n\tvar fnest = false;\n\tif(!ignorePartial){\n\t\tfnest = ret ? false : true;\n\t}\n\t// if(forward == backward){\n\t// \tsingleEstablishLink(forward,data,relatedRecord);\n\t// \treturn true;\n\t// }\n\tif(backward === null){\n\t\tif(relatedRecord.hasOwnProperty(bRelKey)){\n\t\t\tdelete relatedRecord[bRelKey];\n\t\t}\n\t\treturn true;\n\t}\n\tif(backward.dummy || forward == backward){\n\t\tsingleEstablishLink(forward,data,relatedRecord);\n\t}\n\telse{\n\t\tvar bRelKey = backward.relKey, relRecMod = relatedRecord.$.schema;\n\t\tif( !checkForCorrectRelation(db, backward, data) ){\n\t\t\treturn \"ERR14\";\n\t\t}\n\t\tif(backward.relType == \"belongsTo\"){\n\t\t\tif(relatedRecord[bRelKey] != undefined  && relatedRecord[backward.relKey] !== data){\n\t\t\t\ttoDemolishLink(relRecMod, relatedRecord, backward, ignorePartial);\n\t\t\t}\n\t\t\tif(relatedRecord[bRelKey] !== data){\n\t\t\t\tcmpSet(lyte,relatedRecord, bRelKey, data, undefined, true);\n\t\t\t}\n\t\t\tif(relatedRecord.$.partial && Object.keys(relatedRecord.$.partial).length && relatedRecord.$.partial[bRelKey]){\n\t\t\t\tdelete relatedRecord.$.partial[bRelKey];\n\t\t\t}\n\t\t}\n\t\telse if(backward.relType === \"hasMany\"){\n\t\t\tif(!relatedRecord[bRelKey]){\n\t\t\t\tcmpSet(lyte,relatedRecord, bRelKey, [], undefined, true);\n\t\t\t}\n\t\t\tif(!relatedRecord[bRelKey].schema){\n\t\t\t\tdefArrUtls(relatedRecord[bRelKey]);\n\t\t\t\tdefPolyUtls(relatedRecord[bRelKey]);\n\t\t\t\tdefUtls(relatedRecord[bRelKey],data.$.schema,relatedRecord,bRelKey);\n\t\t\t}\n\t\t\tvar bMdl = backward ? getSchemaObj(db, backward.relatedTo) : undefined;\n\t\t\tif( !hasDuplicateRelation(data, relatedRecord[bRelKey], (backward ? bMdl._pK : undefined), type, bMdl) ){\n\t\t\t\thandleArrOp(db.lyte, relatedRecord[bRelKey],\"push\",data);\n\t\t\t}\n\t\t\tvar bret;\n\t\t\tif((!ignorePartial || partRemoveOnly) && backward.opts && backward.opts.serialize){\n\t\t\t\tbret = partialData(relatedRecord, bRelKey, data, \"added\" , undefined,partRemoveOnly);\n\t\t\t}\n\t\t\tvar bnest;\n\t\t\tif(!ignorePartial){\n\t\t\t\tbnest = bret ? false : true;\n\t\t\t}\n\t\t} \n\t}\n\tif(fnest){\n\t\tif(forward && forward.opts && forward.opts.deepNest){\n\t\t\tvar type = \"added\";\n\t\t\tif(data[forward.relKey].partial && data[forward.relKey].partial.get(relatedRecord.$.pK)){\n\t\t\t\ttype = data[forward.relKey].partial.get(relatedRecord.$.pK).type;\n\t\t\t}\n\t\t\tsetDeepNest(data, forward.relKey, relatedRecord.$.pK, \"added\", undefined, relatedRecord);\n\t\t\tbnest = false;\n\t\t}\n\t\t// addDeepNest(relatedRecord, undefined, !ignorePartial ? \"added\" : undefined, ignoreRel);\n\t}\n\tif(bnest){\n\t\tif(backward && backward.opts && backward.opts.deepNest){\n\t\t\tsetDeepNest(relatedRecord, backward.relKey, data.$.pK, \"added\", undefined, data);\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction removeFromStore(def,keys,fromStore,ignorePartial, delayPer, onlyRem, deep, parentRel ,partOnlyRem){\n\tvar data = def.data,\n\tdb = def.db,\n\tlyte = db.lyte;\n\tif(data.length == 0){\n\t\treturn;\n\t}\n\tif(!Array.isArray(keys)){\n\t\tkeys = [keys];\n\t}\n\tvar pKey = def._pK;\n\tfor(var i=0; i<keys.length; i++){\n\t\tvar index = getIndex(data, pKey, keys[i]);\n\t\tif(index == -1){\n\t\t\tcontinue;\n\t\t}\n\t\tvar rec = data[index];\n\t\tvar pK = rec.$.pK;\n\t\tvar relations = def.relations;\n\t\tif(rec.$.isNew){\n\t\t\tonlyRem = delayPer = undefined;\n\t\t\tfromStore = true;\n\t\t} \n\t\tif(relations.size){\n\t\t\ttoDemolishRelation(def, index, ignorePartial, onlyRem, delayPer,partOnlyRem);\t\n\t\t}\n\t\tvar deleted;\n\t\tif(delayPer !== true && onlyRem !== false){\n\t\t\tdeleted = handleArrOp(db.lyte, data,\"removeAt\",undefined,index,1);\n\t\t\tdeep && deleted && deleted.length ? deepRelIter(\"unload\", def, deleted[0], parentRel) : undefined;\n\t\t\tdef.emit(\"remove\", [deleted[0]]);\n\t\t\tdb.emit(\"remove\", [def._name,deleted[0]]);\t\n\t\t\tif(def._properties){\n\t\t\t\tdemoLishObserverBindings(rec, def._properties);\n\t\t\t}\n\t\t}\n\t\tif(fromStore === true){\n\t\t\tcmpSet(lyte, rec.$, \"isUnloaded\", true);\n\t\t\tvar scpObj = rec.$.__scpObj;\n\t\t\tfor(var key in scpObj){\n\t\t\t\tvar sid = scpObj[key];\n\t\t\t\tvar sidArr = sid.split(\"_\");\n\t\t\t\tvar nestObj = nestScp[sidArr[0]];\n\t\t\t\tnestObj ? removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model: def._name, pK:rec.$.pK, attr: key}) : undefined;\n\t\t\t}\n\t\t\tvar cqueries = db.schema.cachedQueries;\n\t\t\tif(cqueries){\n\t\t\t\tvar n=def._name, Nm = cqueries[n]\n\t\t\t\tif(Nm && Nm.length){\n\t\t\t\t\tfor(var j=Nm.length-1; j>=0; j--){\n\t\t\t\t\t\tvar obj = Nm[j];\n\t\t\t\t\t\tif(obj.hasDeletedRecords){\n\t\t\t\t\t\t\tif(obj.data){\n\t\t\t\t\t\t\t\tvar ind = obj.data[n].indexOf(rec);\n\t\t\t\t\t\t\t\tif(ind !== -1){\n\t\t\t\t\t\t\t\t\tNm.splice(j,1);\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(onlyRem == true){\n\t\t\tcontinue;\n\t\t}\n\t\tvar remRec = deleted ? deleted[0] : rec;\n\t\tif(!fromStore){\n\t\t\tcmpSet( lyte, remRec.$, \"isDeleted\", true);\n\t\t\tchangePersist(remRec, true);\n\t\t\t// deleted[0].$.isDeleted = true;\n\t\t\tif((delayPer !== true && onlyRem !== false) && (remRec.$.isNew || remRec.$.isModified)){\n\t\t\t\tdeleteFromArray(def.dirty, remRec.$.pK);\n\t\t\t}\n\t\t\tif(!remRec.$.isNew){\n\t\t\t\taddTo_Del(def, remRec, index);\n\t\t\t\t// model._deleted.push(deleted[0]);\n\t\t\t}\n\t\t\tvar cqueries = db.schema.cachedQueries;\t\t\n\t\t\tif(cqueries){\n\t\t\t\tvar n=def._name, Nm = cqueries[n];\n\t\t\t\tif(Nm && Nm.length){\n\t\t\t\t\tfor(var j=Nm.length-1; j>=0; j--){\n\t\t\t\t\t\tvar obj = Nm[j];\n\t\t\t\t\t\tif(obj && obj.data){\n\t\t\t\t\t\t\tvar ind = obj.data[n].indexOf(rec);\n\t\t\t\t\t\t\tif(ind != -1){\n\t\t\t\t\t\t\t\tobj.hasDeletedRecords = true;\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar ind;\n\t\tif(Array.isArray(def.dirty) && (ind = def.dirty.indexOf(pK)) != -1){\n\t\t\tdef.dirty.splice(ind, 1);\n\t\t}\n\t}\n}\n\nfunction toDemolishRelation(def,index,ignorePartial,onlyRem,delayPers,partOnlyRem){\n\tvar record = def.data[index], \n\trelations = def.relations,\n\tdb = def.db;\n\trelations.forEach(function(rel, key){\n\t\tfor(var i=0; i<rel.length; i++){\n\t\t\tvar relation = rel[i],\n\t\t\trelDef = getSchemaObj(db, relation.relatedTo);\n\t\t\tif(relDef){\n\t\t\t\tvar relPriKey = relDef._pK, \n\t\t\t\trelkey = relation.relKey;\n\t\t\t\t// if(def._name == relDef._name){\n\t\t\t\t// \tvar data = relDef.data,index1,index2;\n\t\t\t\t// \tfor(index1=0 ; index1<data.length; index1++){\n\t\t\t\t// \t\tvar item=data[index1];\n\t\t\t\t// \t\tif(Array.isArray(item[relkey])){\n\t\t\t\t// \t\t\tfor(var index2=0;index2<item[relkey].length;index2++){\n\t\t\t\t// \t\t\t\tvar value = item[relkey][index2];\n\t\t\t\t// \t\t\t\tif(value[relPriKey] == record[relPriKey] && onlyRem !== false)\n\t\t\t\t// \t\t\t\t{\n\t\t\t\t// \t\t\t\t\thandleArrOp(db.lyte, item[relkey],\"removeAt\",undefined,index2,1);\n\t\t\t\t// \t\t\t\t}\n\t\t\t\t// \t\t\t}\n\t\t\t\t// \t\t}\n\t\t\t\t// \t\telse if (isEntity(item[relkey])){\n\t\t\t\t// \t\t\tif(item[relkey][relPriKey] == record[relPriKey] && onlyRem !== false)\n\t\t\t\t// \t\t\t\t{\n\t\t\t\t// \t\t\t\t\titem[relkey] = undefined ;\n\t\t\t\t// \t\t\t\t}\n\t\t\t\t// \t\t}\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t\tif(!record[relation.relKey] && !relation.dummy){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttoDemolishLink(def, record, relation, ignorePartial, onlyRem, delayPers,partOnlyRem);\n\t\t\t}\n\t\t}\t\t\n\t});\n}\n\nfunction toDemolishLink(def,record,relation,ignorePartial,onlyRem,delayPers,partOnlyRem){\n\tvar db = def.db,\n\trecords = record[relation.relKey], \n\tpriKey = def._pK,  \n\trelDef = relation.relatedTo;\n\tif(!relDef){\n\t\treturn;\n\t}\n\tvar bRelation = getBackwardRel(def, relation, getSchemaObj(db, relDef));\n\tif(relation.dummy || (relation == bRelation)){\n\t\trecords = getRelatedRecord(record,getSchemaObj(db, relation.relatedTo),relation.dummy);\n\t}\n\tif(bRelation){\n\t\tif(Array.isArray(records)){\n\t\t\tfor(var i=0; i<records.length; i++){\n\t\t\t\tdemolishLink(db, record, priKey, records[i], bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers,partOnlyRem);\n\t\t\t} \n\t\t}\n\t\telse if(isEntity(records)){\n\t\t\tdemolishLink(db, record, priKey, records, bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers,partOnlyRem);\n\t\t}\n\t}\n}\n\nfunction demolishSingleRelation(record,fName,key,relatedRecord,priKey,onlyRem,delayPers){\n\tvar arr,index;\n\tif(isEntity(record)){\n\t\tarr = record.$._relationships;\n\t\tif(arr && arr[fName] && arr[fName][key] && (onlyRem !== false && delayPers !== true)){\n\t\t\tarr = arr[fName][key];\n\t\t\tindex = getIndex(arr,priKey,relatedRecord[priKey]);\n\t\t\tif(index > -1){\n\t\t\t\tarr.splice(index,1);\n\t\t\t}\n\t\t}\n\t}\n} \n\nfunction demolishLink(db, record, priKey, relatedRecord, bRelKey, relation, bRelation, ignorePartial, ignoreAttrCheck, onlyRem, delayPers, partOnlyRem){\n\tvar links = relatedRecord[bRelKey], \n\trelMod = relatedRecord.$.schema,\n\tlyte = relMod.Lyte,\n\tpK = record.$.pK, \n\tpoly = links ? links.polymorphic : undefined, \n\tpolymorphicType;\n\tif(Array.isArray(links)){\n\t\tvar ind = getIndex(links, priKey, pK, poly ? record._type : undefined), \n\t\t_attrs = relatedRecord.$._attributes, \n\t\tinitialVal = _attrs.hasOwnProperty(bRelKey) && _attrs[bRelKey] && _attrs[bRelKey].size  ? relatedRecord.$.getInitialValues(bRelKey) : undefined, \n\t\ttoRem = links.partial && links.partial.has(record) && links.partial.get(record).type == \"added\" ? true : false;\n\t\tif(ind != -1 && (toRem || (onlyRem !== false && delayPers !== true))){\n\t\t\tpoly ? polymorphicType = links[ind].$.schema._name : undefined;\n\t\t\thandleArrOp(lyte, relatedRecord[bRelKey],\"removeAt\",undefined,ind,1);\n\t\t}\n\t\tif(!ignoreAttrCheck && initialVal){\n\t\t\tif(!hasRecordsArrayChanged(relatedRecord, bRelKey, initialVal)){\n\t\t\t\t   delete relatedRecord.$._attributes[bRelKey];\n\t\t\t\t   if(!Object.keys(relatedRecord.$._attributes).length){\n\t\t\t\t\t//    changeModified(lyte, relatedRecord, false, relatedRecord.$.pK)\n\t\t\t\t\t   cmpSet(lyte, relatedRecord.$, \"isModified\", false);\n\t\t\t\t\t   changePersist(relatedRecord, true);\n\t\t\t\t\t   if(!relatedRecord.$.isNew){\n\t\t\t\t\t\t   deleteFromArray(relMod.dirty, relatedRecord[relMod._pK]);\n\t\t\t\t\t\t   if(!relatedRecord.$.dN || (relatedRecord.$.dN && !Object.keys(relatedRecord.$.dN).length)){\n\t\t\t\t\t\t\tremoveParentNesting(relatedRecord);\n\t\t\t\t\t\t}\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if( links && (typeof links == \"object\" || isEntity(links)) && (onlyRem !== false && delayPers !== true) ){\n\t\tif(lyte != undefined && lyte.objectUtils != undefined){\n\t\t\tlyte.objectUtils(relatedRecord, \"delete\", bRelKey, undefined, undefined, true);\n\t\t}\n\t\telse {\n\t\t\tdelete relatedRecord[bRelKey];\n\t\t}\n\t}\n\telse{\n\t\tdemolishSingleRelation(relatedRecord,record.$.schema._name,relation.relKey,record,priKey, onlyRem, delayPers);\n\t}\n\tif(!bRelation){\n\t\tbRelation = relMod.fieldList[bRelKey];\n\t}\n\tif((!ignorePartial || partOnlyRem )&& onlyRem !== true){\n\t\tvar relType, isPartial, ret, nest, serz;\n\t\tif(bRelation){\n\t\t\tif(bRelation.opts){\n\t\t\t\tisPartial = bRelation.opts.serialize == \"partial\";\n\t\t\t\tserz = bRelation.opts.serialize ? true : false;\n\t\t\t\tnest = bRelation.opts.deepNest;\n\t\t\t}\n\t\t\tvar relType = bRelation ? bRelation.relType : undefined;\n\t\t}\n\t\t// if(delayPers && bRelation && bRelation.opts && /^(id|record)$/.test(bRelation.opts.serialize)){\n\t\t// \treturn;\n\t\t// }\n\t\tif(relType == \"belongsTo\" && serz && !record.$.isNew){\n\t\t\tvar partObj = relatedRecord.$.partial = relatedRecord.$.partial || {};\n\t\t\tpartObj = partObj[bRelKey] = partObj[bRelKey] || new Map();\n\t\t\tif(!partObj.has(record)){\n\t\t\t\tpartObj.set(record, {});\n\t\t\t}\n\t\t\tpartObj = partObj.get(record);\n\t\t\tpartObj.type = \"removed\";\n\t\t}\n\t\tif(bRelation && bRelation.opts && bRelation.opts.serialize){\n\t\t\tret = partialData(relatedRecord, bRelKey, record, \"removed\", polymorphicType ,partOnlyRem);\n\t\t\tnest = ret && relType == \"hasMany\" ? false : nest;\n\t\t}\n\t\tif(nest == true){\n\t\t\tmakeDirty(relatedRecord, \"removed\", bRelation, pK, undefined, record);\n\t\t\taddDeepNest(relatedRecord);\n\t\t}\n\t}\n\tif(ignorePartial){\n\t\tif(bRelation && bRelation.opts && bRelation.opts.serialize){\n\t\t\tpartialData(relatedRecord, bRelKey, record, \"delete\", polymorphicType);\n\t\t\tvar _attrs = relatedRecord.$._attributes, _attr = _attrs[bRelKey];\n\t\t\tif(_attr && _attr.size && _attr.get(record)){\n\t\t\t\t_attr.delete(record);\n\t\t\t}\n\t\t\tif(_attr && _attr.size){\n\t\t\t\tdelete relatedRecord.$._attributes[bRelKey];\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction validateAndMerge(def, data, partialObj, mergeErr, ignoreStrict){\n\tvar db = def.db;\n\tif(!def.rel){\n\t\tdef.rel  = {};\n\t}\n\tvar pkVal = getpKVal(data, def);\n\tif(pkVal === undefined){\n\t\treturn { type:\"error\", args:[\"LD28\", def._name, isEntity(data) ? data : JSON.stringify(data)]};\t\t\t\t\n\t}\n\n\tvar record = db.cache.getEntity(def.def, getpKVal(data, def));\n\tif(!record || !isEntity(record)){\n\t\treturn { type:\"error\", args:[\"LD04\",isEntity(data) ? data : JSON.stringify(data)]};\n\t}\n\tif(!ignoreStrict && record.$.strict && (record.$.isNew || record.$.isModified || record.$.isDeleted)){\n\t\treturn { type:\"error\", args:[\"LD29\"]};\n\t}\n\tmergeData(db, record, data, partialObj, mergeErr);\n\tif(def.didLoad){\n\t\tvar callBack = def.didLoad;\n\t\tfor(var i=0;i<callBack.length;i++){\n\t\t\tcallBack[i].apply(record);\t\t\t\t\n\t\t}\n\t}\n\treturn { data : record};\n}\n\nfunction mergeData(db,record,data,partialObj,mergeErr){\n\tif(!record || !data){\n\t\treturn;\n\t}\n\tvar def = record.$.schema, field, _estObsBind = false;\n\tif(mergeErr){\n\t\tmergeError(def, record, data);\n\t}\n\tfor(var key in data){\n\t\tfield = def.fieldList[key];\n\t\tif(field){\n\t\t\tif(field.type != \"relation\"){\n\t\t\t\tvar empD = getDsrzEmpData(def, field, def._name);\n\t\t\t\tvar boolChk = !empD && data[key]\n\t\t\t\tif(data.hasOwnProperty(key) && (boolChk || empD) && db.dataType.hasOwnProperty(field.type) && db.dataType[field.type].hasOwnProperty(\"deserialize\")){\n\t\t\t\t\tdata[key] = db.dataType[field.type].deserialize(data[key],key,def._name,getpKVal(data,def));\n\t\t\t\t}\n\t\t\t\tvar isPropPresent = def._properties && def._properties.hasOwnProperty(key), propObj = {};\n\t\t\t\tif(isPropPresent){\n\t\t\t\t\tpropObj[key] = def._properties[key];\n\t\t\t\t\tdemoLishObserverBindings(record, propObj);\n\t\t\t\t}\n\t\t\t\tcmpSet(db.lyte,record,key,data[key],undefined,true);\n\t\t\t\tdef._properties && def._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;\n\t\t\t}\n\t\t\telse if(field && field.type == \"relation\"){\n\t\t\t\tvar todo = {};\n\t\t\t\tvar rel = {};\n\t\t\t\tgetRelations(db, record.$.schema, key, getSchemaObj(db, field.relatedTo), rel);\n\t\t\t\tvar bMod = rel.forward.relatedTo;\n\t\t\t\tvar result = compareRelations(db, record,data,key,field,partialObj ? partialObj[key] : undefined ,todo, mergeErr);\n\t\t\t\tmergeRecords(db, todo, result, def, getSchemaObj(db, bMod), record, key, data, rel, partialObj, mergeErr);\n\t\t\t}\n\t\t}\n\t\telse if(key != \"$\"){\n\t\t\tcmpSet( db.lyte,record,key,data[key],undefined, true );\n\t\t}\n\t}\n\tif(_estObsBind){\n\t\testablishObsBindings(record, def._properties);\n\t}\n}\n\nfunction mergeRecords(db, todo, result, def, bMod, record, key, data, rel, partialObj, mergeErr){\n\tif(!rel){\n\t\tvar rel = {};\n\t\tgetRelations(db, def, key, bMod, rel);\t\n\t}\n\tvar pK = def._pK;\n\tif(rel.forward.relType == \"hasMany\" && isEmptyArray(data[key])){\n\t\tcmpSet(db.lyte, record, key, [], undefined, true);\n\t\testablishObsBindings(record,record.$.schema._properties);\n\t\tdefArrUtls(record[key]);\n\t\tdefPolyUtls(record[key]);\n\t\tdefUtls(record[key],bMod,record,key);\n\t}\n\tif(Array.isArray(todo.add)){\n\t\ttodo.add.forEach(function(item){\n\t\t\tcreateAndRelate(def.db, def, bMod, record, key, item, rel, partialObj);\n\t\t});\n\t}\n\tif(Array.isArray(todo.remove)){\n\t\ttodo.remove.forEach(function(obj){\n\t\t\tvar pkVal = obj.pK, schemaName = obj.schema, _def = db.getSchema(schemaName);\n\t\t\tdemolishLink(db, record, pK, db.cache.getEntity(_def, pkVal), rel.backward.relKey,  rel.forward, rel.backward, true); \n\t\t\tdemolishLink(db, db.cache.getEntity(_def, pkVal), db.getSchemaObj(schemaName)._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); \n\t\t});\n\t}\n\tif(record && record.hasOwnProperty(key)){\n\t\tdeleteDeepNest(record, key);\n\t\tif(Array.isArray(record[key]) && record[key].hasOwnProperty(\"partial\")){\n\t\t\tvar partObj = record[key].partial, partKeys = [];\n\t\t\tpartObj.forEach(function(value, partKey){\n\t\t\t\tpartKeys.push(partKey);\n\t\t\t\trecord[key].partial.delete(partKey);\n\t\t\t});\n\t\t}\n\t}\n\tswitch(result){\n\t\tcase 0:{\n\t\t\tif(isEntity(record[key])){\n\t\t\t\tdemolishLink(db, record, pK, record[key], rel.backward.relKey, rel.forward, rel.backward, true); \n\t\t\t\tdemolishLink(db, record[key], bMod._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); \t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tcreateAndRelate(def.db, def, bMod, record, key, data[key], rel, partialObj);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:{\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:{\n\t\t\tmergeData(db,record[key],data[key],undefined,mergeErr);\n\t\t\tbreak;\n\t\t}\n\t\tdefault : break;    \n\t}\n}\n\nfunction compareRelations(db,record,data,key,field,partialObj,todo,mergeErr){\n\t//return 0 - not same, 1 -same, 2 - merge, 3 - partial add, 4 - delete and partial add\n\tvar def = getSchemaObj(db, field.relatedTo), \n\tpK = def._pK, \n\tresult = [];\n\tif(field.relType == \"belongsTo\"){\n\t\tif(partialObj && partialObj.$.type === \"removed\" && (!data || (data && comparePk(record, getpKVal(data, def))))){\n\t\t\treturn 1;\n\t\t}\n\t\treturn compareRecordWithObj(record[key],data[key],pK, partialObj,mergeErr);\n\t}else{\n\t\tvar isPartial = false;\n\t\tif((partialObj && partialObj.partial)){\n\t\t\tisPartial = true;\n\t\t}\n\t\tif(!isPartial && (!record.hasOwnProperty(key) || (record && record.hasOwnProperty(key) && (isEmpty(record[key]) || isEmptyArray(record[key]))))){\n\t\t\tif(todo){\n\t\t\t\tvar arr = data[key] || [];\n\t\t\t\tarr.forEach(function(item){\n\t\t\t\t\tvar add = todo.add = todo.add || [];\n\t\t\t\t\tadd.push(item);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvar len = data[key] ? data[key].length : 0,\n\t\told=0,\n\t\tstatus=1,\n\t\toldPks = [];\n\t\tfor(var i=0;i<len;i++){\n\t\t\tvar obj = data[key][i];\n\t\t\tif(partialObj && partialObj[i] && partialObj[i].$.type == \"removed\"){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar ind = getIndex(record[key], pK, (typeof obj == \"object\") ? getpKVal(obj,def) : obj);\n\t\t\tif(ind == -1){\n\t\t\t\tif(todo){\n\t\t\t\t\tvar add = todo.add = todo.add || [];\n\t\t\t\t\tadd.push(obj);\n\t\t\t\t}\n\t\t\t\tstatus = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toldPks.push(record[key][ind].$.pK);\n\t\t\tvar res = compareRecordWithObj(record[key][ind],obj,pK,partialObj ? partialObj[i] : undefined,mergeErr);\n\t\t\tif(res == 1){\n\t\t\t\told++;\n\t\t\t}\n\t\t\tif(res == 2){\n\t\t\t\tmergeData(db,record[key][ind],obj, partialObj ? partialObj[i] : undefined, mergeErr);\n\t\t\t}\n\t\t\telse if(res == 0){\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t}\n\t\tif(todo && !isPartial){\n\t\t\tvar arr = record[key] || [];\n\t\t\tarr.forEach(function(item){\n\t\t\t\tvar pkVal = item.$.pK;\n\t\t\t\tif(oldPks.indexOf(pkVal) == -1){\n\t\t\t\t\tvar remove = todo.remove = todo.remove || [];\n\t\t\t\t\tremove.push({pK: pkVal, schema: item.$.schema._name});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction compareRecordWithObj(rec,obj,pK,partialObj, mergeErr){\n\tif( !rec || !isEntity(rec) ){\n\t\treturn 0;\n\t}\n\tvar recDef = rec.$.schema, \n\tdb = recDef.db,\n\tisComp = recDef.isComp, \n\trecFields = recDef.fieldList;\n\tif(!isComp) {\n\t\tvar field = recDef.fieldList[pK];\n\t\tif(typeof obj == field.type ){\n\t\t\tif(rec[pK] == obj){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif(obj && typeof obj == \"object\"){\n\t\tif(!comparePk(rec, getpKVal(obj, recDef))){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(var data_key in obj){\n\t\t\tvar field = recFields[data_key];\n\t\t\tif(field){\n\t\t\t\tif(field.type == \"relation\"){\n\t\t\t\t\tvar todo = {};\n\t\t\t\t\tvar res = compareRelations(db, rec, obj, data_key, field, partialObj ? partialObj[data_key] : undefined, todo, mergeErr);\n\t\t\t\t\tmergeRecords(db, todo, res, recDef, getSchemaObj(db, field.relatedTo), rec, data_key, obj, undefined, partialObj);\n\t\t\t\t}\n\t\t\t\telse if(rec[data_key] != obj[data_key]){\n\t\t\t\t\treturn 2;\n\t\t\t\t}                    \n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(rec[data_key] != obj[data_key]){\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction rllBckRecArr(db, oldVal, ins, def, field){\n\tvar rel = {}, \n\tpK = def._pK,\n\tbDef = getSchemaObj(db, field.relatedTo),\n\trelPK = bDef._pK;\n\tgetRelations(db, def, field.relKey, bDef, rel);\n\tif(oldVal.size){\n\t\tvar keys = Array.from(oldVal.keys()).reverse();\n\t\tvar self = this;\n\t\tkeys.forEach(function(itm, idx){\n\t\t\tvar val = oldVal.get(itm);\n\t\t\tif(val._type == \"added\"){\n\t\t\t\tvar relatedRecord = itm;\n\t\t\t\tif(!relatedRecord.$.isUnloaded){\n\t\t\t\t\tdemolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey, rel.forward);\n\t\t\t\t\tif(rel.backward != null){\n\t\t\t\t\t\tdemolishLink(db, ins, pK, relatedRecord, rel.backward.relKey, rel.forward);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(val._type == \"removed\"){\n\t\t\t\tvar relatedRecord = itm;\n\t\t\t\tif(!relatedRecord.$.isUnloaded){\n\t\t\t\t\testablishLink(db, rel.forward, rel.backward, ins, relatedRecord, val.index);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t});\n\t}\n\telse{\n\t\tfor(var i=oldVal.length-1; i>=0; i--){\n\t\t\tvar records = oldVal[i].records;\n\t\t\tif(oldVal[i]._type == \"added\"){\n\t\t\t\tfor(var j=0; j<records.length; j++){\n\t\t\t\t\tvar relatedRecord = records[j];\n\t\t\t\t\tif(recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store\n\t\t\t\t\t\tdemolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey);\n\t\t\t\t\t\tif(rel.backward != null){\n\t\t\t\t\t\t\tdemolishLink(db, ins, pK, relatedRecord, rel.backward.relKey, rel.forward);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(oldVal[i]._type == \"removed\"){\n\t\t\t\tfor(var j=records.length-1; j>=0; j--){\n\t\t\t\t\tvar relatedRecord = records[j];\n\t\t\t\t\tif(recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store\n\t\t\t\t\t\testablishLink(db, rel.forward, rel.backward, ins, relatedRecord, oldVal[i]._indices[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(oldVal[i]._type == \"changed\"){\n\t\t\t\tvar currentRecords = ins[field.relKey];\n\t\t\t\tif(!Array.isArray(currentRecords)){\n\t\t\t\t\tcurrentRecords = [currentRecords]; \n\t\t\t\t}\n\t\t\t\tvar self = this;\n\t\t\t\tvar kLen = currentRecords.length;\n\t\t\t\tfor(var k=0; k<kLen; k++){\n\t\t\t\t\tvar relatedRecord = currentRecords[0];\n\t\t\t\t\tif(relatedRecord != undefined && recChk(db.lyte, relatedRecord)){\n\t\t\t\t\t\tdemolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey);\n\t\t\t\t\t\tif(rel.backward != null){\n\t\t\t\t\t\t\tdemolishLink(db, ins, pK, relatedRecord, rel.backward.relKey,rel.forward);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!Array.isArray(records)){\n\t\t\t\t\trecords = [records];\n\t\t\t\t}\n\t\t\t\tfor(var j=0; j<records.length; j++){\n\t\t\t\t\tvar relatedRecord = records[j];\n\t\t\t\t\tif(typeof relatedRecord == \"string\"){\n\t\t\t\t\t\trelatedRecord = db.cache.getEntity(rel.forward.relatedTo,relatedRecord);\n\t\t\t\t\t}\n\t\t\t\t\tif(relatedRecord != undefined && recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store\n\t\t\t\t\t\testablishLink(db, rel.forward, rel.backward, ins, relatedRecord, undefined);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction sortBy(field, order){\n\tvar fieldArr = mapBy.call(this, field),\n\tdef = this.schema;\n\tvar fie = def.fieldList[field];\n\tif(fie && fie.type == \"string\"){\n\t\tfieldArr.sort();\n\t\tif(order == \"desc\"){\n\t\t\tfieldArr.reverse();\n\t\t}                \n\t}\n\telse{\n\t\tfieldArr.sort(function(a,b){return a-b;});\n\t\tif(order == \"desc\"){\n\t\t\tfieldArr.sort(function(a,b){return b-a;});\n\t\t}\n\t}\n\tvar oldArr = this.slice(0), newArr = [];\n\tfor(var i=0; i<fieldArr.length; i++){\n\t\tif(fieldArr[i] == undefined){\n\t\t\tcontinue;\n\t\t}\n\t\tvar index = getIndex(oldArr, field, fieldArr[i]);\n\t\tnewArr.push(oldArr[index]);\n\t\toldArr.splice(index, 1);\n\t}\n\tif(oldArr.length > 0){\n\t\tif(order == \"desc\"){\n\t\t\tnewArr = newArr.concat(oldArr);\n\t\t}\n\t\telse{\n\t\t\tnewArr = oldArr.concat(newArr);\n\t\t}\t\t\t\t\n\t}\n\tdefArrUtls(newArr);\n\tdefUtls(newArr,this.schema);\n\treturn newArr;\n}\n\nfunction mapBy(field){\n\treturn this.map(function(value){\n\t\treturn value.$.get(field);\n\t});\n}\n\nfunction revertToOldVal(ins, attr, oldVal, rel){\n\tif(oldVal == undefined || oldVal.length == 0){\n\t\treturn;\n\t}\n\telse{\n\t\tif(!Array.isArray(oldVal)){\n\t\t\toldVal = [oldVal];\n\t\t}\n\t\tfor(var i =0; i<oldVal.length; i++){\n\t\t\tvar fRec = oldVal[i];\n\t\t\testablishLink(ins.$.schema.db, rel.forward, rel.backward, ins, fRec, undefined);\n\t\t}\n\t}\n}\n\nfunction removePartial(ins, key){\n\tvar parObj = ins.$.partial;\n\tif(parObj && parObj[key] ){\n\t\tdelete parObj[key];\n\t}\n}\n\nfunction rollBackDelete(def, pkVal, index){\n\tvar arr = [], db = def.db;\n\tif(!pkVal){\n\t\tdef._deleted.forEach(function(itm){\n\t\t\tarr.push(itm);\n\t\t});\n\t}\n\telse{\n\t\tvar deleted = def._deleted, obj = deleted.get(pkVal), pK = def._pK;\n\t\tarr = [obj];\n\t}\n\tvar len = arr.length;\n\tfor(var i=len-1;i>=0;i--){\n\t\tvar obj = arr[i];\n\t\tvar rec = obj.data;\n\t\t//var currentInd = findCurrentInd(model, pkVal);\n\t\tvar isRecInDef = def.data._recMap ? def.data._recMap.get(rec.$.pK) : (def.data.indexOf(rec) !== -1) ;\n\t\tif(isEntity(rec)){\n\t\t\tcmpSet(db.lyte, rec.$, \"isDeleted\", false);\n\t\t\tchangePersist(rec, true);\n\t\t\tvar isDuplicate = isDuplicateEntity(def, rec);\n\t\t\tif(!isRecInDef){\n\t\t\t\tif(index){\n\t\t\t\t\thandleArrOp(db.lyte, def.data,\"insertAt\",rec,obj.index);\n\t\t\t\t\t// db.$.modifyDelInd(model, pkVal);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\thandleArrOp(db.lyte, def.data,\"push\",rec);\n\t\t\t\t}\n\t\t\t\tdef.emit(\"add\", [rec]);\n\t\t\t\tdb.emit(\"add\", [def._name,rec]);\t\n\t\t\t\tvar relArr = def.relations;\n\t\t\t\tif(relArr){\n\t\t\t\t\trollBackDeleteRel(db, def, rec, relArr);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tremoveParentNesting(rec);\n\t\t\t\taddDeepNest(rec, undefined, \"added\");\n\t\t\t}\n\t\t\t// else{\n\t\t\t// \tLyte.error(\"Cannot rollback record of model, since another instance of same record exists in store\");\n\t\t\t// }\n\t\t\tvar cqueries = db.schema.cachedQueries;\t\n\t\t\tif(cqueries){\n\t\t\t\tvar n=def._name, Nm = cqueries[n];\n\t\t\t\tif(Nm && Nm.length){\n\t\t\t\t\tfor(var j=Nm.length-1; j>=0; j--){\n\t\t\t\t\t\tvar obj = Nm[j];\n\t\t\t\t\t\tif(obj && obj.hasDeletedRecords){\n\t\t\t\t\t\t\tvar ind = obj.data[n].indexOf(rec);\n\t\t\t\t\t\t\tif(ind != -1){\n\t\t\t\t\t\t\t\tdelete obj.hasDeletedRecords;\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rec.$.isNew || rec.$.isModified){\n\t\t\t\tcheckAndAddToArray(def.dirty, rec[def._pK]);\n\t\t\t}\n\t\t\tValidationError.clrRecErr(rec.$, pK, \"ERR17\");\n\t\t\t!isDuplicate ? def.data._recMap.set(typeof rec.$.pK == \"object\" ? rec.$.pK : rec.$.pK.toString(), rec) : undefined; //old handling\n\t\t\tdef._deleted.delete(rec.$.pK);\n\t\t}\n\t}\n}\n\nfunction rollBackDeleteRel(db, def, rec, relArr){\n\trelArr.forEach(function(rel){\n\t\tvar rLen = rel.length;\n\t\tfor(var j=0;j<rLen;j++){\n\t\t\tvar item = rel[j];\n\t\t\tvar key = item.relKey, bRel, bMod;\n\t\t\t//if(rec.hasOwnProperty(key)){\n\t\t\t\tbMod = item.relatedTo;\n\t\t\t\tbRel = getBackwardRel(def,item,getSchemaObj(db, bMod));\n\t\t\t\tvar data = rec[key];\n\t\t\t\tif(!item.relKey || (item == bRel)){\n\t\t\t\t\tdata = getRelatedRecord(rec,getSchemaObj(db , item.relatedTo),item.dummy?item.dummy:item.relKey)\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdata = rec[item.relKey];\n\t\t\t\t}\n\t\t\t\tif(Array.isArray(data)){\n\t\t\t\t\tvar dLen = data.length;\n\t\t\t\t\tfor(var k=0; k<dLen; k++){\n\t\t\t\t\t\tif(item == bRel){\n\t\t\t\t\t\t\testablishLink(db,bRel,item,data[k],rec,undefined,false)\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\testablishLink(db,item,bRel,rec,data[k],undefined,false);\t\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(item == bRel){\n\t\t\t\t\t\testablishLink(db,bRel,item,data,rec,undefined,false)\n\t\t\t\t\t}else{\n\t\t\t\t\t\testablishLink(db,item,bRel,rec,data,undefined,false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//}\n\t\t}\t\t\t\t\t\t\n\t});\n}\nfunction rollBackNew(def, record, pK){\n\tremoveFromStore(def, record.$.pK, true);\n\t// var pkVal = record.$.pK;\n\t// var index = this.getIndex(model.data, pK, pkVal);\n\t// store.$.toDemolishRelation(model, index);\n\t// this.handleArrOp(model.data,\"removeAt\",undefined,index,1);\n\t// // record.$.isNew = false;\n\t// store.$.cmpSet(record.$, \"isNew\", false);\n\t// store.$.cmpSet(record, \"$\",  {});\n\t// model.emit(\"remove\", [record]);\n\t// store.emit(\"remove\", [model._name,record]);\n\n}\n\nfunction emit(db, type, record, attr, err){\n\trecord.$.emit(type, [record,attr,err]);\n\trecord.$.schema.emit(type, [record, attr, err]);\n\tdb.emit(type, [record.$.schema._name, record, attr, err]);\n}\n\nfunction hasRecordsArrayChanged(record, attr, old){\n\tvar arr = old || record.$.getInitialValues(attr), \n\tchanged = true;\n\tif(arr && arr.length == record[attr].length){\n\t\tchanged = false;\n\t\tfor(var i=0; i<arr.length; i++){\n\t\t\tif(record[attr].indexOf(arr[i]) == -1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn changed;\n}\n\nfunction cacheQuery(db, name, cacheQuery, data, status){\n    var cq = db.schema.cachedQueries;\n    cq = db.schema.cachedQueries = cq || {};\n    cq = cq[name] = cq[name] || [];\n    cq.push({cacheQuery : cacheQuery, data : data, status : status});\n}\n\nfunction cacheRecordQuery(db, name, key, cacheQuery, data, status){\n    var crq = db.schema.cachedRecordQueries;\n    crq = db.schema.cachedRecordQueries = crq || {};\n    crq = crq[name] = crq[name] || {};\n    crq = crq[key] = crq[key] || [];\n    crq.push({cacheQuery : cacheQuery, data : data, status : status});\n}\n\nfunction isDefData(data){\n    if(Array.isArray(data) && (data.schemaless || (data.schema && data.schema.__class === Schema && !data.polymorphic))){\n        return true;\n    } \n}\n\nfunction handleArrOp(lyte,data,type,obj,pos,len){\n    len = len != undefined ? len : 0;\n    // var toBind = typeof lyte.arrayUtils != \"undefined\" ? true : false, \n\tvar ret;\n    switch(type){\n        case \"push\": {\n            if(isDefData(data)){\n                data._recMap == undefined ? _defProp(data, \"_recMap\", new Map()) : undefined;\n\t\t\t\tif(!data.schemaless){\n\t\t\t\t\tdata._recMap.set(typeof obj.$.pK == \"object\" ? obj.$.pK : obj.$.pK.toString(), obj);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdata._recMap.set(obj[data.pK], obj);\t\t\t\t\t\n\t\t\t\t}\n            }\n\t\t\tret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, \"push\", obj) : data.push(obj);\n            break;\n        }\n        case \"removeAt\": {\n            if(isDefData(data)){\n                var cpyLen = len;\n                for(var i=0;i<cpyLen;i++){\n\t\t\t\t\tvar mpKey = undefined;\n\t\t\t\t\tif(!data.schemaless){\n\t\t\t\t\t\tvar pkVal = data[pos+i] ? data[pos+i].$.pK : undefined;\n\t\t\t\t\t\tpkVal = ((typeof pkVal == \"object\") ? pkVal : pkVal.toString());\n\t\t\t\t\t\tmpKey = pkVal;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmpKey = data[pos+i][data.pK];\n\t\t\t\t\t}\n                    mpKey !== undefined && data._recMap ? data._recMap.delete(mpKey) : undefined;\n                }\n            }\n            // ret =  data.$splice ? data.$splice(pos,len) : data.splice(pos,len);\n\t\t\tret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, \"splice\", pos, len) : data.splice(pos,len);\n            break;\n        }\n        case \"insertAt\": {\n            if(isDefData(data)){\n                data._recMap == undefined ? _defProp(data, \"_recMap\", new Map()) : undefined;\n\t\t\t\tif(!data.schemaless){\n\t\t\t\t\tdata._recMap.set(typeof obj.$.pK == \"object\" ? obj.$.pK : obj.$.pK.toString(), obj);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdata._recMap.set(obj[data.pK], obj);\t\t\t\t\t\n\t\t\t\t}\n            }\n            // ret = data.$splice ? data.$splice(pos,len,obj) : data.splice(pos,len,obj);\n\t\t\tret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, \"splice\", pos, len, obj) : data.splice(pos, len, obj);\n            break;\n        }\n        case \"replaceAt\": {\n            // ret = data.$splice ? data.splice(pos,len,obj) : data.splice(pos,len,obj);\n\t\t\tret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, \"splice\", pos, 1, obj) : data.splice(pos, 1, obj);\n\t\t\tbreak;\n        }\n        default: {\n            Dberror.error(lyte,\"LD07\", type);\n            break;\n        }\n    }\n    return ret;\n}\n\nfunction defArrUtls(obj){\n    Object.defineProperties(obj, {\n        filterBy : {\n            value : filterBy\n        },\n        sortBy : {\n            value : sortBy\n        },\n        mapBy : {\n            value : mapBy\n        }\n    });\n}\n\nfunction defPolyUtls(obj){\n    Object.defineProperties(obj,{\n        add : {\n            value : add\n        },\n        remove : {\n            value : remove\n        }\n    })\n}\n\nfunction defUtls(obj,def,ins,key){\n    if(def){\n        _defProp(obj, \"schema\", def);\n    }\n    if(ins){\n        _defProp(obj, \"entity\", ins, false, true);\n    }\n    if(key){\n        _defProp(obj, \"key\", key);\n    }\n}\n\nfunction defPar(arr){\n    _defProp(arr, \"partial\", new Map());\n}\n\nfunction cmpSet(lyte, obj, key, value, opts, fromStore){\n    if(lyte && lyte.$utils && lyte.$utils.set){\n        lyte.$utils.set(obj, key, value, opts, fromStore);\n    }\n    else{\n        obj[key] = value;\n    }\n}\n\nfunction _defProp(scp, key, val, enume, write, conf){\n    enume = (enume === undefined) ? false : enume;\n    write = (write === undefined) ? false : write;\n\tconf = (conf === undefined) ? false : conf;\n    Object.defineProperty(scp, key, {\n        value : val,\n        enumerable : enume,\n        writable : write,\n\t\tconfigurable : conf\n    });\n}\n\n\nfunction removePartialKeys(db, data, schema){\n    var rels = schema.relations,\n\tdb = schema.db;\n\trels.forEach(function(relArr, key){\n\t\trelArr.forEach(function(rel){\n\t\t\tvar relObj = {}, \n\t\t\tinv, \n\t\t\tbMod = rel.relatedTo;\n\t\t\tif(bMod){\n\t\t\t\tvar inv = getBackwardRel(schema, rel, getSchemaObj(db, bMod));\n\t\t\t\tif(inv && inv.relType == \"hasMany\" && inv.opts && inv.opts.serialize){\n\t\t\t\t\tvar relKey = rel.relKey, invRelKey = inv.relKey, invObj = data[relKey];\n\t\t\t\t\tif(invObj){\n\t\t\t\t\t\tif(Array.isArray(invObj)){\n\t\t\t\t\t\t\tinvObj.forEach(function(invRelRec){\n\t\t\t\t\t\t\t\tvar invRelObj = invRelRec[invRelKey];\n\t\t\t\t\t\t\t\tif(invRelObj && invRelObj.partial && invRelObj.partial.get(data)){\n\t\t\t\t\t\t\t\t\tinvRelObj.partial.delete(data);\n\t\t\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(invObj[invRelKey]){\n\t\t\t\t\t\t\tvar invRelObj = invObj[invRelKey];\n\t\t\t\t\t\t\tif(invRelObj && invRelObj.partial && invRelObj.partial.get(data)){\n\t\t\t\t\t\t\t\tinvRelObj.partial.delete(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\t\t\n\t});\n}\n\nfunction mergeResponse(db, data , schema , response , pK , partialObj, cPersist){\n    var db = schema.db;\n\tremovePartialKeys(db, data, schema, pK);\n    if(partialObj && Object.keys(partialObj).length){\n        mergeNewDataKeys(db, partialObj, data, response, cPersist);\n    }\n    if(mergeError(schema, data, response)){\n        return;\n    }\n    var isRec = db.cache.getEntity(data.$.schema.def, data.$.pK), \n\tdirtyId, \n\tmergeDone = false,\n\tresult;\n    if(data.$.isDeleted){\n       mergeDeletedRec(db, partialObj, data, cPersist);\n    }\n    if(data.$.isNew && isRec){\n        mergeDone = mergeNewRecord(db, partialObj, data, response, true, cPersist);\n    }\n    if(data.$.isModified && isRec){\n        mergeModifiedRec(db, partialObj, data, response, true, mergeDone, cPersist);\n    }\n    if(schema.dirty.length){\n        deleteFromArray(schema.dirty, dirtyId);\n    }\n    if(partialObj && Object.keys(partialObj).length && response && !mergeDone){\n        if(response){\n            if(isRec){\n                result = validateAndMerge(schema, response, partialObj, true, true);\n\t\t\t\tif(result && result.data){\n\t\t\t\t\tresult = result.data;\n\t\t\t\t}\n\t\t\t\telse if(result && result.type){\n\t\t\t\t\tArray.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]\n\t\t\t\t\tDberror[result.type].apply(Dberror, result.args || [db.lyte]);\n\t\t\t\t}\n            }\n            else{\n                result = insertIntoStore(db, schema.def, response, undefined, undefined, partialObj);\n            }\n        }\t\t\t\t\t\n    }\n    // var dirty = data.$.isDirty();\n    // for(var j=0; j < dirty.length ;j++){\n    //     var records = data[dirty[j]];\n    //     if(Array.isArray(records)){\n    //         for(var k=0;k<records.length;k++){\n    //             if(isEntity(records[k])){\n    //                 cmpSet(db.lyte, records[k].$, \"isModified\", false);\n\t// \t\t\t\tchangePersist(records[k], true);\n    //             }\n    //         }\n    //     }\n    //     else if(isEntity(records)){\n    //         cmpSet(db.lyte, records.$, \"isModified\", false);\n\t// \t\tchangePersist(records, true);\n    //     }\n    // }\n    removeDirtyStack(data, partialObj);\n    // removeDeepNest(data);\n}\n\nfunction removeDirtyStack(data,partial){\n    if(partial && partial._removedAttr && Object.keys(partial._removedAttr).length !=0){\n\t\tfor(var key in data.$._attributes){\n\t\t\tif(!partial._removedAttr.hasOwnProperty(key)){\n\t\t\t\tdelete data.$._attributes[key];\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tdata.$._attributes = {};\n\t}\n\t// data.$._attributes={};\n\tdata.$.undoStack = genUnRedoStack();\n\tdata.$.redoStack = genUnRedoStack();\n\tdelete data.$._savedState;\n\tValidationError.clrRecErr(data.$); \n}\n\nfunction mergeNewDataKeys(db, partialObj, data, response, cPersist){\n    if(partialObj && ((data && data.partial && data.partial.size) || partialObj.partial == true)){ //true checked since partial key can come in this \n        if(Array.isArray(partialObj)){\t\t\t\t\n            partialObj.forEach(function(item, index){\n                if(item.$){\n                    var pK = item.$.schema._pK;\n                    var ind = getIndex(data, pK, item.$.pkVal);\n                    if(item.$.onlyDetach === true){\n\t\t\t\t\t\tif(data.entity && data.key){\n\t\t\t\t\t\t\tdeleteDeepNest(data.entity,data.key,item.$.pkVal);\n\t\t\t\t\t\t}\n                        handleArrOp(db.lyte, data, \"removeAt\", undefined, ind, 1);\n                    }\n                    else{\n                        mergeNewDataKeys(db, item, ind != -1 ? data[ind] : undefined, response ? response[index] : undefined, cPersist);\n\t\t\t\t\t\tdata.partial ? data.partial.delete(item.$.pkVal) : undefined;\n                    }\n\t\t\t\t\tif(!item._removedAttr || (item._removedAttr && Object.keys(item._removedAttr).length)){\n\t\t\t\t\t\tdata.partial ? data.partial.delete(item.$.pkVal) : undefined;\n\t\t\t\t\t}\n                }\n            });\n\t\t\tif(Array.isArray(data) && data.partial && data.partial.size && data.entity && data.key && data.entity.$.schema){\n\t\t\t\tvar relFld = data.entity.$.schema.fieldList[data.key], toRemPart = [];\n\t\t\t\tif(relFld.opts && /^(id|record)$/.test(relFld.opts.serialize)){\n\t\t\t\t\tdata.partial.forEach(function(pObj, pKey){\n\t\t\t\t\t\tif(pObj.type == \"removed\"){\n\t\t\t\t\t\t\ttoRemPart.push(pKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ttoRemPart.forEach(function(rItm){\n\t\t\t\t\t\tvar rec = db.cache.getEntity(db.getSchema(data.schema._name), rItm) || db.cache.getEntity(db.getSchema(data.schema._name), rItm, true);\n\t\t\t\t\t\tdata.partial.delete(rItm);\n\t\t\t\t\t\trec ? removeParentNesting(rec) : undefined;\n\t\t\t\t\t});\t\n\t\t\t\t}\n\t\t\t}\n        }\n    }\n    else if(partialObj && partialObj.$ && partialObj.$.type){\n        if(partialObj.$.onlyDetach){ //only for belongsTo\n\t\t\tvar parent = partialObj.$.parent;\n\t\t\tif(parent && parent.$.partial && parent.$.partial[partialObj.$.relKey] && parent.$.partial[partialObj.$.relKey].has(partialObj.$.pkVal) && parent.$.partial[partialObj.$.relKey].get(partialObj.$.pkVal).type == \"removed\"){                        \n\t\t\t\tvar rec = db.cache.getEntity(db.getSchema(partialObj.$.schema.__class), partialObj.$.pkVal) || store.peekRecord(partialObj.$.model, partialObj.$.pkVal, true);\n\t\t\t\tparent.$.partial[partialObj.$.relKey].delete(partialObj.$.pkVal);\n\t\t\t\tif(!parent.$.partial[partialObj.$.relKey].size){\n\t\t\t\t\tdelete parent.$.partial[partialObj.$.relKey];\n\t\t\t\t\tif(!Object.keys(parent.$.partial).length){\n\t\t\t\t\t\tdelete parent.$.partial;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec ? removeParentNesting(rec) : undefined;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tmergePartialObj(db,partialObj, data, response, undefined, cPersist);\n\t\t}\n    }\n    else{\n        if(Array.isArray(partialObj)){\n            partialObj.forEach(function(item, index){\n                mergeNewDataKeys(db, item, data[index], response ? response[index] : undefined, cPersist);\n            });\n        }\n        else if(typeof partialObj == \"object\"){\n            for(var key in partialObj){\n                mergeNewDataKeys(db, partialObj[key], data[key], response ? response[key] : undefined, cPersist);\n            }\n        }\n    }\n}\n\nfunction mergeError(schema, data, response){\n    if(response && response.$ && response.$.isError){\n        if(response.$.error){\n            var obj = response.$.error;\n            for(var key in obj){\n                if(schema.fieldList.hasOwnProperty(key)){\n                    ValidationError.setRecErr(data.$, key, obj[key]);\n                }\n            }\n        }\n\t\tif(response.$.revert){\n\t\t\tdata.$.revert();\n\t\t}\n\t\tdelete response.$.revert;\n        delete response.$.error;\n        delete response.$.isError;\n        return true;\n    }\n}\n\nfunction mergePartialObj(db, partialObj, data, response, doMerge, cPersist){\n    var prec = db.cache.getEntity(partialObj.$.schema.def, partialObj.$.pkVal), data = data || prec, isRec = prec ? true : false, mergeDone;\n    if(partialObj && partialObj.$ && partialObj.$.processed){\n        return;\n    }\n    if(mergeError(db.schema[partialObj.$.schema], data, response)){\n        return;\n    }\n\tif(partialObj.$.type == \"removed\"){\n        mergeDeletedRec(db, partialObj, data, cPersist);\n        return;\n    }\n    else if((partialObj.$.type == \"added\" || (data && data.$ && data.$.isNew == true)) && isRec){\n        mergeDone = mergeNewRecord(db, partialObj, data, response, doMerge, cPersist);\n    }\n    else if((partialObj.$.type == \"modified\" || partialObj.$.type == \"related\" || (data && data.$ && data.$.isModified == true)) && isRec){\n        mergeModifiedRec(db, partialObj, data, response, doMerge, mergeDone, cPersist);\n    }\n    if(isRec){\n        if(partialObj.$.type != \"removed\"){\n            for(var key in partialObj){\n                var part = partialObj[key];\n                mergeNewDataKeys(db, part, data[key], response ? response[key] : undefined,cPersist);\n            }\n        }\n        if(data.$.partial && Object.keys(data.$.partial)){\n            data.$.partial = new Map();\n        }\n        removeDirtyStack(data,partialObj);\n    }\n}\n\nfunction mergeNewRecord(db, partialObj, data, response, doMerge, cPersist){\n\tvar mdl = partialObj.$ ? partialObj.$.schema : data.$.schema,\n\tpKeys = mdl._arrPk, \n\toldPk = data.$.pK, \n\tlyte = db.lyte,\n\trec = db.cache.getEntity(mdl.def, oldPk), \n\tresult, \n\tpartRec = partialObj.$ ? partialObj.$.entity : undefined;\n\tif(isEntity(partRec) && partRec !== rec){\n\t\treturn;\n\t}\n\tif(rec){\n\t\tvar oldRelPk = typeof oldPk == \"object\" ? oldPk : oldPk.toString(), \n\t\tcrProcessed = false;\n\t\tif(cPersist !== true){\n\t\t\tpKeys.forEach(function(item){\n\t\t\t\tif(!response || !response.hasOwnProperty(item)){\n\t\t\t\t\tDberror.error(lyte,\"LD16\", mdl._name, isEntity(data) ? (typeof data.$.pK == \"object\" ? JSON.stringify(data.$.pK) : data.$.pK) : undefined);\n\t\t\t\t\treturn;\n\t\t\t\t}\t\n\t\t\t\tcmpSet(lyte, data, item, response[item], undefined, true);\n\t\t\t\tcrProcessed = true;\n\t\t\t});\n\t\t\tvar newPk = getpKVal(data);\n\t\t\tcmpSet(lyte, data.$, \"pK\", getpKVal(data));\n\t\t\tvar newRelPk = typeof newPk == \"object\" ? newPk : newPk.toString();\n\t\t\tif(mdl.data._recMap){\n\t\t\t\tmdl.data._recMap.delete(oldRelPk);\n\t\t\t\tmdl.data._recMap.set(newRelPk, data);\n\t\t\t}\n\t\t\tchangeRelPkMaps(data, oldRelPk, newRelPk);\n\t\t\tupdateNestScp(data, oldPk);\n\t\t}\n\t\tif(crProcessed && partialObj && partialObj.$ ){\n\t\t\tpartialObj.$.processed = true;\n\t\t}\n\t\tif(doMerge && cPersist !== true){\n\t\t\tresult = validateAndMerge(mdl, response, partialObj, true, true);\n\t\t\tif(result && result.data){\n\t\t\t\tresult = result.data;\n\t\t\t}\n\t\t\telse if(result && result.type){\n\t\t\t\tArray.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]\n\t\t\t\tDberror[result.type].apply(Dberror, result.args || [db.lyte]);\n\t\t\t}\n\t\t}\n\t\tcmpSet(lyte, data.$, \"isNew\", false);\n\t\tif(partialObj.hasOwnProperty(\"_removedAttr\") && Object.keys(partialObj._removedAttr).length!=0){\n\t\t\treturn result;\n\t\t}\n\t\tcmpSet(lyte, data.$, \"isModified\", false);\n\t\tchangePersist(data, true);\n\t\tdeleteFromArray(mdl.dirty, oldPk);\n\t\tif(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){\n\t\t\tremoveParentNesting(data);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction mergeModifiedRec(db, partialObj, data, response, doMerge, mergeDone, cPersist){\n\tvar dirtyId = !dirtyId ? data.$.pK : dirtyId, result, lyte = db.lyte;\n\tif(!data.$.isDeleted && response && !mergeDone && cPersist !== true){\n\t\tif(response && doMerge){\n\t\t\tresult =  validateAndMerge(data.$.schema, response, partialObj, true, true);\n\t\t\tif(result && result.data){\n\t\t\t\tresult = result.data;\n\t\t\t}\n\t\t\telse if(result && result.type){\n\t\t\t\tArray.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]\n\t\t\t\tDberror[result.type].apply(Dberror, result.args || [db.lyte]);\n\t\t\t}\n\t\t}\n\t\tmergeDone = true;\t\t\t\t\t\t\n\t}\n\t// changeModified(lyte, data, false, data.$.pK);\n\tif(partialObj && partialObj.hasOwnProperty(\"_removedAttr\") && partialObj._removedAttr.length){\n\t\treturn result;\n\t}\n\tcmpSet(lyte, data.$, \"isModified\", false);\n\tchangePersist(data, true);\n\tif(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){\n\t\tremoveParentNesting(data);\n\t}\n\treturn result;\n} \n\nfunction mergeDeletedRec(db, partialObj, data){\n\tvar pkVal, schema, obj;\n\tif(partialObj){\n\t\tschema = partialObj.$.schema;\n\t\tpkVal = partialObj.$.pkVal;\n\t}\n\telse if(data){\n\t\tschema = data.$.schema;\n\t\tpkVal = data.$.pK;\n\t}\n\tobj = schema._deleted.get(pkVal); \n\tvar rec = obj ? obj.data : undefined;\n\tvar isRec = db.cache.getEntity(schema.def, pkVal);\n\tif(rec){\n\t\tcmpSet(db.lyte, rec.$, \"isDeleted\", false);\n\t\tcmpSet(db.lyte, rec.$, \"isUnloaded\", true);\n\t\tcmpSet(db.lyte, rec.$, \"isPersisted\", true);\n\t\tvar scpObj = rec.$.__scpObj;\n\t\tfor(var key in scpObj){\n\t\t\tvar sid = scpObj[key];\n\t\t\tvar sidArr = sid.split(\"_\");\n\t\t\tvar nestObj = nestScp[sidArr[0]];\n\t\t\tnestObj ? removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model:schema._name, pK: pkVal, attr: key}) : undefined;\n\t\t}\t\n\t\tschema._deleted.delete(pkVal);\n\t\tremoveParentNesting(rec);\n\t}\n\tif(isRec){\n\t\tremoveFromStore(schema, pkVal, true, undefined, undefined, true);\n\t\tremoveParentNesting(isRec);\n\t}\n\telse{\n\t\tvar cqueries = db.schema.cachedQueries;\n\t\tif(cqueries){\n\t\t\tvar n=schema._name, Nm = cqueries[n];\n\t\t\tif(Nm && Nm.length){\n\t\t\t\tfor(var i=Nm.length-1; i>=0; i--){\n\t\t\t\t\tvar obj = Nm[i];\n\t\t\t\t\tif(obj.hasDeletedRecords){\n\t\t\t\t\t\tif(obj.data){\n\t\t\t\t\t\t\tvar ind = obj.data[n].indexOf(rec);\n\t\t\t\t\t\t\tif(ind !== -1){\n\t\t\t\t\t\t\t\tNm.splice(i,1);\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tif(partialObj && partialObj.$ && partialObj.$.parent){\n\t\tpartialObj.$.parent.$.partial = {};\n\t}\n\tpartialObj && partialObj.$ ? partialObj.$.processed = true : undefined;\n}\n\nfunction changeRelPkMaps(data, oldPk, newPk){\n\tvar schema = data.$.schema,\n\tdb = schema.db,\n\trelations = schema.relations;\n\trelations.forEach(function(rels, key){\n\t\trels.forEach(function(itm){\n\t\t\tvar attr = itm.relKey, relType = itm.relType, inv;\n\t\t\tif(data.hasOwnProperty(attr)){\n\t\t\t\tvar relRec = data[attr],\n\t\t\t\tbMod = getSchemaObj(db, itm.relatedTo), inv;\n\t\t\t\tif(bMod){\n\t\t\t\t\tinv = getBackwardRel(schema,itm,bMod);\n\t\t\t\t\tif(inv && inv.relType == \"hasMany\"){\n\t\t\t\t\t\tif(relType == \"belongsTo\" && isEntity(relRec)){\n\t\t\t\t\t\t\trelRec[inv.relKey] && relRec[inv.relKey]._recMap && relRec[inv.relKey]._recMap.delete(oldPk) ? relRec[inv.relKey]._recMap.set(newPk, data) : undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(relType == \"hasMany\" && Array.isArray(relRec)){\n\t\t\t\t\t\t\trelRec.forEach(function(rec){\n\t\t\t\t\t\t\t\tisEntity(rec) && rec[inv.relKey] && rec[inv.relKey]._recMap && rec[inv.relKey]._recMap.delete(oldPk) ? rec[inv.relKey]._recMap.set(newPk, data) : undefined;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\tvar _rels = data.$._relationships;\n\tfor(var md in _rels){\n\t\tvar mdObj = _rels[md];\n\t\tfor(var attr in mdObj){\n\t\t\tvar arr = mdObj[attr];\n\t\t\tarr.forEach(function(rec){\n\t\t\t\tvar relData = rec[attr];\n\t\t\t\tif(Array.isArray(relData)){\n\t\t\t\t\trelData._recMap && relData._recMap.delete(oldPk) ? relData._recMap.set(newPk, data) : undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction updateNestScp(obj, oldPk){\n\tif(isEntity(obj)){\n\t\tvar scpObj = obj.$.__scpObj || {};\n\t\tfor(var key in scpObj){\n\t\t\tvar val = scpObj[key];\n\t\t\tval = val.split(\"_\")[0];\n\t\t\tif(nestScp && nestScp.hasOwnProperty(val) && nestScp[val].model){\n\t\t\t\tvar mp1 = nestScp[val].model.get(obj.$.schema._name);\n\t\t\t\tif(mp1.has(oldPk)){\n\t\t\t\t\tvar val = mp1.get(oldPk);\n\t\t\t\t\tmp1.delete(oldPk);\n\t\t\t\t\tmp1.set(obj.$.pK, val);\n\t\t\t\t}\n\t\t\t\t// Lyte.nestScp[val].pK = record.$.pK;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction getDsrzEmpData(schema, field){\n\tif(field.hasOwnProperty(\"deserializeEmptyData\")){\n\t\treturn field.deserializeEmptyData;\n\t}\n\telse{\n\t\tvar desrz = getFromCB(schema.db, \"serializer\", schema.serializer, \"deserializeEmptyData\");\n\t\tif(desrz !== undefined){\n\t\t\treturn desrz;\n\t\t}\n\t}\n\treturn false;\n}\n\n// function defpayObjUtls(obj){\n// \tObject.defineProperties(obj,{\n// \t\tset:{\n// \t\t\tvalue: payloadSet\n// \t\t},\n// \t\tremove:{\n// \t\t\tvalue: payloadRemove\n// \t\t}\n// \t})\n// }\n\n// function defPayArrUtls(obj){\n// \tObject.defineProperties(obj,{\n// \t\tadd : {\n// \t\t\tvalue : payloadAdd\n// \t\t},\n// \t\tremove : {\n// \t\t\tvalue : payloadRemove\n// \t\t}\n// \t})\n// }\n\n// function payloadAdd(key,index){\n// \tif(!Array.isArray(key)){\n// \t\tkey=[key];\n// \t}\n// \tvar def = this._schema, db = def.db, partObj=this._partialObj, payload=this._payloadObj;\n// \tfor(var i =0 ; i<key.length; i++){\n// \t\tvar record = db.cache.getEntity({schema:def, pK:key[i]}), partial={};\n// \t\t_defProp(partial, \"$\", {});\n// \t\tvar nPartial = \tpartial.$;\n// \t\tObject.defineProperties(nPartial,{\n// \t\t\tpkVal : {\n// \t\t\t\tvalue : record.$.pK\n// \t\t\t},\n// \t\t\ttype : {\n// \t\t\t\tvalue : \"related\"\n// \t\t\t},\n// \t\t\tschema : {\n// \t\t\t\tvalue : def\n// \t\t\t},\n// \t\t\trecord : {\n// \t\t\t\tvalue : record\n// \t\t\t}\n// \t\t});\n// \t\tvar _pk = typeof(record.$.pK) == \"object\" ? record.$.pK : { [record.$.model._pK] : record.$.pK };\n// \t\tif(index){\n// \t\t\tLyte.arrayUtils(partObj,\"insertAt\",index,partial);\n// \t\t\tLyte.arrayUtils(payload,\"insertAt\",index,_pK);\n// \t\t\tindex=index++;\n// \t\t}\n// \t\telse{\n// \t\t\tLyte.arrayUtils(partObj,\"push\",partial);\n// \t\t\tLyte.arrayUtils(payload,\"push\",_pk);\n// \t\t}\n// \t\tstore.$.defProp(_pk, \"$\", {});\n// \t\tstore.$.defpayObjUtls(_pk.$);\n// \t\tObject.defineProperties(_pk.$,{\n// \t\t\t_pkVal : {\n// \t\t\t\tvalue : record.$.pK\n// \t\t\t},\n// \t\t\t_model : {\n// \t\t\t\tvalue : modelName\n// \t\t\t},\n// \t\t\t_partialObj : {\n// \t\t\t\tvalue : partial\n// \t\t\t},\n// \t\t\t_payloadObj:{\n// \t\t\t\tvalue:_pk\n// \t\t\t}\n// \t\t});\n// \t}\n// }\n\n// function payloadRemove(key){\n// \tvar def = this._schema, \n// \tpartObj=this._partialObj, \n// \tpayload=this._payloadObj;\n// \tif(!Array.isArray(key)){\n// \t\tkey=[key];\n// \t}\n// \tfor(var j =0; j<key.length; j++){\n// \t\tif(Array.isArray(payload)){\n// \t\t\tvar len = payload.length;\n// \t\t\tfor(var i =0; i<len; i++){\n// \t\t\t\tif(partObj[i].$.pkVal == key){\n// \t\t\t\t\tpartObj.splice(i, 1);\n// \t\t\t\t\tpayload.splice(i, 1);\n// \t\t\t\t\t// Lyte.arrayUtils(partObj,\"removeAt\",i,1);\n// \t\t\t\t\t// Lyte.arrayUtils(payload,\"removeAt\",i,1);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\telse{\n// \t\t\tif(payload[key] && partObj[key]){\n// \t\t\t\tdelete payload[key[j]];\n// \t\t\t\tdelete partObj[key[j]];\n// \t\t\t\t// Lyte.objectUtils(payload,\"delete\",key[j]);\n// \t\t\t\t// Lyte.objectUtils(partObj,\"delete\",key[j]);\n// \t\t\t}\n// \t\t}\n// \t}\n// }\n\n// function payloadSet(fkey){\n// \tif(!Array.isArray(fkey)){\n// \t\tfkey=[fkey];\n// \t}\n// \tvar def = this._schema, db = def.db, pk = this._pkVal, payload = this._payloadObj;\n// \tvar record = db.cache.getEntity({schema:def.def,pK:pk}), partial=this._partialObj;\n// \tfor(i_key=0; i_key<fkey.length; i_key++){\n// \t\tvar key = fkey[i_key];\n// \t\tvar field = def.fieldList[key];\n// \t\tif(record[key] && field.type == \"relation\"){\n// \t\t\tif(field.relType == \"hasMany\"){\n// \t\t\t\tpartial[key]=[];\n// \t\t\t\tpayload[key]=[];\n// \t\t\t\t_defProp(payload[key], \"$\", {});\n// \t\t\t\tdefPayArrUtls(payload[key].$);\n// \t\t\t\tObject.defineProperties(payload[key].$,{\n// \t\t\t\t\t_key:{\n// \t\t\t\t\t\tvalue:field.relKey\n// \t\t\t\t\t},\n// \t\t\t\t\t_partialObj:{\n// \t\t\t\t\t\tvalue:partial[key]\n// \t\t\t\t\t},\n// \t\t\t\t\t_schema:{\n// \t\t\t\t\t\tvalue:field.relatedTo\n// \t\t\t\t\t},\n// \t\t\t\t\t_payloadObj:{\n// \t\t\t\t\t\tvalue:payload[key]\n// \t\t\t\t\t},\n// \t\t\t\t\t// replace:{\n// \t\t\t\t\t// \tvalue:store.$.replaceCheck,\n// \t\t\t\t\t// \twritable:true\n// \t\t\t\t\t// }\n// \t\t\t\t})\n// \t\t\t\tfor(i=0; i<record[key].length; i++){\n// \t\t\t\t\tpayload[key].$.add(record[key][i].$.pK);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\telse{\n// \t\t\t\tpartial[key]={};\n// \t\t\t\tpayload[key]={};\n// \t\t\t\tpayload[key]=typeof record[key].$.pK ==\"object\" ? record[key].$.pK:{[record[key].$.model._pK]:record[key].$.pK};\n// \t\t\t\t_defProp(partial[key], \"$\", {});\n// \t\t\t\tvar nPartial = \tpartial[key].$;\n// \t\t\t\tObject.defineProperties(nPartial,{\n// \t\t\t\t\tpkVal : {\n// \t\t\t\t\t\tvalue : record.$.pK\n// \t\t\t\t\t},\n// \t\t\t\t\ttype : {\n// \t\t\t\t\t\tvalue : \"related\"\n// \t\t\t\t\t},\n// \t\t\t\t\tschema : {\n// \t\t\t\t\t\tvalue : def\n// \t\t\t\t\t},\n// \t\t\t\t\trecord : {\n// \t\t\t\t\t\tvalue : record[key]\n// \t\t\t\t\t}\n// \t\t\t\t});\n// \t\t\t\t_defProp(payload[key], \"$\", {});\n// \t\t\t\tObject.defineProperties(payload[key].$,{\n// \t\t\t\t\t_pkVal : {\n// \t\t\t\t\t\tvalue : record[key].$.pK\n// \t\t\t\t\t},\n// \t\t\t\t\t_schema : {\n// \t\t\t\t\t\tvalue : field.relatedTo\n// \t\t\t\t\t},\n// \t\t\t\t\t_partialObj : {\n// \t\t\t\t\t\tvalue : partial[key]\n// \t\t\t\t\t},\n// \t\t\t\t\t_payloadObj:{\n// \t\t\t\t\t\tvalue:payload[key]\n// \t\t\t\t\t}\n// \t\t\t\t});\n// \t\t\t\tdefpayObjUtls(payload[key].$);\n// \t\t\t}\n// \t\t}\n// \t\telse{\n// \t\t\tpayload[key]=record[key];\n// \t\t\tpartial[key]=record[key];\n// \t\t}\n// \t}\n// }\n\n// function replaceCheck(bool){\n// \tstore.$.defProp(this._partialObj,\"replace\",bool)\n// }\n\nexport { evAdd,evRemove,evEmit,addTo_Del,genUnRedoStack,deepCopyStack,deepCopyAttrs,unredoOp,unregisterDef,updateFieldValidation,handleCachedResponse,addToCachedBatch,checkObjAndAddToArr,addToRelate,getDefaultVal,deepValueChange,updateDn,deepRelIter,deepRelOptions,handleResults,handleResponse,setState,validateRelatedRecord,validateRecord,validateField,addOnSave,removeOnSave,registerField,unRegCb,extendDef,demoLishObserverBindings,establishObsBindings,isEmpty,isEmptyObj,isEmptyArray,compareObjects,setData,changeCallbck,setValue,estAttrs,checkAttrs,checkForCorrectRelation,partialData,removeDeepNest,addDeepNest,makeDirty,setDeepNest,deleteDeepNest,getRelatedRecord,removeParentNesting,cmpRelInitVal,_attrsForRel,establishToRelated,add,remove,filter,filterBy,checkAndAddToArray,deleteFromArray,genPk,generateRandomPk,isDuplicateRecord,pkPresence,updateJSON,isDirty,isRelDirty,polymorphicToJSON,polyToJSON,removeBackwardRel,checkPresenceInArray,idbSerialize,idSerialize,recordSerialize,rSerialize,partialSerialize,removeSelfCircularReference,getpKVal,toJSONObj,toJSON,createCopy,initPartialObj,recChk,initCB,cB,cbScp,getFromCB,comparePk,newRecord,getIndex,getCompInd,getInd,isDuplicateEntity,compareRecords,hasRecordInArray,hasDuplicateRelation,toInsertData,insertIntoStore,validateAndPush,validateJSON,handleRelation,getRelations,getBackwardRel,solveRelation,createAndRelate,singleEstablishLink,establishLink,removeFromStore,toDemolishRelation,toDemolishLink,demolishSingleRelation,demolishLink,validateAndMerge,mergeData,mergeRecords,compareRelations,compareRecordWithObj,rllBckRecArr,sortBy,mapBy,revertToOldVal,removePartial,rollBackDelete,rollBackNew,emit,hasRecordsArrayChanged,cacheQuery,cacheRecordQuery,isDefData,handleArrOp,defArrUtls,defPolyUtls,defUtls,defPar,cmpSet,_defProp,removePartialKeys,mergeResponse,removeDirtyStack,mergeNewDataKeys,mergeError,mergePartialObj,mergeNewRecord,mergeModifiedRec,mergeDeletedRec,changeRelPkMaps,updateNestScp, compareData, schArgs, dbModName, getSchemaObj, changePersist};\n","import { History } from \"./src/history\";\nimport { RouterMap } from \"./src/map-parser\";\nimport { Route } from \"./src/route\";\nimport { Router } from \"./src/router\";\n\nexport { Router, RouterMap, Route , History}","import { RouterError } from \"./router-errors\";\nimport { _getObj, _getRouteFromAlias } from \"./router-utils\";\n\nconst startFromStr = \"start-from\",\nltPropStr = \"lt-prop\",\nrouteStr = \"route\",\npReplace = ltPropStr+\"-replace\",\npStartFrom = ltPropStr+\"-\"+startFromStr,\npFragment = ltPropStr+\"-fragment\",\npDp = ltPropStr+\"-dp\",\npQp = ltPropStr+\"-qp\",\npTd = ltPropStr+\"-td\",\npData = ltPropStr+\"-data\",\npTrans = ltPropStr+\"-trans\",\npMeta = ltPropStr+\"-meta\",\nrefreshHRouteStr = \"refresh-\"+routeStr,\npRefreshRoute = ltPropStr+\"-\"+refreshHRouteStr,\nlinktoStr = \"link-to\",\nltPropWarning = \"Error while parsing ltProp in \"+linktoStr,\npRoute = ltPropStr+\"-\"+routeStr;\nconst parse = JSON.parse;\n\nfunction linkToRegistration(lyte,LR,config) {\n    LR.__lp.navigationCompleted = function(trans) {\n        if(config.linkActiveClass && config.allLinks[trans.target]) {\n            config.allLinks[trans.target].forEach(function(tag) {\n                if(!tag.classList.contains(config.linkActiveClass)) {\n                    tag.classList.add(config.linkActiveClass);\n                    config.activeLinkTags.push(tag);\n                }\n            });\n        }\n    }\n\n    LR.__lp.mutateCache = function(target) {\n        if(config.allLinks[target]) {\n            config.allLinks[target].forEach(function(tag) {\n                if(config.linkActiveClass) {\n                    tag.classList.add(config.linkActiveClass);\n                }\n                config.activeLinkTags.push(tag);\n                var aTag = tag.getElementsByTagName('A')[0]\n                if(aTag) {\n                    aTag.setAttribute(\"href\", LR.getURL(tag.getMatchedObject())); \n                }\n            });\n        }\n    }\n\n    class LinkTo extends HTMLElement {\n        static get observedAttributes() {\n            return [pRoute, pDp, pFragment, pQp, ltPropStr, 'lt-prop-class', 'lt-prop-id', 'lt-prop-rel', 'lt-prop-title', 'lt-prop-style', 'lt-prop-target','lt-prop-data-tabindex', 'lt-prop-aria-attributes','lt-prop-tabindex','lt-prop-aria-label'];\n        }\n        attributeChangedCallback(attr, oldValue, newValue) {\n            if(this.matched && this.hasAttribute(\"lyte-rendered\")) {\n                let Atag = this.getElementsByTagName('A')[0];\n                if(Atag) {\n                    //If attr is ltProp\n                    if(attr === ltPropStr) {\n                        this.handleLtProp();\n                        if(!this.hasAttribute(\"lt-prop-custom\")) {\n                            this.setCustomAttributes(Atag, true);\n                        }\n                        this.constructHref(Atag);\n                    } else if(/^(lt-prop-route|lt-prop-fragment|lt-prop-dp|lt-prop-qp)$/.test(attr)) {\n                        //if it is a route transition attribute\n                        this.getMatchedObject();\n                        this.constructHref(Atag, attr, oldValue, newValue);\n                    } else if(!this.hasAttribute('lt-prop-custom')) {\n                        //for rest of the attributes\n                        Atag.setAttribute(attr.substring(8), newValue);\n                    }\n                }\n            }\n        }\n\n        connectedCallback() {\n            this.ltProp = this.ltProp || {};\n            this.handleLtProp();\n            if(this.hasAttribute(\"lyte-rendered\")) {\n                if(this.getElementsByTagName('A')[0] && !this.matched) {\n                    this.getMatchedObject();\n                }\n                return;\n            } \n            var isCustom = this.hasAttribute(\"lt-prop-custom\") || this.ltProp.custom,\n            aTag;\n            if(isCustom) {\n                if(aTag = this.getElementsByTagName('A')[0]) {\n                    this.getMatchedObject();\n                    this.constructHref(aTag);\n                }\n            } else {\n                aTag = document.createElement(\"a\");\n                while(this.childNodes[0]) {\n                    aTag.appendChild(this.childNodes[0]);\n                }\n                this.setCustomAttributes(aTag);\n                this.getMatchedObject();\n                this.constructHref(aTag);\n                this.appendChild(aTag);\n            }\n            if(lyte.$.modules.component) {\n                this._linkToEventId = lyte.$.modules.component[0].addAction(this, \"click\", function(event) {\n                    linkToEventListener(event, this);\n                }, this);\n            } else {\n                this.addEventListener(\"click\", linkToEventListener);\n            }\n            this.setAttribute(\"lyte-rendered\", \"\");\n        }\n\n        modifyLinkToTagsInRoute(remove) {\n            var strRoute = Array.isArray(this.matched.route) ? this.matched.route.join('.') : this.matched.route,\n            allLinks = config.allLinks[strRoute];\n            if(remove) {\n                if(allLinks) {\n                    let pos = allLinks.indexOf(this);\n                    if(pos != -1) {\n                        allLinks.splice(pos,1);\n                    }\n                }\n            } else {\n                if(allLinks) {\n                    allLinks.push(this);\n                } else {\n                    config.allLinks[strRoute] = [this];\n                }\n            }\n            if(config.cacheRoutes[strRoute]) {\n                let routesObj = config.routes,\n                routes;\n                if(remove) {\n                    if(this.matched) {\n                        routes = remove;\n                    } else {\n                        return;\n                    }\n                } else {\n                    routes = this.matched.route;\n                }\n                if(!routes) {\n                    return;\n                } \n                routes = Array.isArray(routes) ? routes : _dotSerperator(routes);\n                for(var i = 0,l = routes.length,r; i < l; i++) {\n                    r = routes[i];\n                    routesObj =  _getObj(r,routesObj);\n                    if(!routesObj || !routesObj.__lp) {\n                        RouterError.error(422,routes,i);\n                        return false;\n                    }\n                    var def = routesObj.__lp.handler && routesObj.__lp.options;\n                    if(remove) {\n                        let pos = def.cacheLinks.indexOf(this);\n                        if(pos !== -1) {\n                            def.cacheLinks.splice(pos,1);\n                        }\n                    } else if(def.qpdef) {\n                        def.cacheLinks.push(this);  \n                    }\n                }\n            }\n        }\n\n        disconnectedCallback() {\n            let m = this.modifyLinkToTagsInRoute.bind(this);\n            if(lyte.$.component && !lyte.$.component.shouldIgnoreDisconnect()) {\n                if(this.matched && this.matched.route) {\n                    m(this.matched.route);\n                }\n                if(this._linkToEventId) {\n                    lyte.$.component.removeLyteEventListener(this, this._linkToEventId);\n                }\n            }\n        }\n        \n        handleLtProp(ignoreError) {\n            var ltProp = this.getAttribute(ltPropStr);\n            if(ltProp) {\n                try{\n                    this.ltProp = parse(ltProp);\n                } catch(e) {\n                    if(!ignoreError) {\n                        lyte.error(ltPropWarning,ltProp);\n                    }\n                }\n            }\n        }\n\n        setCustomAttributes(linkTag, onlyLtProp) {\n            for(let key in this.ltProp) {\n                if(/^(id|class|style|target)$/.test(key)) {\n                    linkTag.setAttribute(key, this.ltProp[key]);\n                }\n            }\n            if(!onlyLtProp) {\n                for(let i=0,attr,attrName; attr = this.attributes[i]; i++) {\n                    if((attrName = attr.nodeName) !== ltPropStr && /^(lt-prop-id|lt-prop-rel|lt-prop-class|lt-prop-style|lt-prop-target|lt-prop-data-tabindex|lt-prop-tabindex|lt-prop-aria-label|lt-prop-aria-attributes)$/.test(attrName)) {\n                        linkTag.setAttribute(attrName.substring(8), attr.nodeValue);\n                    }\n                }\n            }\n        }\n\n        constructHref(linkTag, attr, oldValue) {\n            var href,\n            m = this.modifyLinkToTagsInRoute.bind(this);\n            if(href = LR.getURL.call(this,this.matched)) { /* deepCopyObj this.matched. ??*/\n                linkTag.setAttribute(\"href\", href); \n                if(attr === pRoute) {\n                    m(oldValue);\n                    m();\n                } else {\n                    m();\n                }\n            }\n        }\n    }\n    \n    LinkTo.prototype.getMatchedObject = function() {\n        var matched = this.matched || {},\n        ga = this.getAttribute.bind(this),\n        dynamicParams = ga(pDp) || this.ltProp.dp || [],\n        queryParams = ga(pQp) || this.ltProp.qp || {};\n        if(!(dynamicParams instanceof Array)) {\n            try {\n                dynamicParams = parse(dynamicParams);  \n            } catch(e) {\n                RouterError.error(\"498A\",\"dynamicParams\",this.outerHTML);\n                return;\n            }\n        }\n        if(!(queryParams instanceof Object)) {\n            try{\n                queryParams = parse(queryParams);\n                if(Array.isArray(queryParams)) {\n                    RouterError.error(\"498A\",\"queryParams\",this.outerHTML);\n                    return;\n                }\n            } catch(e) {\n                RouterError.error(\"498A\",\"queryParams\",this.outerHTML);\n                return;\n            }\n        }\n        var routeFromAlias = _getRouteFromAlias.call(lyte,{route : ga(pRoute) || this.ltProp.route, map : config.aliasRouteMap});/* ga(pRoute) || this.ltProp.route; */\n        matched.route = routeFromAlias.route;\n        matched.alias = routeFromAlias.alias;\n        matched.fragment = ga(pFragment) || this.ltProp.fragment;\n        matched.dynamicParams = dynamicParams || [];\n        matched.queryParams = queryParams || {};\n        matched.refreshRoute = ga(pRefreshRoute) != undefined ? ga(pRefreshRoute) : this.ltProp[refreshHRouteStr];\n        matched.refreshRoute = (matched.refreshRoute == \"\" || matched.refreshRoute == 'true') ? matched.route.join(\".\") : matched.refreshRoute;\n        matched.startFrom = ga(pStartFrom) || this.ltProp[startFromStr];\n        return this.matched = matched;\n    };\n    customElements.define(linktoStr, LinkTo);\n    customElements.define(\"go-to\", (function() {\n        class GoTo extends LinkTo {}\n        return GoTo;\n    })());\n\n    function linkToEventListener(event, linkTo) {\n        if(event.button == 2 || event.defaultPrevented) {\n            return;\n        }\n        var targetElem = linkTo || event.currentTarget;\n        if(targetElem.children[0].tagName === \"A\" && (event.ctrlKey == true || event.metaKey == true || event.which == 2 || (targetElem.children[0].hasAttribute(\"target\") && targetElem.children[0].getAttribute(\"target\") !== \"_self\")) ) {\n            return;  \n        }\n        event.preventDefault();\n        if(!targetElem.matched) {\n            targetElem.getMatchedObject();\n        }\n        var matched = Object.assign({},targetElem.matched);\n        matched.route = Array.isArray(matched.route) ? matched.route.join('.') : matched.route;\n        var replace = targetElem.ltProp.replace  || targetElem.hasAttribute(pReplace),\n        transitionInstance = LR[replace && replace != \"false\" ? \"replaceWith\" : \"navigateTo\"](targetElem.matched);\n        targetElem.handleLtProp(true)\n        var transObj = {},\n        transProp,\n        ltProp = targetElem.ltProp;\n        if(transProp = targetElem.getAttribute(pMeta) || targetElem.getAttribute(pTrans) || (ltProp && ltProp.meta)) {\n            try{\n                transObj = parse(transProp);  \n            } catch(e) {\n                RouterError.error(\"498A\", pMeta , linkTo.outerHTML);\n            }\n        }\n        let transitionData = targetElem.getAttribute(pData) || targetElem.getAttribute(pTd) || (ltProp && ltProp.data);\n        if(transitionData/* = (transitionData || transObj.data)*/) {\n            if(typeof transitionData === \"string\") {\n                try {\n                    transitionData = parse(transitionData);\n                } catch(e) {\n                    RouterError.error(\"498A\", pData , linkTo.outerHTML);\n                }\n            }\n            transObj.data = transitionData;\n        }\n        for(var key in transObj) {\n            transitionInstance[key] = transObj[key];\n        }\n    }\n}\n\nexport { linkToRegistration };","import { _delimit } from \"./router-utils\";\nimport { deepCopyObject } from '@slyte/core/src/lyte-utils';\n\nclass Location {\n    constructor(obj) {\n        var ignore = [\"reload\",\"ancestorOrigins\",\"replace\",\"toString\",\"assign\"]\n        for(var key in obj) {\n            if(ignore.indexOf(key) == -1) {\n                this[key] = obj[key];\n            }\n        }\n    }\n}\n\nclass History {\n    constructor({ historyType, popState, parent}) {\n        var __lh = this.__lh = {\n            historyType : parent && parent.history.type || historyType,\n            allowHistoryChange : false,\n            fromHistory : false,\n            historyLength : 1,\n            exp : {                \n            }\n        };\n        this.parent = parent;\n\n        window.addEventListener('popstate', function(event) {\n            __lh.fromHistory = true;\n            setHistoryObj.call(this, event.state);\n            popState(event);\n        }.bind(this));\n       \n\n        // Object.defineProperty(this.constructor.prototype, 'state', {\n        //     get : function() {\n        //         return this.getData();\n        //     },\n        //     set : function(data) {\n        //         if(this.__lh.allowHistoryChange) {\n        //             debugger;\n        //             this.__lh.allowHistoryChange = false;\n        //         } else {\n        //             lyte.warn('setting on data will not be pushed to history. If needed, use `LR.history.replaceState`.');\n        //         }\n        //         return data;\n        //     }\n        // });\n\n        __lh.exp.pushState = this.pushState = function(data, title, url, metaData) {\n            url = mergeWithParentUrl.call(this,{url})\n            return stateChange.call(this, data,title,url,metaData);\n        };\n    \n        __lh.exp.replaceState = this.replaceState = function(data,title,url,metaData) {\n            url = mergeWithParentUrl.call(this,{url})\n            return stateChange.call(this,data,title,url,metaData, true);\n        };\n        __lh.exp.go = this.go = history.go\n        __lh.exp.back = this.back = history.back\n        __lh.exp.forward = this.forward = history.forward\n        __lh.exp.length = this.length = history.length\n        Object.defineProperty(this,\"scrollRestoration\",{\n            get : () => {\n                return history.scrollRestoration;\n            },\n            set : (value) => {\n                history.scrollRestoration = value;\n            }\n        })\n    \n        this.getMeta = function() {\n            var meta = history.state && history.state.meta\n            return meta;\n        }\n\n        function mergeWithParentUrl({url}) {\n            if(this.parent) {\n                debugger;\n                var i,\n                pUrl = this.parent.history.url,\n                serch = ((i = url.indexOf('?')) != -1) ? \"?\"+url.slice(i+1) : \"\";\n                serch = this.parent.history.search+serch;\n                if(url.indexOf(\"#\") != -1) {\n                    url = _delimit(url.split(\"#\")[1])\n                }\n                if(this.__lh.historyType == \"hash\") {\n                    pUrl = this.parent.path\n                    url = pUrl+ url\n                } else if(pUrl.indexOf(\"#\")) {\n                    pUrl = this.parent.path + url + _delimit(pUrl.split(\"#\")[1])\n                } \n                url += (serch ? \"?\"+serch : \"\");\n            }\n            return url\n        }\n        \n        __lh.exp.getData = this.getData = function() {\n            return history.state && history.state.data;\n        }\n        \n        // this.getHistoryObj = function() {\n        //     var retObj =  {\n        //         historyType : historyType,\n        //         index : this.__lh.currentMeta ?  this.__lh.currentMeta.__lh.index : 0,\n        //         fromHistory : this.__lh.fromHistory ? (this.__lh.prevMeta ? (this.__lh.prevMeta.__lh.index < this.__lh.currentMeta.__lh.index ? 'forward' : 'back') : 'reload') : false,\n        //         initial : this.__lh.historyLength == 0\n        //     }\n        //     // allowHistoryChange = true;\n        //     retObj.state = history.state;\n        //     retObj.meta = this.getMeta() || {};\n        //     retObj.data = this.getData() || {};\n        //     return retObj;\n        // }\n    }\n}\n\nfunction getHistoryState(obj) {\n    /* \n    {\n            matched : obj.matched,\n            url : obj.url,\n            index : obj.fromHistory ? (this.getMeta() ? this.getMeta().index : historyLength) : ((obj.replace && this.getMeta()) ? this.getMeta().index : (historyLength = historyLength+1))\n        }\n\n        state data which needs to be pushed to history. \n        - Matched object is added to process url directly with history back and forward.\n        - Index is used to detect browser back or forward.\n    */\n    var metaData = obj.metaData || {},\n    currentMeta = this.__lh.prevMeta = this.__lh.currentMeta;\n    metaData.__lh = {\n        index : obj.replace ? (currentMeta ? currentMeta.__lh.index : this.__lh.historyLength-1) : (currentMeta ? currentMeta.__lh.index+1 : this.__lh.historyLength),\n        url : obj.url,\n        title : obj.title\n    }\n    return {\n        meta : this.__lh.currentMeta = metaData,\n        data : obj.data\n    };\n}\n\nfunction stateChange(data,title,url, metaData, replace) {\n    var args = [getHistoryState.call(this, {data , metaData, replace, title, url}) , title] \n    if(url) {\n        /* support for windows, undefined is appended to url */\n        args.push(url)\n    }\n    // this.__lh.prevMeta = history.state && history.state.meta;\n    window.history[replace ? \"replaceState\" : \"pushState\"].apply(window.history, args);\n    var hstry = setHistoryObj.call(this) //this.getHistoryObj();\n    // this.__lh.index = his.index;\n    if(!hstry.fromHistory && !replace) {\n        this.__lh.historyLength++;\n    }\n    return hstry;\n}\n\nfunction setHistoryObj(popHistory) {\n    var self = deepCopyObject(this);\n    if(popHistory) {\n        self.__lh.currentMeta = self.__lh.prevMeta = popHistory.meta;\n        return self.__lh.exp;\n    }\n    self.__lh.exp = new Location(window.location);\n    var href = self.getMeta() && self.getMeta().__lh.url || window.location.href,\n    urlSplit = href.split(\"?\"),\n    search = urlSplit[1] || \"\",\n    hash = urlSplit[0].split(\"#\")[1] || \"\";\n    self.__lh.exp.index = self.__lh.index = self.__lh.currentMeta ?  self.__lh.currentMeta.__lh.index : 0;\n    self.__lh.exp.fromHistory = self.__lh.fromHistory = self.__lh.fromHistory ? (self.__lh.prevMeta ? (self.__lh.prevMeta.__lh.index < self.__lh.currentMeta.__lh.index ? 'forward' : 'back') : 'reload') : false;\n    self.__lh.exp.initial = self.__lh.initial = self.__lh.historyLength == 0;\n    self.__lh.exp.data = self.getData && self.getData() || history.state && history.state.data;\n    self.__lh.exp.url = href;\n    self.__lh.exp.type = this.parent ? this.parent.history.type : this.__lh.historyType;\n    self.__lh.exp.href = self.__lh.exp.origin+self.__lh.exp.pathname+href;\n    self.__lh.exp.search = search && \"?\"+search;\n    self.__lh.exp.hash = hash && \"#\"+hash;\n    self.__lh.state = history.state;\n    self.__lh.currentMeta = self.__lh.prevMeta = self.getMeta && self.getMeta() || history.state && history.state.meta;\n    return self.__lh.exp;\n}\n\nexport {\n    History\n};\n    ","import { _delimit, _dynamicRouteCheck, _frameQueryParams, _getObj, _strPresence, _splitPath, _wildcardRouteCheck } from \"@slyte/router/src/router-utils\";\n\nconst parseRouteMappingStr = \"parseRouteMapping\",\nfunctionStr = \"function\";\nvar  mapObj = {}, \npathStringArr = [], \nrouteStringArr = [],\n_config,\n_initialRegisterRoute,\nroutesObj;\n\nclass RouterMap {\n    constructor() {\n        this.aliasPrefix = [];\n        this.lazyRoute = this.route;\n        this.mountRoute = this.route;\n\n        this.setAlias = function(lyte,_config,alias,route) {\n            var _alias=\"\";\n            if(alias) {\n                if(this.aliasPrefix.length) {\n                    this.aliasPrefix.forEach((a) => {\n                        _alias += a;\n                    });\n                }\n                alias = _alias+alias\n            };\n            if(_config.aliasRouteMap[alias]) {\n                lyte.error('Duplicate entries found for alias \"'+ alias +'\". Existing entry will be overwritten');\n            }\n            _config.aliasRouteMap[alias] = route;\n            _config.routeAliasMap[route] = alias;\n        };\n    }\n\n    route(routeName, obj, nestedFn) {\n        // var lazyRoute;\n        // if(typeof obj.class == functionStr && obj.class.name == \"__routeProm__\") {\n        //     // className = obj.cName;\n        //     lazyRoute = true\n        // }\n        // if(!obj.class) {\n        //     return \"No route file map\"\n        // };\n        if(typeof obj == \"object\"/*  || lazyRoute*/) {\n            if(!obj.path) {\n                obj.path = _delimit(routeName);\n            } else {\n                if(_strPresence(obj.path,\"?\")) {\n                    var split = obj.path.split('?');\n                    obj.defQP = _frameQueryParams(split[1]);\n                    obj.path = split[0] || \"/\";\n                }  \n            }\n            if(obj.queryParams) {\n                obj.defQP = obj.queryParams;\n            }\n        } else {\n            if(typeof obj == functionStr) {\n                nestedFn = obj;\n            }\n            obj = {path : _delimit(routeName) /* ,cName : obj.class.name */};  \n        }\n        mapObj = _getObj(pathStringArr,_config.routeHash)[obj.path] = {__lp : {}};\n        if(obj.path == '/') {\n            pathStringArr.push('/');\n        } else {\n            var trimedPath = obj.path;\n            if(_dynamicRouteCheck(trimedPath) || _wildcardRouteCheck(trimedPath)) {\n                _splitPath(trimedPath).every(function(seg,index,arr) {\n                if(_dynamicRouteCheck(seg) || _wildcardRouteCheck(seg)) {\n                    var dkey;\n                    if(_dynamicRouteCheck(seg)) {\n                        dkey = seg.replace(\":\",\"\");\n                    } else  {\n                        dkey = seg.replace(\"*\",\"\");\n                        obj.wildcard = mapObj.__lp.wildcard = true;\n                        obj.sufix = mapObj.__lp.sufix = [];\n                        for(var i = index+1,j; j = arr[i]; i++) {\n                            mapObj.__lp.sufix.push(j);\n                        }\n                    }\n                    obj.dkey = mapObj.__lp.dkey = dkey;\n                    obj.dIndex = mapObj.__lp.dIndex = index;\n                    return false;\n                }\n                return true;\n                });\n            } \n            pathStringArr.push(trimedPath);\n        }\n        if(obj && obj.mount) {\n            mapObj.__lp.mount = true;\n        }\n        var routes = _getObj(routeStringArr,routesObj) || routesObj;\n        routeStringArr.push(routeName);\n        mapObj.__lp.route = Array.from(routeStringArr);\n        routes[routeName] ? (Object.assign(routes[routeName].__lp,obj)) : (routes[routeName] = {__lp : obj});\n        if(obj.alias) {\n            this.setAlias(this.lyte,_config,obj.alias,mapObj.__lp.route.join('.'))\n        }\n        if(obj.handler.name == \"__routeProm__\") {\n            // obj.then = function(routeStringArr,data) {\n            //     debugger;\n            //     _initialRegisterRoute(routeStringArr,data[obj.cName]);    \n            // }.bind(undefined,Array.from(routeStringArr))\n        } else {\n            _initialRegisterRoute(routeStringArr,obj.handler);\n        }\n        if(nestedFn) {\n            nestedFn.call(this,{});\n        }\n        // if(obj && obj.mount) {\n        //     _config.dependenciesApps[obj.mount] = _config.dependenciesApps[obj.mount] ? _config.dependenciesApps[obj.mount].push(routeStringArr) : [routeStringArr]\n        //     obj.mount.prototype.map.call(this,{});\n        // }\n        routeStringArr.pop();\n        pathStringArr.pop();\n        this.aliasPrefix.pop();\n    }\n    include(mapClass, obj) {\n        try {\n            obj = obj || {};\n            if(obj.aliasPrefix) {\n                this.aliasPrefix.push(obj.aliasPrefix)\n            }\n            obj && new mapClass().map.call(this,{});\n        } catch(e) {\n            console.error(e, \"Error in includes\")\n        }\n    }\n}\n\nRouterMap.__lMod = \"RouterMap\";\n\nfunction _parseRouteMap(MapClass,{ lyte, config , initialRegisterRoute }) {\n    _config = config;\n    _initialRegisterRoute = initialRegisterRoute;\n    lyte.time(parseRouteMappingStr);\n    routesObj = _config.routes ? _config.routes : (_config.routes = {})\n    var ins = new MapClass({ lyte }),\n    err = ins.map(_config);\n    if(typeof err == \"string\") { lyte.log(err)};\n    lyte.time(parseRouteMappingStr);\n    return routesObj;\n}\n\nfunction _traverseMap(path, config) {\n    if(!path) {\n     return;\n    }\n    var selectedPaths = [],\n    fragment;\n    if(config.historyType) {\n        var fragSplit = path.split('#');\n        if(fragment = fragSplit[1]) {\n            path = fragSplit[0];\n        }\n    }\n    var pathSplit = path.split('?');\n    path = decodeURI(pathSplit[0]);\n    if(path == '/') {\n        if(_getObj(['/'],config.routeHash)) {\n            selectedPaths.push([path]);  \n        } else {\n            return;\n        }\n    } else {\n        var params = pathSplit[1],\n        pathSplitArr = _splitPath(path);\n        var pathLevel = 0,\n        pathArrLevel = [0],\n        exactMatch,\n        matchedPath = [];\n        matchedPath.dynamicParams = [];\n        findPossibleMatch(config.routeHash);\n\n        function checkArrayMatch(arr1,arr2,l,pathObj,matchedPath) {\n            if(!(pathObj.__lp.wildcard || pathObj.__lp.dkey)) {\n            var prevObj;\n            if(prevObj = _getObj(matchedPath,config.routeHash).__lp) {\n                if(prevObj.wildcard) {\n                var pathArr = arr2.slice(l);\n                if(!(l += pathArr.indexOf(arr1[0]))) {\n                    return false;\n                }  \n                }\n            }\n            }\n            for(var i = 0,a1;a1 = arr1[i]; i++,l++) {\n            if(a1 != arr2[l] && !_dynamicRouteCheck(a1)) {\n                if(_wildcardRouteCheck(a1)) {\n                if(pathObj.__lp.sufix.length) {\n                    l = arr2.indexOf(pathObj.__lp.sufix[0])-1; \n                }\n                } else if(arr1[l] == '/') {\n                l--;\n                } else {\n                return false;  \n                }\n            }\n            }\n            return l;\n        }\n\n        function findPossibleMatch(mapObj) {\n            for(var mapPath in mapObj) {\n                if(!exactMatch) {\n                    var pathObj = mapObj[mapPath],\n                    innerLevel;\n                    if(mapPath != \"__lp\") {\n                        var mapPathSplit = _splitPath(mapPath);\n                        if(mapPathSplit) {\n                            if((innerLevel = checkArrayMatch(mapPathSplit,pathSplitArr,pathLevel,pathObj,matchedPath)) !== false) {\n                            pathArrLevel.push(innerLevel);\n                            pathLevel = pathArrLevel[pathArrLevel.length-1];\n                                if(pathSplitArr.length == pathLevel || pathObj.__lp.mount) {\n                                    var path = Array.from(matchedPath.concat(mapPath));\n                                    if(pathObj[\"/\"]) {\n                                        path = path.concat('/');\n                                    }\n                                    selectedPaths.push(path);\n                                    if(pathObj.__lp.wildcard || pathObj.__lp.dkey || pathObj.__lp.mount) {\n                                        pathArrLevel.pop();\n                                        pathLevel = pathArrLevel[pathArrLevel.length-1];\n                                    } else {\n                                        if(!/[:*]/.test(path.join(''))) {\n                                            exactMatch = path;  \n                                        }\n                                        return;\n                                    }\n                                } else {\n                                    var innerRoutes = Object.keys(pathObj);\n                                    matchedPath.push(mapPath);\n                                    if(pathSplitArr[pathLevel]) {\n                                    if(pathObj.__lp.wildcard && !pathObj.__lp.sufix.length && innerRoutes.length == 1) {\n                                        var wildcard= Array.from(matchedPath);\n                                        if(pathObj[\"/\"]) {\n                                        wildcard = wildcard.concat('/');\n                                        }\n                                        selectedPaths.push(wildcard);\n                                    } else if(innerRoutes.length > 1) {\n                                        findPossibleMatch(pathObj);    \n                                    }\n                                    } \n                                    matchedPath.pop();\n                                    pathArrLevel.pop();\n                                    pathLevel = pathArrLevel[pathArrLevel.length-1];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(exactMatch) {\n        return [exactMatch,path,params,fragment];\n    } else if(selectedPaths.length == 1) {\n        return [selectedPaths[0],path,params,fragment];\n    } else if(selectedPaths.length) {\n        return [getBestMatch(getStaticMatches(selectedPaths),selectedPaths),path,params,fragment];\n\n        function getBestMatch(staticMatches, selectedPaths, position) {\n            position = position || 0;\n            var traversedStaticMatch = traversedStaticMatch || traverseArray(staticMatches),\n            maxStaticSeg = Math.max(...traversedStaticMatch[position]),\n            duplicatePos;\n            while(duplicatePos = checkForArrayDuplicates(traversedStaticMatch[position], maxStaticSeg, selectedPaths, staticMatches)) {\n                position = position+1;\n                var newSelectedPaths = [],\n                newStaticMatches = [];\n                for(var i = 0,l = duplicatePos.length; i < l; i++) {\n                    newSelectedPaths.push(selectedPaths[i]);\n                    newStaticMatches.push(staticMatches[i]);\n                }\n                var newSelectedPathsFiltered = [],\n                newStaticMatchesFiltered = [];\n                for(var i = 0,l = newStaticMatches.length; i < l; i++) {\n                    if(newStaticMatches[i][position] != undefined) {\n                        newSelectedPathsFiltered.push(newSelectedPaths[i]);\n                        newStaticMatchesFiltered.push(newStaticMatches[i]);\n                    }\n                }\n                if(!newSelectedPathsFiltered.length) {\n                    return newSelectedPaths[0];\n                } else if(newSelectedPathsFiltered.length == 1) {\n                    return newSelectedPathsFiltered[0];\n                }\n                return getBestMatch(newStaticMatchesFiltered, newSelectedPathsFiltered, position);\n            }\n            return selectedPaths[traversedStaticMatch[position].indexOf(maxStaticSeg)];\n        }\n        \n\n        function getStaticMatches(selectedPaths) {\n            var staticSegmentsInMatch = [];\n            for(var i = 0,l = selectedPaths.length; i < l; i++) {\n                var arr = Array.from(selectedPaths[i]),\n                staticPath = 0,\n                result = [];\n                if(arr[0] == \"/\") {\n                    arr.shift();\n                }\n                if(arr[arr.length-1] == \"/\") {\n                    arr.pop();\n                }\n                var counter = -1;\n                arr.every(function(seg,i) {\n                    var noWildcard = true;\n                    _splitPath(seg).every(function(innerSeg,j) {\n                    counter++;\n                    if(innerSeg == pathSplitArr[counter]) {\n                        staticPath++;\n                        if(arr.length == i+1){\n                        result.push(staticPath);\n                        }\n                        return true;\n                    } else if(innerSeg.indexOf(':') != -1) {\n                        result.push(staticPath);\n                        staticPath = 0;\n                        return true;\n                    } else {\n                        if(innerSeg.indexOf('*') != -1) {\n                        noWildcard = false;\n                        }\n                        result.push(staticPath);\n                        return false;\n                    }\n                    });  \n                    return noWildcard;\n                });\n                staticSegmentsInMatch.push(result);\n            }\n            return staticSegmentsInMatch;\n        }\n    } else {\n        return false;\n    }\n}\n\nfunction checkForArrayDuplicates(arr, value) {\n    var pos = [];\n    for(var i = 0,l = arr.length;i < l; i++) {\n        if(arr[i] == value) {\n            pos.push(i);\n        }\n    }\n    return pos.length == 1 ? false : pos;\n}\n\nfunction traverseArray(arr) {\n    var res = [],\n    maxArrLen = 0;\n    for(var i = 0,l = arr.length; i < l; i++) {\n        var a = arr[i];\n        maxArrLen = a.length > maxArrLen ? a.length : maxArrLen;\n    }\n    for(var i=0,a ;a = arr[i]; i++) {\n        for(var j=0; j<maxArrLen; j++) {\n            res[j] = res[j] || [];    \n            res[j][i] = a[j];\n        } \n    }\n    return res;\n}\n\nexport {\n    _parseRouteMap,\n    _traverseMap,\n    RouterMap\n}","import { _compareObj, _dotSerperator, _normalizeMatchedObj, _normalizeTransitionParams, _strPresence } from \"@slyte/router/src/router-utils\";\nimport { Service } from '@slyte/core/src/service';\n\n/*convert to custom class*/\nclass Route extends Service {\n    constructor({ i, routeName, options, init})  {\n\t\tsuper();\n\t\tconst { lyte, LR } = options;\n\t\tthis.routeName = routeName;\n\t\tthis.$router = LR;\n\t\tObject.defineProperties(this,{\n\t\t\t\"navigation\" : {\n\t\t\t\tget : function() {\n\t\t\t\t\treturn LR.__lp.nav.get(this)._trans;\n\t\t\t\t}\n\t\t\t}, \n\t\t\t\"__lp\" : {\n\t\t\t\tget : function() {\n\t\t\t\t\treturn LR.__lp.nav.get(this).rOpts[i];\n\t\t\t\t},\n\t\t\t\tset : function(key, value) {\n\t\t\t\t\tif(key == \"toBeUsed\") {\n\t\t\t\t\t\tif(this.__lp.toBeUsed.length){\n\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\tlyte.extendService({services : this.__lp.toBeUsed || [], type:\"route\", ins: this, callback : function(serv, key, aName, serName){\n\t\t\t\t\t\t\t\tvar obj = {};\n\t\t\t\t\t\t\t\tobj.key = key;\n\t\t\t\t\t\t\t\tobj.service = serName;\n\t\t\t\t\t\t\t\tlyte.extendService({services : [obj], type:\"route\", ins: self});\n\t\t\t\t\t\t\t}});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLR.__lp.nav.get(this).rOpts[i][key] = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"$\" : {\n\t\t\t\tget : function() {\n\t\t\t\t\treturn LR.__lp.nav.get(this).rOpts[i].$;\n\t\t\t\t},\n\t\t\t\tset : function(key, value) {\n\t\t\t\t\tLR.__lp.nav.get(this).rOpts[i].$[key] = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"currentData\" : {\n\t\t\t\tget : function() {\n\t\t\t\t\treturn LR.__lp.nav.get(this).rOpts[i].currentData;\n\t\t\t\t},\n\t\t\t\tset : function(value) {\n\t\t\t\t\tLR.__lp.nav.get(this).rOpts[i].currentData = value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// this.parent = routes[i-1] instanceof Promise ? routes[i-1].then(function() {this.parent = routes[i-1]}.bind(this)) : routes[i-1];\n\t\tthis.removeFromCache = function(arr) {\n\t\t\tlyte.removeFromCache.assign.call(lyte,arr);\n\t\t};\n\t\tthis.replaceWith = LR.replaceWith;\n\t\tthis.navigateTo = LR.navigateTo;\n\t\tthis.navigateForward = LR.navigateForward;\n\t\tthis.navigateBack = LR.navigateBack;\n\t\tthis.refresh = function(obj) {\n\t\t\tvar refreshFrom = _dotSerperator(this.__lp.objPath).length-1,\n\t\t\ttrans = options.trans,\n\t\t\troute = Array.from(trans.matched.route),\n\t\t\tprocessed = {\n\t\t\t\tmatched : trans.matched,\n\t\t\t\tR : trans.R,\n\t\t\t\trOpts : trans.rOpts,\n\t\t\t\ttransComp : {\n\t\t\t\t\tunRendered : route.splice(refreshFrom),\n\t\t\t\t\trendered : route\n\t\t\t\t}\n\t\t\t};\n\t\t\ttrans.abort({state : 308, iAbort : true});\n\t\t\toptions.newTransInfo = {replace : true, data : trans.data, fromHistory : false, url : trans.url};\n\t\t\tif(obj && obj.refreshTemplate) {\n\t\t\t\tprocessed.refreshFrom = refreshFrom;\n\t\t\t}\n\t\t\treturn options.dispatch(trans.url, processed)._trans;\n\t\t};\n\t\tthis.setTitle = function(title) {\n\t\t\td.title = this.title = title;\n\t\t};\n\t\tthis.getQueryParams = function() {\n\t\t\treturn this.__lp.param.queryParams;\n\t\t};\n\t\tthis.getDynamicParam = function() {\n\t\t\treturn this.__lp.param.dynamicParam;\n\t\t};\n\t\tObject.defineProperty(this,'$lg', {\n\t\t\tvalue : lyte.__gl\n\t\t});\n\t\tthis.getRouteInstance = function(routeName) {\n\t\t\treturn LR.getRouteInstance(routeName);\n\t\t};\n\t\tthis.setDynamicParam = function(value) {\n\t\t\tif(value && this.__lp.param.dynamicParam && this.__lp.param.dynamicParam != value) {\n\t\t\t\tvar dynamicParams = Array.from(options.trans.matched.dynamicParams);\n\t\t\t\toptions.trans.matched.dpObj\n\t\t\t\tdynamicParams.splice(this.__lp.objPath.split(\".\").length-1, 1, value);\n\t\t\t\treturn paramChangeTrans(options, cloneMatchedObj(options.trans.matched,{dynamicParams : dynamicParams}));\n\t\t\t}\n\t\t\treturn options.trans._trans;\n\t\t};\n\n\t\tthis.setQueryParams = function(key,value,opts)  {\n\t\t\tvar obj = {},\n\t\t\trefresh;\n\t\t\tif(typeof key == \"object\") {\n\t\t\t\tobj = key;\n\t\t\t\topts = value;\n\t\t\t} else {\n\t\t\t\tobj[key] = value;\n\t\t\t}\n\t\t\tif(typeof opts == \"object\") {\n\t\t\t\trefresh = opts.refresh;\n\t\t\t}\n\t\t\trefresh = opts;\n\t\t\tvar matched = cloneMatchedObj(options.trans.matched,{queryParams : Object.assign({},options.trans.matched.queryParams,obj)});\n\t\t\tif(!_compareObj(options.trans.matched.queryParams,matched.queryParams)) {\n\t\t\t\tmatched.refreshData = matched.refreshData == undefined ? refresh : matched.refreshData;\n\t\t\t\treturn paramChangeTrans(options, matched);\n\t\t\t}\n\t\t\treturn options.trans._trans;\n\t\t};\n\t\t//give support for remove query params\n\t\tthis.throwEvent = typeof lyte.$.component !== \"undefined\" && lyte.$.component.throwEvent;\n\t\tinit(this)\n\t\tif(this.init) {this.init();}\n\t}\n}\n\nRoute.__lMod = \"Route\";\n\nfunction paramChangeTrans(options, matched) {\n\tvar url = options.constructURLFromRoute(matched),\n\tprocessed = {\n\t\tmatched : matched,\n\t\tR : options.trans.R,\n\t\trOpts : options.trans.rOpts\n\t};\n\toptions.newTransInfo = {\n\t\tdata: options.trans.data,\n\t\turl: url,\n\t\tfromHistory: false\n\t};\n\toptions.dispatch(url, options.decideTransition(processed));\n\treturn options.newTrans._trans;\n}\n\nfunction cloneMatchedObj(matched, data) {\n\tvar obj = Object.assign({}, matched);\n\tobj.route = data.route || Array.from(matched.route)\n\tobj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams)\n\tobj.queryParams = data.queryParams || Object.assign({}, matched.queryParams)\n\tdelete obj.refreshRoute;\n\tdelete obj.refreshData;\n\treturn obj;\n\t// var obj = Object.assign({},matched);\n\t// obj.route = data.route || Array.from(matched.route);\n\t// obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams);\n\t// obj.queryParams = data.queryParams || Object.assign({},matched.queryParams);\n\t// return obj;\n}\n\nexport { Route };\n\n// src = prevInstance || this.constructor,\n// routePredefined = options.routePredefined;\n// for(var key in src) {\n// \tif(_strPresence(routePredefined,key)) {\n// \t\tthis.#__lp__.fns[key] = src[key];\n// \t} else if(key == \"actions\") {\n// \t\tif(typeof ins.constructor.actions == \"function\") {\n// \t\t\tins.actions = ins.constructor.actions();\n// \t\t}\n// \t\toptions.fns.actions = RouteClass.actions && RouteClass.actions() || {};\n// \t} \n// else if(prevInstance) {\n// \tif(key != \"__lp\") {\n// \t\tthis[key] = src[key]; // need to remove this;\n// \t}\n// } \n// }\n// routePredefined.forEach(function(key) {\n// \tif(key == \"actions\") {\n// \t\tif(typeof ins.constructor.actions == \"function\") {\n// \t\t\tins.actions = ins.constructor.actions();\n// \t\t}\n\n// \t\toptions.fns.actions = RouteClass.actions && RouteClass.actions() || {};\n// \t} else {\n// \t\toptions.fns[key] = RouteClass.prototype[key]\n// \t}\n// \tdelete RouteClass.prototype[key];\n// });\n\n// for(var key in src) {\n// \tif(prevInstance || !_strPresence(routePredefined,key)) {\n// \t\tif(key != \"__lp\") {\n// \t\t\tthis[key] = src[key];\n// \t\t}\n// \t} \n// }\n\n// [beforeFetch,fetch,afterFetch].forEach(function(key) {\n// \tObject.defineProperties(this.$, {\n// \t\t[key] : {\n// \t\t\tget : function() {\n// \t\t\t\treturn this.__lt.rOpts[i].$[key];\n// \t\t\t},\n// \t\t\tset : function() {\n// \t\t\t\tthis.__lt.rOpts[i].$[key] = value;\n// \t\t\t}\n// \t\t}\n// \t})\n// })\n// this.__lp = deepCopyObject(prevInstance && prevInstance.__lp || routeOptions);\n// this.__lp = deepCopyObject((prevInstance && prevInstance.__lp) || RouteClass.__lp); make only one instance\n// delete this.__lt.rendered;\n// this.transition = this.navigation = options.newTrans._trans;\n// if(processed.transComp && !processed.transComp.rendered[i] && processed.transComp.redirected) {\n// \tif(processed.transComp.redirected.i < i) {\n// \t\tdelete this.__lp.loadDependencies;\n// \t\tdelete this.__lp.loadResources;\n// \t\tthis.$ = {};\n// \t\tdelete this.currentModel;\n// \t} else if(processed.transComp.redirected.i != i) {\n// \t\tdelete this.__lp.stencils;\n// \t}\n// } else {\n// \tdelete this.__lp.stencils;\n// }\n// this.__lp.param = {\n// \tqueryParams :{},\n// \tdynamicParam : undefined\n// }\n// this.__lp.queryParams = {};","import { Logger } from \"/node_modules/@slyte/core/index.js\";\n\nclass RouterError extends Logger {\n    static getErrorMessage(code) {\n        arguments[0] = `LR${code}`\n        var msg = super.getErrorMessage.apply(this,arguments);\n        return msg;\n    }\n}\n\nRouterError.errorCodes = {\n    LR400 : `url \"{0}\" is not defined in router.`,\n    LR400A : `Base path of url is not specified.`,\n    LR422 : `There is no route definition for the route {args[1].splice(0,args[2]+1).join('.')}.`,\n    LR498 : `Invalid argument {0}`,\n    LR498A : `Invalid argument {0} provided in {1}.`,\n    LR499 : `Dynamic params for the route {0} is not provided.`,\n    LR499A : `Dynamic params for the route {0} is not provided {args[2].outerHTML}.`,\n    LR499B: `Transition tried without arguments.`,\n    LR405 : `Method invocation before Router initialized.`,\n     // LR203 : `Data provided for component is not valid.`,\n     LR428 : `There is no outlet named {0}.`,\n     LR420A : `Error in {0} of route {1}.`,\n     LR420 : `Promise rejected`\n    //  LR424 : `File not loaded in {0} of route {1}.\\n {args[3][0].target.outerHTML}`,\n};\n\nexport {\n    RouterError\n}\n\n\n// var lyte;\n\n// function _getError() {\n//     var args = arguments,\n//     error;\n//     switch(args[0]) {\n//         case 400 :\n//             error = args[1] ? \"url '\"+args[1]+\"' is not defined in router.\" : \"Base path of url is not specified.\";\n//             break;\n//         case 422 :\n//             error = \"There is no route definition for the route \"+(args[1].splice(0,args[2]+1).join('.'))+\".\";\n//             break;\n//         case 424 : \n//             error = \"File not loaded in \"+args[1]+ \" of route \"+args[2]+\".\\n\"+args[3][0].target.outerHTML;\n//             break;\n//         case 498: \n//             error = \"Invalid argument \" + args[1] + (args[2] ? \" provided in \"+args[2] : \".\");\n//             break;\n//         case 499 : \n//             error = args[1] ? (\"Dynamic params for the route \"+args[1]+\" is not provided\" + (args[2] && args[2].outerHTML  ? \" in \"+args[2].outerHTML : \".\")) : \"Transition tried without arguments.\";\n//             break;\n//         case 420 : \n//             error = (args[3]? \"Promise rejected\" : \"Error\")+\" in \"+args[1]+\" of route \"+args[2]+\".\";\n//             break;\n//         case 428 : \n//             error = \"There is no outlet named \"+args[1]+\".\";\n//             break;\n//         case 203 :\n//             error =  \"Data provided for component is not valid.\";\n//             break;\n//         case 405 :\n//             error =  \"Method invocation before Router initialized.\";\n//             break;\n//     }\n//     return 'LR '+args[0]+': '+error;\n// }\n\n// function _bindLyteInstanceToError(ins) {\n//     lyte = ins;\n// }\n\n// function _consoleError() {\n//     return lyte.error(arguments[0].stack ? arguments[0] : _getError.apply(this,arguments),arguments[3]);\n// }\n\n// export {\n//     _bindLyteInstanceToError,\n//     _getError,\n//     _consoleError\n// }\n\n\n\n// class ValidationError extends Dberror{\n//     static errorCodes = {\n//         ERR01 : \"Primary key cannot be modified\", \n//         ERR02 : \"Mandatory prop cannot be empty\", \n//         ERR03 : \"Type of value does not match the specified data type\",\n//         ERR04 : \"Value is greater than the maximum value allowed\",\n//         ERR05 : \"Value is less than the minimum value allowed\", \n//         ERR06 : \"Length of string/array is greater than the maximum limit allowed\", \n//         ERR07 : \"Length of string/array is less than the minimum limit allowed\",\n//         ERR08 : \"String does not match the specified pattern\", \n//         ERR09 : \"Values in array are not unique\", \n//         ERR10 : \"Value is not equal to the specified constant\", \n//         ERR11 : \"Schema of related field is not defined\",\n//         ERR12 : \"Schema of backward relation is not defined\", \n//         ERR13 : \"Entity not found\", \n//         ERR14 : \"Schema does not match the schema defined in the related field\", \n//         ERR15 : \"Error in creating a entity as a relation\",\n//         ERR16 : \"Entity with primary key already exists\", \n//         ERR17 : \"Value cannot be changed because entity has been deleted\", \n//         ERR18 : \"Action not defined\", \n//         ERR19 : \"Schema not defined\",\n//         ERR20 : \"Key not specified\", \n//         ERR21 : \"'one' relationship expects a single object/id\", \n//         ERR22 : \"Type not specified for polymorphic relation\", \n//         ERR23: \"Primary Key value not present\", \n//         ERR24: \"Error while relating entities\", \n//         ERR25: \"Backward relation not present\",\n//         ERR26: \"Primary key value cannot be undefined or null\",\n//         ERR27: `Observer can observe only string data type value, {0} value cannot be observed in the function named '{0}' in the component '{1}'`,\n//         ERR29: \"Property not defined in the object\",\n//         ERR30: \"Property's value is not an instanceof the mentioned class\"      \n//     }\n//     constructor(lyte, attr, obj, message){\n//         super();\n//         Object.defineProperties(this, {\n//              : {\n//                 value : {isError : true , error:message?message:{}}\n//             }\n//         });\n//         if(attr){\n//             ValidationError.setError(lyte,this,attr,obj);\n//         }    \n//     }\n\n//     static setError(lyte,err,attr,codeObj){\n//         if(err..hasOwnProperty(\"error\")){\n//             if(Array.isArray(attr)){\n//                 attr.forEach(function(itm){\n//                     cmpSet(lyte, err..error, itm, codeObj);\n//                 });\n//             }\n//             else{\n//                 cmpSet(lyte, err..error,attr,codeObj);\n//             }\n//         }\n//         else{\n//             ValidationError.error(\"LD03\",err,attr);\n//         }\n//     }\n\n//     static setRecErr(ent, field, code, value){\n//         var lyte = ent.schema.Lyte;\n//         cmpSet(lyte, ent, \"isError\", true);\n//         var errObj = code;\n//         if(typeof errObj == \"object\"){\n//             cmpSet(lyte, ent.error,field,errObj);\n//         }\n//         else{\n//             if(typeof code == \"string\"){\n//                 var errMes = ValidationError.errorCodes[code];\n//                 if(errMes){\n//                     errObj = {code : code, message : ValidationError.errorCodes[code]};\n//                 }\n//                 else{\n//                     errObj = code;\n//                 }\n//             }\n//             cmpSet(lyte, ent.error, field, errObj);\n//             if(value){\n//                 cmpSet(lyte, ent.error[field],\"value\",value);\n//             }\t\t\t\t\n//         }\n// \t\tvar db = ent.schema.db;\n//         emit(db,\"error\",ent.entity,field,errObj);\n//     }\n\n//     static clrRecErr(ent, field, code){\n//         var lyte = ent.schema.Lyte;\n//         var objUtl = lyte.objectUtils;\n//         var err = ent.error;\n//         if(code){\n//             if(ent.error.code == code){\n//                 if(typeof objUtl != \"undefined\"){\n//                     objUtl(err,\"delete\",field);\n//                 }\n//                 else{\n//                     delete err[field];                        \n//                 }\n//             }\n//         }\n//         else if(field){\n//             if(typeof objUtl != \"undefined\"){\n//                 objUtl(err,\"delete\",field);\n//             }\n//             else{\n//                 delete err[field];                       \n//             }\n//         }\n//         else{\n//             if(typeof objUtl != \"undefined\"){\n//                 for(var err in err){\n//                     objUtl(err,\"delete\",err);\n//                 }\n//             }\t\n//             else{\n//                 ent.error = {};\n//             }   \n//         }\n//         if(Object.keys(ent.error).length == 0){\n//             cmpSet(lyte, ent, \"isError\", false);\n//         }\n//     }\n// }\n\n// class ConnectorError extends Dberror {\n//     constructor(msg, xhr){\n//         super();\n//         this.message = msg;\n//         this.xhr = xhr;\n//     }\n// }\n\n// class SerializerError extends Dberror{\n//     constructor(msg, xhr){\n//         super();\n//         this.message = msg;\n//         this.xhr = xhr;\n//     }\n// }\n\n// export { ValidationError, Dberror, ConnectorError, SerializerError };","import { deepCopyObject } from \"@slyte/core/src/lyte-utils\";\nimport { _consoleError } from \"./router-errors\";\n\nconst _strPresence = (str, char) => str.includes(char),\n\n_dotSerperator = (str) => str.split('.').filter(Boolean),\n\n_dynamicRouteCheck = (route) => _strPresence(route,\":\"),\n\n_wildcardRouteCheck = (route) => _strPresence(route,\"*\"),\n\n_delimit = (seg) => seg[0] == \"/\" ? seg : \"/\"+seg,\n\n_splitPath = (path) => path.match(/[^/?]+/g) || [];\n\nfunction scriptExecution(scriptNode) {\n    for(var i=0,currentScript;currentScript = scriptNode[i];i++) {\n        var parent = currentScript.parentNode,\n        s = d.createElement(\"script\");\n        for(var j = 0,attributes;attributes = currentScript.attributes[j]; j++) {\n        s.setAttribute(attributes.name, attributes.value);\n        }\n        s.innerHTML = currentScript.innerHTML;\n        parent.appendChild(s);\n        parent.removeChild(currentScript);\n    }\n}\n\nfunction _compareObj(obj1,obj2) {\n    var obj1keys = Object.keys(obj1),\n    obj2keys = Object.keys(obj2);\n    if(obj1keys.length != obj2keys.length) {\n    return false;\n    } else {\n    for(var key in obj1) {\n        if(obj1[key] != obj2[key]) {\n        return false;\n        }\n    }\n    return true;\n    }\n}\n\nfunction _getObj(arr,obj) {\n    /**\n     *  get nested property from an object\n     * @params {array} array\n     * @params {object} object\n     * @returns\n     */\n    if(!obj) {\n        return;\n    } else if(!arr) {\n        return obj;\n    } else if(!Array.isArray(arr) && typeof arr == 'string') {\n        arr = _dotSerperator(arr);\n    }\n    arr.every(function(key)  {\n        if(obj && obj[key]) {\n            obj = obj[key];\n            return true;\n        }\n        return obj = false;\n    });\n    return obj;\n}\n\nfunction _frameQueryParams(url) {\n    if(url) {\n        var qp = {},\n        split,\n        params = _strPresence(url,\"?\") ? url.split(\"?\")[1] : url;\n        params = _strPresence(params,\"&\") ? params.split(/&/g) : [params];\n        for(var i = 0,l = params.length; i < l; i++) {\n            qp[(split = params[i].split('='))[0]] = split[1] ? decodeURIComponent(split[1]) : split[1];\n        }\n        return qp;\n    } \n}\n\nfunction _frameDynamicParams(url,matched, routesObj) {\n    var dynamicParam,\n    fdp,\n    framedDP = [],\n    urlSplit = _splitPath(url.split('?')[0]);\n    for(var i = 0,l = matched.route.length,r; i < l; i++) {\n        r = matched.route[i];\n        routesObj = _getObj([r],routesObj);\n        var routeObj =  routesObj.__lp;\n        if(routeObj.wildcard) {\n            if(routeObj.sufix.length) {\n            var dp = urlSplit.slice(0,urlSplit.indexOf(routeObj.sufix[0]));\n            fdp = decodeURI(dp.join('/'));\n            pop(dp.concat(routeObj.sufix),urlSplit);\n            } else {\n            fdp = decodeURI(urlSplit.join('/'));\n            }\n        } else if(routeObj.dkey) {\n            dynamicParam = urlSplit[routeObj.dIndex];\n            pop(_splitPath(routeObj.path),urlSplit);\n            fdp = decodeURI(dynamicParam);\n        } else {\n            pop(_splitPath(routeObj.path),urlSplit);\n            fdp = undefined;\n        }\n        framedDP.push(fdp);\n    };\n    return framedDP;\n}\n\nfunction _validateURL(url) {\n    url = url.replace(/\\/\\//g,'/');\n    url = url.replace(/\\/\\?/g,'?');\n    return url;\n}\n\nfunction _normalizeTransitionParams(obj) {\n    // To normalize argument for transition, returns matched obj from obj or native tranisitionTo argument.\n    var params;\n    if(typeof obj == \"object\") {\n        params = obj;\n    } else {\n        params = {\n            queryParams : {},\n            dynamicParams : []\n        };\n        Array.from(arguments).forEach(function(arg,index) {\n            if(Array.isArray(arg)) {\n                _consoleError.call(lyte,498,JSON.stringify(arg));\n                return;\n        } else {\n            if(index == 0) {\n                params.route = arg;\n        } else if(arg && typeof arg == \"object\") {\n            params.queryParams = deepCopyObject(arg);\n            } else {\n                params.dynamicParams.push(arg);\n            }  \n        }\n        });\n    }\n    return params;\n}\n\nfunction _getRouteFromAlias(obj) {\n\tvar route = obj.route,\n    alias;\n\tif(typeof route == \"string\") {\n        if(route.indexOf('$') == 0) {\n            alias = route.split('$')[1],\n            map = obj.map;\n            // if(map || (map = config.engineConf[config.mountedEngines[obj.parent]].aliasRouteMap)) {\n            // }\n                if(map[alias]) {\n                    route = map[alias]\n                } else {\n                    _consoleError.call(this,obj.route+' is not a valid route alias')\n                    return;\n                }\n        }\n        route = route.split('.');\n\t}\n    return { route, alias};\n}\n\nfunction _checkIfSameRoute(transInfo1, transInfo2) {\n    if(transInfo1 && transInfo2 && transInfo1.route == transInfo2.route && transInfo1.fragment == transInfo2.fragment && transInfo1.dynamicParams.length === transInfo2.dynamicParams.length && _compareObj(transInfo1.queryParams,transInfo2.queryParams)) {\n        if(transInfo1.dynamicParams.length) {\n            for(let i = 0,dynamicParam; dynamicParam = transInfo1.dynamicParams[i]; i++) {\n                if(dynamicParam != transInfo2.dynamicParams[i]){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\nfunction pop(path,urlSplit) {\n    for(var i = 0,l = path.length; i < l; i++) {\n        urlSplit.shift();\n    };\n}\n\nexport {\n    _strPresence,\n    _dotSerperator,\n    scriptExecution,\n    _getObj,\n    _delimit,\n    _splitPath,\n    _getRouteFromAlias,\n    _compareObj,\n    _dynamicRouteCheck,\n    _wildcardRouteCheck,\n    _frameQueryParams,\n    _normalizeTransitionParams,\n    _validateURL,\n    _frameDynamicParams,\n    _checkIfSameRoute\n}","import { Lyte } from '@slyte/core';\nimport { deepCopyObject } from '@slyte/core/src/lyte-utils';\nimport { Service } from '@slyte/core/src/service';\nimport { linkToRegistration } from './go-to';\nimport { History } from './history';\nimport { _parseRouteMap, _traverseMap } from './map-parser';\nimport { RouterError } from './router-errors';\nimport { _dotSerperator, scriptExecution, _strPresence, _getObj, _delimit, _splitPath, _getRouteFromAlias, _compareObj, _wildcardRouteCheck, _dynamicRouteCheck, _frameQueryParams, _frameDynamicParams, _normalizeTransitionParams, _validateURL, _checkIfSameRoute} from './router-utils';\n\n/*-----------string declaration starts------------*/\nconst routeStr = \"route\",\nRouteStr = \"Route\",\nfetchStr = \"fetch\",\nFetchStr = \"Fetch\",\nforceFetchStr = \"force\" + FetchStr,\nNavigationStr = \"Navigation\",\nNavigateStr = \"Navigate\",\npendingStr = \"pending\",\ncompletedStr = \"completed\",\nabortedStr = \"aborted\",\nbeforeStr = \"before\",\nafterStr = \"after\",\ndidStr = \"did\",\nwillStr = \"will\",\nnestedForcedPromisesStr = \"nestedForcedPromises\",\nconstructRunLoopStr = \"constructRunLoop\",\ngetRequirementsStr = \"getRequirements\",\ndivertStr = \"divert\",\nrenderStr = \"render\",\nonErrorStr = \"onError\",\nbeforeLoadStr = \"beforeLoad\",\nonBeforeLoadStr = \"onBeforeLoad\",\nLINKTOStr = \"LINK-TO\",\nstateChangeStr = \"stateChange\",\nDestroyStr = \"Destroy\",\nRouteNavigationStr = \"Route\" + NavigateStr,\nafterRenderStr = afterStr + \"Render\",\nbeforeExitStr = beforeStr + \"Exit\",\ndidDestroyStr = didStr + DestroyStr,\npRoute = \"lt-prop-\" + routeStr,\nNavigationAbortedStr = NavigationStr+\" \"+abortedStr + \".\",\nNavigationResumedStr = NavigationStr + \" resumed.\",\nNavigationPausedStr = NavigationStr + \" paused.\",\nNavigationComletedStr = NavigationStr+\" \"+completedStr + \".\",\nbeforeFetchStr = beforeStr + FetchStr,\nafterFetchStr = afterStr + FetchStr,\nwillNavigateStr = willStr + NavigateStr,\ndidNavigateStr = didStr + NavigateStr,\nbeforeRouteNavigationStr = beforeStr+RouteStr + NavigationStr,\nafterRouteNavigationStr = afterStr+RouteStr + NavigationStr,\nbeforeTemplateDestroyStr = beforeStr+\"Template\" + DestroyStr,\nrenderLoadingTemplateStr = \"renderLoadingTemplate\",\nrenderTemplateWarning = renderStr+\" hook should return either component or HTML. Rendering of HTML directly into the DOM within the \"+renderStr + \" hook is deprecated.\",\n__routeProm__Str = \"__routeProm__\",\n/*-----------string declaration ends------------*/\nfontColor = \"MediumOrchid\",\ndloc = document.location,\nresolvedPromise = Promise.resolve(),\nemptyFn = function() {};\n\nfunction getHook(routeInstance, hook) {\n\treturn routeInstance.__lp.fns[hook]\n}\n\nfunction getAction(routeInstance, action) {\n\treturn routeInstance.__lp.fns.actions && routeInstance.__lp.fns.actions[action]\n}\n\n/*convert to custom class*/\nclass Router extends Service {\n    constructor(a) {\n        super(a)\n        this.__lp = {\n            version : \"1.0.0-beta.4\",\n            pendingReg : [],\n            mountedApps : {},\n            config : {},\n            nav : new WeakMap()\n        };\n\n        this.checkIfSameRoute = _checkIfSameRoute;\n        var newTransInfo,\n\t\tnewTransInfoClone,\n\t\tnewTransInfoTimer,\n\t\tlHistory,\n\t\tconfig = {\n\t\t\thistoryType : false,\n\t\t\tbaseURL : \"\",\n\t\t\tdeferInit : false,\n\t\t\tpreserveUrlOnBrowserNavigation : false,\n\t\t\tqueryParamOptions : { cache : true},\n\t\t\trouteHash : {},\n\t\t\turlCache : {},\n\t\t\taliasRouteMap : {},\n\t\t\trouteAliasMap : {},\n\t\t\tcacheRoutes : {},\n\t\t\tallLinks : {},\n\t\t\tactiveLinkTags : []\n\t\t},\n\t\ttrans,\n\t\tprevTrans,\n\t\tnewTrans,\n\t\tvisibleTrans,\n\t\thistoryObj,\n\t\tinitialLoad = true,\n\t\tfromHistoryGo = false,\n\t\tprocessedDispatch;\n\n        const run = {},\n\t\tlyte = this.$app,\n\t\tLR = this;\n\n        lyte.extendEventListeners(this);\n\n        run[getRequirementsStr] = function(hook,index) {\n\t\t\tconst r = this.routes[index],\n\t\t\tres = r.__lp.loadResources =  [],\n\t\t\tdep = r.__lp.loadDependencies = [],\n\t\t\tcallback = r.__lp.fns[hook];\n\t\t\tif(callback) {\n\t\t\t\tcallHookWithoutPromise.call(this,callback,hook,index,[r.__lp.param, res, dep]);\n\t\t\t} \n\t\t\tr.__lp.req = {\n\t\t\t\tresources : r.__lp.loadResources = Promise.all(res).then(function() {\n\t\t\t\t\tr.__lp.resourcesLoaded = true\n\t\t\t\t}),\n\t\t\t\tdependencies : r.__lp.loadDependencies = Promise.all(dep).then(function() {\n\t\t\t\t\tr.__lp.dependenciesLoaded = true\t\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn resolvedPromise;\n\t\t}\n\n        run[beforeFetchStr] = \n\t\trun[fetchStr] = \n\t\trun[afterFetchStr] = function(hook,index) {\n\t\t\tvar routeInstance = this.routes[index],\n\t\t\targs = [getHook(routeInstance, hook),routeInstance];\n\t\t\targs.push(hook == afterFetchStr ? [routeInstance.currentData, routeInstance.__lp.param] : [routeInstance.__lp.param]);\n\t\t\treturn callHookWithPromise.apply(this,args).then(setDataIn$,setDataIn$);\n\t\t\tfunction setDataIn$(data) {\n\t\t\t\trouteInstance.$[hook] = data;\n\t\t\t\tif(hook == fetchStr) {\n\t\t\t\t\trouteInstance.currentData = data;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n        run[divertStr] = function(hook,index) {\n\t\t\tvar routeInstance = this.routes[index];\n\t\t\treturn callHookWithPromise.apply(this,[getHook(routeInstance,hook),routeInstance,[routeInstance.currentData, routeInstance.__lp.param]]);\n\t\t};\n\n        run[onErrorStr] = function(hook,index,err,state,options) {\n\t\t\tsetPendingResume.call(trans,trans.prom);\n\t\t\ttrans._trans.triggerEvent(onErrorStr,{error : err,hook : hook});\n\t\t\tvar errIns = this.routes[index];\n\t\t\tfor(; index >= 0 && !this.aborted && this.paused; index--) {\n\t\t\t\tvar instance = this.routes[index];\n\t\t\t\tlyte.log(onErrorStr+\" of \"+ instance.routeName,routeStr,fontColor);\n\t\t\t\tif(callAction.call(this,onErrorStr,index,[err,this._trans, instance.__lp.param, hook]) == false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}  \n\t\t\t}\n\t\t\tif(!options || !options.consoled) {\n\t\t\t\t_consoleErrorFromCallback(err,hook,errIns.routeName,state,options);\n\t\t\t}\n\t\t};\n\n        run[willNavigateStr] = function(hook,index) {\n\t\t\tif(callAction.call(prevTrans,hook,index,[trans._trans]) == false) {\n\t\t\t\tremoveHook(trans.runLoop.previous,hook);\n\t\t\t}\n\t\t\treturn resolvedPromise;\n\t\t};\n\n        run[beforeRouteNavigationStr] = function() {\n\t\t\tif(validateTransition(this)) {\n\t\t\t\tvar pt;\n\t\t\t\tif(pt = prevTrans && prevTrans._trans) {\n\t\t\t\t\tdelete pt.abort;\n\t\t\t\t\tdelete pt.pause;\n\t\t\t\t}\n\t\t\t\tvar obj = {\n\t\t\t\t\tprevNav : pt,\n\t\t\t\t\tnav : trans._trans,\n\t\t\t\t\tlocation : {fromHistory : (initialLoad ? \"reload\" : (newTrans && newTrans.navigationType ? false : true)), initial : initialLoad}\n\t\t\t\t}\n\t\t\t\tvar callback = LR[beforeRouteNavigationStr]\n\t\t\t\tcallback && callback.call(LR, obj.prevNav, obj.nav , obj.location);\n\t\t\t\ttriggerEventOnInsAndClass(beforeRouteNavigationStr, obj)\n\t\t\t}\n\t\t\treturn resolvedPromise;\t\n\t\t};\n\n        function triggerEventOnInsAndClass(ev,args) {\n\t\t\ttrans._trans.triggerEvent(ev,args);\n\t\t\tLR.triggerEvent(ev, args);\n\t\t\tlyte.triggerEvent(ev, args);\n\t\t}\n\n        run[afterRouteNavigationStr] = function(_trans) {\n\t\t\tvar callback = LR[afterRouteNavigationStr];\n\t\t\tcallback && callback.call(LR, _trans);\n\t\t\ttriggerEventOnInsAndClass(afterRouteNavigationStr, {nav : _trans})\n\t\t};\n\n        run[beforeLoadStr] = function(hook,index) {\n\t\t\tvar routeProp = this.routes[index].__lp;\n\t\t\tif(routeProp.fns[hook]) {\n\t\t\t\tlyte.log(beforeLoadStr +' callback is depricated. Use renderLoadingTemplate callback');\n\t\t\t}\n\t\t\tcallHookWithoutPromise.call(this,routeProp.fns[hook],hook,index,[routeProp.param]);\n\t\t\treturn resolvedPromise;\n\t\t};\n\n        run[onBeforeLoadStr] = function() {\n\t\t\treturn new Promise(function(resolve,reject) {\n\t\t\t\tfor(var len = trans.matched.route.length, i=1; i <= len && validateTransition(trans); i++) {\n\t\t\t\t\tvar l = len-i,\n\t\t\t\t\t// actions,\n\t\t\t\t\trouteInstance = trans.routes[l];\n\t\t\t\t\t// if((actions = routeInstance.__lp.fns.actions) && actions.onBeforeLoad) {\n\t\t\t\t\t// \t// lyte.log(onBeforeLoadStr +' action is depricated. Use beforeLoad callback');\n\t\t\t\t\t// }\n\t\t\t\t\tif(!(routeInstance instanceof Promise) && trans.onLoadCalled.indexOf(l) == -1) {\n\t\t\t\t\t\ttrans.onLoadCalled.push(l)\n\t\t\t\t\t\tif((callAction.call(trans,onBeforeLoadStr,l,[routeInstance.__lp.param]) == false) || (trans.onLoadCalled.length == len) || (i == len)) {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(i == len){resolve();}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n        run[afterRenderStr] =\n\t\trun[didNavigateStr] = function(hook,index) {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\tvar routeInstance = this.routes[index],\n\t\t\t\tst = setTimeout(function() {\n\t\t\t\t\tif(hook == afterRenderStr) {\n\t\t\t\t\t\tthis.rOpts[index].rendered = true;\n\t\t\t\t\t\tcallHookWithPromise.call(this,getHook(routeInstance, hook),routeInstance,[routeInstance.currentData,routeInstance.__lp.param,routeInstance.component]).then(function(data) {\n\t\t\t\t\t\t\tif(!trans.routes[index+1]) {\n\t\t\t\t\t\t\t\ttrans._trans.triggerEvent(afterRenderStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}, function(data) {\n\t\t\t\t\t\t\treject(data);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\trun.removeTemplate.call(this);\n\t\t\t\t\t\tif(callAction.call(this,hook,index,[routeInstance.__lp.param, trans._trans]) == false) {\n\t\t\t\t\t\t\tremoveHook(trans.runLoop.current,hook);\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetVisibleTrans.call(this)\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\tlyte.time(this.prom.hook + this.prom.index);\n\t\t\t\t\t\tif(index == 0) {\n\t\t\t\t\t\t\ttransitionCompleted({state : 200});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.bind(this,hook,index),0);\n\t\t\t\tthis.fns.push(st);          \n\t\t\t}.bind(this));\n\t\t};\n\n        run[beforeExitStr] = function(hook,index) {\n\t\t\tvar prevTransRouteInstance = prevTrans.routes[index];\n\t\t\treturn callHookWithPromise.call(this,prevTransRouteInstance.__lp.fns[hook],prevTransRouteInstance,[prevTransRouteInstance.currentData, prevTransRouteInstance.__lp.param]);\n\t\t};\n\n        // run.getMountApp = function(hook,index) {\n        // \tvar ins = trans.routes[index];\n        // \tvar prom = callHookWithPromise.call(this,ins.__lp.fns[hook],ins,[ins.__lp.param]).then(function(resp) {\n        // \t\tresp.$.mountedTo = {path : LR.getURL(ins.__lp.objPath), app : lyte};\n        // \t\tLR.__lp.mountedApps[ins.__lp.objPath] = resp;\n        // \t});\n        // \treturn prom\n        // };\n\n        run[renderLoadingTemplateStr] = function(hook, index) {\n\t\t\tvar route = this.routes[index],\n  \t\t\tloadingTemplate = callHookWithoutPromise.call(this,route.__lp.fns[hook],hook,index,[route.__lp.param]),\n\t\t\toutlet;\n\t\t\t// routeProp.stencils = loadingTemplate || {};\n\t\t\tif(loadingTemplate && loadingTemplate.outlet && (outlet = getOutlet(loadingTemplate.outlet,route.parent))) {\n\t\t\t\tif(outlet.childNodes[0]) {\n\t\t\t\t\ttriggerTemplateDestroy({outlet,route},false);\n\t\t\t\t}\n\t\t\t\troute.outlet = outlet;\n\t\t\t\tif(loadingTemplate.component) {\n\t\t\t\t\trenderComp(outlet, loadingTemplate.component, {data : loadingTemplate.data , ins : route, hook,index , registry : loadingTemplate.registry || LR.__lp.config.registry})\n\t\t\t\t} else if(loadingTemplate.html) {\n\t\t\t\t\trenderHTML(outlet, loadingTemplate.html)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resolvedPromise;\n\t\t};\n\n        run[renderStr] = function(hook,index) {\n\t\t\tvar routeInstance = this.routes[index],\n\t\t\tcallback = routeInstance.__lp.fns[hook] || routeInstance.__lp.fns.renderTemplate;\n\t\t\tif(callback) {\n\t\t\t\trun.removeTemplate.call(this);\n\t\t\t\tsetVisibleTrans.call(this)\n\t\t\t\t// if(routeInstance.outlet) {\n\t\t\t\t// \trouteInstance.outlet.innerHTML = \"\";\n\t\t\t\t// }\n\t\t\t\tvar renderTemplate = callHookWithoutPromise.call(\n                    this,\n                    callback,\n                    hook,\n                    index,\n                    [routeInstance.currentData, routeInstance.__lp.param]\n                ),\n\t\t\t\toutlet;\n\t\t\t\tif(validateTransition(this)) {\n\t\t\t\t\tif(renderTemplate && (routeInstance.outletName = outlet = (renderTemplate.outlet || routeInstance.outlet))) {\n\t\t\t\t\t\tvar data = routeInstance.currentData;\n\t\t\t\t\t\tif(routeInstance.outlet = outlet = getOutlet(renderTemplate.outlet,routeInstance.parent)) {\n\t\t\t\t\t\t\tvar  obj = {\n\t\t\t\t\t\t\t\toutlet : renderTemplate.outlet,\n\t\t\t\t\t\t\t\troute : routeInstance\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif(renderTemplate.component) {\n\t\t\t\t\t\t\t\tif(routeInstance.component && !renderTemplate.reRender && (routeInstance.component.localName == renderTemplate.component._compName) && routeInstance.outlet == outlet && outlet.contains(routeInstance.component)) {\n\t\t\t\t\t\t\t\t\t// componentDataCheck.call(this,data,routeInstance,hook,index);\n\t\t\t\t\t\t\t\t\trouteInstance.component.setData(data)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttriggerTemplateDestroy(obj,false);\n\t\t\t\t\t\t\t\t\trouteInstance.component = renderComp(outlet, renderTemplate.component,{data, ins : routeInstance , hook,index , registry : renderTemplate.registry || LR.__lp.config.registry})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if(renderTemplate.html) {\n\t\t\t\t\t\t\t\trouteInstance.component = undefined;\n\t\t\t\t\t\t\t\ttriggerTemplateDestroy(obj,false);\n\t\t\t\t\t\t\t\trenderHTML(outlet, renderTemplate.html)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tRouterError.error(428,renderTemplate.outlet);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlyte.warn(renderTemplateWarning);\n\t\t\t\t\t}\n\t\t\t\t}  \n\t\t\t} else if(validateTransition(this) && this.runLoop.templateToRemove && this.routes.length == index+1) {\n\t\t\t\trun.removeTemplate.call(this);\n\t\t\t}\n\t\t\treturn resolvedPromise;\n\t\t};\n\n        // function componentDataCheck(data,routeInstance,hook,index) {\n        // \tif(data) {\n        // \t\tif(typeof data != \"object\" && Array.isArray(data)) {\n        // \t\t\tprocessError.call(this,{stopTrans : true, err :Error(RouterError.getErrorMessage(203)).stack,instance :routeInstance,hook : hook,index : index});\n        // \t\t}   \n        // \t}\n        // }\n\n        function renderHTML(outlet, html) {\n\t\t\toutlet.innerHTML = html;\n\t\t\tvar scripts = outlet.getElementsByTagName('script');\n\t\t\tif(scripts.length) {\n\t\t\t\tscriptExecution(Array.from(scripts),outlet);\n\t\t\t}\n\t\t}\n\n        function renderComp(outlet, component, {data, ins, hook,index, registry }) {\n\t\t\tif(typeof component == \"string\") {\n\t\t\t\tconsole.error(\"Component name cannot be string\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// componentDataCheck.call(this,data,ins,hook,index);\n\t\t\tvar compIns = component._render({\n\t\t\t\toutlet : outlet,\n\t\t\t\tdata : data,\n\t\t\t\toptions : {clearOutlet : true},\n\t\t\t\tregistryInstance : registry,\n\t\t\t\t_route : ins.__lp.objPath\n\t\t\t})\n\t\t\treturn compIns;\n\t\t}\n\n        function getOutlet(outlet,parent) {\n\t\t\tvar _outlet;\n\t\t\tif(parent) {\n\t\t\t\t_outlet =  parent.outlet ? parent.outlet.querySelector(outlet) : undefined;\n\t\t\t\tif(!_outlet) {\n\t\t\t\t\treturn getOutlet(outlet,parent.parent);\n\t\t\t\t}\n\t\t\t} else if(!(_outlet = document.querySelector(outlet))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn _outlet;\n\t\t}\n\n        run.removeTemplate = function() {\n\t\t\tvar arr = this.runLoop.templateToRemove;\n\t\t\tif(!this.cleared) {\n\t\t\t\tif(prevTrans && arr) {\n\t\t\t\t\ttemplateDelete.call(visibleTrans,arr);\n\t\t\t\t}\n\t\t\t\tthis.cleared = true;\n\t\t\t\tdelete this.runLoop.templateToRemove;\n\t\t\t\tlyte.removeFromCache();\n\t\t\t}\n\t\t};\n\n        function setVisibleTrans() {\n\t\t\tif(visibleTrans != this) {\n\t\t\t\tvisibleTrans = this;\n\t\t\t\tif(prevTrans != LR.__lp.visibleTrans) {\n\t\t\t\t\tremoveNavWeakMap(LR.__lp.visibleTrans,this)\n\t\t\t\t}\n\t\t\t\tLR.__lp.visibleTrans = visibleTrans;\n\t\t\t}\n\t\t}\n\n        function validateTransition(trans) {\n\t\t\treturn !trans.aborted && !trans.paused;\n\t\t}\n\n        function addToHistory(obj) {\n\t\t\tvar type = obj.replace ? \"replaceState\" : \"pushState\";\n\t\t\tobj.title = obj.title || document.title;\n\t\t\t/* support for windows, undefined is appended to url */\n\t\t\tvar args = [obj.data, obj.title]\n\t\t\targs.push(config.historyType ? _delimit(shiftBaseURL(obj.url, true)) : '#' + (config.slashAfterHash ? _delimit(obj.url) : (obj.url[0] == \"/\" && obj.url.length > 1 ? obj.url.substring(1,obj.url.length) : obj.url)));\n\t\t\targs.push(obj.meta);\n\t\t\tLR.location = lHistory[type].apply(lHistory,args);\n\t\t\tif(trans) {\n\t\t\t\ttrans.location = LR.location\n\t\t\t}\n\t\t}\n\n        this.getRouteDefinition = function(arr,def) {\n\t\t\tif(arr == \"*\" || !arr) {\n\t\t\t\treturn config.routes;\n\t\t\t} else {\n\t\t\tdef = def || config.routes;\n\t\t\tdef = _getObj(arr,def);\n\t\t\t\treturn def && def.__lp && def.__lp.handler || undefined;  \n\t\t\t}\n\t\t}\n\n        this.setConfig = function(defConfig) {\n\t\t\tfor(var key in defConfig) {\n\t\t\t\tif(key == \"queryParamOptions\") {\n\t\t\t\t\tconfig.queryParamOptions.cache = defConfig.queryParamOptions.cache;\n\t\t\t\t} else if(key == \"historyType\"){\n\t\t\t\t\tconfig[key] = defConfig[key] == \"html5\";\n\t\t\t\t} else if(key == \"history\"){\n\t\t\t\t\tconfig.historyType = defConfig.history == \"html5\";\n\t\t\t\t} else {\n\t\t\t\t\tconfig[key] = defConfig[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.__lp.config = config;\n\t\t}\n        this.setConfig(this.getConfig && this.getConfig());\n        this.__lp.config.registry = this.getComponentRegistry && this.getComponentRegistry();\n\n        configureRoutes.call(this,this.__lp.config && this.__lp.config.baseMap && this.__lp.config.baseMap);\n\n        function configureRoutes(baseMap) {\n\t\t\t_parseRouteMap.call(this,baseMap, {lyte, config, initialRegisterRoute });\n\t\t\tfor(var i = 0,l = this.__lp.pendingReg.length; i < l; i++) {\n\t\t\t\tregisterRoute.apply({},this.__lp.pendingReg[i]);\n\t\t\t}\n\t\t\tthis.__lp.pendingReg = [];\n\t\t\tthis.__lp.routesConfigured = true;\n\t\t}\n\n        function init () {\n\t\t\tif(!config.deferInit && !LR.__lp.initCalled) {\n\t\t\t\tif(lyte.$.isApp) {\n\t\t\t\t\tLR.init();\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tLR.init();\n\t\t\t\t\t},0)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        this.init = function(r) {\n\t\t\tif(!this.__lp.initCalled) {\n\t\t\t\tthis.__lp.initCalled = true;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(this.onInit) { this.onInit();}\n\t\t\tlHistory = new History({\n\t\t\t\thistoryType : LR.__lp.config.historyType ? \"html5\" : \"hash\",\n\t\t\t\tpopState : popState\n\t\t\t}) \n\t\t\tthis.history = lHistory.__lh.exp;\n\t\t\tthis.pushData = function(data,title,url) {\n\t\t\t\tlHistory.pushState(data,title,url,lHistory.getMeta());\n\t\t\t}\n\t\t\tthis.replaceData = function(data,title,url) {\n\t\t\t\tlHistory.replaceState(data,title,url,lHistory.getMeta());\n\t\t\t}\n\t\t\tthis.navigateBack = function(value) {\n\t\t\t\tif(!value) {\n\t\t\t\t\tlHistory.back.call(history);\n\t\t\t\t} else {\n\t\t\t\t\tlHistory.go.call(history,value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.navigateForward = function(value) {\n\t\t\t\tif(!value) {\n\t\t\t\t\tlHistory.forward.call(history);\n\t\t\t\t} else {\n\t\t\t\t\tlHistory.go.call(history,value);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tthis.scrollRestoration = lHistory.scrollRestoration;\n\t\t\tfunction popState(onChangeEvent) {\n\t\t\t\tvar goValue,\n\t\t\t\tmeta,\n\t\t\t\turl = getUrlFromMeta(onChangeEvent);\n\t\t\t\thistoryObj = {\n\t\t\t\t\tfromHistory : true,\n\t\t\t\t\turl : url\n\t\t\t\t};\n\t\t\t\tif(onChangeEvent && lHistory.getData()) {\n\t\t\t\t\thistoryObj.data = lHistory.getData();\n\t\t\t\t}\n\t\t\t\tif(config.preserveUrlOnBrowserNavigation) {\n\t\t\t\t\tif(fromHistoryGo) {\n\t\t\t\t\t\tfromHistoryGo = false;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(lHistory && prevTrans && (meta = lHistory.getMeta()) && (lHistory.__lh.currentMeta.__lh.index !=  meta.__lh.index)) {\n\t\t\t\t\t\tfromHistoryGo = true\n\t\t\t\t\t\tgoValue = lHistory.__lh.currentMeta.__lh.index - meta.__lh.index;\n\t\t\t\t\t\thistory.go(goValue);\n\t\t\t\t\t}\n\t\t\t\t\t// if(lHistory && prevTrans && (meta = lHistory.getMeta()) && (prevTrans.history.index !=  meta.__lh.index)) {\n\t\t\t\t\t// \tfromHistoryGo = true\n\t\t\t\t\t// \t// goValue = prevTrans.history._meta.__lh.index - meta.__lh.index;\n\t\t\t\t\t// \tgoValue = trans.history.__lh.prevMeta.__lh.index - meta.__lh.index;\n\t\t\t\t\t// \thistory.go(goValue);\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t\thistoryObj.goValue = goValue;\n\t\t\t\tif(trans && !trans.aborted) {\n\t\t\t\t\ttrans.abort({state : 308, iAbort : true});\n\t\t\t   \t}\n\t\t\t\tdispatch(url);\n\t\t\t}\n\t\t\tif(lyte.$.isApp) {\n\t\t\t\tif(config.historyType) {\n\t\t\t\t\tpopState();\n\t\t\t\t} else {\n\t\t\t\t\thistoryObj = {\n\t\t\t\t\t\tfromHistory : true,\n\t\t\t\t\t\turl : getLocation()\n\t\t\t\t\t};\n\t\t\t\t\tdispatch(historyObj.url);\n\t\t\t\t}\n\t\t\t\tlinkToRegistration(lyte,this,config);\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n        function getUrlFromMeta(onChangeEvent) {\n\t\t\tvar url;\n\t\t\tif(!(lHistory.getMeta() && (url = lHistory.getMeta().url))) {\n\t\t\t\tif(config.historyType) {\n\t\t\t\t\turl = getLocation();\n\t\t\t\t} else {\n\t\t\t\t\tvar newURL = onChangeEvent && onChangeEvent.newURL || dloc.hash;\n\t\t\t\t\turl = checkForEmptyPath(newURL.replace(/.*#/, ''));\n\t\t\t\t}  \n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n        function setRouteDef(dir, {RouteClass, options}) {\n\t\t\tvar cache = config.routes,\n\t\t\tlen = dir.length,\n\t\t\tdirLen = len - 1;\n\t\t\tfor(var i = 0, key; i < len; i++) {\n\t\t\t\tkey = dir[i];\n\t\t\t\tif (dirLen === i) {\n\t\t\t\t\tvar obj = cache[key];\n\t\t\t\t\tif (obj && obj.__lp) {\n\t\t\t\t\t\tobj.__lp.handler = RouteClass;\n\t\t\t\t\t\tobj.__lp.options = options\n\t\t\t\t\t} else if (obj) {\n\t\t\t\t\t\tobj.__lp = { class : RouteClass, options };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcache[key] = { __lp: { class : RouteClass,  options } };\n\t\t\t\t\t}\n\t\t\t\t} else if (!cache[key]) {\n\t\t\t\t\tcache[key] = {};\n\t\t\t\t}\n\t\t\t\tcache = cache[key];\n\t\t\t}\n\t\t}\n\n        function convertMatchedObjToRouteInfo(matched) {\n\t\t\tvar info = {\n\t\t\t\troute : matched.route.join(\".\"),\n\t\t\t\tfragment : matched.fragment,\n\t\t\t\tdynamicParams : matched.dynamicParams.filter(_arrayClean),\n\t\t\t\tqueryParams : matched.queryParams\n\n\t\t\t};\n\t\t\treturn info;\n\t\t}\n\n        function _arrayClean(e) {\n\t\t\treturn e != undefined;\n\t\t}\n\n        this.replaceWith = function() {\n\t\t\treturn routeTransition.call(this,_normalizeTransitionParams.apply(this,arguments), true);   \n\t\t};\n\n        this.navigateTo = function() {\n\t\t\treturn routeTransition.call(this,_normalizeTransitionParams.apply(this,arguments));  \n\t\t};\n\n        /**\n\t\t * @functionType getURL \n\t\t *  To get url for a route\n\t\t * @author authorName\n\t\t * @version 1.0.0\n\t\t * @params {string} routeName\n\t\t * @params {options} options\n\t\t * @params {function} nestedRoute \n\t\t * @returns\n\t\t */\n        this.getURL = function(matched) {\n\t\t\tif(matched) {\n\t\t\t\tif(!matched.route) {\n\t\t\t\t\tmatched = _normalizeTransitionParams.apply(this,arguments)\n\t\t\t\t} else if(!matched.queryParams) {\n\t\t\t\t\tmatched.queryParams = {}\n\t\t\t\t}\n\t\t\t\tvar url,\n\t\t\t\tl,\n\t\t\t\tlinkTo = this.tagName == LINKTOStr,\n\t\t\t\tcache = config.urlCache,\n\t\t\t\tmatchedCache,\n\t\t\t\tsticky = config.queryParamOptions.cache;\n\t\t\t\tif(!sticky && (matchedCache = cache[Array.isArray(matched.route) ? matched.route.join('.') : matched.route])) {\n\t\t\t\t\turl = matchedCache.url;\n\t\t\t\t\tif(l = matched.dynamicParams && matched.dynamicParams.length) {\n\t\t\t\t\t\tfor(var i = 0; i < l; i++) {\n\t\t\t\t\t\t\turl = url.replace('<<dp>>',matched.dynamicParams[i]);\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(url.indexOf('<<dp>>') != -1) {\n\t\t\t\t\t\tRouterError.error(linkTo ? \"499A\" : 499,matched.route,linkTo ? this : undefined);\n\t\t\t\t\t}\n\t\t\t\t\tif(!matched.queryParams) {matched.queryParams = {}}\n\t\t\t\t\tfor(var key in matchedCache.defQP) {\n\t\t\t\t\t\tif(!matched.queryParams[key] && matchedCache.defQP[key]) {\n\t\t\t\t\t\t\tmatched.queryParams[key] = matchedCache.defQP[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\turl = appendQueryParamsAndFrag(url,matched);\n\t\t\t\t} else {\n\t\t\t\t\tif(linkTo) {\n\t\t\t\t\t\turl = constructURLFromRoute.apply(this,arguments);\n\t\t\t\t\t} else {\n\t\t\t\t\t\turl = constructURLFromRoute.call(this,matched);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(url) {\n\t\t\t\t\turl = config.historyType ? shiftBaseURL(url, true) : '#'+url;\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n        this.getRoute = function(url) {\n\t\t\tvar matched = traverse(shiftBaseURL(url),true);\n\t\t\tif(matched && !matched.error) {\n\t\t\t\tif(config.routeAliasMap[matched.route]) {\n\t\t\t\t\tmatched.alias = config.routeAliasMap[matched.route];\n\t\t\t\t}\n\t\t\t\tmatched.dynamicParams = matched.dynamicParams.filter(_arrayClean);\n\t\t\t\tmatched.route = matched.route.join('.');\n\t\t\t\treturn matched;  \n\t\t\t}\n\t\t};\n\n        function routeTransition(args, replace ) {\n\t\t\tvar processed = normalizeMatchedObj.call(this,args);\n\t\t\tif(processed.error) {\n\t\t\t\tif(trans.running) {\n\t\t\t\t\ttrans.pause();\n\t\t\t\t\trun[onErrorStr].call(trans,trans.prom.hook,trans.prom.index,processed.error,\"420A\",{ consoled : true});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(replace) {\n\t\t\t\tprocessed.matched.replace = true;\n\t\t\t}\n\t\t\tif(!LR.__lp.initCalled) {\n\t\t\t\tRouterError.error(405);\n\t\t\t\treturn \n\t\t\t}\n\t\t\tvar matched = processed.matched,\n\t\t\tcurrRoute;\n\t\t\tprocessed.currRoute = currRoute = matched.route.join('.');\n\t\t\tmatched.refreshRoute && currRoute == prevTrans.info.route;\n\t\t\trouteOptions.newTransInfo = newTransInfo = {\n\t\t\t\treplace : matched.replace || (matched.refreshRoute && LR.checkIfSameRoute(convertMatchedObjToRouteInfo(processed.matched),convertMatchedObjToRouteInfo(prevTrans.matched)) ? true :  matched.replace),\n\t\t\t\ttitle : trans ? trans.title : document.title,\n\t\t\t\tfromHistory : false\n\t\t\t};\n\t\t\tvar url = dispatchTransition(processed);\n\t\t\tif(url && newTrans) {\n\t\t\t\tnewTrans.navigationType = replace ? \"replaceState\" : \"pushState\";\n\t\t\t\tlyte.log(NavigateStr+' to '+currRoute+' '+url,routeStr);\n\t\t\t\treturn newTrans._trans;  \n\t\t\t} else {\n\t\t\t\tlyte.log(NavigateStr+' failed')\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\n        function getLocation(obj) {\n\t\t\tif(config.historyType) {\n\t\t\t\tvar path = checkForEmptyPath(dloc.pathname + dloc.search + (dloc.hash || \"\"));\n\t\t\t\tpath = shiftBaseURL(path);\n\t\t\t\treturn _delimit(path);  \n\t\t\t} else if(obj && obj.withHash)\t{\n\t\t\t\treturn _delimit(checkForEmptyPath(dloc.hash));\n\t\t\t} else {\n\t\t\t\treturn _delimit(checkForEmptyPath(dloc.hash.replace('#','')));\n\t\t\t}\n\t\t}\n\n        function checkForEmptyPath(path) {\n\t\t\tif(!path) {\n\t\t\t\tpath = '/'\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\n        function shiftBaseURL(path,append) {\n\t\t\tvar baseURL;\n\t\t\tif((baseURL = config.baseURL) && path) {\n\t\t\tbaseURL = _delimit(baseURL);\n\t\t\tif(path.indexOf(baseURL) == 0 && !append) {\n\t\t\t\treturn path.replace(baseURL,'');\n\t\t\t} else if(append && path.indexOf(baseURL) != 0) {\n\t\t\t\treturn baseURL+path;\n\t\t\t} \n\t\t\t} \n\t\t\treturn path;\n\t\t}\n\n        function constructURLFromRoute(matched) {\n\t\t\tif(matched && matched.route) {\n\t\t\t\tvar strRoute;\n\t\t\t\tif(!Array.isArray(matched.route)) {\n\t\t\t\t\tmatched.route = _dotSerperator(strRoute = matched.route);\n\t\t\t\t} else {\n\t\t\t\t\tstrRoute = matched.route.join('.')\n\t\t\t\t}\n\t\t\t\tmatched.queryParams = matched.queryParams || {};\n\t\t\t\tmatched.dynamicParams = matched.dynamicParams || [];\n\t\t\t\tmatched.refreshData = false;\n\t\t\t\tvar url,\n\t\t\t\tsameRoute = !!trans,\n\t\t\t\tdynamicPos = matched.dynamicParams.length != matched.route.length,\n\t\t\t\tdynamicParamPos = 0,\n\t\t\t\tlinkTo = this && this.tagName == LINKTOStr,\n\t\t\t\trouteObj = config.routes,\n\t\t\t\ttemplateUrl = url = '',\n\t\t\t\tdefQPTemp = {},\n\t\t\t\troute;\n\t\t\t\tfor(var i = 0, l = matched.route.length; i < l; i++) {\n\t\t\t\t\troute = matched.route[i];\n\t\t\t\t\tif(sameRoute && trans.matched.route[i] != route) {\n\t\t\t\t\t\tsameRoute = false;\n\t\t\t\t\t}\n\t\t\t\t\trouteObj = _getObj(route,routeObj);\n\t\t\t\t\tif(!(routeObj && routeObj.__lp && routeObj.__lp.path)) {\n\t\t\t\t\t\tRouterError.error(422,matched.route,i);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar def = routeObj.__lp.handler && routeObj.__lp.handler.name != __routeProm__Str ? routeObj.__lp.handler : undefined,\n\t\t\t\t\trOpts = routeObj.__lp.options;\n\t\t\t\t\t// if(!def && !linkTo) {\n\t\t\t\t\t// \t_consoleError.call(lyte,422,matched.route,i);\n\t\t\t\t\t// }\n\t\t\t\t\tvar path = routeObj.__lp.path,\n\t\t\t\t\tdefaultQP;\n\t\t\t\t\tif(!def) {\n\t\t\t\t\t\tif(defaultQP = routeObj.__lp.defQP) {\n\t\t\t\t\t\tfor(var key in defaultQP) {\n\t\t\t\t\t\t\tif(matched.queryParams && !matched.queryParams.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tdefQPTemp[key] = matched.queryParams[key] = defaultQP[key];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdefQPTemp[key] = defaultQP[key];\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(def.queryParams) {\n\t\t\t\t\t\tdefaultQP = routeObj.__lp.defQP;\n\t\t\t\t\t\tvar qpdef = rOpts.qpdef;\n\t\t\t\t\t\tfor(var key in qpdef) {\n\t\t\t\t\t\t\tif(!matched.queryParams.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tif(sameRoute && qpdef[key].cache) {\n\t\t\t\t\t\t\t\t\tmatched.queryParams[key] = trans.rOpts[i].param.queryParams[key];\n\t\t\t\t\t\t\t\t} else if(defaultQP && defaultQP.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\tdefQPTemp[key] = matched.queryParams[key] = defaultQP[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!linkTo && !matched.refreshData && qpdef[key].refreshData) {\n\t\t\t\t\t\t\t\tmatched.refreshData = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(routeObj.__lp.dkey) {\n\t\t\t\t\t\tvar dynamicPathSplit = _splitPath(path),\n\t\t\t\t\t\tdynamicPathSplitTemp = _splitPath(path),\n\t\t\t\t\t\tpos = dynamicPos ? dynamicParamPos : i;\n\t\t\t\t\t\tif(!matched.dynamicParams || !matched.dynamicParams[pos]) {\n\t\t\t\t\t\t\tRouterError.error(linkTo ? \"499A\" : 499,route,linkTo ? this : undefined);\n\t\t\t\t\t\treturn false;   \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdynamicPathSplit[routeObj.__lp.dIndex] = encodeURI(matched.dynamicParams[pos]);\n\t\t\t\t\t\t\tdynamicPathSplitTemp[routeObj.__lp.dIndex] = _delimit('<<dp>>');\n\t\t\t\t\t\t\ttemplateUrl += _delimit(dynamicPathSplitTemp.join('/')); \n\t\t\t\t\t\t\turl += _delimit(dynamicPathSplit.join('/')); \n\t\t\t\t\t\t\tdynamicParamPos++;\n\t\t\t\t\t\t} \n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemplateUrl += _delimit(path);\n\t\t\t\t\t\turl += _delimit(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!config.cacheRoutes[strRoute]) {\n\t\t\t\t\tconfig.urlCache[strRoute] = {url : _validateURL(templateUrl), defQP : defQPTemp};\n\t\t\t\t}\n\t\t\t\treturn appendQueryParamsAndFrag(url,matched);\n\t\t\t}\n\t\t}\n\n        function appendQueryParamsAndFrag(url,matched) {\n\t\t\turl = url[url.length-1] == '/' && url.length != 1 ? url.slice(0,-1) : url;\n\t\t\tif(matched.queryParams) {\n\t\t\t\tvar ques = true;\n\t\t\t\tfor(var key in matched.queryParams) {\n\t\t\t\t\tif(matched.queryParams[key] != undefined) {\n\t\t\t\t\t\tif(ques) {\n\t\t\t\t\t\t\turl += '?';\n\t\t\t\t\t\t\tques = false\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turl += '&';\n\t\t\t\t\t\t}\n\t\t\t\t\t\turl+= key+'='+encodeURIComponent(matched.queryParams[key]);  \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(config.historyType && matched.fragment) {\n\t\t\turl = url+\"#\"+matched.fragment;\n\t\t\t}\n\t\t\treturn _validateURL(url);\n\t\t}\n\n        var invokeRunLoop;\n        function dispatch(path,processed) {\n\t\t\tlet history;\n\t\t\tlyte.time(RouteNavigationStr);\n\t\t\tif(path && config.baseURL && document.location.pathname.indexOf(config.baseURL) == -1) {\n\t\t\t\tRouterError.error(\"400A\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed = processed || (!initialLoad && (history = lHistory.getMeta()) && history.matched && history.__lh.url == getLocation({withHash : true}) /* && history.__lh.url.indexOf(path) != -1 */ ? normalizeMatchedObj(history.matched) : traverse(path));\n\t\t\tif(!processed || processed.error) {return};\n\t\t\tclearTimeout(invokeRunLoop);\n\t\t\tprocessed.prevTrans = processed.prevTrans || LR.__lp.prevTrans;\n\t\t\tprocessed.path = processed.path || path;\n\t\t\tprocessed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);\n\t\t\tinvoke(processed);\n\t\t\tlyte.triggerEvent(\"navigationStart\", {prevTrans : prevTrans && prevTrans._trans, nextTrans : newTrans._trans});\n\t\t\tinvokeRunLoop = setTimeout(function() {\n\t\t\t\tif(processed.matched.route.length) {\n\t\t\t\t\tdownloadLazyRoutes(processed)\n\t\t\t\t\tnewTrans._data = newTrans._trans.data ? deepCopyObject(newTrans._trans.data) : {};\n\t\t\t\t\tif(trans && trans.state == 102 && newTrans && LR.checkIfSameRoute(newTrans.info,trans.info) && !trans.aborted && JSON.stringify(trans._data) == JSON.stringify(newTrans._data)) {\n\t\t\t\t\t\tif(trans.iPause == true) {\n\t\t\t\t\t\t\ttrans.resume();    \n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if(trans && trans.state == 102) {\n\t\t\t\t\t\ttrans.abort({state : 409}); \n\t\t\t\t\t}\n\t\t\t\t\tnewTrans.transComp = processed.transComp;\n\t\t\t\t\t// if(trans) {\n\t\t\t\t\t// \tnewTrans.pRoutes = trans.routes;\n\t\t\t\t\t// }\n\t\t\t\t\trouteOptions.trans = trans = newTrans;\n\t\t\t\t\tnewTrans.runLoop = constructPrevRunLoop(processedDispatch = processed);\n\t\t\t\t\tnewTransInfo = routeOptions.newTransInfo;\n\t\t\t\t\ttrans.run();\n\t\t\t\t\t// trans.transComp = processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);\n\t\t\t\t\t// routeOptions.trans = trans = newTrans;\n\t\t\t\t\t// newTransInfo = routeOptions.newTransInfo;\n\t\t\t\t\t// if(trans._trans.data) {\n\t\t\t\t\t// \tnewTransInfo.data = trans._trans.data;\n\t\t\t\t\t// }\n\t\t\t\t\t// newTransInfo.meta = trans.meta = {matched : trans.matched}\n\t\t\t\t\t// newTransInfo.state = trans.stateObj = getHistoryState({\n\t\t\t\t\t// \treplace : newTransInfo.replace,\n\t\t\t\t\t// \tdata : newTransInfo.data,\n\t\t\t\t\t// \turl : trans.url,\n\t\t\t\t\t// \tmatched : trans.matched,\n\t\t\t\t\t// \tfromHistory : newTransInfo.fromHistory\n\t\t\t\t\t// });\n\t\t\t\t\t// getHistoryObj(newTransInfo);\n\t\t\t\t\t\n\t\t\t\t} \n\t\t\t},0);\n\t\t\treturn newTrans;\n\t\t}\n\n        function downloadLazyRoutes(processed) {\n\t\t\tvar R = processed.R,\n\t\t\tpromArr = [];\n\t\t\tR.forEach(function(fn,i) {\n\t\t\t\tif(fn.name == __routeProm__Str) {\n\t\t\t\t\tvar dirArr = processed.matched._routes[i],\n\t\t\t\t\trouteDetail = _getObj(dirArr, config.routes);\n\t\t\t\t\tpromArr.push(fn.call(routeDetail.__lp).then(function(data) {\n\t\t\t\t\t\tinitialRegisterRoute(dirArr, data[routeDetail.__lp.cName]);\n\t\t\t\t\t\tprocessed.R[i] = routeDetail.__lp.handler;\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn Promise.all(promArr);\n\t\t}\n\n        function getTransitionDiffernce(prevTrans, matched, R) {\n\t\t\tvar like = true,\n\t\t\tsimilar = true,\n\t\t\trendered = [],\n\t\t\tcommon = [],\n\t\t\tunRendered = [],\n\t\t\ttemplateToRemove,\n\t\t\tcurrRoute = matched.route.join('.'),\n\t\t\tr,\n\t\t\ttar = \"\";   \n\t\n\t\t\tif(prevTrans) {\n\t\t\t\tvar prevMatched = prevTrans.matched,\n\t\t\t\troute,\n\t\t\t\tstartFrom = matched.refreshRoute && currRoute == prevTrans.info.route ?  matched.refreshRoute : matched.startFrom;\n\t\t\t\tfor(var i = 0, l = matched.route.length; i < l; i++) {\n\t\t\t\t\troute = matched.route[i];\n\t\t\t\t\ttar = tar + (tar ? \".\" : \"\") + route;\n\t\t\t\t\tif(similar && route == prevMatched.route[i] && (!startFrom || tar != startFrom)) {\n\t\t\t\t\t\tr = R ? R[i] : LR.getDefinition(route.slice(0,i));\n\t\t\t\t\t\tif(r.name != __routeProm__Str && like && compareRoute(matched._routes[i],i,prevMatched,matched)) {\n\t\t\t\t\t\t\tcommon.push(route);\n\t\t\t\t\t\t\tif(prevTrans.rOpts[i].rendered) {\n\t\t\t\t\t\t\t\trendered.push(route);  \n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// like = false; dont change this code. It is commented for decideTransition function\n\t\t\t\t\t\t\t\tunRendered.push(route);  \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlike = false;\n\t\t\t\t\t\t\tunRendered.push(route);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsimilar = false;\n\t\t\t\t\t\tif(templateToRemove == undefined && prevTrans.routes[i] && prevTrans.rOpts[i].rendered != -1 && prevTrans.routes[i].outlet) {\n\t\t\t\t\t\t\ttemplateToRemove = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunRendered.push(route);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prevMatched.route.length > matched.route.length) {\n\t\t\t\t\tvar index = matched.route.length;\n\t\t\t\t\tif(templateToRemove == undefined && prevTrans.rOpts[i].rendered/* && prevTrans.routes[i].outlet */) {\n\t\t\t\t\ttemplateToRemove = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunRendered = unRendered.concat(matched.route);\n\t\t\t}\n\t\t\treturn { rendered, unRendered, common, templateToRemove };\n\t\t}\n\n        function compareRoute(rArr,index,prevMatched,matched) {\n\t\t\tvar same = true,\n\t\t\trouteObj = _getObj(rArr,config.routes),\n\t\t\tropt = routeObj.__lp.options;\n\t\t\tif(!ropt.queryParams && !routeObj.__lp.dkey) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(routeObj.__lp.dkey && prevMatched.dynamicParams[index] != matched.dynamicParams[index]) {\n\t\t\t\treturn false;\n\t\t\t} else if(ropt.queryParams && matched.refreshData) {\n\t\t\t\tropt.queryParams.every(function(key) {\n\t\t\t\t\tif(same && ropt.qpdef[key].refreshData && (matched.queryParams || prevMatched.queryParams) && matched.queryParams[key] != prevMatched.queryParams[key]) {\n\t\t\t\t\treturn same = false;\n\t\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t\t} \n\t\t\t\t});\n\t\t\t}\n\t\t\treturn same;\n\t\t}\n\n        const basicHooks = [fetchStr,divertStr,renderStr,afterRenderStr];\n\n        function constructPrevRunLoop() {\n\t\t\tlyte.time(constructRunLoopStr);\n\t\t\tvar b4Exit = [],\n\t\t\twillNavigate = [],\n\t\t\tb4RouteTrans = [{hook : beforeRouteNavigationStr}];\n\t\t\tif(prevTrans) {\n\t\t\t\tfor(var i = prevTrans.matched.route.length-1,r;r = prevTrans.matched.route[i]; i--) {\n\t\t\t\t\tvar r1 = trans.matched._routes[i];\n\t\t\t\t\tif(!r1 || (r1.join('.') != prevTrans.matched._routes[i].join('.'))) {\n\t\t\t\t\t\tb4Exit.push({hook : beforeExitStr, index : i});\n\t\t\t\t\t}\n\t\t\t\t\twillNavigate.push({hook : willNavigateStr, index : i});\n\t\t\t\t}\n\t\t\t\tlyte.time(constructRunLoopStr);\n\t\t\t\treturn {previous : willNavigate.concat(b4RouteTrans).concat(b4Exit) ,current : b4Exit};\n\t\t\t}\n\t\t\treturn {};\n\t\t\t// return { previous : b4RouteTrans };\n\t\t}\n\n        function pushFetchHooks(loop, index) {\n\t\t\tloop.push(\n\t\t\t\t{hook : beforeFetchStr, index : index},\n\t\t\t\t{hook : fetchStr, index : index},\n\t\t\t\t{hook : afterFetchStr, index : index})\n\t\t}\n\n        function convertToFF({ trans, index }) {\n\t\t\tvar r = trans.routes[index];\n\t\t\tif(typeof r.__lp.fns.forceFetch && callHookWithoutPromise.call(trans,r.__lp.fns.forceFetch,forceFetchStr,index,[])) {\n\t\t\t\ttrans.runLoop.forceFetch[index] = []\n\t\t\t\tpushFetchHooks((trans.runLoop.forceFetch[index] = []),index)\n\t\t\t\ttrans.runLoop.current.every(function(obj,i) {\n\t\t\t\t\tif(obj.hook == beforeFetchStr && obj.index == index) {\n\t\t\t\t\t\ttrans.runLoop.current.splice(i, 3);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t})\n\t\t\t\tr.__lp.fetchStatus = pendingStr;\n\t\t\t}\n\t\t}\n\n        function constructRunLoop(processed) {\n\t\t\tlyte.time(constructRunLoopStr);\n\t\t\tvar transComp = processed.transComp,\n\t\t\trunLoop = trans.runLoop = {\n\t\t\t\tprevious : [],\n\t\t\t\tcurrent : [],\n\t\t\t\tforceFetch : {}\n\t\t\t},\n\t\t\tcurrent = runLoop.current,\n\t\t\t// forceFetch = {},\n\t\t\tloadingTemplate = [],\n\t\t\treq = [],\n\t\t\tdidTransit = [];\n\t\t\t\n\t\t\tif(transComp.rendered && transComp.rendered.length) {\n\t\t\t\ttransComp.rendered.forEach(function(hook,index) {\n\t\t\t\t\ttrans.rOpts[index].rendered = true;\n\t\t\t\t\tcurrent.push({hook : divertStr,index : index});\n\t\t\t\t\tdidTransit.push({hook : didNavigateStr,index : trans.matched.route.length-index-1});\n\t\t\t\t});\n\t\t\t}\n\t\t\tif(transComp.unRendered && transComp.unRendered.length) {\n\t\t\t\ttransComp.unRendered.forEach(function(hook,orgIndex) {\n\t\t\t\t\tvar index = transComp.rendered.length+orgIndex,\n\t\t\t\t\tr = trans.routes[index];\n\t\t\t\t\tif(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {\n\t\t\t\t\t\tloadingTemplate.push({hook : renderLoadingTemplateStr, index})\n\t\t\t\t\t\treq.push({hook : getRequirementsStr,index});\n\t\t\t\t\t}\n\t\t\t\t\tbasicHooks.forEach(function(h,i) {\n\t\t\t\t\t\tif(i == 0) {\n\t\t\t\t\t\t\tif(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {\n\t\t\t\t\t\t\t\tpushFetchHooks(current,index)\n\t\t\t\t\t\t\t\t// if(!transComp.unRendered[orgIndex+1] && trans.matched.mountRoute) {\n\t\t\t\t\t\t\t\t// \tcurrent.push({hook : \"getMountApp\", index});\n\t\t\t\t\t\t\t\t// }\t\t\n\t\t\t\t\t\t\t\tif(r instanceof Promise) {\n\t\t\t\t\t\t\t\t\tr.then(function() {\n\t\t\t\t\t\t\t\t\t\tconvertToFF({trans, index})\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconvertToFF({trans, index})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}  else {\n\t\t\t\t\t\t\tcurrent.push({hook : h, index}); \n\t\t\t\t\t\t\tif(h == renderStr && transComp.unRendered[orgIndex+1]) {\n\t\t\t\t\t\t\t\tcurrent.push({hook : renderLoadingTemplateStr,index : index+1});\n\t\t\t\t\t\t\t}    \n\t\t\t\t\t\t}\n\t\t\t\t\t});  \n\t\t\t\t\tdidTransit.push({hook : didNavigateStr,index : trans.matched.route.length-index-1});\n\t\t\t\t});\t\t\n\t\t\t}\n\t\t\ttrans.runLoop.current = [{hook : onBeforeLoadStr}].concat(loadingTemplate).concat(req).concat(current).concat(didTransit)\n\t\t\tif(!prevTrans) {\n\t\t\t\ttrans.runLoop.current.unshift({hook : beforeRouteNavigationStr})\n\t\t\t}\n\t\t\trunLoop.templateToRemove = (prevTrans && prevTrans.runLoop.templateToRemove) ? prevTrans.runLoop.templateToRemove : [];\n\t\t\tif(transComp.templateToRemove != undefined) {\n\t\t\t\trunLoop.templateToRemove.push({index : transComp.templateToRemove, routes : visibleTrans.routes});\n\t\t\t}\n\t\t\tlyte.time(constructRunLoopStr);\n\t\t}\n\n        function invoke(processed) {\n\t\t\trouteOptions.newTrans = LR.__lp.newTrans = newTrans = new Navigation(processed);\n\t\t\tnewTrans.url = processed.path;\n\t\t\tnewTrans.runLoop = {};\n\t\t\tnewTrans._trans = limitTransition(newTrans);\n\t\t\tlyte.extendEventListeners(newTrans._trans);\n\t\t\tif(historyObj) {\n\t\t\t\trouteOptions.newTransInfo = newTransInfo = historyObj;\n\t\t\t\tnewTransInfo.url = processed.path;\n\t\t\t\tnewTrans._trans.data = historyObj.data || lHistory.getData() || {};\n\t\t\t\tnewTransInfo.replace = true;\n\t\t\t\thistoryObj = undefined;\n\t\t\t} else if(newTrans._trans.data) {\n\t\t\t\tLR.history.replaceState(newTrans._trans.data);\n\t\t\t}\n\t\t}\n\n        function abortRunningPromises(trans) {\n\t\t\tif(trans.runningProm) {\n\t\t\t\ttrans.runningProm.reject(abortedStr);  \n\t\t\t}\n\t\t\tif(trans.fRunningProm) {\n\t\t\t\ttrans.fRunningProm.reject(abortedStr);   \n\t\t\t}\n\t\t}\n\n        var navId = 0;\n        function Navigation(processed) {\n\t\t\tthis.navId = navId = navId+1;\n\t\t\tthis.matched = processed.matched;\n\t\t\tthis.target = processed.matched.target;\n\t\t\tthis.logs = [];\n\t\t\tthis.onLoadCalled = [];\n\t\t\tthis.fns = [];\n\n\t\t\tthis.getDynamicParams = function() {\n\t\t\t\tvar dpObj = {};\n\t\t\t\tif(this.matched.dynamicParams) {\n\t\t\t\t\tthis.matched.dynamicParams.forEach(function(dp,i) {\n\t\t\t\t\t\tif(dp) {\n\t\t\t\t\t\t\tvar routesObj = _getObj(this.matched._routes[i], config.routes)\n\t\t\t\t\t\t\tdpObj[routesObj.__lp.dkey] = dp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this))\n\t\t\t\t}\n\t\t\t\treturn dpObj;\n\t\t\t};\n\t\t\tthis.pending = {\n\t\t\t\tdependencies : new Set(),\n\t\t\t\tresources : new Set(),\n\t\t\t\tforceFetch : new Set()\n\t\t\t};\n\t\t\tthis.info = {\n\t\t\t\troute : processed.matched.target,\n\t\t\t\tqueryParams : processed.matched.queryParams,\n\t\t\t\tdynamicParams : processed.matched.dynamicParams.filter(_arrayClean),\n\t\t\t\talias : processed.matched.alias\n\t\t\t};\n\t\t\tif(processed.matched.fragment) {\n\t\t\t\tthis.info.fragment = processed.matched.fragment;\n\t\t\t}\n\t\t\tthis.R = processed.R;\n\t\t\tthis.rOpts = processed.rOpts;\n\t\t\tthis.running = this.aborted = this.paused = false;\n\t\t\tthis.abort = function(obj) {\n\t\t\t\tif(newTransInfo && newTransInfo.goValue) {\n\t\t\t\t\tfromHistoryGo = false;\n\t\t\t\t}\n\t\t\t\tthis.abort = emptyFn;\n\t\t\t\tabortRunningPromises(this);\n\t\t\t\tthis.aborted = true;\n\t\t\t\tif(!obj) {\n\t\t\t\t\tobj = {state : 308};\n\t\t\t\t} \n\t\t\t\tif(this.running) {\n\t\t\t\t\tlyte.log(NavigationAbortedStr,routeStr);\n\t\t\t\t}\n\t\t\t\tif(!obj.iAbort) {\n\t\t\t\t\tdelete this.runLoop.templateToRemove;\n\t\t\t\t}\n\t\t\t\ttransitionCompleted(obj);\n\t\t\t}.bind(this);\n\t\t\tthis.pause = function (obj) {\n\t\t\tlyte.log(NavigationPausedStr, routeStr);\n\t\t\tif (obj && obj.iPause) {\n\t\t\t\tthis.iPause = true;\n\t\t\t} else {\n\t\t\t\tthis.iPause = false;\n\t\t\t\tthis.state = this._trans.state = 307;\n\t\t\t\tthis._trans.triggerEvent(stateChangeStr,this.state);\n\t\t\t}\n\t\t\tthis.paused = trans.prom || true;\n\t\t\tthis.resume = this._trans.resume = function (t) {\n\t\t\t\tt = t || this;\n\t\t\t\tif (t.prom != t.eProm) {\n\t\t\t\t\tif (!t.pendingResume) {\n\t\t\t\t\t\tt.pendingResume = t.resume;\n\t\t\t\t\t\tdelete t._trans.resume;\n\t\t\t\t\t\tdelete t.resume;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdelete t._trans.resume;\n\t\t\t\tdelete t.resume;\n\t\t\t\tlyte.log(NavigationResumedStr, routeStr);\n\t\t\t\tif (t.paused) {\n\t\t\t\t\tvar state,\n\t\t\t\t\tprom = t.prom;\n\t\t\t\t\tif(t.paused != true) {\n\t\t\t\t\t\tstate = t.paused.state;\n\t\t\t\t\t}\n\t\t\t\t\tif (t.runLoop[state]) {\n\t\t\t\t\t\tif(state == forceFetchStr) {\n\t\t\t\t\t\t\tvar newProm = t.runLoop.forceFetch[prom.index];\n\t\t\t\t\t\t\tif(newProm[0] && prom.hook == newProm[0].hook) {\n\t\t\t\t\t\t\t\tnewProm.splice(0, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(t.runLoop[state][0] && t.runLoop[state][0].hook == t.paused.hook && t.runLoop[state][0].index == t.paused.index) {\n\t\t\t\t\t\t\tremoveHook(t.runLoop[state], t.paused.hook, t.paused.index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt.iPause = t.paused = false;\n\t\t\t\t\tt.state = t._trans.state = 102;\n\t\t\t\t\tthis._trans.triggerEvent(stateChangeStr,t.state);\n\t\t\t\t\tif(this.forceFetchRunning) {\n\t\t\t\t\t\tif(t.runLoop.forceFetch[prom.index][0]) {\n\t\t\t\t\t\t\tt.run(t.runLoop.forceFetch[prom.index][0]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.routes[prom.index].__lp.fetchStatus = completedStr;\n\t\t\t\t\t\t\tif (t.pending.waitingForFF != undefined && t.pending.waitingForFF == prom.index) {\n\t\t\t\t\t\t\t\tdelete t.pending.waitingForFF;\n\t\t\t\t\t\t\t\tt.run();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(state && state == forceFetchStr && !t.runLoop.forceFetch[prom.index][0]) {\n\t\t\t\t\t\t\tt.routes[prom.index].__lp.fetchStatus = completedStr;\n\t\t\t\t\t\t} \n\t\t\t\t\t\tt.run();  \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.bind(this);\n\t\t\treturn this._trans;\n\t\t\t}.bind(this);\n\t\t}\n\n        function templateDelete(arr) {\n\t\t/* clears outlet, from parent to child */\n\t\t\tfor(var i = 0,l = arr.length,obj; i < l; i++) {\n\t\t\t\tobj = arr[i];\n\t\t\t\tfor (var inst, j = obj.routes.length - 1; j >= obj.index; j--) {\n\t\t\t\t\tinst = obj.routes[j];\n\t\t\t\t\tif (inst.outlet) {\n\t\t\t\t\t\ttriggerTemplateDestroy({outlet : inst.outletName, route : inst},true)\n\t\t\t\t\t\tinst.outlet.innerHTML = \"\";\n\t\t\t\t\t\tif(!trans.routes[j] || trans.routes[j].__lp.objPath != inst.__lp.objPath) {\n\t\t\t\t\t\t\tcallDidDestroy.call(this,inst,j,obj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        function triggerTemplateDestroy(obj) {\n\t\t\tLR.triggerEvent(beforeTemplateDestroyStr,obj);\n\t\t\tlyte.triggerEvent(beforeTemplateDestroyStr,obj);\n\t\t}\n\n        function callDidDestroy(inst,index) {\n\t\t\tlyte.log(didDestroyStr+\" of \"+ inst.routeName,routeStr,fontColor);\n\t\t\tlyte.time(didDestroyStr+index);\n\t\t\tcallHookWithoutPromise.call(this,inst.didDestroy,didDestroyStr,index,[inst.currentData, inst.__lp.param]);\n\t\t\tlyte.time(didDestroyStr+index);\n\t\t}\n\n        var stoppableHooks = [getRequirementsStr,beforeFetchStr,fetchStr,afterFetchStr];\n        // error in these hooks should pause transition and call onerror action\n        function errorStoppableHook(hook) {\n\t\t\treturn _strPresence(stoppableHooks,hook);\n\t\t}\n\n        function callHookWithPromise(callback,instance, args) {\n\t\t\t/* executes route hooks which will returns promise */\n\t\t\tif(callback) { \n\t\t\t\tvar resp,\n\t\t\t\tt = trans,\n\t\t\t\tprom = trans.prom,\n\t\t\t\thook = prom.hook,\n\t\t\t\tindex = prom.index,\n\t\t\t\tstopNav = errorStoppableHook(hook),\n\t\t\t\tself = this;\n\t\t\t\treturn new Promise(function(resolve,reject) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.logs.push(hook +' of route '+instance.routeName+ ' called');\n\t\t\t\t\t\tvar result = callback.apply(instance,args);\n\t\t\t\t\t\tif(stopNav && result) { /* check why stopTrans is needed? */\n\t\t\t\t\t\t\tresult = lyte.resolvePromises(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresp = Promise.resolve(result);\n\t\t\t\t\t} catch(err) {\n\t\t\t\t\t\tprocessError.call(self,{hook : hook, index : index, stopNav , err : err,instance : instance, promise : {resolve : resolve, reject : reject}});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresp.then(function(data) {\n\t\t\t\t\t\tif(prom.state != \"previous\" && trans._trans != instance.navigation) {\n\t\t\t\t\t\t\tt.logs.push(\"old navigation's promise rejected\");\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t\tcallback.then && callback.then.success.apply(this,arguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t},function(err) {\n\t\t\t\t\t\tt.prom = prom;\n\t\t\t\t\t\treject(err)\n\t\t\t\t\t\tcallback.then && callback.then.failure.apply(this,arguments)\n\t\t\t\t\t\tprocessError.call(self,{hook, index,stopNav,err,instance, PR : true});\n\t\t\t\t\t});  \n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn resolvedPromise;\n\t\t\t}\n\t\t}\n\n        function callHookWithoutPromise(callback,hook,index,args,splInstance) {\n\t\t\t/* executes route hooks which wont return promise  */\n\t\t\tif(callback) {\n\t\t\t\tvar instance = this.routes[index];\n\t\t\t\ttry {\n\t\t\t\t\ttrans.logs.push(hook +' of route '+instance.routeName+ ' called');\n\t\t\t\t\treturn callback.apply(splInstance || instance,args);\n\t\t\t\t} catch(err) {\n\t\t\t\t\tprocessError.call(this,{hook, index, stopNav : errorStoppableHook(hook),err,instance});\n\t\t\t\t\treturn;\n\t\t\t\t}  \n\t\t\t}\n\t\t}\n\n        function callAction(hook,index,args) {\n\t\t\t/* executes route's actions  */\n\t\t\tvar action,\n\t\t\trouteInstance = this.routes[index] && this.routes[index];\n\t\t\tif(action = getAction(routeInstance, hook)) {\n\t\t\t\ttry {\n\t\t\t\t\ttrans.logs.push(hook +' of route '+routeInstance.routeName+ ' called');\n\t\t\t\t\tif(action.apply(routeInstance,args) == false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\t_consoleErrorFromCallback(e,hook,routeInstance.routeName);\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\n        function _consoleErrorFromCallback(err,hook,routeName,state,options) {\n\t\t\tif(typeof err == \"string\" || (typeof err == \"object\" && err.stack && !err.$)) {\n\t\t\t\tif(!err.stack) {\n\t\t\t\t\terr = Error(err);\n\t\t\t\t}\n\t\t\t\terr.$ = true;\n\t\t\t\tvar internalErr = RouterError.getErrorMessage(state) || RouterError.getErrorMessage(\"420A\",hook,routeName);\n\t\t\t\terr.stack = err.stack.replace(err.message,err.message = err.message+\"\\n\\t\"+internalErr);\n\t\t\t\tRouterError.error(err);\n\t\t\t} else {\n\t\t\t\tRouterError.error(state,hook,routeName,err,options && options.PR);\n\t\t\t}\n\t\t}\n\n        function processError(options) {\n\t\t\t/* handles error in hooks */\n\t\t\tvar instance = options.instance,\n\t\t\tstopNav = options.stopNav,\n\t\t\terr = options.err,\n\t\t\thook = options.hook,\n\t\t\tindex = options.index;\n\t\t\tif(stopNav) {\n\t\t\t\ttrans.pause();\n\t\t\t\trun[onErrorStr].call(this,hook,index,err,\"420\",options);\n\t\t\t} else {\n\t\t\t\t_consoleErrorFromCallback(err,hook,instance.routeName);\n\t\t\t\t// if(_strPresence([willNavigateStr,didNavigateStr,beforeExitStr,redirectStr],hook)) {\n\t\t\t\t\tif(options.promise) {\n\t\t\t\t\t\toptions.promise.resolve();\n\t\t\t\t\t}\n\t\t\t\t// } else {\n\t\t\t\t\t// trans.abort({state : 4, iAbort : true});\n\t\t\t\t// }\n\t\t\t}  \n\t\t}\n\n        function runLoopPromise(fn,fnName,loop,success,failure) {\n\t\t\tsuccess = success || emptyFn;\n\t\t\tfailure = failure || function(error) {\n\t\t\t\tif(error != abortedStr) {\n\t\t\t\t\tRouterError.error(error);\n\t\t\t\t}\n\t\t\t};\n\t\t\tnew Promise(function(resolve,reject) {\n\t\t\t\tif(fnName == nestedForcedPromisesStr ) {\n\t\t\t\t\tthis.fRunningProm = {resolve : resolve, reject : reject};\n\t\t\t\t\tfn.call(this,this.runLoop.forceFetch,resolve);\n\t\t\t\t} else {\n\t\t\t\t\tthis.runningProm = {resolve : resolve, reject : reject};\n\t\t\t\t\tfn.call(this,this.runLoop,loop,resolve);  \n\t\t\t\t}\n\t\t\t}.bind(this)).then(success,failure);\n\t\t}\n\n        Navigation.prototype.run = function (pausedForcedProm) {\n\t\t\tif(pausedForcedProm) {\n\t\t\t\tnestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,pausedForcedProm);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessRunLoop.call(this);\n\t\t};\n\n        function processRunLoop() {\n\t\t\trunLoopPromise.call(trans,nestedPromises,\"nestedPromises\",'previous',function() {\n\t\t\tif(processedDispatch && !trans.running && !trans.aborted ) {\n\t\t\t\tinitRoute(trans, processedDispatch);\n\t\t\t\tif(processedDispatch.hasOwnProperty(\"refreshFrom\")) {\n\t\t\t\t\tfor(var i = processedDispatch.refreshFrom,r; r = newTrans.routes[i]; i++) {\n\t\t\t\t\t\tdelete r.component;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdocument.title = this.title = this.routes[this.routes.length-1].title || document.title;\n\t\t\t\tif(trans._trans.data) {\n\t\t\t\t\tnewTransInfo.data = trans._trans.data;\n\t\t\t\t}\n\t\t\t\tnewTransInfo.meta = trans.meta = {matched : trans.matched}\n\t\t\t\ttrans.state = trans._trans.state = 102;\n\t\t\t\ttrans._trans.triggerEvent(stateChangeStr,trans.state);\n\t\t\t\tif(newTransInfo) {\n\t\t\t\t\tif(config.preserveUrlOnBrowserNavigation && newTransInfo.fromHistory) {\n\t\t\t\t\t\t// if(newTransInfo) {\n\t\t\t\t\t\t\t// if(config.preserveUrlOnBrowserNavigation) {\n\t\t\t\t\t\tif(/* newTransInfo.fromHistory && */ !!newTransInfo.goValue) {\n\t\t\t\t\t\t\tfromHistoryGo = true;\n\t\t\t\t\t\t\thistory.go(-(newTransInfo.goValue));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTransInfo.data = trans._trans.data || newTransInfo.data;\n\t\t\t\t\t\t// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;\n\t\t\t\t\t\tnewTransInfoClone = deepCopyObject(newTransInfo);\n\t\t\t\t\t\ttrans.stateObj = newTransInfo.state;\n\t\t\t\t\t\tnewTransInfoTimer = setInterval(function() {\n\t\t\t\t\t\t\tif(!newTransInfoClone) {\n\t\t\t\t\t\t\t\tclearInterval(newTransInfoTimer);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!fromHistoryGo) {\n\t\t\t\t\t\t\t\tclearInterval(newTransInfoTimer);\n\t\t\t\t\t\t\t\taddToHistory(newTransInfoClone);\n\t\t\t\t\t\t\t\tnewTransInfoClone = undefined;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},0)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewTransInfo.data = trans._trans.data || newTransInfo.data;\n\t\t\t\t\t\t// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;\n\t\t\t\t\t\taddToHistory(newTransInfo);\n\t\t\t\t\t\ttrans.stateObj = newTransInfo.state;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\t// \tnewTransInfo.data = trans._trans.data || newTransInfo.data;\n\t\t\t\t\t// \t// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;\n\t\t\t\t\t// \tnewTransInfoClone = deepCopyObject(newTransInfo);\n\t\t\t\t\t// \ttrans.stateObj = newTransInfo.state;\n\t\t\t\t\t// \tnewTransInfoTimer = setInterval(function() {\n\t\t\t\t\t// \t\tif(!newTransInfoClone) {\n\t\t\t\t\t// \t\t\tclearInterval(newTransInfoTimer);\n\t\t\t\t\t// \t\t\treturn;\n\t\t\t\t\t// \t\t}\n\t\t\t\t\t// \t\tif(!fromHistoryGo) {\n\t\t\t\t\t// \t\t\tclearInterval(newTransInfoTimer);\n\t\t\t\t\t// \t\t\taddToHistory(newTransInfoClone);\n\t\t\t\t\t// \t\t\tnewTransInfoClone = undefined;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t// \t\t}\n\t\t\t\t\t// \t},0)\n\t\t\t\t\t// } else {\n\t\t\t\t\t// \tnewTransInfo.data = trans._trans.data || newTransInfo.data;\n\t\t\t\t\t// \t// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;\n\t\t\t\t\t// \taddToHistory(newTransInfo);\n\t\t\t\t\t// \ttrans.stateObj = newTransInfo.state;\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t\tLR.__lp.trans = trans;            \n\t\t\t\tprocessedDispatch.previous = false;\n\t\t\t\tconstructRunLoop(processedDispatch);\n\t\t\t\tsetParamsInInst(processedDispatch);\n\t\t\t\trouteOptions.newTransInfo = processedDispatch = newTransInfo = undefined;\n\t\t\t\ttrans.running = true;\n\t\t\t}\n\t\t\trunLoopPromise.call(trans,nestedPromises,\"nestedPromises\",'current');\n\t\t\t}.bind(this));\n\t\t}\n\n        function setPendingResume(promise) {\n\t\t\ttrans.eProm = promise;\n\t\t\tif (this.pendingResume) {\n\t\t\tvar resume = this.pendingResume;\n\t\t\tdelete this.pendingResume;\n\t\t\tresume();\n\t\t\t}\n\t\t}\n\n        function nestedForcedPromises(forcedLoop, resolve, promise) {\n\t\t\tif (validateTransition(this) && forcedLoop) {\n\t\t\t\tif(!promise) {\n\t\t\t\t\tfor(var key in forcedLoop) {\n\t\t\t\t\t\tvar routeLoop = forcedLoop[key],\n\t\t\t\t\t\tp = routeLoop[0];\n\t\t\t\t\t\tif(p) {\n\t\t\t\t\t\t\tif(!p.running) {\n\t\t\t\t\t\t\t\tnestedForcedPromises.call(this, forcedLoop, resolve,p);    \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar routeInstance = this.routes[promise.index];\n\t\t\t\tpromise.state = forceFetchStr;\n\t\t\t\ttrans.prom = promise;\n\t\t\t\tif (promise.hook == beforeFetchStr && !routeInstance.__lp.dependenciesLoaded) {\n\t\t\t\t\trouteInstance.__lp.loadDependencies.then(function() {\n\t\t\t\t\t\tnestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,this.runLoop.forceFetch[promise.index][0]);\n\t\t\t\t\t}.bind(this))\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlogCallbacks(promise);\n\t\t\t\tforcedLoop[promise.index][0].running = true;\n\t\t\t\tforcedLoop[promise.index].splice(0, 1);\n\t\t\t\tlyte.time(promise.hook+promise.index);\n\t\t\t\trun[promise.hook].call(this, promise.hook, promise.index).then(function (data) {\n\t\t\t\t\tlyte.time(promise.hook+promise.index);\n\t\t\t\t\tsetPendingResume.call(trans, trans.prom);\n\t\t\t\t\tif(promise.hook == afterFetchStr) {\n\t\t\t\t\t\trouteInstance.__lp.fetchStatus = completedStr;\n\t\t\t\t\t\tif (this.pending.waitingForFF != undefined && this.pending.waitingForFF == promise.index) {\n\t\t\t\t\t\t\tdelete this.pending.waitingForFF;\n\t\t\t\t\t\t\tnestedPromises.call(this,this.runLoop,\"current\",this.runningProm.resolve);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(promise.hook == fetchStr) {\n\t\t\t\t\t\tif(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterFetchStr) {\n\t\t\t\t\t\t\tnestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == fetchStr) {\n\t\t\t\t\t\t\tnestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.bind(this),function() {debugger;});\n\t\t\t} else {\n\t\t\t\tthis.forceFetchRunning = false;\n\t\t\t}\n\t\t}\n\n        function logCallbacks(promise) {\n\t\t\tif(lyte.config.debug) {\n\t\t\t\tvar hook = promise.hook,\n\t\t\t\tindex = promise.index;\n\t\t\t\tif([beforeRouteNavigationStr, onBeforeLoadStr].indexOf(promise.hook) != -1) {\n\t\t\t\t\tlyte.log(hook,routeStr,fontColor);\n\t\t\t\t\treturn;  \n\t\t\t\t}\n\t\t\t\tvar route = promise.state == \"previous\" ? prevTrans.R[index] : trans.R[index];\n\t\t\t\tlyte.log(hook +' of route '+route.routeName,routeStr,fontColor);    \n\t\t\t}\n\t\t}\n\n        function nestedPromiseCall(promise, routeInstance, loop, state, resolve) {\n\t\t\tif(promise.hook == beforeFetchStr && !routeInstance.__lp.dependenciesLoaded) {\n\t\t\t\trouteInstance.__lp.loadDependencies.then(function() {\n\t\t\t\t\trouteInstance.__lp.dependenciesLoaded = true\n\t\t\t\t\tnestedPromises.call(this,loop,state,resolve);\n\t\t\t\t}.bind(this));\n\t\t\t\treturn;\n\t\t\t} else if(promise.hook == renderStr && !routeInstance.__lp.resourcesLoaded) {\n\t\t\t\trouteInstance.__lp.loadResources.then(function() {\n\t\t\t\t\trouteInstance.__lp.resourcesLoaded = true\n\t\t\t\t\tnestedPromises.call(this,loop,state,resolve);\n\t\t\t\t}.bind(this));\n\t\t\t\treturn;\n\t\t\t} else if(promise.hook == divertStr && routeInstance.__lp.fns.forceFetch && routeInstance.__lp.fetchStatus == pendingStr) {\n\t\t\t\tif(!this.forceFetchRunning) {\n\t\t\t\t\tthis.forceFetchRunning = true;\n\t\t\t\t\trunLoopPromise.call(this,nestedForcedPromises,nestedForcedPromisesStr);\n\t\t\t\t}\n\t\t\t\tthis.pending.waitingForFF = promise.index;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpromise.state = state;\n\t\t\t\ttrans.prom = promise;\n\t\t\t\tlogCallbacks(promise);\n\t\t\t\tlyte.time(promise.hook+promise.index);\n\t\t\t\trun[promise.hook].call(this,promise.hook,promise.index).then(function(data) {\n\t\t\t\t\tlyte.time(promise.hook+promise.index);\n\t\t\t\t\tsetPendingResume.call(trans,trans.prom);\n\t\t\t\t\tif(this.runningProm.resolve == resolve) {\n\t\t\t\t\tremoveHook(loop[state],promise.hook,promise.index);\n\t\t\t\t\tnestedPromises.call(this,loop,state,resolve);  \n\t\t\t\t\t}\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t}\n\n        function nestedPromises(loop,state,resolve) {\n\t\t\tif(validateTransition(this)) {\n\t\t\t\tvar runLoop = loop[state];\n\t\t\t\tif(runLoop && runLoop.length) {\n\t\t\t\t\tvar promise = runLoop[0],\n\t\t\t\t\trouteInstance = state == \"previous\"? prevTrans.routes[promise.index] : this.routes[promise.index];\n\t\t\t\t\tif(routeInstance instanceof Promise) {\n\t\t\t\t\t\trouteInstance.then(function() {\n\t\t\t\t\t\t\tif(this.onLoadCalled.length && runLoop[0].hook != onBeforeLoadStr) {\n\t\t\t\t\t\t\t\trunLoop.unshift({hook : onBeforeLoadStr});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnestedPromises.call(this, loop, state, resolve);\n\t\t\t\t\t\t}.bind(this))\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnestedPromiseCall.call(this,promise, routeInstance, loop, state, resolve)\n\t\t\t\t\t}\n\t\t\t\t} else if(resolve) {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t} else if(this.paused && this.runningProm) {\n\t\t\t\tthis.runningProm.reject(abortedStr);  \n\t\t\t}\n\t\t}\n\n        function removeHook(loop,hook,index) {\n\t\t\tfor(var i = 0,obj;obj = loop[i]; i++) {\n\t\t\t\tif(obj.hook == hook) {\n\t\t\t\t\tif(index != undefined) {\n\t\t\t\t\t\tif(index == obj.index) {\n\t\t\t\t\t\t\tloop.splice(i,1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tloop.splice(i,1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        function transitionCompleted(obj) {\n\t\t\t/* called after a atransition is completed or aborted*/\n\t\t\ttrans.fns = [];\n\t\t\tif(trans.running) {\n\t\t\t\tif(trans == newTrans) {\n\t\t\t\t\trouteOptions.newTrans = LR.__lp.newTrans = newTrans = undefined;  \n\t\t\t\t}\n\t\t\t\tif(newTransInfoClone) {\n\t\t\t\t\tclearInterval(newTransInfoTimer);\n\t\t\t\t\taddToHistory(newTransInfoClone);\n\t\t\t\t\tnewTransInfoClone = undefined;\n\t\t\t\t}\n\t\t\t\tLR.__lp.navigationCompleted && LR.__lp.navigationCompleted(trans)\n\t\t\t\tfor(var i = 0,l = trans.fns.length; i < l; i++) {\n\t\t\t\t\tclearTimeout(trans.fns[i]);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\ttrans.pendingResume = undefined;\n\t\t\t\ttrans.running = false;\n\t\t\t\ttrans.state = trans._trans.state = obj.state;\n\t\t\t\ttrans._trans.triggerEvent(stateChangeStr,trans.state);\n\t\t\t\tif(initialLoad || trans.state == 200) {\n\t\t\t\t\tremoveNavWeakMap(prevTrans, trans)\n\t\t\t\t\trouteOptions.prevTrans = LR.__lp.prevTrans = prevTrans = trans;\n\t\t\t\t\tlyte.log(NavigationComletedStr,routeStr);\n\t\t\t\t\tlyte.time(RouteNavigationStr);\n\t\t\t\t\tif(config.historyType && trans.info.fragment) {\n\t\t\t\t\t\tvar elem;\n\t\t\t\t\t\tif((elem = document.getElementById(trans._trans.info.fragment)) && elem.scrollIntoView && (LR.beforeScroll && LR.beforeScroll(trans._trans) != false)) {\n\t\t\t\t\t\t\telem.scrollIntoView();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trun[afterRouteNavigationStr](trans._trans);\n\t\t\t\t} else if(obj.iAbort || visibleTrans == trans) {\n\t\t\t\t\tremoveNavWeakMap(prevTrans, trans)\n\t\t\t\t\trouteOptions.prevTrans = LR.__lp.prevTrans = prevTrans = trans;\n\t\t\t\t\tif (trans.state && trans.state != 201) {\n\t\t\t\t\trun[afterRouteNavigationStr](trans._trans);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (trans.state && trans.state != 201) {\n\t\t\t\t\t\trun[afterRouteNavigationStr](trans._trans);\n\t\t\t\t\t}\n\t\t\t\t\tremoveNavWeakMap(trans, newTrans || prevTrans)\n\t\t\t\t\trouteOptions.trans = LR.__lp.trans = trans = prevTrans;  \n\t\t\t\t}\n\t\t\t\tif(initialLoad) {\n\t\t\t\t\tinitialLoad = false;\n\t\t\t\t}\n\t\t\t} else if(prevTrans){\n\t\t\t\trouteOptions.trans = LR.__lp.trans = trans = prevTrans;\n\t\t\t}\n\t\t}\n\n        function removeNavWeakMap(p,t) {\n\t\t\tif(p && (visibleTrans && p != visibleTrans)) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tp.routes.forEach(function(route,i) {\n\t\t\t\t\t\tif(/*!t.rOpts[i] || p.rOpts[i].objPath != t.rOpts[i].objPath || */p.routes[i] != t.routes[i]) {\n\t\t\t\t\t\t\tLR.__lp.nav.delete(route);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},0)\n\t\t\t}\n\t\t}\n\n        function traverse(path, get) {\n\t\t\tif(path) {\n\t\t\t\tvar routeObj = _traverseMap(path, config)\n\t\t\t\tif(routeObj) {\n\t\t\t\t\treturn pathProcessor.apply(this,[get].concat(routeObj));\n\t\t\t\t} else {\n\t\t\t\t\tRouterError.error(\"400A\",config.baseURL && path.indexOf(config.baseURL) != 0 ? '' : path);\n\t\t\t\t\treturn { error : true }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        function pathProcessor(get,selectedPath,path,params,fragment) {\n\t\t\tvar newURL,\n\t\t\torgMatched,\n\t\t\tnewMatched,\n\t\t\tmatched = {\n\t\t\troute : _getObj(selectedPath,config.routeHash).__lp.route,\n\t\t\tqueryParams : params ? _frameQueryParams(params) : {}\n\t\t\t};\n\t\t\tif(config.historyType) {\n\t\t\t\tmatched.fragment = fragment;\n\t\t\t}\n\t\t\tmatched.dynamicParams = _frameDynamicParams(path,matched,config.routes);\n\t\t\tif(get) {return matched;}\n\t\t\tmatched.dpProcessed = true;\n\t\t\tvar transInfo = normalizeMatchedObj(matched);\n\t\t\tif(transInfo != false) {\n\t\t\t\torgMatched = deepCopyObject(transInfo.matched);\n\t\t\t\tnewMatched = deepCopyObject(transInfo.matched);\n\t\t\t\tif(!transInfo.matched.hasOwnProperty('refreshData')) {\n\t\t\t\t\tif(!constructURLFromRoute(transInfo.matched)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewURL = constructURLFromRoute(newMatched);\n\t\t\t\tif(!_compareObj(newMatched.queryParams,orgMatched.queryParams)) {\n\t\t\t\t\taddToHistory({replace : true,state : window.history.state,url : newURL,fromHistory : true});\n\t\t\t\t\ttransInfo.path = newURL;\n\t\t\t\t}  \n\t\t\t}\n\t\t\treturn transInfo;\n\t\t}\n\n        function setParamsInInst(processed) {\n\t\t\tif(config.linkActiveClass) {\n\t\t\t\tconfig.activeLinkTags.forEach(function(tag) {\n\t\t\t\t\t\ttag.classList.remove(config.linkActiveClass);\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.activeLinkTags = [];\n\t\t\tvar R,\n\t\t\tr,\n\t\t\tmatched = processed.matched;\n\t\t\ttry {\n\t\t\t\tfunction linkTagPush(tag) {\n\t\t\t\t\tif(tag.getAttribute('lt-prop-route') == matched.target && activeLinkTags.indexOf(tag) == -1) {\n\t\t\t\t\t\tactiveLinkTags.push(tag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfunction setParams(i){\n\t\t\t\t\tvar rOpts = trans.rOpts[i];\n\t\t\t\t\t// r = trans.routes[i];\n\t\t\t\t\tif(rOpts.qpdef) {\n\t\t\t\t\t\tfor(var key in rOpts.qpdef) {\n\t\t\t\t\t\t\trOpts.param.queryParams[key] = matched.queryParams[key];\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\trOpts.param.dynamicParam = matched.dynamicParams[i];\n\t\t\t\t\tif(i+1 == l) {\n\t\t\t\t\t\trOpts.linkTags.forEach(linkTagPush);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction callSetParams(i) {\n\t\t\t\t\tsetParams(i)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(var i = 0,l = trans.R.length; i < l; i++) {\n\t\t\t\t\tif(trans.routes[i] instanceof Promise) {\n\t\t\t\t\t\ttrans.routes[i].then(callSetParams.bind(this,i))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetParams(i)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tLR.__lp.mutateCache(matched.target)\n\t\t\t} catch(e) {\n\t\t\t\tRouterError.error(e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n        function initialRegisterRoute() {\n\t\t\tif(config.routes) {\n\t\t\t\tregisterRoute.apply({},arguments);\n\t\t\t} else {\n\t\t\t\tthis.__lp.pendingReg.push(arguments);\n\t\t\t}\n\t\t}\n\n        function registerRoute(dir,RouteClass) {\n\t\t\tif(RouteClass.name != __routeProm__Str) {\n\t\t\t\tvar options = {fns : {actions : {}}, $ : {}}\n\t\t\t\tif(!RouteClass.__lp || !RouteClass.__lp.fns) {\n\t\t\t\t\tRouteClass.__lp = { fns : options.fns };\n\t\t\t\t\t[renderLoadingTemplateStr,getRequirementsStr,forceFetchStr,beforeFetchStr,fetchStr,afterFetchStr,divertStr,renderStr,afterRenderStr,\"actions\",beforeExitStr/*,\"getMountApp\"*/].forEach(function(key) {\n\t\t\t\t\t\tvar prop = RouteClass.prototype[key];\n\t\t\t\t\t\toptions.fns[key] = prop\n\t\t\t\t\t\tdelete RouteClass.prototype[key];\n\t\t\t\t\t});\n\t\t\t\t\tif(typeof RouteClass.actions == \"function\") {\n\t\t\t\t\t\toptions.fns.actions = RouteClass.prototype.actions = RouteClass.actions();\n\t\t\t\t\t}\n\t\t\t\t\t// RouteClass.prototype.routeName = dir[dir.length-1];\n\t\t\t\t} else {\n\t\t\t\t\toptions.fns = RouteClass.__lp.fns;\n\t\t\t\t}\n\t\t\t\toptions.objPath = dir.join('.');\n\t\t\t\toptions.cacheLinks = [];\n\t\t\t\toptions.linkTags = [];\n\t\t\t\toptions.param = {\n\t\t\t\t\tqueryParams :{},\n\t\t\t\t\tdynamicParam : undefined\n\t\t\t\t};\n\t\t\t\tvar cache = config.queryParamOptions.cache;\n\t\t\t\tif(options.queryParams = RouteClass.queryParams) {\n\t\t\t\t\toptions.qpdef = {};\n\t\t\t\t\toptions.$ = {};\n\t\t\t\t\tRouteClass.queryParams.forEach(function(qp,i) {\n\t\t\t\t\t\tif(typeof qp == \"string\") {\n\t\t\t\t\t\t\toptions.qpdef[qp] = {\n\t\t\t\t\t\t\tcache : cache,\n\t\t\t\t\t\t\trefreshData : true\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif(config.cacheRoutes[dir] == undefined && cache) {\n\t\t\t\t\t\t\tconfig.cacheRoutes[dir] = cache\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(typeof qp == \"object\") {\n\t\t\t\t\t\tfor(var key in qp) {\n\t\t\t\t\t\t\toptions.qpdef[key] = {\n\t\t\t\t\t\t\t\tcache : qp[key].hasOwnProperty('cache') ? qp[key].cache : cache,\n\t\t\t\t\t\t\t\trefreshData : qp[key].hasOwnProperty('refreshData') ? qp[key].refreshData : true\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif(!config.cacheRoutes[dir] && options.qpdef[key].cache) {\n\t\t\t\t\t\t\t\tconfig.cacheRoutes[options.objPath] = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRouteClass.queryParams[i] = key;\n\t\t\t\t\t\t}\n\t\t\t\t\t});  \n\t\t\t\t}\n\t\t\t\tRouteClass.routeName = dir[dir.length -1];\n\t\t\t\tsetRouteDef(dir,{RouteClass, options});\n\t\t\t}\n\t\t}\n\n        const transPredefined = ['runLoop','running','paused','R','routes',abortedStr,'prom','run',pendingStr,'matched','fns','rOpts','logs','onLoadCalled','getDynamicParams'];\n\n        function limitTransition(int) {\n\t\t\tvar _trans = new navigation(int);\n\t\t\tint.state = _trans.state = 201;\n\t\t\treturn _trans;\n\t\t}\n\n        function dummy() {\n\t\t\t/*\n\t\t\tDont delete this function.\n\t\t\tThis one is to avoid function to be merged during minification.\n\t\t\t*/\n\t\t\tvar _trans = new navigation(int);\n\t\t}\n\n        function navigation(int) {\n\t\t\tfor(var prop in int) {\n\t\t\t\tif(transPredefined.indexOf(prop) == -1) {\n\t\t\t\t\tif(prop == 'info') {\n\t\t\t\t\t\tthis.info = deepCopyObject(int[prop]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis[prop] = int[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        this.getRouteInstance = function(routeName,t) {\n\t\t\tvar newTrans;\n\t\t\tif(LR && LR.__lp.initCalled && (newTrans = (t || (LR.__lp && LR.__lp.trans) || trans)) && newTrans.routes) {\n\t\t\t\tvar routeLen = newTrans.routes.length;\n\t\t\t\tif(!routeName) {\n\t\t\t\t\treturn newTrans.routes[routeLen-1];\n\t\t\t\t} else if(routeName == \"*\") {\n\t\t\t\t\treturn newTrans.routes;\n\t\t\t\t} else {\n\t\t\t\t\tvar reqRouteLen = routeName.split('.').length-1,\n\t\t\t\t\treqRoute = newTrans.routes[reqRouteLen];\n\t\t\t\t\treturn reqRoute && reqRoute.__lp.objPath == routeName ? reqRoute : undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n        function normalizeMatchedObj(obj) {\n\t\t\t// To construct dynamic params array.\n\t\t\tif(obj.route) {\n\t\t\t\tvar routesObj = config.routes,\n\t\t\t\t// parentRouteObj,\n\t\t\t\tmatched,\n\t\t\t\t// def,\n\t\t\t\tR = [],\n\t\t\t\trOpts = [],\n\t\t\t\terrorCheck = function(route,i) {\n\t\t\t\t\troutesObj = _getObj(route,routesObj);\n\t\t\t\t\tif(!routesObj) {\n\t\t\t\t\t\tthrow Error(RouterError.getErrorMessage(\"400A\",matched.target));\n\t\t\t\t\t}\n\t\t\t\t\tR.push(routesObj.__lp.handler)\n\t\t\t\t};\n\t\t\t\tif(obj._routes) {\n\t\t\t\t\tmatched = obj;\n\t\t\t\t} else {\n\t\t\t\t\tvar routeFromAlias = _getRouteFromAlias.call(this,{route : obj.route, map : config.aliasRouteMap});\n\t\t\t\t\tmatched = {\n\t\t\t\t\t\troute : routeFromAlias.route, /* Array.isArray(obj.route) ? obj.route : _dotSerperator(obj.route), */\n\t\t\t\t\t\talias : routeFromAlias.alias,\n\t\t\t\t\t\tqueryParams : obj.queryParams || {},\n\t\t\t\t\t\tdynamicParams : [],\n\t\t\t\t\t\tfragment : obj.fragment,\n\t\t\t\t\t\ttarget : \"\",\n\t\t\t\t\t\trefreshRoute : obj.refreshRoute,\n\t\t\t\t\t\tstartFrom : obj.startFrom,\n\t\t\t\t\t\t_routes : []\n\t\t\t\t\t};\n\t\t\t\t\tif(obj.dynamicParams) {\n\t\t\t\t\t\tif(obj.dpProcessed) {\n\t\t\t\t\t\t\tmatched.dynamicParams = Array.from(obj.dynamicParams);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar dynamicParams =  Array.from(obj.dynamicParams);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmatched.route.forEach(obj._routes ? errorCheck : function(route,i) {\n\t\t\t\t\t\tmatched.target = matched.target ? matched.target+'.'+route : route;\n\t\t\t\t\t\tmatched._routes.push(_dotSerperator(matched.target));\n\t\t\t\t\t\terrorCheck(route,i)\n\t\t\t\t\t\tif(dynamicParams) {\n\t\t\t\t\t\t\tmatched.dynamicParams.push(routesObj.__lp.dkey ? dynamicParams.shift() : undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tvar r = _getObj(matched._routes[matched._routes.length-1],config.routes)\n\t\t\t\t\tif(r && r.__lp.mount) {\n\t\t\t\t\t\tmatched.mountRoute = true\n\t\t\t\t\t}\n\t\t\t\t\tif(dynamicParams && dynamicParams.length) {\n\t\t\t\t\t\tlyte.error('Extra dynamic params found. Provide exact numbers dynamic params required for the transition '+ JSON.stringify(dynamicParams));\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\tRouterError.error(e);\n\t\t\t\t\treturn {error : e};\n\t\t\t\t}\n\t\t\t\treturn { \n\t\t\t\t\trOpts,\n\t\t\t\t\tmatched,\n\t\t\t\t\tR\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif(this.tagName == LINKTOStr) {\n\t\t\t\t\tRouterError.error(\"498A\", pRoute ,this.outerHTML);\n\t\t\t\t} else {\n\t\t\t\t\tRouterError.error(\"499B\");  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        function initRoute(trans, processed, from) {\n\t\t\ttrans.routes = [];\n\t\t\tprocessed.rOpts = processed.rOpts || [];\n\t\t\tvar RouteClass,\n\t\t\trouteObj,\n\t\t\tmatched = processed.matched,\n\t\t\trefMatch = processed.prevTrans,\n\t\t\tsimilarRoute = true;\n\t\t\ttrans.routes = [];\n\n\t\t\tfunction pushRoute(i, routeObj, ins) {\n\t\t\t\tLR.__lp.nav.set(ins, newTrans);\n\t\t\t\tins.parent = newTrans.routes[i-1] instanceof Promise ? newTrans.routes[i-1].then(function() {ins.parent = newTrans.routes[i-1]}.bind(this)) : newTrans.routes[i-1];\n\t\t\t\ttrans.rOpts[i] = deepCopyObject(routeObj.__lp.options);\n\t\t\t\tnewTrans.routes[i] = ins\n\t\t\t}\n\n\t\t\tfunction promFunc({routeStringArr, i, routeObj}, res) {\n\t\t\t\trouteObj.__lp.handler().then(function(data) {\n\t\t\t\t\tinitialRegisterRoute(routeStringArr,(trans.R[i] = RouteClass = routeObj.__lp.handler = data[routeObj.__lp.cName]));\n\t\t\t\t\tlyte.scopedInstance(RouteClass,[{ i ,routeName : routeStringArr[i],options : routeOptions, init : pushRoute.bind(this,i,routeObj)}],emptyFn,[LR]);\n\t\t\t\t\tres()\n\t\t\t\t}.bind(routeObj));\n\t\t\t};\n\n\t\t\tfor(var i = from || 0, route; route = matched.route[i]; i++) {\n\t\t\t\trouteObj = _getObj(newTrans.matched._routes[i], config.routes);\n\t\t\t\tRouteClass = routeObj.__lp.handler;\n\t\t\t\tif(!RouteClass) {return false;}\n\t\t\t\tif(refMatch && similarRoute && refMatch.matched && refMatch.matched.route[i] == route) {\n\t\t\t\t\tmodifyInstance({route : refMatch.routes[i],i,processed, nav : newTrans});\n\t\t\t\t\t// lyte.scopedInstance(RouteClass,[rOpts,trans.routes,i,processed,routeOptions,refMatch.routes[i]],pushRoute.bind(this,i),[LR]);\n\t\t\t\t} else {\n\t\t\t\t\tif(RouteClass.name == __routeProm__Str) {\n\t\t\t\t\t\ttrans.routes.push(new Promise(promFunc.bind(this, {routeStringArr : matched._routes[i], i, routeObj})))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlyte.scopedInstance(RouteClass,[{i ,routeName : route, options : routeOptions, init : pushRoute.bind(this,i, routeObj)}],emptyFn,[LR]);\n\t\t\t\t\t}\n\t\t\t\t\tsimilarRoute = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trefMatch = undefined;\n\t\t}\n\n        function modifyTransition(trans) {\n\t\t\tif(trans.changedInstance) {\n\t\t\t\ttrans.routes.forEach(function(route,i) {\n\t\t\t\t\tLR.__lp.nav.set(route,trans);\n\t\t\t\t\tLR.__lp.nav.get(route).rOpts = trans.rOpts[i]\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn trans;\n\t\t}\n\n        function modifyInstance({route, i, processed, nav }) {\n\t\t\tvar rOpts = nav.rOpts[i] = deepCopyObject(LR.__lp.nav.get(route).rOpts[i])\n\t\t\tLR.__lp.nav.set(route, nav);\n\t\t\tdelete rOpts.rendered;\n\t\t\tif(processed.transComp && !processed.transComp.rendered[i] && processed.transComp.redirected) {\n\t\t\t\tif(processed.transComp.redirected.index < i) {\n\t\t\t\t\tdelete rOpts.loadDependencies;\n\t\t\t\t\tdelete rOpts.loadResources;\n\t\t\t\t\troute.$.beforeFetch = route.$.fetch = route.$.afterFetch = undefined;\n\t\t\t\t} else if(processed.transComp.redirected.index != i) {\n\t\t\t\t\tdelete rOpts.stencils;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete rOpts.stencils;\n\t\t\t}\n\t\t\tnav.routes[i] = route;\n\t\t}\n\n        function dispatchTransition(processed) {\n\t\t\tconst url = constructURLFromRoute(processed.matched);\n\t\t\tif(url) {\n\t\t\t\tprocessed.path = newTransInfo.url = url;\n\t\t\t\tdispatch(url,decideTransition(processed));\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n        const allHooks = [getRequirementsStr,beforeFetchStr,fetchStr,afterFetchStr,divertStr,renderStr,afterRenderStr];\n        function decideTransition(processed) {\n\t\t\t/* determines which transition to consider as previous transition */\n\t\t\tif(trans) {\n\t\t\t\tif(trans.running) {\n\t\t\t\t\tvar matched = processed.matched;\n\t\t\t\t\tif(trans.state == 102 && trans.prom && trans.prom.hook == divertStr) {\n\t\t\t\t\t\tvar transComp = getTransitionDiffernce(trans,matched,processed.R),\n\t\t\t\t\t\ttransitioningRoute = allHooks.indexOf(trans.prom.hook) <= 6 ? trans.prom.index : trans.prom.index+1,\n\t\t\t\t\t\tvisibleTransComparison = getTransitionDiffernce(visibleTrans,matched,processed.R);\n\t\t\t\t\t\tif(transComp.common.length < visibleTransComparison.common.length) {\n\t\t\t\t\t\t\tif(trans.runLoop.templateToRemove.length) {\n\t\t\t\t\t\t\t\ttrans.runLoop.templateToRemove.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(transComp.rendered.length < visibleTransComparison.rendered.length) {\n\t\t\t\t\t\t\t\tprocessed.prevTrans = modifyTransition(visibleTrans);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransComp = visibleTransComparison;\n\t\t\t\t\t\t\tif(trans.prom.index <= visibleTransComparison.common.length -1) {\n\t\t\t\t\t\t\t\ttransComp.redirected = trans.prom;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(transComp.common.length-1 >= transitioningRoute) {\n\t\t\t\t\t\t\tif(trans.prom.index <= transComp.common.length -1) {\n\t\t\t\t\t\t\t\tprocessed.prevTrans = trans;\n\t\t\t\t\t\t\t\ttransComp.redirected = trans.prom;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}  \n\t\t\t\t\t}\n\t\t\t\t\tconst info = {\n\t\t\t\t\t\troute : matched.target,\n\t\t\t\t\t\tqueryParams : matched.queryParams,\n\t\t\t\t\t\tdynamicParams : matched.dynamicParams.filter(_arrayClean)\n\t\t\t\t\t};\n\t\t\t\t\tif(LR.checkIfSameRoute(trans.info,info) && !trans.aborted) {\n\t\t\t\t\t\ttrans.pause({iPause : true});  \n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrans.abort({state : 409, iAbort : true});\n\t\t\t\t\t}\n\t\t\t\t\tprocessed.transComp = transComp;\n\t\t\t\t} else if(trans && !trans.aborted) {\n\t\t\t\t\ttrans.abort({state : 409, iAbort : true});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn processed;\n\t\t}\n\n        if(lyte.$.modules.triggerEvent) {\n\t\t\tlyte.$.modules.triggerEvent(\"add\", \"router\", this);\n\t\t}\n        var routeOptions = {\n\t\t\tlyte,\n\t\t\tdispatch,\n\t\t\tLR,\n\t\t\tconstructURLFromRoute,\n\t\t\tdecideTransition\n\t\t}\n        Lyte.domContentLoaded(init);\n        return this;\n    }\n}\n\nRouter.__lMod = \"Router\";\n\nexport { Router };"],"names":[],"sourceRoot":""}