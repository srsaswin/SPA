(self["webpackChunkclient"] = self["webpackChunkclient"] || []).push([["lyte"],{

/***/ 93521699:
/*!***********************************************************************************!*\
  !*** ./node_modules/@slyte/component/src/ZohoSecurity/lyte-component-security.js ***!
  \***********************************************************************************/
/***/ (() => {

;if(!window.ZSEC) {if(window.ZSEC||Object.defineProperty(window,"ZSEC",{value:{},writable:!1,configurable:!1,enumerable:!1}),Object.defineProperty(ZSEC,"util",{value:{},writable:!1,configurable:!1,enumerable:!1}),function(){if(!Object.defineProperty||!function(){try{return Object.defineProperty({},"x",{}),!0}catch(e){return!1}}()){var e=Object.defineProperty;Object.defineProperty=function(t,r,o){if(e)try{return e(t,r,o)}catch(e){}if(t!==Object(t))throw TypeError("Object.defineProperty called on non-object");return Object.prototype.__defineGetter__&&"get"in o&&Object.prototype.__defineGetter__.call(t,r,o.get),Object.prototype.__defineSetter__&&"set"in o&&Object.prototype.__defineSetter__.call(t,r,o.set),"value"in o&&(t[r]=o.value),t}}}(),ZSEC.util.defineProperty=function(e,t,r,o,n,i,a){if(o||!(t in e))return n=1==n,i=1==i,a=1==a,Object.defineProperty(e,t,{value:r,writable:n,configurable:i,enumerable:a})},ZSEC.util.defineProperty(ZSEC,"version","4.0",!0),ZSEC.util.defineProperty(ZSEC,"constants",ZSEC.constants||{},!0),ZSEC.util.ArrayIndexOf=Array.prototype.indexOf,ZSEC.util.ArrayIndexOf||(ZSEC.util.ArrayIndexOf=function(e){if(void 0===this||null===this)throw TypeError();var t=Object(this),r=t.length>>>0;if(0===r)return-1;var o=0;if(arguments.length>0&&(o=Number(arguments[1]),isNaN(o)?o=0:0!==o&&o!==1/0&&o!==-1/0&&(o=(o>0||-1)*Math.floor(Math.abs(o)))),o>=r)return-1;for(var n=o>=0?o:Math.max(r-Math.abs(o),0);n<r;n++)if(n in t&&t.charAt(n)===e)return n;return-1}),String.prototype.codePointAt)ZSEC.util.defineProperty(String.prototype,"codePointAt",String.prototype.codePointAt,!0);else{var codePointAt=function(e){if(null==this)throw TypeError();var t=String(this),r=t.length,o=e?Number(e):0;if(o!=o&&(o=0),!(o<0||o>=r)){var n,i=t.charCodeAt(o);return i>=55296&&i<=56319&&r>o+1&&(n=t.charCodeAt(o+1))>=56320&&n<=57343?1024*(i-55296)+n-56320+65536:i}};ZSEC.util.defineProperty(String.prototype,"codePointAt",codePointAt,!1)}if(String.fromCodePoint)ZSEC.util.defineProperty(String,"fromCodePoint",String.fromCodePoint,!0);else{var stringFromCharCode=String.fromCharCode,floor=Math.floor,fromCodePoint=function(){var e,t,r=[],o=-1,n=arguments.length;if(!n)return"";for(var i="";++o<n;){var a=Number(arguments[o]);if(!isFinite(a)||a<0||a>1114111||floor(a)!=a)throw RangeError("Invalid code point: "+a);a<=65535?r.push(a):(e=55296+((a-=65536)>>10),t=a%1024+56320,r.push(e,t)),(o+1==n||r.length>16384)&&(i+=stringFromCharCode.apply(null,r),r.length=0)}return i};ZSEC.util.defineProperty(String,"fromCodePoint",fromCodePoint,!1)}!function(){var e={log:function(e){if(navigator&&navigator.userAgent){var t=navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(t&&t[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;")}window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}};ZSEC.util.defineProperty(ZSEC,"Console",e,!0,!1,!1,!0)}(),ZSEC.Console.log();};window.DOMPurifyCopy = window.DOMPurify ? window.DOMPurify : undefined;;if(!window.ZSEC.HTMLPurifier) {function addToSet(e,t){for(var r=t.length;r--;)e[t[r]]=!0;return e}function addObjsToSet(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=!0);return e}function removeFromSet(e,t){var r={};for(var o in e)e.hasOwnProperty(o)&&o!=t&&(r[o]=e[o]);return r}!function(e){window.DOMPurify=e(window)}(function e(t){var r=function(t){return e(t)};if(r.version="0.8.5",r.removed=[],!t||!t.document||9!==t.document.nodeType)return r.isSupported=!1,r;var o=t.document,n=o,T=t.DocumentFragment,i=t.HTMLTemplateElement,a=t.Node,A=t.NodeFilter,_=t.NamedNodeMap||t.MozNamedAttrMap,E=t.Text,O=t.Comment,L=t.DOMParser;if("function"==typeof i){var s=o.createElement("template");s.content&&s.content.ownerDocument&&(o=s.content.ownerDocument)}var l=o.implementation,d=o.createNodeIterator,u=o.getElementsByTagName,c=o.createDocumentFragment,R=n.importNode,S={};r.isSupported=void 0!==l.createHTMLDocument&&9!==o.documentMode;var f=function(e,t){for(var r=t.length;r--;)"string"==typeof t[r]&&(t[r]=t[r].toLowerCase()),e[t[r]]=!0;return e},p=null,B=f({},[]),m=null,N=f({},[]),D=null,I=null,h=!0,U=!0,v=!1,b=!1,y=!1,g=/\{\{[\s\S]*|[\s\S]*\}\}/gm,G=/<%[\s\S]*|[\s\S]*%>/gm,F=!1,w=!0,M=!1,C=!1,P=!1,W=!0,J=!0,x=f({},["audio","head","math","script","svg","video","style"]),H=f({},["audio","video","img","source","image"]),k=f({},["alt","class","for","id","label","name","pattern","placeholder","summary","title","value","style","xmlns"]),Y=null,z=o.createElement("form"),V=function(e){"object"!=typeof e&&(e={}),p="ALLOWED_TAGS"in e?f({},e.ALLOWED_TAGS):B,m="ALLOWED_ATTR"in e?f({},e.ALLOWED_ATTR):N,D="FORBID_TAGS"in e?f({},e.FORBID_TAGS):{},I="FORBID_ATTR"in e?f({},e.FORBID_ATTR):{},h=!1!==e.ALLOW_ARIA_ATTR,U=!1!==e.ALLOW_DATA_ATTR,v=e.ALLOW_UNKNOWN_PROTOCOLS||!1,b=e.SAFE_FOR_JQUERY||!1,y=e.SAFE_FOR_TEMPLATES||!1,F=e.WHOLE_DOCUMENT||!1,M=e.RETURN_DOM||!1,C=e.RETURN_DOM_FRAGMENT||!1,P=e.RETURN_DOM_IMPORT||!1,w=!1!==e.FORCE_BODY,W=!1!==e.SANITIZE_DOM,J=!1!==e.KEEP_CONTENT,y&&(U=!1),C&&(M=!0),e.ADD_URI_SAFE_ATTR&&f(k,e.ADD_URI_SAFE_ATTR),J&&(p["#text"]=!0),Object&&"freeze"in Object&&Object.freeze(e),Y=e},j=function(e){r.removed.push({element:e});try{e.parentNode.removeChild(e)}catch(t){e.outerHTML=""}},Q=function(e,t){r.removed.push({attribute:t.getAttributeNode(e),from:t}),t.removeAttribute(e)},X=function(e){var t,r;w&&(e="<remove></remove>"+e);try{t=(new L).parseFromString(e,"text/html")}catch(e){}return t&&t.documentElement||((r=(t=l.createHTMLDocument("")).body).parentNode.removeChild(r.parentNode.firstElementChild),r.outerHTML=e),"function"==typeof t.getElementsByTagName?t.getElementsByTagName(F?"html":"body")[0]:u.call(t,F?"html":"body")[0]},Z=function(e){return d.call(e.ownerDocument||e,e,A.SHOW_ELEMENT|A.SHOW_COMMENT|A.SHOW_TEXT,function(){return A.FILTER_ACCEPT},!1)},K=function(e){return!(e instanceof E||e instanceof O)&&!("string"==typeof e.nodeName&&"string"==typeof e.textContent&&"function"==typeof e.removeChild&&e.attributes instanceof _&&"function"==typeof e.removeAttribute&&"function"==typeof e.setAttribute)},q=function(e){return"object"==typeof a?e instanceof a:e&&"object"==typeof e&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName},$=function(e){var t,o;if(ae("beforeSanitizeElements",e,null),K(e))return j(e),!0;if(t=e.nodeName.toLowerCase(),ae("uponSanitizeElement",e,{tagName:t,allowedTags:p}),!p[t]||D[t]){if(J&&!x[t]&&"function"==typeof e.insertAdjacentHTML)try{e.insertAdjacentHTML("AfterEnd",e.innerHTML)}catch(e){}return j(e),!0}return"style"!=t?(!b||e.firstElementChild||e.content&&e.content.firstElementChild||!/</g.test(e.textContent)||(r.removed.push({element:e.cloneNode()}),e.innerHTML=e.textContent.replace(/</g,"&lt;")),y&&3===e.nodeType&&(o=(o=(o=e.textContent).replace(g," ")).replace(G," "),e.textContent!==o&&(r.removed.push({element:e.cloneNode()}),e.textContent=o))):!b||e.firstElementChild||e.content&&e.content.firstElementChild||!/</g.test(e.textContent)||(r.removed.push({element:e.cloneNode()}),e.innerHTML=e.textContent.replace(/</g,"\\3c ")),ae("afterSanitizeElements",e,null),!1},ee=/^data-[-\w.\u00B7-\uFFFF]/,te=/^aria-[-\w]+$/,re=/^(?:(?:https?|mailto|tel):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,oe=/^(?:\w+script|data):/i,ne=/[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,Te=function(e){var t,n,T,i,a,A,_,E;if(ae("beforeSanitizeAttributes",e,null),A=e.attributes){for(_={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:m},E=A.length;E--;)if(t=A[E],n=t.name,T=t.value.trim(),i=n.toLowerCase(),_.attrName=i,_.attrValue=T,_.keepAttr=!0,ae("uponSanitizeAttribute",e,_),T=_.attrValue,"name"===i&&"IMG"===e.nodeName&&A.id?(a=A.id,A=Array.prototype.slice.apply(A),Q("id",e),Q(n,e),A.indexOf(a)>E&&e.setAttribute("id",a.value)):("id"===n&&e.setAttribute(n,""),Q(n,e)),_.keepAttr&&(!W||"id"!==i&&"name"!==i||!(T in o||T in z))){y&&(T=(T=T.replace(g," ")).replace(G," "));if(U&&ee.test(i))!0;else if(h&&te.test(i))!0;else{if(!m[i]||I[i])continue;if(k[i])!0;else if(re.test(T.replace(ne,"")))!0;else if("src"!==i&&"xlink:href"!==i||0!==T.indexOf("data:")||!H[e.nodeName.toLowerCase()])if(v&&!oe.test(T.replace(ne,"")))!0;else{if(T)continue;!0}else!0}try{e.setAttribute(n,T),r.removed.pop()}catch(e){}}ae("afterSanitizeAttributes",e,null)}},ie=function(e){var t,r=Z(e);for(ae("beforeSanitizeShadowDOM",e,null);t=r.nextNode();)ae("uponSanitizeShadowNode",t,null),$(t)||(t.content instanceof T&&ie(t.content),Te(t));ae("afterSanitizeShadowDOM",e,null)},ae=function(e,t,o){S[e]&&S[e].forEach(function(e){e.call(r,t,o,Y)})};return r.sanitize=function(e,o){var i,A,_,E,O,L;if(e||(e="\x3c!--\x3e"),"string"!=typeof e&&!q(e)){if("function"!=typeof e.toString)throw new TypeError("toString is not a function");e=e.toString()}if(!r.isSupported){if("object"==typeof t.toStaticHTML||"function"==typeof t.toStaticHTML){if("string"==typeof e)return t.toStaticHTML(e);if(q(e))return t.toStaticHTML(e.outerHTML)}return e}if(V(o),r.removed=[],e instanceof a)1===(A=(i=X("\x3c!--\x3e")).ownerDocument.importNode(e,!0)).nodeType&&"BODY"===A.nodeName?i=A:i.appendChild(A);else{if(!M&&!F&&-1===e.indexOf("<"))return e;if(!(i=X(e)))return M?null:""}for(w&&j(i.firstChild),O=Z(i);_=O.nextNode();)3===_.nodeType&&_===E||$(_)||(_.content instanceof T&&ie(_.content),Te(_),E=_);if(M){if(C)for(L=c.call(i.ownerDocument);i.firstChild;)L.appendChild(i.firstChild);else L=i;return P&&(L=R.call(n,L,!0)),L}return F?i.outerHTML:i.innerHTML},r.addHook=function(e,t){"function"==typeof t&&(S[e]=S[e]||[],S[e].push(t))},r.removeHook=function(e){S[e]&&S[e].pop()},r.removeHooks=function(e){S[e]&&(S[e]=[])},r.removeAllHooks=function(){S={}},r}),function(e){var t={};t.ALLOW_ARIA_ATTR=!0,t.ALLOW_DATA_ATTR=!0,t.ALLOW_UNKNOWN_PROTOCOLS=!1,t.SAFE_FOR_JQUERY=!1,t.SAFE_FOR_TEMPLATES=!1,t.WHOLE_DOCUMENT=!1,t.RETURN_DOM=!1,t.RETURN_DOM_FRAGMENT=!1,t.RETURN_DOM_IMPORT=!1,t.FORCE_BODY=!0,t.SANITIZE_DOM=!0,t.KEEP_CONTENT=!0,t.STYLE_VALIDATION=!0,t.REMOVE_ONEVENTS=!0,t.ALLOWED_STYLE="NONE",t.ALLOWED_TAGS="a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text".split("|"),t.ALLOWED_ATTR="accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox".split("|"),t.ALLOWED_STYLE_PROPS="azimuth|background|background-attachment|background-color|background-image|background-position|content|background-repeat|border-collapse|border-color|border-top-color|border-right-color|border-bottom-color|border-left-color|bottom|caption-side|clear|color|cue-after|cue-before|direction|display|elevation|empty-cells|float|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|height|left|letter-spacing|line-height|list-style-image|list-style-position|list-style-type|marker-offset|max-height|max-width|min-height|min-width|orphans|outline-color|overflow|page-break-after|page-break-before|page-break-inside|pause-after|pause-before|pitch|pitch-range|position|richness|right|size|speak|speak-header|speak-numeral|speak-punctuation|speech-rate|stress|table-layout|text-indent|text-transform|top|unicode-bidi|vertical-align|visibility|volume|white-space|widows|width|word-spacing|border-style|border-top-style|border-right-style|border-bottom-style|border-left-style|border-top-width|border-right-width|border-bottom-width|border-left-width|border-width|margin|margin-top|margin-right|margin-bottom|margin-left|outline-style|outline-width|padding|padding-top|padding-right|padding-bottom|padding-left|border|border-top|border-right|border-bottom|border-left|cue|list-style|marks|outline|pause|text-decoration|border-spacing|clip|counter-increment|clip|cursor|text-shadow|font|font-family|page|play-during|text-align|voice-family".split("|"),t.FORBID_TAGS=[],t.FORBID_ATTR=[],t.ALLOWED_TAGS_OBJ={},t.ALLOWED_ATTR_OBJ={},t.FORBID_TAGS_OBJ={},t.FORBID_ATTR_OBJ={},t.ADD_URI_SAFE_ATTR=[],t.EXTENDS=["GLOBAL_ATTRIBUTES","GLOBAL_TAGS","FORBID_TAGS","FORBID_ATTR","GLOBAL_APPEND_ATTRIBUTES","GLOBAL_ATTRIBUTE_RULES","ADD_URI_SAFE_ATTR","TAG_RULES"],t.TAG_RULES={a:{APPEND_ATTRIBUTES:[{NAME:"rel",VALUE:"noopener noreferrer",CRITERIA:[{NAME:"target",CONTAINS:"_blank"}]}]}},t.GLOBAL_APPEND_ATTRIBUTES=[],t.GLOBAL_ATTRIBUTE_RULES={},ZSEC.util.defineProperty(ZSEC,"HTMLPurifier",e(t,DOMPurify(window)),!0,!1,!1,!0),delete window.DOMPurify}(function e(t,r){function o(e){if(!e||e.constructor!==Object)return t;var r={};for(var o in t)t.hasOwnProperty(o)&&(o in e?o in m&&(1==e[o]||0==e[o]?r[o]=e[o]:r[o]=t[o]):r[o]=t[o]);return r.SAFE_FOR_TEMPLATES&&(r.ALLOW_DATA_ATTR=!1),r.RETURN_DOM_FRAGMENT&&(r.RETURN_DOM=!0),r.KEEP_CONTENT&&(r.ALLOWED_TAGS_OBJ["#text"]=!0),r}function n(e){for(var t in e)e.hasOwnProperty(t)&&e[t].constructor==String&&(e[t]&&b[t]?v=!0:e[t]&&("cssText"==t||/^\d.*/.test(t)||(e[t]="",I=!0)))}function T(e){for(var t=e.length-1;t>=0;t--){var r=e[t];1==r.type&&r.selectorText||8==r.type&&r.keyText?r.style&&n(r.style):4!=r.type&&7!=r.type||!r.cssRules||T(r.cssRules)}}function i(e,t){for(var r=t.length-1;r>=0;r--)1!=t[r].type&&4!=t[r].type&&7!=t[r].type||e.push(t[r].cssText)}function a(e,t,r){var r=void 0==r?e.IS_MANDATORY:r;if(e.NAME&&!t.hasAttribute(e.NAME.toLowerCase()))return e.IS_FORBIDDEN||!r;if(e.IS_FORBIDDEN)return!1;var o=t.getAttribute(e.NAME.toLowerCase());if(void 0!==o&&null!==o||(o=""),o.constructor==String){if(e.DONT_TRIM||(o=o.trim()),e.CASE_SENSITIVE||!1||(o=o.toLowerCase()),e.MAX_LENGTH&&o.length>e.MAX_LENGTH)return!1;if(e.MIN_LENGTH&&o.length<e.MIN_LENGTH)return!1;if(void 0!=e.REGEX){if(e.REGEX.constructor==RegExp&&-1==o.search(e.REGEX))return!1;if(e.REGEX.constructor==Array)for(T=0;T<e.REGEX.length;T++)if(-1==o.search(e.REGEX[T]))return!1}}if(e.LIST&&-1==e.LIST.indexOf(o))return!1;if("INTEGER"==e.TYPE||"FLOAT"==e.TYPE){var n;try{n="INTEGER"==e.TYPE?window.parseInt(o,10):window.parseFloat(o)}catch(e){return!1}if(window.isNaN(n))return!1;if(void 0!=e.GREATER_THAN&&n<=e.GREATER_THAN)return!1;if(void 0!=e.GREATER_THAN_OR_EQUAL&&n<e.GREATER_THAN_OR_EQUAL)return!1;if(void 0!=e.LESSER_THAN&&n>=e.LESSER_THAN)return!1;if(void 0!=e.LESSER_THAN_OR_EQUAL&&n>e.LESSER_THAN_OR_EQUAL)return!1;if(void 0!=e.EQUAL&&n!=e.EQUAL)return!1;if(void 0!=e.NOT_EQUAL&&n==e.NOT_EQUAL)return!1}else if(o.constructor==String){if(void 0!=e.STARTS_WITH&&0!=o.indexOf(e.STARTS_WITH))return!1;if(void 0!=e.ENDS_WITH&&o.lastIndexOf(e.ENDS_WITH)!=o.length-e.ENDS_WITH.length)return!1;if(void 0!=e.CONTAINS){if(e.CONTAINS.constructor==String&&-1==o.indexOf(e.CONTAINS))return!1;if(e.CONTAINS.constructor==Array)for(T=0;T<e.CONTAINS.length;T++)if(-1==o.indexOf(e.CONTAINS[T]))return!1}if(void 0!=e.NOT_CONTAINS){if(e.NOT_CONTAINS.constructor==String&&o.indexOf(e.NOT_CONTAINS)>-1)return!1;if(e.NOT_CONTAINS.constructor==Array)for(var T=0;T<e.NOT_CONTAINS.length;T++)if(o.indexOf(e.NOT_CONTAINS[T])>-1)return!1}if(void 0!=e.EQUAL&&o!==e.EQUAL)return!1;if(void 0!=e.NOT_EQUAL&&o===e.NOT_EQUAL)return!1}return!0}function A(e){if(!e)return e;if(e.constructor==Object)for(var t in e)e.hasOwnProperty(t)&&(e[t]=E(e[t]));return e}function _(e){if(!e)return e;if(e.constructor==Array)for(var t=0;t<e.length;t++)if(e[t].CRITERIA)for(var r=0;r<e[t].CRITERIA.length;r++)e[t].CRITERIA[r]=E(e[t].CRITERIA[r]);return e}function E(e){if(e){var t=["STARTS_WITH","ENDS_WITH","CONTAINS","EQUAL","NOT_EQUAL","LIST"];if(!(e.CASE_SENSITIVE||!1))for(var r=0;r<t.length;r++){var o=t[r];e[o]&&(e[o]=O(e[o]))}}return e}function O(e){if(e&&e.constructor==String)return e.toLowerCase();if(e.constructor==Array)for(var t=0;t<e.length;t++)e[t]=O(e[t]);return e}function L(e,t){if(!e||e.constructor==Object)return e;for(var r={},o=0;o<e.length;o++){var n=e[o];r[n[t]]=n}return r}function s(e,t){if(e)for(var r=0;r<e.length;r++){var o=e[r];if(!t.hasAttribute(o.NAME.toLowerCase())){var n=!0;if(o.CRITERIA)for(var T=0;T<o.CRITERIA.length;T++)if(!a(o.CRITERIA[T],t,!0)){n=!1;break}n?t.setAttribute(o.NAME,o.VALUE):void 0!=o.DEFAULT_VALUE&&t.setAttribute(o.NAME,o.DEFAULT_VALUE)}}}function l(e,t){if(!t||t.constructor!==Object)return e;if(!e||e.constructor!==Object)return t;for(var r in t)t.hasOwnProperty(r)&&r in e?(void 0==e[r].APPEND_ATTRIBUTES&&(e[r].APPEND_ATTRIBUTES=t[r].APPEND_ATTRIBUTES),void 0==e[r].ATTRIBUTE_RULES&&(e[r].ATTRIBUTE_RULES=t[r].ATTRIBUTE_RULES)):e[r]=t[r];return e}function d(e,t,r){return!(t&&!a(t,e))||(void 0!==t.DEFAULT_VALUE?e.setAttribute(r,t.DEFAULT_VALUE):e.removeAttribute(r),!1)}function u(e){if("object"==typeof e){e.ALLOWED_TAGS=e.GLOBAL_TAGS,e.ALLOWED_ATTR=e.GLOBAL_ATTRIBUTES;for(var r in h)!h.hasOwnProperty(r)||void 0!=e[r]||r in D||(e[r]=t[r]);if(e.TAG_RULES=L(e.TAG_RULES,"NAME"),e.TAG_RULES&&e.TAG_RULES.constructor==Object)for(var o in e.TAG_RULES)if(e.TAG_RULES.hasOwnProperty(o)){var n=e.TAG_RULES[o];n.ATTRIBUTE_RULES=A(L(n.ATTRIBUTE_RULES,"NAME")),n.APPEND_ATTRIBUTES=_(n.APPEND_ATTRIBUTES)}if(e.GLOBAL_ATTRIBUTE_RULES=A(L(e.GLOBAL_ATTRIBUTE_RULES,"NAME")),e.GLOBAL_APPEND_ATTRIBUTES=_(e.GLOBAL_APPEND_ATTRIBUTES),e.EXTENDS)for(var T=0;T<e.EXTENDS.length;T++){var i=e.EXTENDS[T];switch("GLOBAL_TAGS"==i&&(i="ALLOWED_TAGS"),"GLOBAL_ATTRIBUTES"==i&&(i="ALLOWED_ATTR"),i){case"ALLOWED_TAGS":case"ALLOWED_ATTR":case"FORBID_TAGS":case"FORBID_ATTR":e[i+="_OBJ"]={},t[i]&&(e[i]=addObjsToSet(e[i],t[i]));break;case"ADD_URI_SAFE_ATTR":case"GLOBAL_APPEND_ATTRIBUTES":if(e[i]||(e[i]=[]),!t[i]||t[i].constructor!==Array)break;e[i]=e[i].concat(t[i]);break;case"GLOBAL_ATTRIBUTE_RULES":if(e.GLOBAL_ATTRIBUTE_RULES||(e.GLOBAL_ATTRIBUTE_RULES={}),t.GLOBAL_ATTRIBUTE_RULES&&t.GLOBAL_ATTRIBUTE_RULES.constructor==Object)for(var a in t.GLOBAL_ATTRIBUTE_RULES)t.GLOBAL_ATTRIBUTE_RULES.hasOwnProperty(a)&&!e.GLOBAL_ATTRIBUTE_RULES[a]&&(e.GLOBAL_ATTRIBUTE_RULES[a]=t.GLOBAL_ATTRIBUTE_RULES[a]);break;case"TAG_RULES":e.TAG_RULES||(e.TAG_RULES={}),e.TAG_RULES=l(e.TAG_RULES,t.TAG_RULES)}}for(var E in N)N.hasOwnProperty(E)&&(e[E+"_OBJ"]||(e[E+"_OBJ"]={}),void 0!=e[E]?e[E].constructor===Array&&(e[E+"_OBJ"]=addToSet(e[E+"_OBJ"],e[E])):e[E]=[]);for(var O=0;O<B.length;O++){var s=B[O];e[s]||(e[s]=[])}"ALL"==e.ALLOWED_STYLE?(e.FORBID_TAGS_OBJ=removeFromSet(e.FORBID_TAGS_OBJ,"style"),e.FORBID_ATTR_OBJ=removeFromSet(e.FORBID_ATTR_OBJ,"style"),e.ALLOWED_TAGS_OBJ=addToSet(e.ALLOWED_TAGS_OBJ,["style"]),e.ALLOWED_ATTR_OBJ=addToSet(e.ALLOWED_ATTR_OBJ,["style"])):"INLINE"==e.ALLOWED_STYLE?(e.FORBID_ATTR_OBJ=removeFromSet(e.FORBID_ATTR_OBJ,"style"),e.ALLOWED_ATTR_OBJ=addToSet(e.ALLOWED_ATTR_OBJ,["style"]),e.FORBID_TAGS_OBJ=addToSet(e.FORBID_TAGS_OBJ,["style"]),e.ALLOWED_TAGS_OBJ=removeFromSet(e.ALLOWED_TAGS_OBJ,"style")):"INTERNAL"==e.ALLOWED_STYLE?(e.FORBID_TAGS_OBJ=removeFromSet(e.FORBID_TAGS_OBJ,"style"),e.ALLOWED_TAGS_OBJ=addToSet(e.ALLOWED_TAGS_OBJ,["style"]),e.FORBID_ATTR_OBJ=addToSet(e.FORBID_ATTR_OBJ,["style"]),e.ALLOWED_ATTR_OBJ=removeFromSet(e.ALLOWED_ATTR_OBJ,"style")):"NONE"==e.ALLOWED_STYLE&&(e.FORBID_TAGS_OBJ=addToSet(e.FORBID_TAGS_OBJ,["style"]),e.FORBID_ATTR_OBJ=addToSet(e.FORBID_ATTR_OBJ,["style"]),e.ALLOWED_TAGS_OBJ=removeFromSet(e.ALLOWED_TAGS_OBJ,"style"),e.ALLOWED_ATTR_OBJ=removeFromSet(e.ALLOWED_ATTR_OBJ,"style"));for(var d in N)if(N.hasOwnProperty(d)){for(var u in e[d+"_OBJ"])e[d+"_OBJ"].hasOwnProperty(u)&&e[d].push(u);e[d+"_OBJ"]=addToSet(e[d+"_OBJ"],e[d])}ZSEC.configValidator&&ZSEC.configValidator.HTMLPurifierValidation(e,h,N,c,R)}else{e={};for(var S in t)t.hasOwnProperty(S)&&(e[S]=t[S].valueOf())}return e}var c=addToSet({},["script"]),R=addToSet({},[]),S=["ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_JQUERY","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_DOM_IMPORT","FORCE_BODY","SANITIZE_DOM","KEEP_CONTENT","ALLOWED_STYLE_PROPS"],f=["ALLOWED_TAGS","ALLOWED_ATTR","FORBID_TAGS","FORBID_ATTR"],p=["ALLOWED_TAGS_OBJ","ALLOWED_ATTR_OBJ","FORBID_TAGS_OBJ","FORBID_ATTR_OBJ"],B=["ADD_URI_SAFE_ATTR","GLOBAL_APPEND_ATTRIBUTES","GLOBAL_ATTRIBUTE_RULES","TAG_RULES"],m=addToSet({},S),N=addToSet({},f),D=(addToSet({},p),addToSet({},B));D=addToSet(D,f),D=addToSet(D,p);var I,h=addToSet({},S.concat(["STYLE_VALIDATION","ALLOWED_STYLE","EXTENDS","REMOVE_ONEVENTS","GLOBAL_ATTRIBUTES","GLOBAL_TAGS"],f,p,B)),U={iframe:{NAME:"iframe",ATTRIBUTE_RULES:{sandbox:{NAME:"sandbox",NOT_CONTAINS:["allow-top-navigation","allow-popups-to-escape-sandbox"],DEFAULT_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin"}},APPEND_ATTRIBUTES:[{NAME:"sandbox",VALUE:"allow-popups allow-forms allow-scripts allow-same-origin"}]}},v=!1,b=addToSet({},t.ALLOWED_STYLE_PROPS);!function(){t.FORBID_TAGS_OBJ=addObjsToSet(t.FORBID_TAGS_OBJ,c),t.FORBID_ATTR_OBJ=addObjsToSet(t.FORBID_ATTR_OBJ,R);for(var e in N)N.hasOwnProperty(e)&&(t[e+"_OBJ"]=addToSet(t[e+"_OBJ"],t[e]));r.removeAllHooks(),I=!1,"NONE"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=addToSet(t.FORBID_TAGS_OBJ,["style"]),t.FORBID_ATTR_OBJ=addToSet(t.FORBID_ATTR_OBJ,["style"])),"INLINE"!=t.ALLOWED_STYLE&&"ALL"!=t.ALLOWED_STYLE||(t.STYLE_VALIDATION&&r.addHook("afterSanitizeAttributes",function(e){if(!e.ownerDocument.baseURI){var t=document.createElement("base");t.href=document.baseURI,e.ownerDocument.head.appendChild(t)}if(e.hasAttribute("style")){var r="";I=!1,n(e.style),(r=I?e.style.cssText:e.getAttribute("style")).length?e.setAttribute("style",r):e.removeAttribute("style")}}),"INLINE"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=addToSet(t.FORBID_TAGS_OBJ,["style"]),t.FORBID_ATTR_OBJ=removeFromSet(t.FORBID_ATTR_OBJ,"style"))),"INTERNAL"!=t.ALLOWED_STYLE&&"ALL"!=t.ALLOWED_STYLE||(t.STYLE_VALIDATION&&r.addHook("uponSanitizeElement",function(e,t){if("style"===t.tagName&&null!=e.sheet){var r=e.sheet.cssRules;if(I=!1,T(r),I){var o=[];i(o,r),e.textContent=o.join("\n")}}}),"INTERNAL"==t.ALLOWED_STYLE&&(t.FORBID_ATTR_OBJ=addToSet(t.FORBID_ATTR_OBJ,["style"]),t.FORBID_TAGS_OBJ=removeFromSet(t.FORBID_TAGS_OBJ,"style"))),"ALL"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=removeFromSet(t.FORBID_TAGS_OBJ,"style"),t.FORBID_ATTR_OBJ=removeFromSet(t.FORBID_ATTR_OBJ,"style")),(t.GLOBAL_ATTRIBUTE_RULES||t.TAG_RULES)&&r.addHook("afterSanitizeAttributes",function(e){for(var r=e.nodeName.toLowerCase(),o=t.GLOBAL_ATTRIBUTE_RULES,n=t.TAG_RULES&&t.TAG_RULES[r]&&t.TAG_RULES[r].ATTRIBUTE_RULES,T=U&&U[r]&&U[r].ATTRIBUTE_RULES,i=e.attributes.length;i--;){var a=e.attributes[i].name;d(e,n&&n[a]||o&&o[a],a)&&d(e,T&&T[a],a)}}),(t.GLOBAL_APPEND_ATTRIBUTES||t.TAG_RULES)&&r.addHook("afterSanitizeAttributes",function(e){var r=e.nodeName.toLowerCase();s(t.TAG_RULES&&t.TAG_RULES[r]&&t.TAG_RULES[r].APPEND_ATTRIBUTES,e),s(t.GLOBAL_APPEND_ATTRIBUTES,e),s(U&&U[r]&&U[r].APPEND_ATTRIBUTES,e)}),t.REMOVE_ONEVENTS&&r.addHook("uponSanitizeAttribute",function(e,t){0==t.attrName.indexOf("on")&&(t.keepAttr=!1)})}();var y=function(t){return t=u(t),e(t,r(window))};return y.isSupported=r.isSupported,y.removed="",ZSEC.util.defineProperty(y,"sanitize",function(e,t){var n=o(t),T=r.sanitize(e,n);return y.removed=r.removed,T},!1,!1,!0),y});};;if(window.DOMPurifyCopy) { window.DOMPurify = window.DOMPurifyCopy; window.DOMPurifyCopy = undefined; };;if(!window.ZSEC.Encoder) {!function(r){function e(r){for(var e=[],a=0;a<r.length;a++)e.push(r[a].charCodeAt(0));return e}var a={},t="34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams";t=t.split("|");for(var i=0;i<t.length;i++){var n=t[i].split("=");a[n[0]]=n[1]}var u={characterToEntityMap:a,IMMUNE_HTML:e(new Array(",",".","-","_"," ")),IMMUNE_HTMLATTR:e(new Array(",",".","-","_")),IMMUNE_CSS:e(new Array),IMMUNE_JAVASCRIPT:e(new Array(",",".","_"))};ZSEC.util.defineProperty(ZSEC,"Encoder",r(u),!0,!1,!1,!0)}(function(r){function e(r,e,a,t){if(null==e||void 0==e||"string"!=typeof e)return e;for(var i="",n=0;n<e.length;n++)if(t){var u=e.codePointAt(n);i+=a(r,u,t),u>65535&&n++}else i+=a(r,e.charCodeAt(n));return i}for(var a={},t=r.characterToEntityMap,i=[],n=0;n<255;n++)i[n]=n>=48&&n<=57||n>=65&&n<=90||n>=97&&n<=122?null:n.toString(16);var u=function(r){return r<256?i[r]:r.toString(16)},o=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCodePoint(e);var a=u(e);if(null==a)return String.fromCodePoint(e);if(e<=31&&"\t"!=e&&"\n"!=e&&"\r"!=e||e>=127&&e<=159||" "==e)return" ";var i=t[e];return null!=i?i+";":"&#x"+a+";"},l=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCharCode(e);if(null==u(e))return String.fromCharCode(e);var a=e.toString(16);if(e<256){var t="00".substr(a.length);return"\\x"+t+a.toUpperCase()}return"\\u"+(t="0000".substr(a.length))+a.toUpperCase()},c=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCodePoint(e);var a=u(e);return null==a?String.fromCodePoint(e):"\\"+a+" "};return a.encodeForHTML=function(a){return e(r.IMMUNE_HTML,a,o,!0)},a.encodeForHTMLAttribute=function(a){return e(r.IMMUNE_HTMLATTR,a,o,!0)},a.encodeForJavaScript=function(a){return e(r.IMMUNE_JAVASCRIPT,a,l,!1)},a.encodeForCSS=function(a){return e(r.IMMUNE_CSS,a,c,!0)},Object.freeze&&Object.freeze(a),a});};

/***/ }),

/***/ 10026946:
/*!*****************************************************************************!*\
  !*** ./node_modules/@slyte/component/src/compiler/cli/lyte-base-compile.js ***!
  \*****************************************************************************/
/***/ ((module) => {

// function BaseCompiler(){
    let Compile = {};
    Compile.regex = {
        get lyteTemplateType1() { return /if|for|switch/g },
        get getArrayArgRegex() { return /\[(?=([\s]*[\w-_.]+)([\(\[]))/g },
        get getArrayArgRegexCLI() { return /\[(?=([\s]*[\w-_]+)([\(\[]))/g },
        get matchInsideParentheses() { return /\(.*\)$/ },
        get startsAndEndWithNumber() { return /^[0-9]$/ },
        get matchInsideSquareBrackets() { return /\[.*\]/ },
        get getHelperRegex() { return /\((?:[^\)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/ },
        get matchAllEmptyCharacter() { return /\s/g },
        get endsWithCloseParantheses() { return /\)$/g },
        get startWithMustacheWithContent() { return /^{{(?=[\s]*[\w-_\(\$)]+)/ },
        get dynamicValueCheck() { return /[\w!@#\$%\^\&*\)\(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g },
        get validMustacheCheck() { return /{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/ },
        get mustacheCountCheck() { return /{{[a-zA-Z0-9_.\[\]\(\)]*(?![\\])}}/g },
        get validateArrayIndexing() { return /[a-zA-z0-9]*\[.*\]/g },
        get mustache() { return /{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g },
        get lyteTemplateType2() { return /(for|forIn|if|switch)$/ },
        get splitTextNodesMustache() { return /{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g },
        get tableTags() { return /^(TR|TD|TH|TBODY|THEAD|TFOOT)$/ },
        get tableTagsWithSelect() { return /^(SELECT|TR|TABLE|TBODY|THEAD|TFOOT)$/ },
        get eventListRegexFull() { return /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|ondragstart|ondrag|ondragenter|ondragleave|ondragover|ondrop|ondragend|onload|onunload|onabort|onerror|onscroll|onreset|onblur|onafterprint|onbeforeprint|ononbeforeunload|onerror|onhashchange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onstorage|onunload|oninput|oninvalid|onsearch|ononmousewheel|onwheel|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|onabort|oncanplay|oncanplaythrough|oncuechange|ondurationchange|onemptied|onended|onloadeddata|onloadedmetadata|onloadstart|onpause|onplay|onplaying|onprogress|onratechange|onseeked|onseeking|onstalled|onsuspend|ontimeupdate|onvolumechange|onwaiting|onpaste)$/ },
        get eventListRegexPart() { return /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu)$/ },
        get keyWordsRegex() { return /((const)|(continue)|(default)|(delete)|(do)|(else)|(enum)|(export)|(extends)|(finally)|(for)|(function)|(if)|(import)|(in)|(instanceof)|(new)|(return)|(super)|(switch)|(try)|(typeof)|(var)|(void)|(while)|(with))(?!\w)/g },
        get lyteHelperRegex() { return /__LyteHelper(\w*?)__/g },
        get tableElementRegex() { return /^(TBODY|THEAD|TFOOT)$/ },
        get getTransitionOrderRegex() { return /^f|fI|e|s|cD|cM|i|r|yield$/g },
        get getChildRegex() { return /^f|fI|e|s|cD|i|r|yield$/g },
        get startWithMustacheRegex() { return /^{{/ },
        get endWithMustacheRegex() { return /}}$/ },
        get baseCaseMustacheCheck() { return /{{.*}}/ },
        get commentedMustacheCheck() { return /\\{{.*}}/ }
    
    }
    Compile.getTrimmedContent = function(content, position, node) {
        let dummyContent = content;
        if(node) {
            position = [];
            let parentNode = node.parentNode;
            while(true) {
                position.$unshift(this.getArrayIndex(parentNode.childNodes,node));
                parentNode = parentNode.parentNode;
                node = node.parentNode;
                if(!parentNode) {
                    break;
                }
            }
        }
        for(let i=0;i<position.length;i++) {
            for(let j=content.childNodes.length-1;j>position[i];j--) {
                content.childNodes[j].remove();
            }
            content = content.childNodes[position[i]];
        }
        return dummyContent;
    }
    Compile.getArrayIndex = function(array,value) {
        for(let i=0;i<array.length;i++) {
            if(array[i] === value) {
                return i
            };
        }
    }

    Compile.splitMixedText = function(str,componentName,errors){
            // console.log("str",str);
        var stack = [],
        start = 0,
        flag = false,
        helper = {
            name: "concat",
            args: []
        };
        for (var i = 0; i < str.length; i++) {
            var j = i;
            if (str[i - 1] !== "\\" && str[i] === "{" && str[++i] === "{") {
                stack.push('{{');
                helper.args.push("'" + str.substr(start, j - start) + "'");
                start = i + 1;
            } else if (str[i] === "}" && str[++i] === "}" && stack.length) {
                stack.pop(start);
                var toPush = str.substr(start, j - start);
                if((toPush.startsWith("'") && toPush.endsWith("'")) || (toPush.startsWith('"') && toPush.endsWith('"'))){
                    console.warn("Rendering string value inside dynamic data (mustache) is depriciated","for the value ",toPush ,"on the attribute value ",str);
                }
                var actObj  =  this.getArray(toPush);  
                if(actObj && actObj == "timeoutError"){
                    errors.push(new Error("(LC:timeout8)Syntax error in node "+node.node+" for the value: "+" - "+node.text));
                    return;
                }else if(actObj === false){
                    errors.push(new Error("(LC:14)Syntax Error in node "+node.node+"for the value:"+node.text));
                    return;
                }
                if(actObj){
                    toPush = actObj;
                    helper.args.push({type:"sq",value:actObj});
                    flag = true;
                }
                if(!actObj){
                    actObj = this.getHelper(toPush);  
                    if(actObj){
                        if(actObj == "timeoutError"){
                            errors.push(new Error("(LC:timeout5)Syntax Error in node "+"  for : "+str));
                            return;
                        }
                        else if(actObj.name == "lbind"){
                            errors.push(new Error("(LC:lbind5) Syntax Error : lbind are not allowed with prepending or appending with texts "+" for : "+str));
                            return;
                        }
                        else if(actObj == "lbindError" || actObj.args == "lbindError"){
                            errors.push(new Error("(LC:lbind6)Syntax Error : lbind are not allowed inside helpers on node "+node.node+" for: "+ str));
                            return;
                        }
                        else if(actObj.name == "lbind" && node.tagName == "TEMPLATE"&& node.hasAttribute("is") && this.regex.lyteTemplateType1.test(node.attr.is)){
                            errors.push(new Error("(LC:lbind7)Syntax Error : lbind not allowed as value in if/for/switch node"+"for: "+str));
                            return;
                        }
                        
                        else if(actObj.name == "action"){
                            errors.push(new Error("(LC:9)Syntax Error : action are not allowed with prepending or appending with texts "+"for :"+str));
                            return;
                        }
                        else if(actObj.name == "method"){
                            errors.push(new Error("(LC:10)Syntax Error : method are not allowed with prepending or appending with texts "+"for :"+str));
                            return;
                        }
                        toPush = actObj;
                        if(!this.fromCLI && this.regex.getArrayArgRegex.test(toPush)){
                            flag = true;
                        }
                        helper.args.push({ type: "helper", value: toPush })
                        if (this.fromCLI) {
                            if (this.defaultImpDetails.helpers.indexOf(actObj.name) == -1 && this.defaultHelpers.indexOf(actObj.name) == -1) {
                                this.defaultImpDetails.helpers.push(actObj.name);
                            }
                            this.getImportedHelpers(actObj.args, this.defaultImpDetails.helpers);
                        }
                    }
                    else if(actObj === false){
                        errors.push(new Error("(LC:13)Syntax error in node "+node.node+" for the attribute:"+node.attributes[x].nodeName+"- "+node.attributes[x].text));
                        return;
                    }
                    else{
                        if((toPush.startsWith("'") && toPush.endsWith("'")) || (toPush.startsWith('"') && toPush.endsWith('"'))){
                            console.warn("Rendering string value inside dynamic data (mustache) is depriciated","for the value ",toPush ,"on the attribute value ",str);
                        }
                        helper.args.push(toPush);
                    }
                    if(this.fromCLI){
                        start = i + 1;  
                    }
                }
                if (!this.fromCLI) {
                    start = i + 1;//checkWithMentor 3055 it should come up one step
                }
                // var actObj = getHelper(toPush, componentName);
                // if (actObj) {
                //     toPush = actObj;
                //     helper.args.push({
                //         type: "helper",
                //         value: toPush
                //     });
                // } else {
                //     helper.args.push(toPush);
                // }
                // start = i + 1;
            }

        }
        if (start < str.length) {
            helper.args.push("'" + str.substr(start, str.length - start) + "'");
        }
        if (flag) {
            helper._t = "hq";
            return helper;
        }
        else {
            return helper;
        }
    }

    Compile.getHelper = function(dynamicValue) {
        let helperValue = this.regex.getHelperRegex.exec(dynamicValue);
        if(helperValue){
            let actObj = this.getHelperInfo(dynamicValue,helperValue);
            if(this.regex.getArrayArgRegex.test(dynamicValue)){
                actObj._t = 'hq';
            }
            // actObj._importHelperArray = importHelperArray;
            return actObj;
        }
        return undefined;
    }
    

    Compile.getHelperInfo = function(dynamicValue, helperValue){
        let helperFunc = {};
        helperFunc.name = dynamicValue.substr(0, helperValue.index).replace(this.regex.matchAllEmptyCharacter, '');
        helperValue = (helperValue) ? helperValue[0].trim() : helperValue;
        let args = this.getHelperArgs(helperValue.substr(1,helperValue.length-2));
        if(helperFunc.name == "lyteViewPort" && helperValue == "()"){
            helperFunc.args = [];
            return helperFunc;
        }
        if (args === false) {
            return false;
        }
        helperFunc.args = args;
        return helperFunc;
    }

    Compile.getHelperArgs = function(str){
        let stack = [],
        escapeQuote = false,
        stringStarted = false,
        bracketStack = [],
         args = [],
          from = 0;
        let lastPushed;
        for(let i=0; i<str.length; i++){
            if(!stack.length && str.charAt(i) === ","){
                let toPush = str.substr(from,i-from);
                toPush = toPush.trim();
                if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
                    toPush = toPush.slice(1,-1);
                    toPush = "'" + toPush + "'";
                }
                try{
                    toPush = this.getHelperArgValue(toPush);
                }
                catch(err){
                    console.log("errr",err);
                    if(err.message == "lbindError"){
                        return "lbindError"
                    }
                }
                args.push(toPush);
                from = i + 1;
            }
            else if(!bracketStack.length && stringStarted && str.charAt(i) === "\\" && /\\|\'|\"/g.test(str.charAt(i+1))){
                str = str.substr(0,i)  + str.substr(i+1,str.length);
            }
            else if(str.charAt(i) === "\\" && /\\/g.test(str.charAt(i+1))){
                // str = str.substr(0,i)  + str.substr(i+1,str.length);
                // continue;
                i++;
            }
            else if(str.charAt(i) === "\\" && /\'|\"/g.test(str.charAt(i+1))){
                escapeQuote = true
            }
            else if(str.charAt(i) === "("){
                if(stack[stack.length - 1] != "'" && stack[stack.length - 1] != "\""){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    bracketStack.push("(");
                }
            }
            else if(str.charAt(i) === ")"){
                if(stack[stack.length-1] === "("){
                    stack.pop();
                    bracketStack.pop();
                }
            }
            else if(str.charAt(i) === "'"){// && str.charAt(i-1) !== "\\"
                if(escapeQuote){
                    escapeQuote = false;
                    continue;
                }
                else if(stack[stack.length-1] === "'"){
                    stringStarted = false
                    stack.pop();
                }
                else if(stack[stack.length-1] !== "\""){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    stringStarted = true;
                }
            }
            else if(str.charAt(i) === "\""){// && str.charAt(i-1) !== "\\"
                if(escapeQuote){
                    escapeQuote = false;
                    continue;
                }
                else if(stack[stack.length-1] === "\""){
                    stringStarted = false
                    stack.pop();
    //                  str.replaceAt(i, "'");
                }
                else if(stack[stack.length-1] !== "'"){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    stringStarted = true;
    //                  str.replaceAt(i, "'");
                }
            }
        }
        if (stack.length) {
            return false;
        }
        let toPush = str.substr(from, str.length - from);
        toPush = toPush.trim();
        if (toPush && toPush.startsWith("\"") && toPush.endsWith("\"")) {
            toPush = toPush.slice(1, -1);
            toPush = "'" + toPush + "'";
        }
        try{
            toPush = this.getHelperArgValue(toPush);
        }
        catch(err){
            console.log("errr",err);
            if(err.message == "lbindError"){
                return "lbindError"
            }
            return false;
        }
        args.push(toPush);
        return args;
    }
    
    Compile.getHelperArgValue = function(argValue) {
        switch (argValue) {
            case "undefined":
                return undefined
            case "true":
                return true;
            case "false":
                return false;
            case "null":
                return null;
            case "":
                return undefined;
            default:
                if (argValue && argValue.startsWith("'") && argValue.endsWith("'")) {
                    return (this.fromCLI)?this.decodeHtmlEntities.decode(argValue):argValue;
                }else if(this.fromCLI && this.regex.getArrayArgRegexCLI.test(argValue) && !this.regex.endsWithCloseParantheses.test(argValue)){// //array //if array inside helepr or array inside array it should work/\w+\[.*\]/g
                    let arg = this.getArrayArg(argValue);
                    return arg.args[0];
                } 
                else if(!this.fromCLI && this.regex.getArrayArgRegex.test(argValue) && !this.regex.endsWithCloseParantheses.test(argValue)){
                    let arg = this.getArrayArg(argValue);
                    return arg.args[0];
                }
                else if(/\([\w\s,')(]*/.test(argValue)) {
                    let arg = this.getHelper(argValue);
                    if(arg === false){
                        throw new Error(argValue);
                    }
                    if(arg.name == "lbind"){
                        throw new Error("lbindError");
                    }
                    return {"type" : "helper" , "value" : arg}
                } else if (!isNaN(argValue)) {
                    return parseInt(argValue);
                } else {
                    return argValue;
                }
        }
    }
    Compile.getMustache = function(value,componentName,syn){
        value=(value && typeof value === "string") ? value.trim() : value;
            if(this.regex.startWithMustacheWithContent.test(value)){
            let arr = value.match(this.regex.mustacheCountCheck);
                if(arr && arr.length > 1){
                    console.log("length>1",value)
                    return undefined;
                }
                // console.log(value);
                if(syn && !syn.bool){
                    console.log("syntax error",syn)
                    return {bool:false,err:syn.err};
                }
                if(!this.regex.validMustacheCheck.test(value)){
                    return undefined;
                }
                let dynamic = value.match(this.regex.dynamicValueCheck); // /* */
                if(dynamic && dynamic.length > 1){
                    return undefined;
                }
                else{
                    dynamic = (dynamic) ? dynamic[0].trim(): dynamic;                
                }
                // console.log("dynamic value before returning ", dynamic);
                return dynamic;
            }
            return undefined;
    }
    Compile.syntaxCheckWorkerNew = function(val){
        var parsingMustache;
        var retObj = {
            "mustache":0,
            bool : true,
            err : null
        }
        for(let i=0;i<val.length;i++){
            if(parsingMustache){
                if(val[i] == "\\"){
                    i=i+1;
                }
                else if(val[i] == "'"){
                    if(lastString != '"'){//val[i-1] != "\\"  && 
                        if(!stringStarted){
                            stringStarted = true;
                            lastString = "'";
                        }else{
                            stringStarted = false;
                            lastString = undefined;
                        }
                    }               
                }
                else if(val[i] == '"'){
                    if(lastString != "'"){//val[i-1] != "\\" &&
                        if(!stringStarted){
                            stringStarted = true;
                            lastString = '"'
                        }else{
                            stringStarted = false;
                            lastString = undefined;
                        }
                    }
                }
                else if(val[i] == "{" && !stringStarted){
                    retObj.bool = false;
                    retObj.err = " unexpected '{' bracket ";
                    return retObj;
                }
                else if(val[i] == "{" && stringStarted && val[i-1] == "{"){
                    retObj.mustache ++;
                }
                else if(val[i] == "}" && val[i-1] == "}" && !stringStarted){
                    if(curlyBracket.length){
                        retObj.bool = false;
                        retObj.err = " error unmatched '(' bracket ";
                        return retObj;
                    }
                    if(squareBracket.length){
                        retObj.bool = false;
                        retObj.err = " unmatched '['bracket ";
                        return retObj;
                    }
                    parsingMustache = false;
                }
                else if(val[i] == "[" && !stringStarted){
                    squareBracket.$push("[");
                }
                else if(val[i] == "]" && !stringStarted){
                    if(squareBracket.length){
                        squareBracket.$pop();
                    }else{
                        retObj.bool = false;
                        retObj.err = " unmatched ']' bracket ";
                        return retObj;
                    }
                }
                else if(val[i] == "(" && !stringStarted){
                    curlyBracket.$push('(');
                }
                else if(val[i] == ")" && !stringStarted){
                    if(curlyBracket.length){
                        curlyBracket.$pop();
                    }else{
                        retObj.bool = false;
                        retObj.err = " unmatched ')' bracket "; 
                        return retObj;
                    }
                }
            }    
            else if((val[i] == "{" && val[i-1] == "{" && val[i-2] != "\\")){
                //start parsing
                var curlyBracket =[] ,squareBracket =[] ,stringStarted ,lastString;
                var parsingMustache = true;
            }
        }
        if(parsingMustache){
            retObj.bool = false;
            retObj.err = " unmatched '{' bracket";
            return retObj;
        }
        return retObj;
    }
    Compile.getArray = function(mustacheVal){
        // becomses true if it is arr[arr[0]] or arr[helper()]
        if(this.regex.getArrayArgRegex.test(mustacheVal) && !this.regex.endsWithCloseParantheses.test(mustacheVal)){
            let arg = this.getArrayArg(mustacheVal);
            if(arg && arg.args[0]){
                arg.args[0].value._t = "sq";
                return arg.args[0].value;
            }else{
                return false;
            }
        }
    }
    Compile.splitMultiDimensionArray = function(val,arrayExtra){
        var openSq = 0,openSqPos = 0,lastString,stringStarted,openSPos,resultStack = [],extra = false,extraPos;
        for(var i=0 ; i<val.length;i++){
            if(val[i] == "\\"){
                i=i+1;
            }
            else if(val[i] == "'"){
                if(lastString != '"'){//val[i-1] != "\\"  &&
                    if(!stringStarted){
                        stringStarted = true;
                        lastString = "'";
                    }else{
                        stringStarted = false;
                        lastString = undefined;
                    }
                }               
            }
            else if(val[i] == '"'){
                if(lastString != "'"){//val[i-1] != "\\" &&
                    if(!stringStarted){
                        stringStarted = true;
                        lastString = '"'
                    }else{
                        stringStarted = false;
                        lastString = undefined;
                    }
                }
            }
            else if(val[i] == "[" && !stringStarted){
                openSq = openSq + 1;
                if(openSq == 1){
                    openSqPos = i;
                }
            }
            else if(val[i] == "]" && !stringStarted){
                openSq = openSq - 1;
                if(!extra && openSq == 0){
                    resultStack.push(val.substring(openSqPos+1,i));//need to handlw []
                    openSq = 0;
                    if(val[i+1]=='.'){
                        extra = true;
                        extraPos = i+1;
                    }
                }
            }
        }
        if(extra){
            arrayExtra.push(val.substring(extraPos,i));//need to handlw []
        }
        return resultStack;
    }
    Compile.getArrayArg = function(argStr){
        //argStr may be 0 or '0' or 'abc' or a() or a[] or a(b[]) or a[b()]
        // var arg = {"type":"sq","value":{"args":[],"name":""}},arrayName;
        if(this.regex.matchInsideParentheses.test(argStr)){
            //if arr comes inside helper
            let arg = this.getHelper(argStr);  
            if(arg === false){
                return false;
            };
            return {"args":[{ "type": "helper", "value": arg }]}
        }
        else if(this.regex.validateArrayIndexing.test(argStr)){
            let arg = {'args':[]}, ret = [], temp,arrayExtra=[],retNew = [];
            let arrayArg = this.regex.matchInsideSquareBrackets.exec(argStr);
            let arrayName = argStr.substr(0,arrayArg.index);
            // arrayArg = arrayArg[0];
            //splitting multi dimensional array a[one][two][three] into array
            var arr = this.splitMultiDimensionArray(argStr, arrayExtra);
            for(var i=0; i<arr.length; i++){
                if(this.regex.getArrayArgRegex.test(arr[i]) || this.regex.matchInsideParentheses.test(arr[i])){
                    temp = this.getArrayArg(arr[i]);
                    ret.push(temp.args[0]);
                }
                else{
                    ret.push(arr[i])
                }
            }
            for(var i=0; i<arrayExtra.length; i++){
                if(this.regex.getArrayArgRegex.test(arrayExtra[i])){
                    temp = this.getArrayArg(arrayExtra[i]);
                    retNew.push(temp.args[0])
                }else{
                    retNew.push(arrayExtra[i])
                }
            }
            ret.forEach(function(item,index){
                if (item && item && typeof item == "string" && item.startsWith("\"") && item.endsWith("\"")) {
                    item = item.slice(1, -1);
                    item = "'" + item + "'";
                }else if(typeof item == "string" && Compile.regex.startsAndEndWithNumber.test(item)){
                    item = "'" + item + "'";
                }
                arg.args.push(item)
            })
            arg.name = arrayName;
            if(retNew && retNew.length > 0){
                arg.extra = retNew;
            }
            return {"args":[{"type" : "sq" , "value" : arg}]};
        } 
    }
    Compile.getDV = function(value){
        var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
        for(var i=0;i<value.length;i++){
            if(value[i] === "."){
                if(data.length){
                    ref.$push(data);
                }
                data = "";
                continue;
            }
            else if(value[i] === "["){
                arrayStack.$push(i)
                if(data.length){
                    ref.$push(data);
                }
                while(value[i+1] === "\s"){
                    i++;
                }
                if(value[i+1] === "\"" || value[i+1] === "'"){
                    strStack.$push(value[i+1]);
                    strLast = value[i+1];
                    i++;
                }
                else if(arr.length){
                    ref.$push([]);
                    refStack.$push(ref);
                    ref = ref[ref.length-1];
                }else{
                    arr.$push([]);
                    refStack.$push(ref);
                    ref = arr[arr.length-1];
                }
                data = "";
                continue;
            }
            else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
                while(value[i] === "\s" && value[i] != "]"){
                    i++;
                }
                strStack.$pop();
                str = true;
            }
            if(value[i] === "]"){
                arrayStack.$pop();
                if(data.length){
                    if(str === true){
                        ref.$push(data);    
                    }
                    else if(!isNaN(parseInt(data))){
                        if(refStack.length){
                            ref = refStack.$pop();
                            if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
                                ref.$pop();
                            }
                            ref.$push(data);
                            if(!arrayStack.length && arr.length){
                                arr.$shift();
                            }
                        }
                    }
                    else{
                        ref.$push(data);
                    }
                }
                if(!arrayStack.length && arr.length){
                    result.$push(arr.$shift());
                    ref = result;
                }
                else if(refStack.length && !arr.length){ 
                    ref = refStack.$pop();
                }
                data = "";
                str = "";
                continue;
            }
            data = data.concat(value[i]);
        }
        if(data.length){
            result.$push(data);
        }
        if(strStack.length || arrayStack.length){
            console.log("check the syntax",strStack,arrayStack);
        }
        return result;
    }
    // return Compile;
// }

if(  true && typeof module.exports === "object" ) {
    module.exports = Compile;
}else{
    window.BaseCompiler = Compile;
}
// BaseCompiler();


/***/ }),

/***/ 81800751:
/*!*************************************************************!*\
  !*** ./node_modules/@slyte/component/src/lyte-component.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component),
/* harmony export */   "ComponentRegistry": () => (/* binding */ ComponentRegistry),
/* harmony export */   "Helper": () => (/* binding */ Helper),
/* harmony export */   "LyteCustomElement": () => (/* binding */ LyteCustomElement),
/* harmony export */   "RawComponent": () => (/* binding */ RawComponent),
/* harmony export */   "_LC": () => (/* binding */ _LC),
/* harmony export */   "appendChild": () => (/* binding */ appendChild),
/* harmony export */   "arrayUtils": () => (/* binding */ arrayUtils),
/* harmony export */   "customElementPrototype": () => (/* binding */ customElementPrototype),
/* harmony export */   "defProp": () => (/* binding */ defProp),
/* harmony export */   "insertAfter": () => (/* binding */ insertAfter),
/* harmony export */   "insertBefore": () => (/* binding */ insertBeforeFn),
/* harmony export */   "objectUtils": () => (/* binding */ objectUtils),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "replaceWith": () => (/* binding */ replaceWith),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "shouldIgnoreDisconnect": () => (/* binding */ shouldIgnoreDisconnect)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @slyte/core */ 53501236);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @slyte/core */ 36329437);
/* harmony import */ var _slyte_core_src_JsonPath_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @slyte/core/src/JsonPath.js */ 38345401);
/* harmony import */ var _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compiler/cli/lyte-base-compile.js */ 10026946);
/* harmony import */ var _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _ZohoSecurity_lyte_component_security_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ZohoSecurity/lyte-component-security.js */ 93521699);
/* harmony import */ var _ZohoSecurity_lyte_component_security_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ZohoSecurity_lyte_component_security_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _slyte_data_src_dberror_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @slyte/data/src/dberror.js */ 67992299);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/service */ 10723535);
/* harmony import */ var _slyte_data_src_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @slyte/data/src/utils */ 67921756);
/* harmony import */ var _slyte_core_src_Utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @slyte/core/src/Utils.js */ 90502503);
/* harmony import */ var _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/lyte-errors.js */ 22296759);
// debugger




 //slicer af
 //slicer store



//@Slicer.developmentStart

//@Slicer.developmentEnd
if(!window.__lyteConfig){
    window.__lyteConfig = {
        _definedBeforeBridging : [],
        _alreadyDefinedBeforeBridging : [],
        v4 : true
    }
}
window.__lyteConfig.v4 = true;
let ltCf = window.__lyteConfig;
if(!ltCf.customElementsDefine){
    ltCf.customElementsDefine = customElements.constructor.prototype.define; 
    Object.defineProperty(customElements.constructor.prototype,"define",{
        value : function(name, compClass, options, _lyteOptions){
            if(customElements.get(name)){
                ltCf._alreadyDefinedBeforeBridging.push({name : name, compClass : compClass, options : options, _lyteOptions : _lyteOptions, scope : this});
            }else{
                ltCf._definedBeforeBridging.push({name : name, compClass : compClass, options : options ,_lyteOptions : _lyteOptions, scope : this});
                ltCf.customElementsDefine.apply(this,arguments);
            }
        },
        enumerable: false
    })
}
/*convert to custom class*/
class ComponentRegistry extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__.Service {
    isComponentRegistry(){
        return true;
    }
    getDirectiveObj(){
        if(this._directive){
            return this._directive;
        }
        return false;
    }
    static getFastObj(){
        return this.turbo ? this.turbo : false;
    }
    constructor(opt){
        super(opt);
        var registryClass = this.constructor;
        if(!registryClass._registered){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC001", registryClass.name);
            //@Slicer.developmentEnd
            return;
        }
        // //@Slicer.afzalStart
        // console.log("aaffff")
        // //@Slicer.$afzalEnd
        /* registering component in app module - for router */
        let app = _LC.getNearestParentApp(this);
        app.$.modules.triggerEvent("add", "component", this);
        if(_LC.getDefaultRegistry() == registryClass){
            //set default registry instance and it can be overrided with app's getRegistryInstance.
            _LC.setDefaultRegistryIns(this)
        }
        registryClass._instanciated = true;
        this.registeredComponents = {};
        this.registeredCeComponents = {}
        this._registeredComponents = {};
        this._registeredCeComponents = {};
        this._defaultDirectives = [];
        this.registeredDirectives = [];
        this._registeredDirectivesClass = {};
        ComponentRegistry.registerAllComponent(registryClass._registeredComponentClass,this);
        ComponentRegistry.registerAllCeComponent(registryClass._registeredCeComponentClass,this);
        registryClass._instanceList.push(this);
        _LC.setAddedRegistries(this,registryClass.name);
        this.render = _LC.render;     
        // this.renderHTML = _LC.renderHTML;
        this.set = _LC.set;
        this.get = _LC.get;
        let currentAppOrAddon = _LC.getAppOrAddon(this);
        this.setDefaultDirectives(currentAppOrAddon);
        _LC.updateDomApis(this);
        this.replaceWith = _LC.replaceWith;
        this.throwEvent = _LC.throwEvent;
        this.chI = _LC.chI;
        this.chromeBugFix = _LC.chromeBugFix;
        this.lyteComponentsDiv = _LC.lyteComponentsDiv;
        this.String = _LC.String;
        this.addAction = _LC.addAction;
        this.getLyteComponentsDiv = function(){
            return _LC.getComponentsDiv(_LC.lyteComponentsDiv,registryClass.name);
        }
        this._getLyteComponent = function(){
            return _LC;
        }
    }
    setDefaultDirectives(app){ 
        let defaultDirectives = ["directive","shadow","shadow-style","shadow-supported","turbo","turbo-supported","unbound","view"];
        let self = this;
        defaultDirectives.forEach(function(item){
            let directiveIns;
            if(self.constructor[item]){
                app.scopedInstance(self.constructor[item],[self],function(ins){
                    directiveIns = ins;
                },[])
                self["_"+item] = directiveIns;
            }
            self._defaultDirectives.push(item);
        })
    }
    static register(options){
        if(options){
            if(options.app == true){
                _LC.setDefaultRegistry(this);
            }
            if(options.hash){
                this._hash = options.hash;
            }
            if(options.refHash){
                this._refHash = options.refHash;
            }
        }
        this._registeredComponentClass = Object.assign({},ComponentRegistry._defaultComponents);
        this._registeredCeComponentClass = Object.assign({},ComponentRegistry._defaultCeComponents);
        this._registered = true;
        this.prototype.registeredHelpers = Object.assign({},ComponentRegistry._defaultHelpers,this._beforeRegisteredHelpers ? this._beforeRegisteredHelpers : {});
        this.registeredHelpers = this.prototype.registeredHelpers;
        this.appendChild = _LC.appendChild;//because of ui comps
        this.insertAfter = _LC.insertAfter;
        this.insertBefore = _LC.insertBefore;
        this.replaceWith = _LC.replaceWith;
        this.shouldIgnoreDisconnect = _LC.shouldIgnoreDisconnect;
        this._beforeRegisteredHelpers = {};
        this._instanceList = [];
        var registryClassDef = this;
        ComponentRegistry._registeredRegistries.push({
            name : registryClassDef.name,
            class : registryClassDef
        });
        if((_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().needDummyComponentsDiv)){
            _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,this.name);
        }
        _LC.setComponentsDiv(_LC.lyteComponentsDiv,this.name);
        if(registryClassDef.idePlugins){
            registryClassDef.idePlugins.forEach(function(plugin){
                plugin(_LC)
            })
        }
        if(this.arrayOverride){
            _LC.arrayOverride();
        }
        let lazyDir = this._lazyRegisterDirectives;
        if(lazyDir){
            for(let key in lazyDir){
                this[key] = lazyDir[key];
                _LC.updateDirectivesInReg(ComponentRegistry, lazyDir[key], key);
            }
        }
        // if(registryClassDef.Compile.needDummyComponentsDiv){
        //     _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,this.name);
        // }
        /*convert to custom class*/
        this.Component = (function() {
            class newC extends ComponentRegistry._componentApis {
                constructor(){
                    super();
                }
                static register(compName){
                    compName = compName || _LC.String.dasherize(this.name);
                    this._registryClass = registryClassDef;
                    registryClassDef.registerComponent(compName, this);
                }
                static unregisterComponent(){
                    _LC.unregisterComponent.apply(this,arguments);
                }
            }newC.__lMod = "Component";newC._registryClass = registryClassDef;newC._render = function(){
                return _LC._render.apply(this,arguments);
            };
            return newC;
        })();
        this.registerDirective = function(name,directiveClass){
            var registry = this;
            if(registry._directivesList[name]){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC002", "Directive", name, registry.name);
                //@Slicer.developmentEnd
                return;
            }
            registry._directivesList[name] = directiveClass;
            directiveClass._registryClass = registry;
            if(registry._instanciated){
                registry._instanceList.forEach(function(ins){
                    directiveClass.actualRegistration(name,directiveClass,ins);
                })
            }
        }
        /*convert to custom class*/
        this.CustomElements = (function() {
            class newCE extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__.Service {
                constructor(){
                    super();
                }
                static register(compName){
                    compName = compName || _LC.String.dasherize(this.name);
                    this._registryClass = registryClassDef;
                    registryClassDef.registerCeComponent(compName, this, this.options);
                }
            }newCE._registryClass = registryClassDef;
            return newCE;
        })();
    }
    static registerCeComponent(name,CompClass, options){
        var registry = this;
        if(registry._registeredCeComponentClass[name]){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC002", "Raw Component", name, registry.name);
            //@Slicer.developmentEnd
            return;
        }
        CompClass.activeInstances = 0;
        registry._registeredCeComponentClass[name] = CompClass;//af move below
        CompClass._compName = name;
        CompClass._options = options;
        if(registry._instanciated){
            registry._instanceList.forEach(function(ins){
                registry.registerAllCeComponent({[name] : CompClass},ins);
            })
        }
    }
    static registerComponent(name,CompClass){
        var registry = this;
        if(registry._registeredComponentClass[name] && registry._reRegisteredComponents.indexOf(name) == -1){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC002", "Component", name, registry.name);
            //@Slicer.developmentEnd
            return;
        }
        CompClass.activeInstances = 0;
        registry._registeredComponentClass[name] = CompClass;//af move below
        CompClass._compName = name;
        if(registry._instanciated){
            registry._instanceList.forEach(function(ins){
                registry.registerAllComponent({[name] : CompClass},ins);
            })
        }
    }
    static unregisterComponent(){
        _LC.unregisterComponent.apply(this,arguments);
    }
    static registerHelper(name,helper){
        //@Slicer.developmentStart
        if(ComponentRegistry._defaultHelpers[name]){    
            console.warn("Deprecated : Default helpers of Lyte can't be overrided - " + name + "");
        }else if(this._registered && this.prototype.registeredHelpers[name] || this._beforeRegisteredHelpers && this._beforeRegisteredHelpers[name]){
            console.warn("Deprecated : Helper named - " + name + " is already registered");
        }
        //@Slicer.developmentEnd
        if(this._registered){
            this.prototype.registeredHelpers[name] = helper;
        }else if(this._beforeRegisteredHelpers){
            this._beforeRegisteredHelpers[name] = helper;
        }else{
            this._beforeRegisteredHelpers = {[name] : helper};
        }
    }
    static registerCustomPropHandler(){
        _LC.registerCustomPropHandler.apply(this,arguments);
    }
}
ComponentRegistry.__lMod = "ComponentRegistry";
ComponentRegistry._registeredRegistries = [];
ComponentRegistry._definedComponents = {};
ComponentRegistry._definedCeComponents = {};
ComponentRegistry._registeredCommonClass = {};
ComponentRegistry._registeredCommonCeClass = {};
ComponentRegistry.customPropHandlers = [];
ComponentRegistry.customPropRegex = "";
ComponentRegistry._defaultHelpers = {};
ComponentRegistry._defaultComponents = {};
ComponentRegistry._defaultCeComponents = {};
ComponentRegistry.globalComponents = ["lyte-event-listener","import-shadow-style"];
ComponentRegistry._unRegisteredComponents = [];
ComponentRegistry._reRegisteredComponents = [];
ComponentRegistry._directivesList = {};
ComponentRegistry._registeredDirectivesClass = {};
ComponentRegistry._lazyRegisterDirectives = {};
ComponentRegistry._preLoadedDirectives = {};
/*convert to custom class*/
ComponentRegistry._componentApis = (function() {
    class apis extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__.Service {
        constructor(){
            super();
            this.$ = {
                validate : function(){
                    return _LC.validate.apply(this, arguments);
                },
                _ins : this
            }
        }
        set(){
            return _LC.componentSet.apply(this, arguments);
        }
        get(){
            return _LC.componentGet.apply(this, arguments);
        }
        throwEvent(){
            return _LC.throwEvent.apply(this, arguments);
        }
        executeMethod(){
            return _LC.executeMethod.apply(this, arguments);
        }
        getData(){
            return _LC.componentGetData.apply(this, arguments);
        }
        setData(){
            return _LC.componentSetData.apply(this, arguments);
        }
        getMethods(){
            return _LC.componentGetMethods.apply(this, arguments);
        }
        setMethods(){
            return _LC.componentSetMethods.apply(this, arguments);
        }
        hasAction(){
            return _LC.componentHasAction.apply(this, arguments);
        }
        getActions(){
            return _LC.componentGetActions.apply(this, arguments);
        }
        getObservers(){
            return _LC.componentGetObservers.apply(this, arguments);
        }
        getApp(){
            return _LC.getApp.apply(this, arguments);
        }
        getAppOrAddon(){
            return _LC.getAppOrAddon.apply(this, arguments);
        }
    }
    return apis;
})();
ComponentRegistry.registerAllComponent = function(compClassList, registryInstance) {
    for(var compName in compClassList){
        let compClass = compClassList[compName];
        // if (registryInstance.constructor._reRegisteredComponents.indexOf(compName) == -1 && registryInstance.registeredComponents[compName]) {
        //     _Lyte.error("Component " + componentName + " already registered");
        //     return;
        // }
    if (registryInstance.constructor._definedComponents[compName] && registryInstance.constructor._reRegisteredComponents.indexOf(compName) == -1 && !registryInstance.constructor._unRegisteredComponents[compName]) {
            //same component class for same reigstry which has multiple registry instance
            registryInstance.registeredComponents[compName] = true;
            continue;
        }
        compClass._compName = compName;
        compClass._data = compClass.prototype.data;
        compClass._actions = compClass.actions();
        compClass._methods = compClass.methods();
        compClass.__observers = _LC.executeObservers(compClass);
        compClass.addRegistries = compClass.prototype.addRegistries;
        if(compClass._dynamicNodes && compClass._dynamicNodes.length && compClass._dynamicNodes[compClass._dynamicNodes.length-1].type == "dc"){
            compClass.dc = compClass._dynamicNodes.$pop();
        }
        compClass._callBacks = {};
        compClass._observers = [];
        _LC.updateCustomCrmComponent(compClass);
        compClass._observedMethodAttributes = compClass._observedMethodAttributes || {};
        _LC.registerComponent(compName, compClass,registryInstance);
        registryInstance.registeredComponents[compName] = true;
        registryInstance._registeredComponents[compName] = compClass;
    }
};
ComponentRegistry.registerAllCeComponent = function(compClassList, registryInstance) {
    for(var compName in compClassList){
        let compClass = compClassList[compName];
        if (registryInstance.constructor._definedCeComponents[compName]) {
            //same component class for same reigstry which has multiple registry instance
            registryInstance.registeredComponents[compName] = true;
            continue;
        }
        compClass._compName = compName;
        compClass.addRegistries = compClass.prototype.addRegistries;
        _LC.registerCeComponent(compName, compClass,registryInstance);
        registryInstance.registeredCeComponents[compName] = true;
        registryInstance._registeredCeComponents[compName] = compClass;
    }
};
/*convert to custom class*/
ComponentRegistry.Component = (function() {
    class newC extends ComponentRegistry._componentApis {
        constructor(){
            super();
        }
        static register(compName){
            compName = compName || _LC.String.dasherize(this.name);
            if(ComponentRegistry.globalComponents.indexOf(compName) != -1){
                let compClass = this;
                compClass._registryClass = ComponentRegistry;
                ComponentRegistry._defaultComponents[compName] = compClass;
                compClass._compName = compName;
                compClass.activeInstances = 0;   
                ComponentRegistry._registeredRegistries.forEach(function(reg){
                    let registry = reg.class;
                    registry._registeredComponentClass[compName] = compClass;
                    if(registry._instanciated){
                        registry._instanceList.forEach(function(ins){
                            registry.registerAllComponent({[compName] : compClass},ins);
                        })
                    }
                })
            }
            //@Slicer.developmentStart
            else{
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC003" , compName);
            }
            //@Slicer.developmentEnd
        }
    }newC.__lMod = "Component";newC._registryClass = ComponentRegistry;
    return newC;
})();
ComponentRegistry.addFakeDirective = function(baseClass,name){
    this._lazyRegisterDirectives[name] = baseClass;
    this[name] = baseClass;
    _LC.updateDirectivesInReg(this,baseClass,name);
};
/*convert to custom class*/
class Component extends ComponentRegistry._componentApis {
    constructor(){
        super();
    }
    // static _registryClass = registryClassDef;
    static register(compName, options){
        var _registryClass = _LC.getRegistryClass(options);
        if(!_registryClass){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC004", "Component", compName)
            //@Slicer.developmentEnd
            return
        }
        this._refHash = options.refHash
        compName = compName || _LC.String.dasherize(this.name);
        this._registryClass = _registryClass;
        _registryClass.registerComponent(compName, this);
    }
    static unregisterComponent(){
        _LC.unregisterComponent.apply(this,arguments);
    }
}
Component.__lMod = "Component";
Component._render = function(){
    return _LC._render.apply(this,arguments);
};
/*convert to custom class*/
class RawComponent extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__.Service {
    constructor(){
        super();
    }
    // static _registryClass = registryClassDef;
    static register(compName, options){
        var _registryClass = _LC.getRegistryClass(options);
        if(!_registryClass){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC004", "Raw Component", compName)
            //@Slicer.developmentEnd
            return;
        }
        this._refHash = options.refHash
        compName = compName || _LC.String.dasherize(this.name);
        this._registryClass = _registryClass;
        _registryClass.registerCeComponent(compName, this, this.options);
    }
}
RawComponent.__lMod = "RawComponent";
class Helper {
    static register(name, helper, options){
        var _registryClass = _LC.getRegistryClass(options);
        if(!_registryClass){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC004", "Helper", name)
            //@Slicer.developmentEnd
            return;
        }
        helper._hash = options.hash;
        helper._refHash = options.refHash;
        //@Slicer.developmentStart
        if(ComponentRegistry._defaultHelpers[name]){    
            console.warn("Deprecated : Default helpers of Lyte can't be overrided - " + name + "");
        }else if(_registryClass._registered && _registryClass.prototype.registeredHelpers[name] || _registryClass._beforeRegisteredHelpers && _registryClass._beforeRegisteredHelpers[name]){
            console.warn("Deprecated : Helper named - " + name + " is already registered");
        }
        //@Slicer.developmentEnd
        if(_registryClass._registered){
            _registryClass.prototype.registeredHelpers[name] = helper;
        }else if(_registryClass._beforeRegisteredHelpers){
            _registryClass._beforeRegisteredHelpers[name] = helper;
        }else{
            _registryClass._beforeRegisteredHelpers = {[name] : helper};
        }
    }
}
Helper.__lMod = "Helper";
function arrayUtils(){
    return _LC.aF.apply(_LC, arguments);
}
function objectUtils(){
    return _LC.oF.apply(_LC, arguments);
}
function set(){
    return _LC.set.apply(_LC.String, arguments);
}
ComponentRegistry._registeredComponentClass = {};
ComponentRegistry._registeredCeComponentClass = {};
// ComponentRegistry.Compile = Compile;
let orgArrFns = ["push", "pop", "splice", "shift", "unshift", "concat"];
for(let i=0; i<orgArrFns.length; i++){
    let arrFnName = orgArrFns[i];
    // Array.prototype["$"+orgArrFns[i]] = Array.prototype[orgArrFns[i]]
    Object.defineProperty(Array.prototype, "$"+arrFnName, {
        enumerable: false, 
        value : Array.prototype[arrFnName]
    })
}
var _LC = {
    validateRenderData : function(data){
        //@Slicer.developmentStart
        if( !(data === undefined || data === null || (typeof data == "object" && !Array.isArray(data)) ) ){
            _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Invalid data passed to render the component from route.");
            // return false;
        }
        //@Slicer.developmentEnd
        return true;
    },
    _render : function(object){
        let compClass = this;
        ltCf.fromV4Render = true;
        let oldLyteV4 = ltCf.lyteV4;
        let outlet = object.outlet;
        let registryInstance = object.registryInstance;
        let data = object.data;
        let options = object.options;
        if(compClass._registered){
            if(_LC.validateRenderData(data)){
                if(data && data.lyteV4){
                    ltCf.lyteV4 = true;
                }
                if(registryInstance){
                    if(!_LC.isValidReg(registryInstance)){
                        //@Slicer.developmentStart
                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC006");
                        //@Slicer.developmentEnd
                        ltCf.fromV4Render = false;
                        ltCf.lyteV4 = oldLyteV4
                        return;
                    }
                    let ele = registryInstance.render(compClass,data,outlet,options);
                    if(object._route){
                        ele._route = object._route;
                    }
                    ltCf.fromV4Render = false;
                    ltCf.lyteV4 = oldLyteV4
                    return ele;
                }else{
                    let registryClass = compClass._registryClass;
                    if(registryClass._instanciated && registryClass._instanceList.length){
                        // if(registryClass._instanceList.length > 1){
                        //     Lyte.error("Registry not instanced for ",compClass.name);
                        // }else{
                            let ele = registryClass._instanceList[0].render(compClass, data, outlet, options);
                            if(object._route){
                                ele._route = object._route;
                            }
                            ltCf.fromV4Render = false;
                            ltCf.lyteV4 = oldLyteV4
                            return ele;
                        // }
                    }
                    //@Slicer.developmentStart
                    else{
                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC007");
                    }
                    //@Slicer.developmentEnd
                }
            }
        }
        //@Slicer.developmentStart
        else{
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC008");
        }
        //@Slicer.developmentEnd
    },
    Security : {
        defaultTags : ["link-to"],
        defaultAttr : ["yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title"],
        sanitizeHTML : function(obj){
            let clean;
            let divEle = document.createElement("div");
            let html = obj.html;
            let instance = obj.instance;
            // let options = obj.options;
            let additionalObject = obj.additionalObject ? obj.additionalObject : {};
            if(instance && Object.keys(instance).length){
                if(additionalObject && Object.keys(additionalObject).length){
                    clean = _LC.Security.sanitizeWithConfig(html ,additionalObject, instance);
                }
                else{
                    clean = instance.sanitize(html);
                }
            }else{
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC009");
                //@Slicer.developmentEnd
                return;
            }
            divEle.innerHTML = clean;
            return divEle;
        },
        createSanitizer : function (obb) {
            _LC.Security.initializeConfig(obb);
            _LC.Security.addConfig(obb);
            _LC.Security.addLyteComponents(obb);
            let instance = ZSEC.HTMLPurifier(obb);
            instance._GLOBAL_TAGS = obb.GLOBAL_TAGS;
            instance._GLOBAL_ATTRIBUTES = obb.GLOBAL_ATTRIBUTES;
            instance._FORBID_TAGS = obb.FORBID_TAGS;
            instance._FORBID_ATTR = obb.FORBID_ATTR;
            return instance;
        },
        sanitizeWithConfig : function(html , additionalObject, instance){
            _LC.Security.addGlobalObject(instance,additionalObject);
            let clean = instance.sanitize(html);
            _LC.Security.removeGlobalObject(instance,additionalObject);
            return clean;
        },
        initializeConfig : function(obb){
            if (!obb.GLOBAL_ATTRIBUTES) {
                obb.GLOBAL_ATTRIBUTES = [];
            }
            if (!obb.FORBID_TAGS) {
                obb.FORBID_TAGS = [];
            }
            if (!obb.FORBID_ATTR) {
                obb.FORBID_ATTR = [];
            }
            if (!obb.GLOBAL_TAGS) {
                obb.GLOBAL_TAGS = [];
          }
        },
        addConfig : function(obb){
            _LC.Security.defaultAttr.forEach(function(item){
                obb.GLOBAL_ATTRIBUTES.$push(item);
            })
            _LC.Security.defaultTags.forEach(function(item){
                obb.GLOBAL_TAGS.$push(item);
            })
        },
        removeConfig : function(obb){
            if(obb && Object.keys(obb) && Object.keys(obb).length > 0){
                if(obb.GLOBAL_ATTRIBUTES && obb.GLOBAL_ATTRIBUTES.length > 0){
                    _LC.Security.defaultAttr.forEach(function(item){
                        var index = obb.GLOBAL_ATTRIBUTES.indexOf(item);
                        if(index != -1){
                            obb.GLOBAL_ATTRIBUTES.$splice(index,1);
                        }
                    })
                }
                if(obb.GLOBAL_TAGS && obb.GLOBAL_TAGS.length > 0){
                    _LC.Security.defaultTags.forEach(function(item){
                        var index = obb.GLOBAL_TAGS.indexOf(item);
                        if(index != -1){
                            obb.GLOBAL_TAGS.$splice(index,1);
                        }
                    })
                }
            }
        },
        addLyteComponents : function(obb){
            var globalTagArr = Array.from(obb.GLOBAL_TAGS);
            var attr = [];
            for(var a=0; a<globalTagArr.length; a++){
                let regComps = ComponentRegistry._registeredCommonClass;
                if(regComps[globalTagArr[a]]){
                    attr = regComps[globalTagArr[a]].observedAttributes;
                }else if(_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.registeredCustomComponent[globalTagArr[a]]){
                    if(_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes){
                        attr = _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
                    }
                }
                for(var i=0; i<attr.length; i++){
                    if(obb.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
                        obb.GLOBAL_ATTRIBUTES.$push(attr[i]);
                    }
                }
            }
        },
        addGlobalObject : function(instanceObj,additionalObj){
            for (var property in additionalObj) {
                    if(Array.isArray(additionalObj[property])){
                        additionalObj[property].forEach(function(item){
                            if(instanceObj["_"+property].indexOf(item) == -1){
                                instanceObj["_"+property].$push(item);
                            }
                        });
                }
            }
        },
        removeGlobalObject : function(instanceObj,additionalObj){
            for (var property in additionalObj) {
                if(Array.isArray(additionalObj[property])){
                    additionalObj[property].forEach(function(item){
                        var index = instanceObj["_"+property].indexOf(item);
                        if(index != -1){
                            instanceObj["_"+property].$splice(index,1);
                        }
                    });
            }
            };
        }
    },
    toBeRegistered : [],
    getRegistryClass : function(options){
        let registryClass;
        ComponentRegistry._registeredRegistries.forEach(function(obj){
            let reg = obj.class;
            if(reg._hash == options.refHash){
                registryClass = reg;
                return
            }

        })
        return registryClass;
    },
    "setCurrentRegistryIns" : function(currentReg){
        _LC._currentRegistryInstance = currentReg;
    },
    "setCurrentRegistry" : function(reg){
        _LC._currentRegistry = reg;
    },
    "getCurrentRegistryIns" : function(){
        return _LC._currentRegistryInstance;
    },
    "getCurrentRegistry" : function(){
        return _LC._currentRegistry;
    },
    "getDecidedRegistry" : function(){
        return _LC._decidedRegistry;
    },
    "setDecidedRegistry" : function(reg){
        _LC._decidedRegistry = reg;
    },
    "setDefaultRegistry" : function(reg){
        _LC._defaultRegistry = reg;
    },
    "setDefaultRegistryIns" : function(regIns){
        _LC._defaultRegistryIns = regIns;
    },
    "getDefaultRegistryIns" : function(){
        return _LC._defaultRegistryIns;
    },
    "getDefaultRegistry" : function(){
        return _LC._defaultRegistry;
    },
    "setAddedRegistries" : function(scope,scopeName){
        let addedRegistries = scope.addRegistries ? scope.addRegistries.apply(scope) : [];
        if(addedRegistries){
            let validReg = _LC.validateArrRegistry(addedRegistries,scopeName);
            scope.addedRegistries = validReg ? addedRegistries : [];
        }else{
            scope.addedRegistries = [];
        }
    },
    "validateArrRegistry" : function(arr , moduleName){
        for(let i=0; i<arr.length; i++){
            if(!_LC.validateRegistry(arr[i],moduleName)){
                return false;
            }
        }
        return true;
    },
    "isValidReg" : function(reg){
        return reg && reg.isComponentRegistry && reg.isComponentRegistry()
    },
    "validateRegistry" : function(reg,moduleName){
        if(!_LC.isValidReg(reg)){
            let name =  reg ? reg.constructor ? reg.constructor.name : reg : reg ;
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC005", name, moduleName);
            //@Slicer.developmentEnd
            return false;
        }
        return true;
    },
    "getApp" : function(node){
        if(node){
            return node.$app ? node.$app : node.$addon.$app;
        }else{
            return this.$app ? this.$app : this.$addon.$app;
        }
    },
    "getNearestParentApp" : function(node){
        if(!node){
            node = this;
        }
        while(node){
            if(node.$app){
                app = node.$app;
                break;
            }
            else if(node.$addon){
                if(node.$addon.$app){
                    app = node.$addon.$app
                    break;
                }
            }
            node = node.$addon;
        }
        return app;
    },
    "getAppOrAddon" : function(node){
        // node can be component or registry
        node = node ? node : this;
        if(node){
            return node.$app ? node.$app : node.$addon;
        }
    },
    "migratedv2" : function(app){
        if((app.constructor._migration && app.constructor._migration.version == "2") || (app.constructor.__slyteApp)){
            return true;
        }
    },
    "updateDirectivesInReg" : function(self,dClass,name){
        self._registeredRegistries.forEach(function(regObj){
            let regClass = regObj.class;
            if(regClass._instanciated){
                regClass._instanceList.forEach(function(regIns){
                    let directiveIns;
                    let app = _LC.getAppOrAddon(regIns);
                    app.scopedInstance(dClass,[regIns],function(ins){
                        directiveIns = ins;
                    },[])
                    regIns["_"+name] = directiveIns;
                    regIns._defaultDirectives.push(name);
                })
            }
        })
    },
    "updateDomApis" : function(regIns){
        regIns.appendChild = _LC.appendChild;
        regIns.insertAfter = _LC.insertAfter;
        regIns.insertBefore = _LC.insertBefore
    },
    "getMyScope" : function(node){
        if(node.$app){
            return node.$app;
        }else if(node.$addon){
            return node.$addon;
        }
    },
    "setComponentsDiv" : function(template,name){
        let div = createElement("div");
        div.setAttribute("id",name);
        template.appendChild(div);
        return div;
    },
    "getComponentsDiv" : function(template,name){
        return template.querySelector("#"+name);
    },
    "getCompRegistry" : function(obj,self){
        var initProp = self._initProperties;
        if((initProp && initProp.lyteRegistry) || (self.hasAttribute("lyte-registry"))){
            var reg = initProp.lyteRegistry || self.getAttribute("lyte-registry");
            var registryMap = new WeakMap();
            if(this.checkInRegistry(reg,obj,registryMap)){
                return;
            }
        }
        var currentReg = _LC.getCurrentRegistryIns();
        if(currentReg){
            this.traverseRegistries([currentReg],obj,self);
        }else{
            let defRegIns = _LC.getDefaultRegistryIns();
            if(defRegIns){
                this.traverseRegistries([defRegIns],obj,self);    
            }else{
                let defaultReg = _LC.getDefaultRegistry();
                let defaultRegInsArr = defaultReg._instanceList;
                this.traverseRegistries(defaultRegInsArr,obj,self);
            }
        }
    },
    "verifyDetails" : function(obj){
        var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;
        if(!lIns || !compClass || !regIns){
            return false;
        }
        return true;
    },
    "isValidateLyteReg" : function(reg,registryMap){
        if(!_LC.isValidReg(reg)){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC006", reg.constructor.name);
            //@Slicer.developmentEnd
            return false;
        }else if(registryMap.get(reg)){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC007", reg.constructor.name);
            //@Slicer.developmentEnd
            return false;
        }
        registryMap.set(reg,reg);
        return true;
    },
    "checkInRegistry" : function(registry,obj,registryMap){
        if(this.isValidateLyteReg(registry,registryMap)){
            obj.compClass = obj.type == "component" ? registry.constructor._registeredComponentClass[obj.compName] : registry.constructor._registeredCeComponentClass[obj.compName];
            if(obj.compClass){
                obj.regIns = registry;
                obj.lIns = registry.$app ? registry.$app : registry.$addon;
                return true;
            }else{
                if(registry.addedRegistries){
                    let addedReg = registry.addedRegistries;
                    for(let i=0; i<addedReg.length; i++){
                        if(this.checkInRegistry(addedReg[i],obj,registryMap)){
                            return true;
                        }
                    }
                }
            }
        }
    },
    "iterateRegistries" : function(baseRegistryArr,obj,registryMap){
        for(let i=0; i<baseRegistryArr.length; i++){
            if(this.checkInRegistry(baseRegistryArr[i],obj,registryMap)){
                return true;
            }
        }
    },
    "traverseRegistries" : function(baseRegistryArr,obj,self){
        let registryMap = new WeakMap();
        if(this.iterateRegistries(baseRegistryArr,obj,registryMap)){
            return
        }
        let parentComp = self._callee || self.getCallee && self.getCallee(self.parentNode);
        if(!parentComp){
            return;
        }
        while(parentComp){
            let parentCompReg = parentComp.$registry;
            registryMap = new WeakMap();
            if(this.checkInRegistry(parentCompReg,obj,registryMap)){
                return;
            }
            if(parentComp.component.addedRegistries){
                let pcAddedReg = parentComp.component.addedRegistries;
                for(let i=0; i<pcAddedReg.length; i++){
                    registryMap = new WeakMap();
                    if(this.checkInRegistry(pcAddedReg[i],obj,registryMap)){
                        return;
                    }
                }
            }
            parentComp = parentComp._callee || parentComp.getCallee && parentComp.getCallee(parentComp.parentNode);
        }
        
    },
    "getCommonClass" : function(componentName){
        var customCrmComponent = ComponentRegistry._registeredCommonClass[componentName];
        return customCrmComponent;
    },
    "getCommonCustomClass" : function(componentName){
        var customCrmComponent = ComponentRegistry._registeredCommonClass[componentName];
        return customCrmComponent;
    },

    "registerCeComponent" : function(componentName, componentClass, registryInstance){
        let customLyteCustomComponent;
        let registry = componentClass._registryClass;
        let registryName = registry.name;
        if(registryInstance.registeredCeComponents[componentName] && ComponentRegistry._registeredCommonCeClass[componentName]._reg[registryName]) {
            customLyteCustomComponent = this.getCommonCustomClass(componentName,registryName);
        }else{
            customLyteCustomComponent = class extends LyteCustomElement {
                constructor(){
                    super()
                }
            }
            customLyteCustomComponent._observedAttributes = componentClass.observedAttributes || [];
            customLyteCustomComponent._deepWatchProperties = componentClass._deepWatchProperties || {};
            registryInstance.registeredCeComponents[componentName] = true;
            if (document.readyState === "complete" || document.readyState === "interactive") {     
                customElements.define(componentName, customLyteCustomComponent, undefined, {v4raw : true});
            }
            else{
                _LC.toBeRegistered.$push({name:componentName, def: customLyteCustomComponent, _lyteOptions : {v4raw : true} });//af check
            }
            ComponentRegistry._definedCeComponents[componentName] = customLyteCustomComponent;
            componentClass._instanciated = true;
            componentClass._registered = true;
            ComponentRegistry._registeredCommonCeClass[componentName] = customLyteCustomComponent;
            registry._registeredCeComponentClass[componentName] = componentClass;
        } 
    },
    "validate" : function() {
        var compInstance = this._ins;
        var data = compInstance.data;
        for(var key in data) {
            _LC.handleValidation(data, key, data[key], compInstance);
        }
    },
    "registerComponent" : function(componentName,componentClass,registryInstance) {
        let customCrmComponent;
        let alreadyRegistered;
        let registry = componentClass._registryClass;
        let registryName = registry.name;
        if(registryInstance.registeredComponents[componentName] && ComponentRegistry._registeredCommonClass[componentName]._reg[registryName]) {
            //think this place wont be called need to remove this check
            customCrmComponent = this.getCommonClass(componentName, registryName);
        }
        else if(ComponentRegistry._unRegisteredComponents[componentName]){
            customCrmComponent = this.getCommonClass(componentName);
            delete ComponentRegistry._unRegisteredComponents[componentName];
            alreadyRegistered = true;
        }
         else {
            customCrmComponent = class extends customElementPrototype {
                constructor(){
                    super()
                }
            }
            registryInstance.registeredComponents[componentName] = true;
            customCrmComponent._reg = {[registryName] : {}};
            customCrmComponent._depthTemp = document.createElement("template");//af check
            customCrmComponent.prototype.throwAction = this.throwAction;
            customCrmComponent._compName = componentName;
            Object.defineProperty(customCrmComponent.prototype, "setData", {
                configurable : true, 
                writable : true,
                value : function(arg0, arg1 ,options) {
                    return this.component.setData(arg0, arg1, options);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "getData", {
                configurable : true, 
                writable : true,
                value : function(arg0) {
                    return this.component.getData(arg0);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    return this.component.setMethods(arg0, arg1);
                }
            })
            customCrmComponent.prototype.get = this.nodeGet;
            customCrmComponent.prototype.set = this.nodeSet;
        }
        if(componentClass.ssr){
            customCrmComponent._ssr = componentClass.ssr();
            if(customCrmComponent._ssr.config){
                customCrmComponent._config = customCrmComponent._ssr.config;
            }
        }

        customCrmComponent.componentClass = componentClass;
        var Component;
        if(ComponentRegistry._registeredCommonClass[componentName]){
            Component = ComponentRegistry._registeredCommonClass[componentName].component;
            Component.list.push(componentClass);
        }else{
            Component = {list : [componentClass]};
        }
        componentClass._v4 = true;
        customCrmComponent.component = Component;
        customCrmComponent._observedAttributes = componentClass._observedAttributes || [];
        customCrmComponent._deepWatchProperties = componentClass._deepWatchProperties || {};
        // if(!componentClass._registered){
            customCrmComponent._registerComponent(
                componentName,
                customCrmComponent,
                componentClass,
                registry,
                registryInstance
            );
        // }
        customCrmComponent._bindsIds = [];
        if(!ComponentRegistry._definedComponents[componentName]) {
            if (document.readyState === "complete" || document.readyState === "interactive") {     
                customElements.define(componentName, customCrmComponent, undefined, {v4 : true});
            }
            else{
                _LC.toBeRegistered.$push({name:componentName, def: customCrmComponent, _lyteOptions : {v4 : true}});
            }
        }
        ComponentRegistry._definedComponents[componentName] = customCrmComponent;
        let depthTemp = customCrmComponent._depthTemp;
        if(depthTemp && depthTemp.content.childNodes.length) { //removed _ie
            depthTemp.setAttribute("data-id", "depthTemp_" + componentName);
            let lyteComponentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv,registry.name);
            lyteComponentsDiv.appendChild(depthTemp);
        } else {
            delete customCrmComponent._depthTemp;
        }
        componentClass._instanciated = true;
        componentClass._registered = true;
        ComponentRegistry._registeredCommonClass[componentName] = customCrmComponent;
        registry._registeredComponentClass[componentName] = componentClass;
        if(alreadyRegistered) {
            var pendingComps = customCrmComponent._pendingComponents || [];
            pendingComps.forEach(function(item) {
                delete item.__lyteIgnore 
                item.actualConstructor();
                var arr = Array.from(item.attributes);
                arr.forEach(function(attr) {
                    if(item.constructor.observedAttributes.indexOf(attr.name) != -1) {
                        item.attributeChangedCallback(attr.name, null, attr.value);
                    }
                    
                });
                item.connectedCallback();
            });
            customCrmComponent._pendingComponents = [];
        }
        return customCrmComponent;
    },
    // "_lyteInstance": Lyte,
    "shadow" : {
        "getHostElement" : function(node){
            if(node){
                let host = node.host;
                if(host && host.tagName){
                    return host;
                }
            }
        },
        "stringToStyle" : function(str){
            var wrapper = document.createElement("wrapper");
            wrapper.innerHTML = str;
            return wrapper.firstChild;
        },
    },
    "directive" : {
        setTagDirectives : function(compClass,comp){
            if(compClass._lyteOptions && compClass._lyteOptions.attributes && compClass._lyteOptions.attributes.length){
                let attr = compClass._lyteOptions.attributes;
                for(let i=0; i<attr.length; i++){
                    if(typeof attr[i] == "object"){
                        if(attr[i].name.startsWith("@")){
                            comp._tagDirectives.push(attr[i]);
                            compClass._lyteOptions.attributes.splice(i,1);
                            i--;
                        }
                    }else{
                        if(attr[i].startsWith("@")){
                            comp._tagDirectives.push(attr[i]);
                            compClass._lyteOptions.attributes.splice(i,1);
                            i--;
                        }
                    }
                }
            }
        },
        checkSameAttrName : function(arr,directiveName,arg){
            let duplicateFound;
            arr.forEach(function(attr){
                if(attr.hookName == directiveName && arg){
                    attr.stringValue = arg;
                }
            })
            return duplicateFound;
        },
        isDirectiveNode : function(node){
            if(node.hookNode || (node.nodeName && node.nodeName.startsWith("@")) || node._isDirectiveNode){
                return true;
            }
            return false;
        },
        getActualTransitionArg : function(attr,node){
            if(attr.hasOwnProperty("dynamicValue") || attr.hasOwnProperty("helperInfo")){
                if(node.hasOwnProperty("_transitionArgs")){
                    if(node._transitionArgs.hasOwnProperty(attr.hookName)){
                        return node._transitionArgs[attr.hookName];
                    }
                }
            }else if(attr.hasOwnProperty("stringValue")){
                if(attr.hasOwnProperty("stringValue")){
                    if(attr.stringValue === ""){
                        return true
                    }if(attr.stringValue === "true"){
                        return true
                    }else if(attr.stringValue === "false"){
                        return false
                    }else{
                        return attr.stringValue;
                    }
                }
            }
        },
        getTransitionArg : function(node,directiveName){
            let transitionArg;
            if(node.component && node.component.constructor._options){
                this.setAttrFromRender(node);
            }
            var self = this;
            if(node._specialAttributeDetails){
                node._specialAttributeDetails.forEach(function(attr){
                    if(directiveName == attr.hookName){
                        transitionArg = self.getActualTransitionArg(attr,node);
                        return;
                    }
                })
            }
            return transitionArg;
        },
        setAttrFromRender : function(comp,tagDirectives){
            if(tagDirectives.length){
                if(!comp._specialAttributeDetails){
                    comp._specialAttributeDetails = [];
                }
                var self = this;
                tagDirectives.forEach(function(directiveName){
                    if(self.checkSameAttrName(comp._specialAttributeDetails,directiveName,directiveName.value)){
                        return;
                    }
                    let attr;
                    if(typeof directiveName == "string"){ 
                        attr = {
                            hookName : directiveName.slice(1,directiveName.length),
                            hookNode : true,
                            name : directiveName,
                            stringValue : ""
                        }   
                    }else{
                        attr = {
                            hookName : directiveName.name.slice(1,directiveName.name.length),
                            hookNode : true,
                            name : directiveName.name,
                            stringValue : directiveName.value
                        }
                    }
                    comp._specialAttributeDetails.push(attr)
                })
            }
        },
        setNodeArgs : function(node,nodeValue){
            // node.ownerElement._transitionArgs = nodeValue;
            let nodeName = node.nodeName;
            node.ownerElement.removeAttribute(nodeName);
            // node.nodeName = node.nodeName.slice(1,node.nodeName.length);
            if(!node.ownerElement._transitionArgs){
                node.ownerElement._transitionArgs = {};
            }
            let actNodeName = nodeName
            if(nodeName.startsWith("@")){
                actNodeName = nodeName.slice(1,nodeName.length);
            }
            node.ownerElement._transitionArgs[actNodeName] = nodeValue;
            node.ownerElement.setAttribute("lyte-directive-" + actNodeName,"");
        }
    },
    "fRP" : {},
    "fRC" : 0,
    // "frcUnused" : [],
    "customPropRegex" : "",
    // "pushFrc" : function(fastRenderIndex) {
    //     this.frcUnused.$push(fastRenderIndex);
    //     delete _LC.fRP[fastRenderIndex];
    // },
    // "getFrc" : function() {
    //     let frcIndex;
    //     if(this.frcUnused.length) {
    //         frcIndex = this.frcUnused.$shift()
    //     } else {
    //         frcIndex = this.fRC++;
    //     }
    //     return frcIndex;
    // },
    "customPropHandlers" : [],
    "_registeredComponents" : {},
    // "_reRegisteredComponents" : [],
    // "toBeRegistered" : [],
    "updateCustomCrmComponent" : function(componentClass){
        var def = componentClass.__observers;
        for(let key in def) {
            if (def[key] && def[key].type === "observer") {
                def[key].fnName = key;
                componentClass._observers.$push(def[key]);
            } else if (def[key] && def[key].type === "callBack") {
                var props = def[key].properties;
                for (var k = 0; k < props.length; k++) {
                    if (!componentClass._callBacks[props[k]]) {
                        componentClass._callBacks[props[k]] = [];
                    }
                    def[key].fnName = key;
                    componentClass._callBacks[props[k]].$push(def[key]);
                }
                if (def[key].observes) {
                    def[key].observes.fnName = key;
                    componentClass._observers.$push(def[key].observes);
                }
            }
        }
        // delete orgDef.observers;
        // for (let key in orgDef) {
        //     componentClass.prototype[key] = orgDef[key];
        // }
        // return orgDef;
    },
    // "dataFromMixin" : function(mixinsToBeUsed,actionsFromMixin,methodsFromMixin,newDefinition){
    //     var mixinslen = mixinsToBeUsed.length;
    //     for(let i=0; i<mixinslen ; i++) {
    //         for(let item in mixinsToBeUsed[i]){
    //             if(item === "actions") {
    //                 Object.assign(actionsFromMixin, mixinsToBeUsed[i][item]);    
    //             } else if(item === "methods") {
    //                 Object.assign(methodsFromMixin, mixinsToBeUsed[i][item]);    
    //             } else {
    //                 newDefinition[item] = mixinsToBeUsed[i][item];
    //             }
    //         }
    //     }
    //     return{"actionsFromMixin":actionsFromMixin,"methodsFromMixin":methodsFromMixin,"newDefinition":newDefinition}
    //   },
    "throwEvent" : function(eventName){
        let self = this.$node ? this.$node : this;
        const evt = self._actions? self._actions[eventName] : undefined; 
        let customArgs = [];        
        if(arguments.length > 1){        
            for(let i=1;i<arguments.length; i++){            
                customArgs.$push(arguments[i]);                
                }        
            }
            //wait for release
            //eventName = _LC.String.toCamelCase(eventName);
            _LC.throwAction.call(self, self._callee, eventName, undefined, true, customArgs, self);
        if(this.$node) {
            self.dispatchEvent(evt? evt : new CustomEvent(eventName, {"detail" : customArgs}));
        }
    },
    //this and scope reference should be either a node or a route.
    "throwAction" : function(scope,eventName,actObj,isCustom,customArgs, node, event, hasHandled, fromEv){
        let actionsObj;
        let app = _LC.getNearestParentApp(this.component);
        if(this._route && isCustom) {
            // scope = Lyte.Router.getRouteInstance(this._route);
            scope = app.$.modules.router[0].getRouteInstance(this._route)//.__lp.fns;
            var fns = scope.__lp.fns;
            actionsObj = fns.actions || (fns.actions = {});
        } else if(this.routeName) {
            //process for the parent route and get the current component and proceed;
            let parentRoute = this.parent;
            if(parentRoute) {
                if(parentRoute.component && parentRoute.component.component) {
                    scope = parentRoute.component;
                    actionsObj = scope.component.constructor._actions; 
                } else {
                    scope = parentRoute;
                    // actionsObj =  scope.actions || (scope.actions = {});            
                    var fns = scope.__lp.fns;
                    actionsObj = fns.actions || (fns.actions = {});
                }
            }
        } else if(scope){
                actionsObj = scope.component.constructor._actions
        }
        if(!scope) {
            //Only warning is thrown because, we can have a eventListener for the dom directly. 
            //@Slicer.developmentStart
            if(!hasHandled) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Nothing handled the action "+ eventName + ".");    
            }
            //@Slicer.developmentEnd
            return;
        }
        actObj = (actObj) ? actObj : this._actions && this._actions[eventName]? this._actions[eventName].processAction : void 0;     
        //wait for release
        /* 
        var dasherizedEventName = _LC.String.dasherize(eventName);
        actObj = (actObj) ? actObj : this._actions && this._actions[dasherizedEventName]? this._actions[dasherizedEventName].processAction : void 0;     
        */
        let args = customArgs ? customArgs : [];
        if(actObj){
            var contextSwitchArray = [];
            if(node) {
                _LC.adCx(node, contextSwitchArray);
            }
            let concatArgs;
            if(actObj.skipArgProcessing) {
                // concatArgs = deepCopyObject(actObj.args);
                // concatArgs.$shift();
                // var eventIndex = concatArgs.indexOf("__lyteEvent__");
                // var nodeIndex = concatArgs.indexOf("__lyteNode__");
                // if(eventIndex !== -1) {
                //     concatArgs[eventIndex] = event;
                // } 
                // if(nodeIndex !== -1) {
                //     concatArgs[nodeIndex] = target;
                // }
                concatArgs = actObj.args;
            } else {
                concatArgs = this.processArgs(scope,{"helperInfo" : actObj}, undefined, event, node);
            }
            args.$splice.apply(args, [0,0].$concat(concatArgs) );
            if(node) {
                _LC.rmCx(node, contextSwitchArray);
            }
            if(actionsObj[actObj.name]){
                if(!isCustom){  
                    //args.$unshift(window.event);
                    let parent = node.parentNode;
                    let val = actionsObj[actObj.name].apply(this.component,args);
                    if(event.currentTarget !== document.body && !_LCSD.getHostElement(event.currentTarget) && !fromEv) {
                        val = false;
                    }
                    hasHandled = true;
                    if(val !== false && !event.cancelBubble){
                        if(actObj.from && node.getAttribute(event.type) && node._boundEvents && node._boundEvents[event.type]) {
                            let actions = node._callee.component.constructor._actions;
                            let actObj = node._boundEvents[event.type];
                            let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(actObj);
                            // cloneActObj.args.$shift();
                            _LC.skipArgProcessing(cloneActObj, event, node);
                            _LC.throwAction.call(node._callee,node._callee,event.type,cloneActObj, undefined, undefined, node, event, hasHandled);
                        } else {
                            if(_LC.hasLyteEvents(node, eventName)) {
                                let eventStopped = _LC.handleLyteEvents(node, event);
                                val = eventStopped ? false : true;       
                            }
                            if(val === false) {
                                return;
                            }
                            if(_LC.isCustomElement(node)){
                                scope = parent;
                            }
                            if(parent){
                                let eventStopped;
                                while(parent && !_LCSD.getHostElement(parent) && (!parent.getAttribute(eventName) || parent.hasAttribute("disabled") ) && parent.tagName != "BODY"){
                                    if(_LC.hasLyteEvents(parent, eventName)) {
                                        eventStopped = _LC.handleLyteEvents(parent, event);
                                        if(eventStopped) {
                                            break;
                                        }
                                    }
                                    parent = parent.parentNode;
                                }
                                if(eventStopped || !parent || parent.tagName === "BODY"){
                                    return;
                                }
                                if(!parent._callee){
                                    parent._callee = parent.getCallee ? parent.getCallee(parent) : _LC.getCallee(parent);
                                }
                                if(parent && event.type === eventName && !event.cancelBubble){
                                   if(parent._evBoundEvents && parent._evBoundEvents[eventName]) {
                                       let actObj = parent._evBoundEvents[eventName];
                                       let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(actObj);
                                    //    cloneActObj.args.$shift();
                                        _LC.skipArgProcessing(cloneActObj, event, parent);
                                       _LC.throwAction.call(parent,parent,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                   } else if(parent && parent._boundEvents && parent._boundEvents[eventName]) {
                                       let actObj = parent._boundEvents[eventName];
                                       let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(actObj);
                                       _LC.skipArgProcessing(cloneActObj, event, parent);
                                       _LC.throwAction.call(parent._callee,parent._callee,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                   }
                                }
                            }
                        }
                    }
                }            
                else{                
                    actionsObj[actObj.name].apply(this._callee.component,args);
                    hasHandled = true;                                             
                } 
            }
            //@Slicer.developmentStart
            else{
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error(app, "LC004" , actObj.name);
            }
            //@Slicer.developmentEnd
        } else if(isCustom) {
            var eventsObj = actionsObj[eventName]  || actionsObj[_LC.String.toCamelCase(eventName)] || actionsObj[_LC.String.dasherize(eventName)];
            if(eventsObj) {
                var scopeS = _LC.isCustomElement(scope) ? scope.component : scope;   
                let val = eventsObj.apply(scopeS, args);
                //let val = eventsObj.apply(_LC.isCustomElement(scope)? scope.component : scope, args);
                hasHandled = true;
                if(val !== false) {
                    _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
                }
            } else {
                _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
            }
        }
        
    },
    "isControlHelper" : function(ownerElement) {
        return (ownerElement.tagName === "TEMPLATE" && ownerElement.getAttribute("is") && ownerElement.getAttribute("is") !== "component") || (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin"));
    },
    "isCustomElement" : function(node, isTemplate) {
        return node.hasAttribute && ((( node.tagName ==="TEMPLATE" || node.attributes["lyte-for"] || node.attributes["lyte-if"] || node.attributes["lyte-switch"] || node.attributes["lyte-forin"] ) && isTemplate )  || (node.nodeName && node.nodeName.indexOf('-') !== -1 && (ComponentRegistry._registeredCommonClass[node.localName] || node.tagName === "LYTE-YIELD")));
    },
    "componentSet" : function(key, value, options, forceExecute, fromParent) {
        if(!forceExecute && this.get(key) === value) {
            _LC.clearError(this.data, key);
            //@Slicer.developmentStart
            if(!fromParent){
                if(typeof value == "object"){
                    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("The data passed to update '" + key + "' is the same reference of the actual data. So component bindings won't be updated.");
                }
            }
            //@Slicer.developmentEnd
            return;
        }
        //temporary fix
        _LC.set(this.data, key, value, options, undefined, fromParent);
    },
    "componentGet" : function(key) {
        return key ? _LC.get(this.data, key) : this.data;
    },
    "nodeGet" : function(key) {
        return key ? this.component.get(key) : this.component.data;
    },
    "nodeSet" : function(key, value, options, fromParent) {
        this.component.set(key, value, options, undefined, fromParent);
    },
    "registerMixin" : function(name,mixin){
        _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.Mixin.register.call(_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte, name, mixin);
    },
    "sendtoclient": function(prop,server,node){
        var data = server ? prop.component.data : prop;
        var newData = {};
        var data_prop = node;
        for (var i in data){
            if(server){
                var def = prop.component.__data[i];
                if(i == "bindIds"){ 
                    newData[i] = {value : data[i] }
                }
                    if(def && /^(object|array)$/.test(def.type) && prop._attributeDetails && prop._attributeDetails.hasOwnProperty(_LC.String.dasherize(i))){
                        newData[i] = { "fP" : true };
                    }
                    else if(data[i] instanceof Date){
                        newData[i] = { "value" : data[i] , "type" : "Date" }
                    }
                    else if(data_prop[i]){
                        newData[i] = { "value" : data[i] , "type" : data_prop[i].type }
                    }else{
                        var type = typeof(data[i])
                        if(data[i] == undefined){
                            type = undefined;
                        }
                        newData[i] = {"value" : data[i] ,"type":type}
                    }
            }else{
                if(data[i].type=="Date"){
                    newData[i] = new Date(data[i].value);
                }
                else if(!data[i].fP){
                    newData[i]= data[i].value;
                }
            }
        }
        return newData;        	
    },
    "typeCast" : function(value, dataType, obj) {
        if(value === null) {
            return value;
        }
        try {
            switch(dataType) {
            case "string" : 
                return typeof value === "object" ? JSON.stringify(value) : value.toString(); 	
            break;
            case "number" :
                {
                if(value == "") {
                    return undefined;
                }
                let val = +value;
                if(isNaN(val)) {
                    throw "TypeCast exception";
                } 
                return val;
                }
            break;
            case "array" : 
            case "object" :
                return JSON.parse(value);
                break;
            case "boolean" :
                return ( (!value && value !== "") || value=== "false") ? false : true; 
            break;
            default : 
                return value;
            }
        } catch(e) {
            if(obj) {
                obj.isError = true;
            }
            return value;
        }
        
    },
    "getDataType" : function(value) {
        var type = typeof value;
        if(type === "object") {
            if(Array.isArray(value)) {
                return "array";
            }
        }
        return type;
    },
    "handleValidation" : function(object, property, value, component ,init) {
        let error = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.validateData)(object, property, value, component ,this._lyteInstance ,init);
        if(error) {
            _LC.set(component.data.errors, property, error);
            if(component.$node.callback) {
                component.$node.callback("onError", property, error);
            }
        } else {
            _LC.clearError(object, property);
        }
        return error;
    },
    "clearError" : function(data, property) {
        if(data.errors && data.errors[property]) {
            _LC.oF(data.errors, "delete", property);
        }
    },
    "createLyteId" : function(comp){
        comp.__counter++;
        return "__lyteId" + comp.__counter;
    },
    "apdNode" : function(node, comp) {
        _LC.tDiv.content.appendChild(node);
        let id = this.createLyteId(comp);
        comp.__h[id] = node;
        node.__lyteId = id;
    },
    "update":function(object, property, value, options, fromStore,oldValue,setterScope, actualProperty, fromParent ,FromUtils, storeRecord){
        let fromComponent = object.__component__;
        let updateAttr = true;
        let dataType, dataDef, estObjBind = false;
        if(!oldValue){
            oldValue = object[property];
            if(fromComponent && fromComponent.tagName !== "LYTE-YIELD") {
                dataDef = fromComponent.component.__data[property];
                if(dataDef && (dataType = dataDef.type)) {
                    updateAttr = !dataDef.hideAttr;
                    if(dataType !== _LC.getDataType(value) && (value !== undefined || dataType === "boolean")) {
                        value = _LC.typeCast(value, dataType);
                    }
                }
                if(value === oldValue) {
                    _LC.clearError(object, property);
                    return;
                }
                if(!options || (typeof options == "object" && options.skipValidation != true)){
                    let error = _LC.handleValidation(object, property, value, fromComponent.component);
                    if(error) {
                        // if(fromComponent.component.data.errors && Object.keys(fromComponent.component.data).length){
                        //     Lyte.error("Error in data passed to component '"+fromComponent.component.$node.localName+"' for the properties - "+Object.keys(fromComponent.component.data.errors).toString());
                        // }
                        return;
                    }
                }
        }
            //object[property] = value;
            if(!object.hasOwnProperty(property) && !(Array.isArray(object))) {
                _LC.oF(object, "add", property, value, true )
            } else {
                object[property] = value;
            }
        }
        let toBeExecuted = fromComponent ? true : false;
        let dasherizedAttr = _LC.String.dasherize(property);
        if(fromComponent && actualProperty && ( (typeof value === "string" && fromComponent.getAttribute(dasherizedAttr) !==  value) || fromComponent.hasAttribute(dasherizedAttr) )) {
            // (customPropRegex && this.customPropRegex)
            let cpr;
            if(fromComponent.tagName == "LYTE-YIELD"){
                cpr = fromComponent._callee.component._registryClass.customPropRegex;
            }else{
                cpr = fromComponent.component._registryClass.customPropRegex;
            }
             if((!cpr.exec(property) || fromComponent.hasAttribute(dasherizedAttr) ) && updateAttr) {
                 if(value && typeof value === "object") {
                     let jsonString;
                     try{
                        jsonString = JSON.stringify(value);
                        fromComponent.attributes.getNamedItem(dasherizedAttr).__lyteIgnore = true;
                        fromComponent.setAttribute(dasherizedAttr, jsonString);
                     } catch(e) {

                     }
                 } else {
                     let attributeString = _LC.typeCast(value, "string");
                     if(fromComponent.getAttribute(dasherizedAttr) !== attributeString) {
                         let detAttr = fromComponent.attributes.getNamedItem(dasherizedAttr);
                         if(detAttr) {
                             detAttr.__lyteIgnore = true;
                         }
                         attributeString = attributeString || "";
                         fromComponent.setAttribute(dasherizedAttr, attributeString);
                     }
                 }
             }
        }
        if(value && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number" ) {
            //newValue is of type object 
            
            if(oldValue && typeof oldValue === "object" && oldValue._bindings) {
                //Both oldValue and newValue are objects. 
                if(!value._bindings) {
                    defProp(value, "_bindings", {
                        enumerable: false, 
                        writable: true, 
                        value : new Set(),
                        configurable: true
                    });
                }
                //for changing only child component
                if(fromComponent && fromComponent.component.data === object && property.indexOf('.')=== -1) {
                    let bindings = fromComponent.getProperty(property);
                    this.removeSelectedBindingDeep(bindings, oldValue);
                    addBindings(value._bindings,bindings);
                    this.establishBindings(bindings, value);
                    //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                    if(bindings._forHelpers) {
                        let bindfor = bindings._forHelpers.toArrayLyte();
                        for(var i=0;i<bindfor.length;i++){
                            let item = bindfor[i];
                            if(item._propBindingObject) {
                                this.removeSelectedBindingDeep(item._propBindingObject, oldValue);
//                                  value._bindings.add(item._propBindingObject);
//                                  this.establishBindings(item._propBindingObject, value);
                            }
                        }
                    }
                    let stack = [];
                    this.affectChanges(bindings,undefined,oldValue,setterScope,object[property],stack);
                    this.executeObserver(stack);
                } else {
                    //To change only the bindings present in the object and not all the bindings present in the oldValue.
                    if(object._bindings) {
                        let oldbind = object._bindings.toArrayLyte();
                        for(let i=0; i<oldbind.length;i++){
                            let item = oldbind[i][property];
                            if(item) {
                                this.removeSelectedBindingDeep(item, oldValue);
                                addBindings(value._bindings,item);
                                this.establishBindings(item, value);
                                //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                                if(item._forHelpers) {
                                    let forbind = item._forHelpers.toArrayLyte();
                                    for(let j=0;j<forbind.length;j++){
                                        let itemBinding = forbind[j];
                                        if(itemBinding._propBindingObject) {
                                            this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                        }
                                    }
                                }
                                let stack = [];
                                this.affectChanges(item,undefined,oldValue,setterScope,object[property],stack);
                                this.executeObserver(stack);
                            }
                        }
                    }
                
                
                }
            } else {
                //newValue is object and oldValue is string. Hence establish bindings from oldValue's object and place it in the newValue. 
                if(object._bindings) {
                    makeSet(value, "_bindings");
                    let objbind = object._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item[property]) {
                            addBindings(value._bindings,item[property]);
                            this.establishBindings(item[property], value);
                            let stack = [];
                            this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],stack);
                            this.executeObserver(stack);
                        }
                    }
                }
            }
            dataDef = dataDef || (fromComponent && fromComponent.tagName !== "LYTE-YIELD" ? fromComponent.component.__data[property] : undefined); 
            if((fromStore && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(object)) || (object && object.hasOwnProperty("_scp") && object._scp.size) || (dataDef && (/^(object|array)$/.test(dataDef.type)) && (dataDef.watch || dataDef.hasOwnProperty("items") || dataDef.hasOwnProperty("properties")))){
                estObjBind = true;
            }
        } else {
            //newValue is string
            
            if(oldValue && typeof oldValue === "object" && oldValue._bindings && object._bindings) {
                //newValue is string and oldValue is object 
                let objbind = object._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item[property]) {
                        //oldValue._bindings.delete(item[property]);
                        //if(oldValue._bindings.size === 0) {
                        //  delete oldValue._bindings;
                        //  break;
                        //}
                    this.removeSelectedBindingDeep(item[property], oldValue);
                        if(item[property]._forHelpers) {
                            let forbind = item[property]._forHelpers.toArrayLyte();
                            for(let j=0;j<forbind.length;j++){
                                let itemBinding =forbind[j];
                                if(itemBinding._propBindingObject) {
                                    this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                }
                            }
                        }
                    }
                }
            }
            
            //when newValue and oldValue , both are string, no need to change bindings. 
            if(object._bindings) {
                let objbind = object._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item[property]) {
                        let stack = [];
                        this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],stack);
                        this.executeObserver(stack);
                    }
                }
            }
        }
        if(object._scp){
            if(!(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.cmpData)(oldValue, value)){
                this.callDeepObservers(object, { type:"deepChange", oldValue:oldValue, newValue : value }, property);
            }
            if(oldValue && (Array.isArray(oldValue) || typeof oldValue == "object")){
                var keys = Array.from(object._scp.keys());
                keys.forEach(function(id){
                    var nestObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.nestScp[id];
                    var isCyclic = nestObj.cyclic;
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.removeNestScp)(oldValue, id);
                    if(isCyclic){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.bindObj)(nestObj._data, undefined, id, [], new Map());
                    }
                });
            }
        }
        if(((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(object) && object.$.__scpObj) || (object.hasOwnProperty("__component__") && object.__component__.__scpObj)){
            var _scpObj, kmpKey;
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(object)){
                _scpObj = object.$.__scpObj;
                kmpKey = object;
            }else{
                _scpObj = object.__component__.__scpObj;
                kmpKey = object.__component__;
            }
            if(_scpObj.hasOwnProperty(property)){
                var _sId = _scpObj[property].split("_");
                (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.removeNestScp)(oldValue, _sId[0], _sId[1], undefined, kmpKey, undefined, (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(value) || Array.isArray(value) && value.model && value.add ? value : undefined);
                delete _scpObj[property];
            }
        }
        if (!FromUtils) {
            _LC.callObjectObservers(object, { type: "change", "oldValue": oldValue, "newValue": value, item: property });
        }
        if(estObjBind){
            // establishObjectBinding(object, property, fromStore, true);
            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.establishObjectBinding)(
                object,
                property,
                fromStore,
                true,
                storeRecord,
                (dataDef && dataDef.watch)?dataDef.watch:undefined
            );
        }
        if(toBeExecuted && !fromParent && fromComponent._attributeDetails && fromComponent._callee) {
            //let syntaxValue = fromComponent.getAttributeNode(property).syntaxValue;
            let attrDetail = fromComponent._attributeDetails[_LC.String.dasherize(property)];
            let syntaxValue;
            if(attrDetail && attrDetail.isLbind) {
                syntaxValue = attrDetail.dynamicValue;
            }
            if(syntaxValue) {
                let contextSwitchArray;
                if(fromComponent._cx) {
                    contextSwitchArray = [];
                    _LC.changeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
                }
                let obj = _LC.getNew(fromComponent._callee.component.data, syntaxValue);
                if(!obj.context){
                    return;
                }
                let exec = false;
                if(obj.context === fromComponent._callee.component.data) {
                    if(fromComponent._callee._properties[obj.lastKey] && fromComponent._callee._properties[obj.lastKey].__fromComponent) {
                        exec = true;
                    }
                } else {
                    exec = true;
                }
                //self.setData(this._lbind,this.value);
                if(exec) {
                    let lastKeyIndex = +obj.lastKey;
                    if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
                        _LC.aF(obj.context, lastKeyIndex < obj.context.length ? "replaceAt" : "insertAt", lastKeyIndex, value);
                    } else {
                        _LC.set(obj.context, obj.lastKey, value, options);
                    }
                }
                if(contextSwitchArray) {
                    _LC.removeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
                }
            }
        }
    },
    "getContentForIE" : function getContentForIE(content, constr, newlyCreated, info) {
        if(typeof content === "string") {
            newlyCreated = true;
            var div = createElement("div");
            div.innerHTML = content;
            content = div.childNodes[0];
            constr.splitTextNodes(content);
        }
        if(content.getAttribute && content.getAttribute("depth")) {
            if(info) {
                info._content = div;
            }
            var itr = parseInt(content.getAttribute("depth"));
            content =  newlyCreated ? content.content : content.content.cloneNode(true);
            // content = Lyte._ie ? content : (newlyCreated ? content.content : content.content.cloneNode(true));
            for(var i=0;i<itr;i++) {
                content = content.childNodes[0];
            }
        }
        return content;
    },
    "replaceWithPf" : function(node1, node2) {
        // if(Lyte._rwpf) {
        //     _LC.insertBeforeNative(node1.parentNode,node2, node1);
        //     node1.remove();
        // } else {
            node1.replaceWith(node2);
        // }
    },
    "getCallee" : function(callee, self){
        while(callee &&  !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
            if(callee.tagName === "BODY") {
                callee = null;
                break;
            }
            let hostEle = _LCSD.getHostElement(callee)
            if(!callee.parentNode && hostEle){
                callee = hostEle;
            }
            else{
                callee = callee.parentNode;
            }
        }
        if(callee && callee.tagName === "LYTE-YIELD") {
        return callee._registerYield? callee._registerYield._callee : undefined;
        }
        return ((self ===  callee) ? undefined : callee);
    },
    "set" : function(object, property, value, options, fromStore, fromParent, FromUtils) {
        let lastIndex = -1;
        var s_rec,check={},recDottedProp;
        if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(object) && fromStore){
            s_rec=object;
        }
        if(!(typeof property === "object") || !property){
            property = property+"";
            lastIndex = property.lastIndexOf('.');
        }
        let actualProperty = property;
        if(lastIndex !== -1) {
            let outerPropertyPath = property.substring(0, lastIndex);
            property = property.substring(lastIndex + 1);
            object = _LC.get(object, outerPropertyPath);
            recDottedProp = true;
        }
        if(typeof property === "string" && object[property] === value) {
            if(object.__component__) {
                _LC.clearError(object, property);
            } else if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(object)) {
                if(!object.$.isCloned){
                    _slyte_data_src_dberror_js__WEBPACK_IMPORTED_MODULE_6__.ValidationError.clrRecErr(object.$, property);
                }
                object.$.emit("set", [object, property]);
                if(object.$.schema){
                    object.$.schema.emit("set", [object.$.schema._name, object, property]);
                    object.$.schema.db.emit("set", [object.$.schema._name, object, property]);
                }
                else if(object.$.model){
                    object.$.model.emit("set", [object.$.model._name, object, property]);
                    object.$.model.db.emit("set", [object.$.model._name, object, property]);
                }

            }
            return;
        }
        let oldValues = [];
        if(object._setterScope){
            var setterScope = object._setterScope;
        }
        var checkSim = false, watch = [];
        if(object._scp && object._scp.size){
            var keys = Array.from(object._scp.keys()), obj;
            keys.forEach(function(id){
                var _obj = object._scp.get(id);
                obj = _obj.paths;
                var recObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.nestScp[id], model, field, rec, attr, wobj = {};
                var pathArr = Object.keys(obj), aPath;
                if(pathArr.length > 1){
                    aPath = "*";
                }
                else if(pathArr.length == 1){
                    aPath = pathArr[0];
                }
                wobj.path = aPath;
                wobj.id = id;
                if(pathArr.length > 1){
                    wobj.paths = pathArr;
                }
                wobj.attr = attr;
                wobj.data = recObj.data;
                wobj.dtype=recObj.dtype||undefined;
                wobj.key=recObj.key||undefined;
                wobj.Error=recObj.Error||undefined;
                var db = recObj.db;
                if(recObj.model){
                    var mMap = recObj.model;
                    var mKeys = Array.from(recObj.model.keys());
                    for(var i=0; i<mKeys.length; i++){
                        var mName = mKeys[i];
                        var pkMap = mMap.get(mName);
                        if(pkMap){
                            var pkArr = Array.from(pkMap.keys());
                            var pkLen = pkArr.length;
                            for(var j=0; j<pkLen; j++){
                                var mPk = pkArr[j];
                                var attrMap = pkMap.get(mPk);
                                var attrArr = Array.from(attrMap.keys());
                                var attrLen = attrArr.length;
                                for(k=0; k<attrLen; k++){
                                    var mAttr = attrArr[k];
                                    var mObj = Object.assign({}, wobj);
                                    if(db.getSchema){
                                        var mRec = recObj.db.cache.getEntity({schema:db.getSchema(mName), pK:mPk});
                                    }
                                    else{
                                        var mRec = recObj.db.cache.getEntity({model:db.getModel(mName), pK:mPk});
                                    }
                                    if(mRec){
                                        model = mRec.$.schema ? mRec.$.schema : mRec.$.model;
                                        field = model.fieldList[mAttr];
                                        if(field && field.watch == true){
                                            mObj.data = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(mRec[mAttr]);
                                            mObj.rec = mRec;
                                            mObj.isRec = true;
                                            mObj.attr = mAttr;
                                            mObj.dtype = model.fieldList[mAttr];
                                            mObj.Error=mRec.$.error;
                                        }
                                        watch.$push(mObj);
                                    }
                                }
                            }
                        }
                    }
                } 
                else{
                    watch.$push(wobj);
                }         
            });
            watch.forEach(function(val){
                if((!options || (typeof options == "object" && options.skipValidation != true)) && (val.dtype || val.rec) ){
                    var id = val.id,path=val.path.split("."),dtype=val.dtype;
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.checkNestedProp)(id,path,dtype,val,object,property,value,check);
                    if(object.$ && Object.values(object.$.error).length==0){
                        delete object.$
                    };
                }
            })
            if(check.value && check.value.code){
                return;
            }
        }
        actualProperty = actualProperty === property ? actualProperty : undefined;
        var shareObj = {};
        if(typeof property === "object"){
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(object) && !fromStore && !object.$.isCloned) {
                    // for(let key in property){
                    //     if(Array.isArray(object[key])){
                    //         oldValues.$push({key:key,oldValue:object[key].slice(0)});    
                    //     }
                    //     else{
                    //         oldValues.$push({key:key,oldValue:object[key]});
                    //     }
                    // }
                    for(let key in property) {
                        let locValue = property[key];
                        let dataType = object.$.schema ? object.$.schema.fieldList[key] : object.$.model.fieldList[key];
                        dataType = dataType ? dataType.type : undefined;
                        if(dataType && (locValue !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(locValue)) {
                            property[key] = _LC.typeCast(locValue, dataType);
                        }
                    }
                    let record = (0,_slyte_data_src_utils__WEBPACK_IMPORTED_MODULE_7__.setData)(object.$, property, undefined, options, undefined, undefined, shareObj);
                    if(record.$.isError){
                        return record;
                    }
                    // for(let i=0; i<oldValues.length; i++){
                    //     _LC.update(object,oldValues[i].key,object[oldValues[i].key],fromStore,(oldValues[i].oldValue === undefined)?null:oldValues[i].oldValue ,setterScope, actualProperty, fromParent);
                    // }
            } else {
                //object[property] =  value;
                for(let key in property){
                    //_LC.update(object,key,property[key],fromStore,undefined,setterScope, actualProperty, fromParent);
                    //value is option here
                    _LC.set(object, key, property[key], value, fromStore, fromParent);
                }
            }
        }
        else{
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(object) && (!fromStore || (fromStore && recDottedProp)) && !object.$.isCloned) {
                let old = object[property];
                let dataType = object.$.schema ? object.$.schema.fieldList[property] : object.$.model.fieldList[property];
                dataType = dataType ? dataType.type : undefined;
                if(dataType && (value !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(value)) {
                    value = _LC.typeCast(value, dataType);
                }
                let record = (0,_slyte_data_src_utils__WEBPACK_IMPORTED_MODULE_7__.setData)(object.$, property,value, options, undefined, undefined, shareObj);
                if(record.$.isError){
                    return record;
                }
                //Commented because update will happend when "set" is called from setData of store. 
                //_LC.update(object,property,value,fromStore,(old === undefined) ? null : old,setterScope , actualProperty);    
            } else {
                _LC.update(object,property,value,options,fromStore,undefined,setterScope,actualProperty, fromParent, FromUtils, s_rec);
            }
        }
        if(watch && watch.length){
            watch.forEach(function(obj){
                if(obj.isRec){
                    (0,_slyte_data_src_utils__WEBPACK_IMPORTED_MODULE_7__.deepValueChange)(obj.rec, obj.attr, obj.rec[obj.attr], obj);
                }
            });
        }
    },
    "adCx" : function(node, contextSwitchArray) {
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
        } else if(isYield && node._callee._cx) {
            _LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
        }
    }, 
    "rmCx" : function(node, contextSwitchArray) {
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
        } else if(isYield && node._callee._cx) {
            _LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
        }
    },
    "changeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
        if(!contextSwitchInfo) {
            return;
        }
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
        } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
            _LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx);
        }
        if(isYield) {
            let insertYield = node._registerYield;
            let callee = insertYield._callee;
            if(callee && callee._cx) {
                _LC.changeContext(callee._cx.node, contextSwitchArray, callee._cx);
            }
        }
        let indexValue, itemValue;
        if(contextSwitchInfo.type) {
            if(contextSwitchInfo.type === "for") {
                indexValue = node.getAttribute("index");
                itemValue = node.getAttribute("item");
                if(node._items.length === 0) {
                    return;
                }
            } else {
                indexValue = node.getAttribute("key");
                itemValue = node.getAttribute("value");
                if(Object.keys(node._items).length === 0) {
                    return;
                }
            }
            let callee = node._callee;
            let initialItemValue = callee.component.data[itemValue];
            let initialIndexValue = callee.component.data[indexValue];
            let initialItemProp = callee._properties[itemValue];
            let initialIndexProp = callee._properties[indexValue];
             let items = contextSwitchInfo.type === "for" ? node._currentItems : node._currentObject;
            callee.component.data[itemValue] = items[contextSwitchInfo.itemIndex];
            callee.component.data[indexValue] = contextSwitchInfo.itemIndex;
            callee._properties[itemValue] = node._items[contextSwitchInfo.itemIndex].itemProperty;
            callee._properties[indexValue] = node._items[contextSwitchInfo.itemIndex].indexProperty;
            let dummyObject = {"initialItemValue" : initialItemValue , "initialIndexValue" : initialIndexValue, "initialItemProp" : initialItemProp, "initialIndexProp" : initialIndexProp};
            contextSwitchArray.$push(dummyObject);
        } else {
            //handling for yield
            let dummyObject = {};
            let callee = node._registerYield._callee;
            Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                dummyObject[key] = {};
                dummyObject[key].value = callee.component.data[key];
                dummyObject[key].property = callee._properties[key];
                callee._properties[key] = contextSwitchInfo.node._properties[key];
                callee.component.data[key] = contextSwitchInfo.node.component.data[key];
            }); 
            contextSwitchArray.$push(dummyObject);
        }
    },
    "removeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
        if(!contextSwitchInfo) {
            return;
        }
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
        } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
            _LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx)
        }
        if(isYield) {
            let insertYield = node._registerYield;
            let callee = insertYield._callee;
            if(callee && callee._cx) {
                _LC.removeContext(callee._cx.node, contextSwitchArray, callee._cx);
            }
        }
        let indexValue, itemValue;
        if(contextSwitchInfo.type) {
            if(contextSwitchInfo.type === "for") {
                indexValue = node.getAttribute("index");
                itemValue = node.getAttribute("item");
                if(node._items.length === 0) {
                    return;
                }
            } else {
                indexValue = node.getAttribute("key");
                itemValue = node.getAttribute("value");
                if(Object.keys(node._items).length === 0) {
                    return;
                }
            }
            let callee = node._callee;
            let items = node._attributes.items;
            let removedObject = contextSwitchArray.$shift();
            callee.component.data[itemValue] = removedObject.initialItemValue;
            callee.component.data[indexValue] = removedObject.initialIndexValue;
            callee._properties[itemValue] = removedObject.initialItemProp;
            callee._properties[indexValue] = removedObject.initialIndexProp;
        } else {
            let callee = node._registerYield._callee;
            let removedObject = contextSwitchArray.$shift();
            Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                callee.component.data[key] = removedObject[key].value;
                callee._properties[key] = removedObject[key].property;
            });
        }
    },
    "objectUtils" : function(){
        return _LC.oF.apply(_LC, arguments);
    },
    "sortCommands" : function(array1, arrayB) {
        var retVal = {};
        var arrayA = array1.slice();
        retVal.origianlArray = array1;
        var commands = [];
        
        for (let i = 0; i < arrayB.length; i++) {
            // var targetIndex = arrayA.findIndex((element) => element === arrayB[i]);
            var targetIndex = arrayA.indexOf(arrayB[i]);
        
            if (targetIndex === -1) {
            commands.push({
                type: 'Add',
                element: arrayB[i], 
                toIndex : i
            });
            arrayA.splice(i, 0, arrayB[i]);
            } else {
            if (targetIndex !== i) {
                commands.push({
                type: 'Move',
                element: arrayB[i],
                fromIndex: targetIndex,
                toIndex: i
                });
                arrayA.splice(targetIndex, 1);
                arrayA.splice(i, 0, arrayB[i]);
            }
            }
        }
        
        for (let i = arrayA.length - 1; i >= arrayB.length; i--) {
            commands.push({
            type: 'Remove',
            element: arrayA[i]
            });
            arrayA.splice(i, 1);
        }
        retVal.commands = commands;
        retVal.changedArray = arrayB;
        return retVal;
    },
    "oF" : function() {
        let object = arguments[0];
        let functionName = arguments[1];
        let property = arguments[2];
        let newValue = arguments[3];
        let fromComponent = arguments[4];
        let fromStore = arguments[5];
        if(functionName === "add" && !fromComponent) {
            let obj = {type:"change","oldValue":object[property],"newValue":newValue,"item":property};
            _LC.set(object, property, newValue,undefined, fromStore,undefined,true);
            _LC.callObjectObservers(object,obj);
            return;
        }
        let options = {};
        options.type = functionName;
        options.property = property;
        if(!/^(add|delete)$/.test(functionName)) {
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC001", functionName);
            //@Slicer.developmentEnd
            return;
        }
        let bindings = object._bindings;
        if(functionName === "delete") {
            let obj = {type:"change","oldValue":object[property],"newValue":newValue,"item":property};
            _LC.set(object, property, undefined, undefined, fromStore,undefined,true);
            _LC.callObjectObservers(object,obj);
        } else {
            object[property] = newValue;
        }
        if(bindings) {
            let bind = bindings.toArrayLyte();
            for(let i=0;i<bind.length;i++) {
                let binding = bind[i];
                let forHelpers = binding._forHelpers;
                if(forHelpers) {
                    let helperBind = forHelpers.toArrayLyte();
                    for(let j=0;j<helperBind.length;j++) {
                        let forHelper = helperBind[j];
                        if(forHelper.getAttribute("is") != "forIn"){
                            continue;
                        }
                        let itemValue = forHelper.getAttribute("key");
                        //Need to check
//                            _LC.removeSelectedBindingDeep({[itemValue] :                        forHelper._items[property].itemProperty}, {[itemValue] : object[property]});
                        let contextSwitchArray = [];
                        if(functionName === "add") {
                            _LC.adCx(forHelper, contextSwitchArray);
                        }
                        forHelper._callee.updateForInHelper(forHelper, options);
                        if(functionName === "add") {
                            _LC.rmCx(forHelper, contextSwitchArray);
                        }
                    }
                }
            }
        }
        if(functionName === "delete") {
            delete object[property];
        }
    },
    "arrayUtils" : function(){
        return _LC.aF.apply(_LC, arguments);
    },
    "aF" : function() {
        var argumentsArr = Array.from(arguments);
        var fromOverride = false;
        if(argumentsArr[0] && typeof argumentsArr[0] == "object" && argumentsArr[0].fromOverride){
            argumentsArr.$shift();
            fromOverride = true;
        }
        let array = argumentsArr[0];
        let initialArrLength = array.length;
        let callLengthObserver = true;
        let functionName = argumentsArr[1];
        let value = arguments[3],check={};
        if(/^(replaceAt|removeAt|shift)$/.test(functionName) && !array.length) {
            //@Slicer.developmentStart
            _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn(functionName + " operation cannot be performed on empty array");
            //@Slicer.developmentEnd
            return;
        }
        let commands;
        if(functionName == "sort") {
            var originalArray = arguments[0];
            var sortFunction = arguments[2];
            var addedArguments = arguments[3] || [];
            var dummyArray = originalArray.slice();
            addedArguments.forEach(function(item) {
                dummyArray.push(item);
            });
            if(typeof arguments[2] == "function") {
                dummyArray.sort(sortFunction);
            } else {
                var obj = arguments[2];
                var key = obj.sortBy;
                var order = obj.sortOrder;
                function sorting(item1, item2) {
                    var item1 = key ? item1[key] : item1;
                    var item2 = key ? item2[key] : item2;
                    if(item1 > item2) {
                        return order ? 1 : -1;
                    } else if(item1 < item2) {
                        return order ? -1 : 1;
                    } else {
                        return 0;
                    }
                }
                dummyArray.sort(sorting)
            }
            commands = this.sortCommands(originalArray, dummyArray).commands;
        }
        let commArgs = arguments[2], oldVal, obsObj, watch = [];
        if(array._scp && /^(replaceAt|splice|removeAt|remove|insertAt)$/.test(functionName)){
            array._scp.forEach(function(_obj, id){
                var rec, attr, wobj = {};
                var recObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.nestScp[id];
                var obj = _obj.paths;
                var pathArr = Object.keys(obj), aPath;
                if(pathArr.length > 1){
                    aPath = "*";
                }
                else if(pathArr.length == 1){
                    aPath = pathArr[0];
                }
                wobj.path = aPath;
                wobj.id = id;
                if(pathArr.length > 1){
                    wobj.paths = pathArr;
                }
                wobj.attr = attr;
                wobj.data = recObj.data;
                wobj.reInit = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(recObj.data) || (Array.isArray(recObj.data) && (recObj.data.schema || recObj.data.model) && recObj.data.add);
                wobj.dtype=recObj.dtype||undefined;
                wobj.key=recObj.key||undefined;
                wobj.Error=recObj.Error||undefined;
                wobj.index=commArgs;
                if(recObj.model){
                    var mMap = recObj.model;
                    var mKeys = Array.from(recObj.model.keys());
                    for(var i=0; i<mKeys.length; i++){
                        var mName = mKeys[i];
                        var pkMap = mMap.get(mName);
                        if(pkMap){
                            var pkArr = Array.from(pkMap.keys());
                            var pkLen = pkArr.length;
                            for(var j=0; j<pkLen; j++){
                                var mPk = pkArr[j];
                                var attrMap = pkMap.get(mPk);
                                var attrArr = Array.from(attrMap.keys());
                                var attrLen = attrArr.length;
                                for(k=0; k<attrLen; k++){
                                    var mAttr = attrArr[k];
                                    var mObj = Object.assign({}, wobj);
                                    if(recObj.db.getSchema){
                                        var mRec = recObj.db.cache.getEntity({schema:recObj.db.getSchema(mName), pK:mPk});
                                    }
                                    else{
                                        var mRec = recObj.db.cache.getEntity({model:recObj.db.getModel(mName), pK:mPk});
                                    }
                                    if(mRec){
                                        var model = mRec.$.schema ? mRec.$.schema : mRec.$.model;
                                        var field = model.fieldList[mAttr];
                                        if(field && (field.properties || field.items || field.watch == true)){
                                            mObj.data = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(mRec[mAttr]);
                                            mObj.rec = mRec;
                                            mObj.isRec = true;
                                            mObj.attr = mAttr;
                                            mObj.dtype = model.fieldList[mAttr];
                                            mObj.Error=mRec.$.error;
                                            mObj.key=mAttr;
                                        }
                                        // mObj.reInit = true;
                                        watch.push(mObj);
                                    }
                                }
                            }
                        }
                    }
                } 
                else{
                    wobj.reInit = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.isEntity)(recObj.data) || (Array.isArray(recObj.data) && (recObj.data.schema || recObj.data.model ) && recObj.data.add);
                    watch.push(wobj);
                }
            });
            watch.forEach(function(val){
                if((val.dtype || val.rec) ){
                    var id = val.id,path=val.path.split("."),dtype=val.dtype;
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.checkNestedProp)(id,path,dtype,val,array,path,commArgs,check);
                    if(array.$ && Object.values(array.$.error).length==0){
                        delete array.$
                    };
                }
            });
            if(check.value && check.value.code){return;}
        }  
        switch(functionName) {
        case "replaceAt" : 
            {
            let index = parseInt(argumentsArr[2]);
            if(index > array.length) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("index provided for replaceAt is greater than array length");
                return [];
            }
            //let args = Array.prototype.slice.call(argumentsArr, 3);
            let args = argumentsArr[3];
            if(!(Array.isArray(args))) {
                args = [args];
            }
            else if(fromOverride){
                args = [args];
            }
            let deletedItems = array.$splice.apply(array, [index, 1].$concat(args));
            let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "replace"};
            //All references updated by now
            if(options.secondIndex == 1){
                callLengthObserver = false;
            }
            //remove binding from previous object
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item._forHelpers) {
                        let helperbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<helperbind.length;j++){
                            let helper = helperbind[j];
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            /*if(helper.hasAttribute("unbound")) {
                                continue;
                            }*/
                            let finalIndex = index + deletedItems.length;
                            let itemValue = helper.getAttribute("item");
                            for(let i=index, j=0;i<finalIndex;i++,j++) {
                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
                    for(let key in item) {
                        let parsedKey = parseInt(key);
                        let cond = (options.secondIndex == 1) ? (parsedKey == options.firstIndex) : (parsedKey >= options.firstIndex);
                        if(!isNaN(parsedKey) && cond) {
                            let diff = parsedKey - options.firstIndex;
                            let oldObject;
                            if(diff < 1) {
                                oldObject = deletedItems[diff];
                            } else {
                                oldObject = array[options.firstIndex - 1  + options.secondIndex + diff];
                            }
                            this.removeSelectedBindingDeep(item[key], oldObject);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                            }
                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                            if(options.secondIndex == 1){
                                break; 
                            }
                        }
                    }
                }
            }
            obsObj = {type:"array",insertedItems:args, removedItems:deletedItems, index:index};
            _LC.bindWatchObj(watch, array, args, deletedItems, index);
            _LC.callArrayObservers(array,obsObj,callLengthObserver,initialArrLength);
            return deletedItems[0];
            }
            break;
        case "splice" : {
            let index = parseInt(argumentsArr[2]);
            if(index > array.length) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("index provided is greater than array length");
                return [];
            }
            let toBeDeleted = argumentsArr.length > 3 ? argumentsArr[3] : array.length - index;
            let args;
            let skip = false;
            if(argumentsArr.length > 4){
                args = argumentsArr[4]
            }else{
                args = []
                skip = true;
            }
            if(!(Array.isArray(args))) {
                args = [args];
            }
            else if(!skip && fromOverride){
                args = [args];
            }
            let deletedItems = array.$splice.apply(array, [index, toBeDeleted].$concat(args));
            let options = {"firstIndex" : index, "secondIndex" : args.length, "thirdIndex" : toBeDeleted, "type" : "splice"};
            //All references updated by now
            if(options.secondIndex == options.thirdIndex){
                callLengthObserver = false
            }
            //remove binding from previous object
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item._forHelpers) {
                        let helperbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<helperbind.length;j++){
                            let helper = helperbind[j];
                            /*if(helper.hasAttribute("unbound")) {
                                continue;
                            }*/
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let finalIndex = index + deletedItems.length;
                            let itemValue = helper.getAttribute("item");
                            for(let i=index, j=0;i<finalIndex;i++,j++) {
                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
                    for(let key in item) {
                        let parsedKey = parseInt(key);
                        var cond = options.secondIndex == options.thirdIndex ? key >= options.firstIndex && key < (options.firstIndex+options.secondIndex) : parsedKey >= options.firstIndex;
                        if(!isNaN(parsedKey) && cond) {
                            let diff = parsedKey - options.firstIndex;
                            let oldObject;
                            if(diff < options.thirdIndex) {
                                oldObject = deletedItems[diff];
                            } else {
                                oldObject = array[options.firstIndex - options.thirdIndex  + options.secondIndex + diff];
                            }
                            this.removeSelectedBindingDeep(item[key], oldObject);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                            }
                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                        }
                    }
                }
            }
            obsObj = {type:'array',index:index,insertedItems:args, removedItems:deletedItems};
            _LC.bindWatchObj(watch, array, args, deletedItems, index);
            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);
            return deletedItems;
        }
        break;
        case "push" : 
            {
            let toPush = argumentsArr[2];
            if(fromOverride && argumentsArr.length > 3){
                toPush = argumentsArr.$splice(2,argumentsArr.length);
            }
            else if(!(Array.isArray(toPush))) {
                toPush = [toPush];
            }
            else if(fromOverride){
                toPush = [toPush];
            }
            _LC.aF(array, 'insertAt', array.length, toPush);
            }
            break;
        case "pop" : 
               return _LC.aF(array, 'remove', array.length -1)[0];
            break;
        case "shift" : 
        case "shiftObject" :
              return _LC.aF(array, 'remove', 0)[0];
              break;
        case "removeAt" : 
        case "remove" : 
            {
            let index = parseInt(argumentsArr[2]);
            if(index > array.length) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("index provided for removeAt is greater than array length");
                return [];
            }
            let length = argumentsArr[3] ? parseInt(argumentsArr[3]) : 1;
            let options = {"firstIndex" : index, "secondIndex" : length, "type" : "remove"};
            let deletedItems = array.$splice(index,length);
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item._forHelpers) {
                        let helperbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<helperbind.length;j++){
                            let helper = helperbind[j];
                            /*if(helper.hasAttribute("unbound")) {
                                continue;
                            }*/
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let finalIndex = index + deletedItems.length;
                            let itemValue = helper.getAttribute("item");
                            for(let i=index, j=0;i<finalIndex;i++,j++) {
                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                       }
                        for(let key in item) {
                        let parsedKey = parseInt(key);
                        if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                            let diff = parsedKey - options.firstIndex;
                            let oldObject;
                            if(diff < options.secondIndex) {
                                oldObject = deletedItems[diff];
                            } else {
                                oldObject = array[options.firstIndex - options.secondIndex + diff];
                            }
                            this.removeSelectedBindingDeep(item[key], oldObject);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                            }
                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                        }
                    }
                }
            }
            obsObj = {type:"array",removedItems:deletedItems,index:index};
            _LC.bindWatchObj(watch, array, undefined, deletedItems, index);
            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength); 
            return deletedItems;
            }
            break;
        case "removeObject" : 
                commArgs = [commArgs];
        case "removeObjects" :
            if(!(Array.isArray(commArgs))) {
                commArgs = [commArgs];
            }
            else if(fromOverride){
                commArgs = [commArgs];
            }
            if(commArgs == array){
                commArgs = Array.from(commArgs);// both array are same instance so cloning
            }
            for(var i=0;i<commArgs.length;i++) {
                let inde = array.indexOf(commArgs[i]);
                if(inde !== -1) {
                   _LC.aF(array, 'removeAt', inde);                         
                }
            }
            //Lyte.arrayUtils(array, 'removeObject', actObj);
            //Lyte.arrayUtils(array, 'removeObjects', []);
        break;
        case "unshift" : 
        case "unshiftObject" : 
        case "unshiftObjects" : 
            //_LC.aF.apply(_LC, [array, 'insertAt', 0].$concat(Array.prototype.slice.call(argumentsArr, 2)));
            {
            let toPush = argumentsArr[2];
            if(!(Array.isArray(toPush))) {
                toPush = [toPush];
            }
            else if(fromOverride){
                toPush = [toPush];
            }
            _LC.aF(array, 'insertAt', 0, toPush);
            }
            break;
        case "insertAt" : 
            {
            let index = parseInt(argumentsArr[2]);
            //let args = Array.prototype.slice.call(argumentsArr, 3);
            let args = argumentsArr[3];
            let len = args.length;
            if(!(Array.isArray(args))) {
                args = [args];
            }
            else if(fromOverride){
                args = [args];
            }
            for(let i=index;i>array.length;i--) {
                args.$unshift(undefined);
                index--;
            }
            let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "insert"};
            array.$splice.apply(array, [index, 0].$concat(args));
            if(array._bindings) {
                let arrbind = array._bindings.toArrayLyte();
                for(let i=0;i<arrbind.length;i++){
                    let item = arrbind[i];
                    if(item._forHelpers) {
                        let forbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<forbind.length;j++){
                            /*if(forbind[j].hasAttribute("unbound")) {
                                continue;
                            }*/
                            let helper = forbind[j];
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
                    for(let key in item) {
                        let parsedKey = parseInt(key);
                        if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                            this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
                            }
                            this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
                        }
                    }
                }
            }
            let position = parseInt(argumentsArr[2]);
            obsObj = {type:"array",insertedItems:(!(Array.isArray(argumentsArr[3]))) ? [argumentsArr[3]]: argumentsArr[0].slice(position,position+len),index:position};
            _LC.bindWatchObj(watch, array, args, undefined, position);
            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);                
            }
            break;
        case "concat" : 
            //_LC.aF.apply(_LC, [array, 'insertAt',array.length].$concat(argumentsArr[2]));
            _LC.aF(array, 'insertAt', array.length, argumentsArr[2]);
            break;
        case "sort" : 
            let optionsArray = [];
            commands.forEach(function(command) {
                switch(command.type) {
                    case "Remove" : {
                        let removedItems = array.splice(command.toIndex, 1);
                        optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                    }
                    break;
                    case "Move" : {
                        let removedItems = array.splice(command.fromIndex, 1);
                        array.splice(command.toIndex, 0, command.element);
                        optionsArray.push({"firstIndex" : command.fromIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                        // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                        optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                    }
                    break;
                    case "Add" : {
                        array.splice(command.toIndex, 0, command.element);
                        // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                        optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                    }
                    break;
                }
            });
            if(array._bindings) {
                let arrbind = array._bindings.toArrayLyte();
                for(let i=0;i<arrbind.length;i++){
                    let item = arrbind[i];
                    if(item._forHelpers) {
                        let forbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<forbind.length;j++){
                            /*if(forbind[j].hasAttribute("unbound")) {
                                continue;
                            }*/
                            let helper = forbind[j];
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            for(let j=0;j<optionsArray.length;j++) {
                                let optionItem = optionsArray[j];
                                // Removal of bindings
                                let itemValue = helper.getAttribute("item");
                                if(optionItem.type == "remove") {
                                    this.removeSelectedBindingDeep({[itemValue] : helper._items[optionItem.firstIndex].itemProperty}, {[itemValue] : optionItem.removedItem});
                                }
                                helper._callee.updateForHelper(helper, optionItem);
                            }
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
//                         for(let key in item) {
//                             let parsedKey = parseInt(key);
//                             if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
//                                 this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
//                                 if(item[key]._forHelpers) {
//                                     let bindfor = item[key]._forHelpers.toArrayLyte();
//                                     for(var j=0;j<bindfor.length;j++){
//                                         let item1 = bindfor[j];
//                                         if(item1._propBindingObject) {
//                                             this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
// //                                          value._bindings.add(item._propBindingObject);
// //                                          this.establishBindings(item._propBindingObject, value);
//                                         }
//                                     }
//                                 }
//                                 if(array[parsedKey] && typeof array[parsedKey] === "object") {
//                                 	makeSet(array[parsedKey], "_bindings");
//                                 this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
//                                 }
//                                 this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
//                             }
//                         }
                }
            }
            break;
        default: 
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC002", functionName);
            //@Slicer.developmentEnd
            return;
        }
        return array;
    },
    "callDeepObservers" : function (data, args, property ,callLengthObserver){
        var self = this;
        var keys = Array.from(data._scp.keys());
        keys.forEach(function(id){
            var _scp = data._scp.get(id), 
            scp = _scp.paths,
            pathArr = Object.keys(scp), 
            aPath;
            if(pathArr.length == 1){
                aPath = pathArr[0];
            }
            else if(pathArr.length > 1){
                aPath = pathArr;
            }
            var recObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.nestScp[id], 
            attr, 
            rec, 
            isRec = false;
            if(recObj.model){
                var mMap = recObj.model;
                var db = recObj.db;
                var mKeys = Array.from(recObj.model.keys());
                for(var i=0; i<mKeys.length; i++){
                    var mName = mKeys[i];
                    var pkMap = mMap.get(mName);
                    if(pkMap){
                        var pkArr = Array.from(pkMap.keys());
                        var pkLen = pkArr.length;
                        for(var j=0; j<pkLen; j++){
                            var mPk = pkArr[j];
                            var attrMap = pkMap.get(mPk);
                            var attrArr = Array.from(attrMap.keys());
                            var attrLen = attrArr.length;
                            for(k=0; k<attrLen; k++){
                                var mAttr = attrArr[k];
                                if(db.getSchema){
                                    var mRec = db.cache.getEntity({schema:db.getSchema(mName), pK:mPk});
                                }
                                else{
                                    var mRec = db.cache.getEntity({model:db.getModel(mName), pK:mPk});
                                }
                                self.deepObsBind(mRec, true, mAttr, args, pathArr, aPath, data, property, callLengthObserver)                                    
                            }
                        }
                    }
                }
            } 
            else{
                rec = recObj.data;
                self.deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver)
            }
        });
    },
    "deepObsBind":function(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver){
        var type = args.type
        var watchPath , propPath;
        if(rec._bindings){
            var newArgs = Object.assign({},args);
            var objbind = rec._bindings.toArrayLyte();
            for (var _i65 = 0; _i65 < objbind.length; _i65++) {
                propPath = aPath;
                var binding = objbind[_i65], obj = undefined;
                watchPath = objbind[_i65]._path
                if(isRec){
                    if(binding.hasOwnProperty(attr) && binding[attr].hasOwnProperty("*")){
                        obj = binding[attr]["*"];
                        watchPath = binding[attr]._path;
                    } 
                }
                else if(binding.hasOwnProperty("*")){
                    obj = binding["*"];
                }
                if(obj){
                    var obsbind = obj._observers ? obj._observers.toArrayLyte() : [], path;
                    if(property){
                        if(pathArr.length > 1){
                            var len = pathArr.length, nPathArr = [];
                            for(var i=0;i<len;i++){
                                nPathArr.push(pathArr[i] ? pathArr[i]+"."+property : property);
                            }
                            propPath = nPathArr;
                        }
                        else if(pathArr.length == 1){
                            propPath = aPath ? aPath.concat("." + property) : property;
                        }
                    }
                    for (var j = 0; j < obsbind.length; j++) {
                        var observer = obsbind[j];
                        newArgs.path = propPath;
                        newArgs.type = "deepChange";
                        newArgs.data = rec;
                        var argPath = obj._path.split('.');
                        argPath.$pop();
                        newArgs.item = argPath.join('.'); 
                        var exactPath = newArgs.index!=undefined?(propPath!=""?propPath+".":propPath)+newArgs.index:propPath
                        if(observer.callee && observer.callee.component){
                            //  observer.observer.value.call(observer.callee.component, newArgs);
                            var calldeep = true;
                            var _data = observer.callee.component.__data[newArgs.item];
                            var _watch = _data ? _data.watch : undefined;
                            if(_data && typeof _watch != "boolean"){
                                var watchArr = obsbind[j].observer.Jpath[watchPath];
                                calldeep = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.checkWatchPath)(exactPath , watchArr);
                            }
                            if(calldeep){
                                observer.observer.value.call(observer.callee.component, newArgs);
                            }
                        }
                        else{
                            var scope = data._setterScope ? data._setterScope : window;
                            if(Array.isArray(scope)){
                                var sLen = scope.length;
                                for(var k=0;k<sLen;k++){
                                    var itm = scope[k];
                                    var calldeep = true;
                                    if(newArgs.data && newArgs.hasOwnProperty("item")){
                                        var watchArr = newArgs.data.$.schema._fldGrps.watch[newArgs.item].watch
                                        if(Array.isArray(watchArr)){
                                            watchArr = obsbind[j].observer.Jpath[watchPath];
                                            calldeep = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.checkWatchPath)(exactPath , watchArr);
                                        }
                                    }
                                    if(calldeep){
                                        observer.observer.value.call(itm, newArgs);
                                    }
                                }
                            }
                            else{
                                var calldeep = true;
                                if(newArgs.data && newArgs.hasOwnProperty("item")){
                                    var watchArr = newArgs.data.$.schema._fldGrps.watch[newArgs.item].watch
                                    if(Array.isArray(watchArr)){
                                        watchArr = obsbind[j].observer.Jpath[watchPath];
                                        calldeep = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.checkWatchPath)(exactPath , watchArr);
                                    }
                                }
                                if(calldeep){
                                    observer.observer.value.call(scope, newArgs);
                                }
                            }
                        }
                    }
                }
                if (!callLengthObserver && type == "array" && binding.length) {
                    this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,callLengthObserver);
                }
            }
        }
    },
    "callArrayObservers" : function(array, args ,callLengthObserver ,initialArrLength) {
        if(array._scp && array._scp.size){
            this.callDeepObservers(array, Object.assign({},args) ,undefined, true);          
        }
        if(array._bindings) {
            let objbind = array._bindings.toArrayLyte();
            for(let i=0;i<objbind.length;i++){
                let binding = objbind[i];
                let path = objbind[i]._path;
                if(binding._observers) {
                    let obsbind = binding._observers.toArrayLyte();
                    for(let j=0;j<obsbind.length;j++){
                        let observer = obsbind[j];
                        if(observer.isArrayObserver) {
                            if(args){
                                args.item = path;
                            }
                            if(observer.callee && observer.callee.component){
                                observer.observer.value.call( observer.callee.component, args);
                            }
                            else{
                                var scope = array._setterScope ? array._setterScope : window;
                                if(Array.isArray(scope)){
                                    var sLen = scope.length;
                                    for(var k=0;k<sLen;k++){
                                        var itm = scope[k];
                                        observer.observer.value.call( itm, args);                                                        
                                    }
                                }
                                else{
                                    observer.observer.value.call(scope, args);
                                }
                            }
                        }
                    }
                }
                if(binding.length) {
                    this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,undefined,callLengthObserver);
                }
            }
        }
    },
    "callObjectObservers" : function(obj, args) {
        if(obj._bindings) {
            let objbind = obj._bindings.toArrayLyte();
            if(args.oldValue !== args.newValue){
                for(let i=0;i<objbind.length;i++){
                    let binding = objbind[i];
                    let path = objbind[i]._path;
                    if(binding["{}"]){
                        this.affectChanges(binding["{}"]);
                    }
                    if(binding._objectObservers && binding._observers) {
                        let obsbind = binding._observers.toArrayLyte();
                        for(let j=0;j<obsbind.length;j++){
                            let observer = obsbind[j];
                            if(observer.isObjectObserver) {
                                if(args){
                                    if(args.item){
                                        args.item = path + "." + args.item;
                                    }else{
                                        args.item = path;
                                    }
                                }
                                observer.observer.value.call( observer.callee && observer.callee.component ? observer.callee.component : obj._setterScope? obj._setterScope : window , args);
                            }
                        }
                    }
                }
            }
        }
    },
    "bindWatchObj" : function(watch, data, insItems, remItems, pos){
        if(watch && watch.length){
            watch.forEach(function(wObj){
                if(wObj.isRec){
                    (0,_slyte_data_src_utils__WEBPACK_IMPORTED_MODULE_7__.deepValueChange)(wObj.rec, wObj.attr, data, wObj);
                }
                if(remItems){
                    remItems.forEach(function(itm){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.removeNestScp)(itm, wObj.id, undefined, undefined, undefined, undefined, wObj.reInit ? wObj.data : undefined);
                    });
                }
                if(insItems){
                    insItems.forEach(function(itm,idx){
                        if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                            var pth = wObj.path.split(',');
                            pth.$push(pos+idx);
                            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.bindObj)(itm, undefined, wObj.id,  pth && pth.length ? pth : [], undefined, undefined, true);
                        }
                    });
                }
                if(pos !== undefined){
                    var nestObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.nestScp[wObj.id];
                    if(nestObj.cyclic){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.removeNestScp)(nestObj._data, wObj.id);
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.bindObj)(nestObj._data, undefined, wObj.id, [], undefined, undefined, true);
                    }
                    else{
                        var insLen = insItems ? insItems.length : 0, newInd = pos+insLen;
                        var arr = data.slice(newInd);
                        arr.forEach(function(itm){
                            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.removeNestScp)(itm, wObj.id);
                        });
                        arr.forEach(function(itm,idx){
                            if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                                var pth = wObj.path.split(',');
                                pth.$push(newInd+idx);
                                (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.bindObj)(itm, undefined, wObj.id,  pth && pth.length ? pth : [], undefined, undefined, true);
                            }
                        });
                    }
                }
            });
        }
    },
    "establishUpdateBindings" : function(bindings, property, actualData) {
        let objbind = bindings.toArrayLyte();
        for(let i=0;i<objbind.length;i++){
            let item = objbind[i];
            if(item[property]) {
                makeSet(actualData, "_bindings");
                addBindings(actualData._bindings,item[property]);
                this.establishBindings(item[property], actualData);
            }

        }
    },
    "establishSelectedBinding" : function(property, actualData,node) {
        if(!property) {
            return;
        }
        let propName = property._path;
        let props = propName.split('.');
        let currentProp = node.getProperty(props[0]);
        let currentValue = actualData[props[0]];
        for(let i=0;i<props.length;i++) {
            if(!currentValue || typeof currentValue !== "object") {
                break;
            } 
            makeSet(currentValue, "_bindings");
                addBindings(currentValue._bindings,currentProp);
                currentProp = currentProp[props[i+1]];
                currentValue = currentValue[props[i+1]];
        }
    },
    "establishBindings": function(properties, actualData) {
        if(properties._helperNodes) {
            let path = properties._path;
            let arr = properties._helperNodes.toArrayLyte();
            for(let s=0;s<arr.length;s++) {
                let nodes = arr[s]._dynamicProperty ? arr[s]._dynamicProperty[path]: undefined;
                if(nodes) {
                    for(let j=0;j<nodes.length;j++) {
                        let node = nodes[j];
                        let helper = node.ownerElement;
                        if(helper && helper.tagName === "TEMPLATE" && helper.getAttribute("is") === "for") {
                            if(helper._items) {
                                let item = helper.getAttribute("item");
                                for(let i=0;i<helper._items.length;i++) {
                                    let data = actualData[i];
                                    let item = helper.getAttribute("item");
                                    if(data) {
                                        if(typeof helper._items[i] === "object") {
                                            this.establishBindings(helper._items[i].itemProperty, {[item] : data});
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        for(let i in properties) {
            let actData = actualData[i];
            if(!actData || typeof actData === "string" || typeof actData === "number" || typeof actData === "boolean") {
                if(!actualData._bindings) {
                    makeSet(actualData, "_bindings");
                }
                addBindings(actualData._bindings,properties);
            } else {
                if(!actData._bindings) {
                    makeSet(actData, "_bindings");
                }
                addBindings(actData._bindings,properties[i]);
                if(typeof properties[i] === "object") {
                    this.establishBindings(properties[i], actData);
                }
            }
        }
    },
    "removeSelectedBindingDeep" : function(binding, actualData, fromDisConnect) {
        var del = "delete";
        if(!actualData && !fromDisConnect) {
            return;
        }
        if(actualData && actualData._bindings) {
            deleteBindingCheckSize(actualData, "_bindings", binding);
        }
        for(let i in binding) {
            let actData;
            if(actualData){
                actData = actualData[i];
            }   
            if(actData && actData._bindings) {
                deleteBindingCheckSize(actData, "_bindings", binding[i]);
            }
            if(typeof binding[i] === "object") {
                this.removeSelectedBindingDeep(binding[i], actData ,fromDisConnect);
            }
        }
        if(fromDisConnect){
            let dynNodes = binding._dynamicNodes;
            let helperNodes = binding._helperNodes;
            if(dynNodes && dynNodes.length){
                binding._dynamicNodes.$splice(0,dynNodes.length);   
            }
            if(helperNodes && helperNodes.size){
                helperNodes.clear();
            }
        }
        if(binding && binding._forHelpers) {
            let objbind = binding._forHelpers.toArrayLyte();
            for(let i=0;i<objbind.length;i++){
                let fH = objbind[i];
                if(fH.getAttribute("is") === "for") {
                    let item = fH.getAttribute("item");
                    let items = fH._attributes.items;
                    let itemCases = fH._items;
                    for(let i=0;i<itemCases.length;i++) {
                        this.removeSelectedBindingDeep(itemCases[i].itemProperty, items[i], fromDisConnect);
                    }
                } else {
                    if(fH._propBindingObject) {
                        if(actualData && actualData._bindings) {
                            deleteBindingCheckSize(actualData, "_bindings", fH._propBindingObject);
                            this.removeSelectedBindingDeep(fH._propBindingObject, actualData, fromDisConnect);
                        }
                    }
                }
            }
        }
    },
    "removeAllBindings" : function(properties, data) {
        var del = "delete";
        for(let key in properties) {
            if(data[key] && data[key]._bindings) {
//                    data[key]._bindings[del](properties[key]);
//                    if(!data[key]._bindings.size) {
//                        delete data[key]._bindings;
//                    }
                deleteBindingCheckSize(data[key], "_bindings", properties[key]);
            }
            if(data[key] && typeof data[key] !== "string") {
                _LC.removeAllBindings(properties[key], data[key]);
            }
        }
    },
    "affectChanges" : function(item, contextAlreadySwitched,oldValue,setterScope,newValue,stack,callLengthObserver) {
        if(item._dynamicNodes) {
            for(let i=0;i<item._dynamicNodes.length;i++) {
                item._dynamicNodes[i]._callee.updateNode(item._dynamicNodes[i], item._path);
            }
        }
        let propPath = item._path;
        if(item._helperNodes) {
            let nodes = [],itemHelperNodes = item._helperNodes.toArrayLyte();
            for(let s=0;s<itemHelperNodes.length;s++){
                if(!item._helperNodes.has(itemHelperNodes[s])) {
                    continue;
                }
                if(itemHelperNodes[s].getAttribute("is") === "for" && itemHelperNodes[s]._items) {
                    let innerContextSwitchArray = [];
                    _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                    let  indexValue = itemHelperNodes[s].getAttribute("index");
                    let itemValue = itemHelperNodes[s].getAttribute("item");
                    let callee = itemHelperNodes[s]._callee;
                    let initialItemValue = callee.component.data[itemValue];
                    let initialIndexValue = callee.component.data[indexValue];
                    let initialItemProp = callee._properties[itemValue];
                    let initialIndexProp = callee._properties[indexValue];
                    let items = itemHelperNodes[s]._attributes.items;
                    for(let i=0;i<itemHelperNodes[s]._items.length;i++) {
                        callee.component.data[itemValue] = items[i];
                        callee.component.data[indexValue] = i;
                        callee._properties[itemValue] = itemHelperNodes[s]._items[i].itemProperty;
                        if(itemHelperNodes[s]._items[i]._dynamicProperty[propPath]) {
                            nodes = itemHelperNodes[s]._items[i]._dynamicProperty[propPath];
                            for(let i=0;i<nodes.length;i++) {
                                nodes[i]._callee.updateNode(nodes[i], propPath);
                            }
                        }
                    }
                    callee.component.data[itemValue] = initialItemValue;
                    callee.component.data[indexValue] = initialIndexValue;
                    callee._properties[itemValue] = initialItemProp;
                    callee._properties[indexValue] = initialIndexProp;
                    _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);                                    
                } else if(itemHelperNodes[s].getAttribute("is") === "forIn" && itemHelperNodes[s]._items) {
                    let innerContextSwitchArray = [];
                    _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                    let  indexValue = itemHelperNodes[s].getAttribute("key");
                    let itemValue = itemHelperNodes[s].getAttribute("value");
                    let callee = itemHelperNodes[s]._callee;
                    let initialItemValue = callee.component.data[itemValue];
                    let initialIndexValue = callee.component.data[indexValue];
                    let initialItemProp = callee._properties[itemValue];
                    let initialIndexProp = callee._properties[indexValue];
                    let object = itemHelperNodes[s]._attributes.object;
                    for(let key in itemHelperNodes[s]._items) {
                        callee.component.data[itemValue] = object[key];
                        callee.component.data[indexValue] = key;
                        callee._properties[itemValue] = itemHelperNodes[s]._items[key].itemProperty;
                        if(itemHelperNodes[s]._items[key]._dynamicProperty[propPath]) {
                            nodes = itemHelperNodes[s]._items[key]._dynamicProperty[propPath];
                            for(let i=0;i<nodes.length;i++) {
                                nodes[i]._callee.updateNode(nodes[i], propPath);
                            }
                        }
                    }
                    callee.component.data[itemValue] = initialItemValue;
                    callee.component.data[indexValue] = initialIndexValue;
                    callee._properties[itemValue] = initialItemProp;
                    callee._properties[indexValue] = initialIndexProp;
                    _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);    
                } else {
                    nodes = itemHelperNodes[s]._dynamicProperty[item._path] || [];
                    let contextSwitchArray = [];
                    if(nodes.length) {
                        _LC.adCx(itemHelperNodes[s], contextSwitchArray);
                        for(let i=0;i<nodes.length;i++) {
                            nodes[i]._callee.updateNode(nodes[i], item._path);
                        }
                        _LC.rmCx(itemHelperNodes[s], contextSwitchArray);    
                    }
                    
                }
            }
        }
        if(item._observers) {
            let objbind = item._observers.toArrayLyte();
            let cond = callLengthObserver == false ? false : oldValue != undefined || newValue != undefined;
            if(cond){
                for(let i=0;i<objbind.length;i++){
                    let observer = objbind[i];
                    let obsObj = {type:"change",oldValue:oldValue,newValue:newValue, item: item._path};
                    if(observer.callee && observer.callee.component){
                        if(stack && observer.isObjectObserver){
                            obsObj.observer = observer;
                            stack.$push(obsObj);
                        }else{
                            observer.observer.value.call(  observer.callee.component, obsObj);                      
                        }
                    }
                    else{
                        var scope = setterScope ? setterScope : window;
                        if(Array.isArray(scope)){
                            var sLen = scope.length;
                            for(var k=0;k<sLen;k++){
                                var itm = scope[k];
                                observer.observer.value.call( itm, obsObj);
                            }
                        }
                        else{
                            observer.observer.value.call( scope, obsObj);                      
                        }
                    }
                }
            }
        }
        if(Array.isArray(item)){
            for(var i=0;i<item.length;i++){
                for(let key in item[i]) {
                    this.affectChanges(item[i][key], true,oldValue?(oldValue[i]?oldValue[i][key]:oldValue[i]):oldValue,setterScope,newValue?(newValue[i]?newValue[i][key]:newValue[i]):newValue);
                }
            }
        }
        else{
            for(let key in item) {
                var oldV = oldValue ? oldValue[key] : oldValue, newV = newValue ? newValue[key] : newValue;
                if(key == "*" && item[key].hasOwnProperty("_observers")){
                    oldV = oldValue;
                    newV = newValue
                }
                this.affectChanges(item[key], true, oldV, setterScope, newV,stack);
            }
        }
    },
    "executeObserver": function(stack){
        stack.forEach(function(obj){
            obj.observer.observer.value.call( obj.observer.callee && obj.observer.callee.component ? obj.observer.callee.component : setterScope ? setterScope : window ,{type:obj.type,oldValue:obj.oldValue,newValue:obj.newValue, item: obj.item});   
        });
    },
    "skipArgProcessing" : function(cloneActObj,ev,target) {
        if(cloneActObj.skipArgProcessing) {
            let args = cloneActObj.args = cloneActObj.actArgs;
            args.$shift();
            var eventIndex = args.indexOf("__lyteEvent__");
            var nodeIndex = args.indexOf("__lyteNode__");
            if(eventIndex !== -1) {
                args[eventIndex] = ev;
            } 
            if(nodeIndex !== -1) {
                args[nodeIndex] = target;
            }
        } else {
            cloneActObj.args.$shift();
        }
    },
    // getDV added
    // "getDV" : function(value){    
    //     var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
    //     for(var i=0;i<value.length;i++){
    //         if(value[i] === "."){
    //             if(data.length){
    //                 ref.$push(data);
    //             }
    //             data = "";
    //             continue;
    //         }
    //         else if(value[i] === "["){
    //             arrayStack.$push(i)
    //             if(data.length){
    //                 ref.$push(data);
    //             }
    //             while(value[i+1] === "\s"){
    //                 i++;
    //             }
    //             if(value[i+1] === "\"" || value[i+1] === "'"){
    //                 strStack.$push(value[i+1]);
    //                 strLast = value[i+1];
    //                 i++;
    //             }
    //             else if(arr.length){
    //                 ref.$push([]);
    //                 refStack.$push(ref);
    //                 ref = ref[ref.length-1];
    //             }else{
    //                 arr.$push([]);
    //                 refStack.$push(ref);
    //                 ref = arr[arr.length-1];
    //             }
    //             data = "";
    //             continue;
    //         }
    //         else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
    //             while(value[i] === "\s" && value[i] != "]"){
    //                 i++;
    //             }
    //             strStack.$pop();
    //             str = true;
    //         }
    //         if(value[i] === "]"){
    //             arrayStack.$pop();
    //             if(data.length){
    //                 if(str === true){
    //                     ref.$push(data);    
    //                 }
    //                 else if(!isNaN(parseInt(data))){
    //                     if(refStack.length){
    //                         ref = refStack.$pop();
    //                         if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
    //                             ref.$pop();
    //                         }
    //                         ref.$push(data);
    //                         if(!arrayStack.length && arr.length){
    //                             arr.$shift();
    //                         }
    //                     }
    //                 }
    //                 else{
    //                     ref.$push(data);
    //                 }
    //             }
    //             if(!arrayStack.length && arr.length){
    //                 result.$push(arr.$shift());
    //                 ref = result;
    //             }
    //             else if(refStack.length && !arr.length){ 
    //                 ref = refStack.$pop();
    //             }
    //             data = "";
    //             str = "";
    //             continue;
    //         }
    //         data = data.concat(value[i]);
    //     }
    //     if(data.length){
    //         result.$push(data);
    //     }
    //     if(strStack.length || arrayStack.length){
    //         console.log("check the syntax",strStack,arrayStack);
    //     }
    //     return result;
    // },
    "ccDelay" : [],
    "callCC" : function() {
        this.ccDelay.forEach(function(item) {
            if(item.component) {
                item.actualConnectedCallback();
            }
        });
        this.ccDelay = [];
    },
    "getDD":function(context,dataArr){
        var self = context;
        dataArr.forEach(function(item,index){
            if(Array.isArray(item)){
                if(context == undefined){
                    return undefined;
                }
                var inner = _LC.getDD(self,item);
                if(inner == undefined){
                    return undefined;
                }
                context = context[inner];
            }else{
                if(context == undefined){
                    return undefined;
                }
                context = context[item];
            }
        });
        return context;
    },

    "processStatic" : function(temp) {
        let arr = temp.innerHTML.split("__**");
        let newArr = [];
        for(var i=0;i<arr.length;i++) {
            if(arr[i].startsWith("--Lyte")) {
                newArr.$push(parseInt(arr[i].substring(6)));
            } else {
                newArr.$push(undefined);
            }
        }
        arr.cc = newArr;
        return arr;
    },
    "findLastNodeL" : function(lastNode1,count,node){
        var totalNodeIndex = 0;
        if(count != undefined){
            totalNodeIndex = count; 
        }
        var helperNode;
        switch(node.getAttribute("is")) {
            case "for" : 
                if(node._helpers[totalNodeIndex]){
                    helperNode = node._helpers[totalNodeIndex][0];   
                }
                if(!lastNode1) {
                    if(node._forContent[0]){
                        lastNode1 = node._forContent[0][0];
                    }
                }
                break;
            case "forIn" : 
                if(node._helpers[node._keysArray[0]]){
                    helperNode = node._helpers[node._keysArray[0]][0];
                }
                if(!lastNode1) {
                    if(node._forContent[node._keysArray[0]]){
                        lastNode1 = node._forContent[node._keysArray[0]][0];
                    }
                }                   
                break;
            case "if" : 
            case "switch" : 
                helperNode = node._helpers[totalNodeIndex];
                if(!lastNode1) {
                    lastNode1 = node._caseContent[0];
                }
            break;
            case "component" : 
                lastNode1 = lastNode1._renderedComponent[lastNode1._currentComponent] || lastNode1;
                return lastNode1;
        }
        if(!lastNode1){
            lastNode1 = node._placeHolder;
        }
        if(helperNode && (lastNode1 == helperNode._placeHolder)) {
            lastNode1 =  this.findLastNodeL(undefined, undefined, helperNode);
        }
        return lastNode1;
    },
    "processAction" : function(node) {
        Array.from(node.querySelectorAll('[lyteaction]')).forEach(function(item) { 
            let locIndex = item.attributes.lyteaction.value;
            item._boundEvents = _LC.fRP[locIndex];
            delete _LC.fRP[locIndex];
            // _LC.$pushFrc(locIndex);
            // item._boundEvents = JSON.parse(item.attributes.lyteaction.value);
            var _cx = item._boundEvents._cx;
            let boundEvents = item._boundEvents;
            delete boundEvents._cx;
            let componentName = boundEvents.componentName;
            delete boundEvents.componentName;
            for(var key in item._boundEvents) {
                if(key.indexOf("-") !== -1) {
                    item._actions = item._actions || {};
                    item._actions[key] = new CustomEvent(key);
                    item._actions[key].processAction = item._boundEvents[key];
                    item._boundEvents[key].actArgs.$shift();
                    let nodeIndex = item._boundEvents[key].actArgs.indexOf("__lyteNode__");
                    if(nodeIndex !== -1) {
                        item._boundEvents[key].actArgs[nodeIndex] = item;
                    }
                    item._boundEvents[key].args = item._boundEvents[key].actArgs;
                    delete item._boundEvents[key];
                } else {
                    let actArgs = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(item._boundEvents[key].args);
                    let actName = actArgs.$splice(0,1)[0];
                    actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                    let actString = getArgString(actName, actArgs);
                    item.setAttribute(key.startsWith("on") ? key.substr(2) : key ,componentName+" => "+ actString);
                    if(!item._boundEvents[key].globalEvent) {
                        item.addEventListener(key,globalEventHandler);
                    }
                }
            }
            item._boundEvents._cx = _cx;
            item.removeAttribute("lyteaction");
            //item._boundEvents = item.
        });
    },
    "getCtxVal" : function(context,val){
        if(context != undefined){
            return context[val];
        }else{
            return undefined;
        }
    },
    "get" : function(context, path, ac,cache) {
        if(!ac) {
            ac = [];
        }
        if(cache && cache.hasOwnProperty(path)){// cache.cacheData[path]
            var nodeValue = cache[path]._data; /* put as local variable due to error. plz cross check - christo */
            if(cache[path]._dyn){
                cache[path]._dyn.forEach(function(item){
                    ac.$push(item);
                });
            }
            return nodeValue;
        }
        else{
        try{
            if(path.search(/^\$\./g)!=-1){
                return (0,_slyte_core_src_JsonPath_js__WEBPACK_IMPORTED_MODULE_8__.Jwalk)(context,path);
            }
            let arr = path.match(/([^[\]]+|\[\])/g);
            let initialContext = context;
            ac.$push(arr[0]);
            let locArr = arr[0].split('.'); 
            for(let k=0;k<locArr.length;k++) {
                context = _LC.getCtxVal(context,locArr[k])
            }
            for(let i=1;i<arr.length;i++) {
                let locVal = arr[i];
                //this is context switching
                if(locVal.startsWith(".")) {
                    //direct context switching
                    let locArr = locVal.substring(1).split('.');
                    for(let k=0;k<locArr.length;k++) {
                        context = _LC.getCtxVal(context,locArr[k])
                    }
                    // ac[ac.length -1] = ac[ac.length - 1] + locVal;
                    ac[0] = ac[0] + locVal;
                } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                    if(!isNaN(locVal)) {
                        // ac[ac.length-1] = ac[0] + "." + locVal;
                        ac[0] = ac[0] + "." + locVal;
                        context = _LC.getCtxVal(context,locVal)
                    } else {
                        // ac[ac.length-1] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                        ac[0] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                        context = _LC.getCtxVal(context,locVal.substring(1, locVal.length -1))
                    } 
                } else {
                    let length = ac.length;
                    let val = _LC.get(initialContext, locVal, ac);
                    ac[0] = ac[0] + "." + val;
                    context = _LC.getCtxVal(context,val)
                }
                }
                if(cache){
                    cache[path] = {};
                    cache[path]._data = context;  
                    cache[path]._dyn = ac;
                }
            return context;
        } catch(e) {
            return undefined;
        }
        }
    },
    "getNew" : function(context, path) {
        try{
            let arr = path.match(/([^[\]]+|\[\])/g);
            let initialContext = context;
            let locArr = arr[0].split('.'); 
            if(arr.length < 2) {
                if(locArr.length <2) {
                    return {"context": initialContext, "lastKey" : locArr[0]};
                } else {
                    for(var k=0;k<locArr.length-1;k++) {
                        context = context[locArr[k]];
                    }
                    return {"context" : context, "lastKey" : locArr[k]}
                }
            }
            for(let k=0;k<locArr.length;k++) {
                context = context[locArr[k]];
            }
            for(var i=1;i<arr.length - 1;i++) {
                let locVal = arr[i];
                //this is context switching
                if(locVal.startsWith(".")) {
                    //direct context switching
                    let locArr = locVal.substring(1).split('.');
                    for(let k=0;k<locArr.length;k++) {
                        context = context[locArr[k]];
                    }
                } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                    context = context[locVal.substring(1, locVal.length -1)];
                } else {
                    let val = this.get(initialContext, locVal);
                    context = context[val];
                }
                }
            let lastKey = arr[i];
            if(lastKey.startsWith(".")) {
                //direct context switching
                let locArr = lastKey.substring(1).split('.');
                let k=0
                for(;k<locArr.length - 1;k++) {
                    context = context[locArr[k]];
                }
                lastKey = locArr[k];
            } else if(lastKey.startsWith("'") || lastKey.startsWith('"') || !isNaN(lastKey)) {
                lastKey = lastKey.substring(1, lastKey.length -1);
            } else {
                lastKey = this.get(initialContext, lastKey);
            }
            return {"context" : context, "lastKey" : lastKey };
        } catch(e) {
            return undefined;
        }
    },
    "componentGetData" : function(key){
        if(key) {
            return this.get(key);
        } else {
            return this.data;
        }
    },
    "componentSetData" : function(arg0, arg1 ,options) {
        if(typeof arg0 === "string") {
            this.set(arg0, arg1 ,options);
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this.set(key, arg0[key],arg1);
            }
        }
    },
    "componentGetMethods" : function(key) {
        if(key) {
            return this._methods[key];
        } else {
            return this._methods;
        }
    }, 
    "componentHasAction" : function(key) {
        if(key && this.$node._actions[key]) {
            return true;
        } else {
            return false;
        }
    }, 
    "componentGetActions" : function(key) {
        if(key) {
            return this.constructor._actions[key];
        } else {
            return this.constructor._actions;
        }
    }, 
    "componentGetObservers" : function() {
        return this.constructor._observers;
    },
    "componentsetActions" : function(arg0,arg1) {
        let actions = this.$node.constructor._actions;
        if(typeof arg0 === "string") {
            actions[arg0] = arg1;
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                actions[key] = arg0[key];
            }
        }
    },
    "componentSetMethods" : function(arg0, arg1) {
        if(typeof arg0 === "string") {
            this._methods[arg0] = arg1;
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._methods[key] = arg0[key];
            }
        }
    },
    "String" : {
        "cache_c":{},
        "cache_d":{},
        "upperCaseFirstLetter" : function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        },
        "lowerCaseFirstLetter" : function(string) {
            return string.charAt(0).toLowerCase() + string.slice(1);
        }, 
        "toCamelCase" : function(string) {
            if(!this.cache_c[string]){
                this.cache_c[string] = string.replace(/(-\w)/g, function(m){return m[1].toUpperCase();});
            }
            return this.cache_c[string];
        }, 
        "dasherize" : function(string) {
            if(!this.cache_d[string]){
                this.cache_d[string] = string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
            }
            return this.cache_d[string];
        }
    },
    "appendChild" : function(outlet, component) {
        _LC.ignoreDisconnect = _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.ignoreDisconnect = true;
        outlet.appendChild(component);
        _LC.ignoreDisconnect = _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.ignoreDisconnect = false;
    },
    "replaceWith" : function() {
        var argumentsArr = Array.from(arguments);
        var oldNode = argumentsArr.$shift();
        _LC.ignoreDisconnect = true;
        var parentNode = oldNode.parentNode;
        for(var i=0,node;node=argumentsArr[i];i++) {
            _LC.insertBeforeNative(parentNode, node, oldNode);
        }
        oldNode.remove();
        _LC.ignoreDisconnect = false;
    },	
    // "removeIfCaseContent" : function(comp,node,direct){
    //     if(!direct){
    //         for(let tempName in node._tempList) {
    //             this.removeDynamicNodes(node._tempList[tempName],comp);
    //         }
    //     }
    // },
    // "removeYieldContent" : function(node,){
    //     if(!direct){
    //         for(let tempName in node._tempList) {
    //             this.removeDynamicNodes(node._tempList[tempName]);
    //         }
    //     }
    // },
    "insertBeforeNative" : function(parent, newNode, refNode) {
        parent.insertBefore(newNode, refNode);
    },
    "insertBefore" : function(referenceNode, newNode, parentNode) {
        _LC.ignoreDisconnect = true;
        if(!parentNode) {
            if(!referenceNode) {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC005");
                //@Slicer.developmentEnd
                _LC.ignoreDisconnect = false;
                return;
            } else {
                parentNode = referenceNode.parentNode;
            }
        }
        _LC.insertBeforeNative(parentNode , newNode, referenceNode ? referenceNode : null);
        _LC.ignoreDisconnect = false;
    },
    "insertAfter" : function() {
        var argumentsArr = Array.from(arguments);
        var referenceNode = argumentsArr.shift();
        _LC.ignoreDisconnect = true;
        referenceNode.after.apply(referenceNode, argumentsArr);
        _LC.ignoreDisconnect = false;
    },
    "executeMethod" : function() {
        let args = Array.prototype.slice.call(arguments, 1);
        var methodName = _LC.String.toCamelCase(arguments[0]);
        if(!this._methods[methodName]) {
            //@Slicer.developmentStart
            let app = _LC.getNearestParentApp(this.component);
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error(app, "LC005", methodName, this.$node.tagName);
            //@Slicer.developmentEnd
            return;
        }
        return this._methods[methodName].apply(this, args);
    },
    // "getProperData" : function(obj) {
    //     var dataType = obj.dataType;
    //     var attr = obj.attr;
    //     var newValue = obj.newValue;
    //     var tagName = obj.tagName;
    //     switch(dataType) {
    //     case "boolean" : 
    //         {
    //             if(!newValue || newValue === "false") {
    //                 newValue= false;
    //             } else {
    //                 newValue = true;
    //             }
    //         }
    //         break;
    //     case "object" : 
    //         try{
    //             newValue = JSON.parse(newValue);
    //             if(!(newValue instanceof Object)) {
    //                 Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
    //             }
    //         } catch(e) {
    //             Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
    //             return;
    //         }
    //         break;
    //     case "array":
    //         try{
    //             newValue = JSON.parse(newValue);
    //             if(!(newValue instanceof Array)) {
    //                 Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
    //             }
    //         } catch(e) {
    //             Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
    //             return;
    //         }
    //         break;
    //     case "number":
    //         {
    //     let numValue = +newValue;
    //         if(newValue === numValue+"") {
    //             newValue = numValue;
    //         } else {
    //             Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
    //             return;
    //         }
    //     }
    //         break;
    //     }
    //     obj.newValue = newValue;
    //     return true;
    // }, 
    "cssEscape" : function(string) {
        if(string) {
            return string.replace(/['"]/g, "\\$&");    
        } else {
            return string;
        }
        
    },
    "arrayOverride" : function(){
        let allArrFns = ["push","pop","splice","shift","unshift","concat","replaceAt","shiftObject","remove","removeAt","removeObject","removeObjects","unshiftObject","unshiftObjects","insertAt"];
        for(let i=0; i<allArrFns.length; i++){
            let fnName = allArrFns[i];
            Array.prototype[fnName] = (function() {
                return function() {
                    let actArgs = Array.from(arguments);
                    if(_LC){
                        let opt = {fromOverride : true};
                        actArgs.$unshift(opt,this,fnName);
                        return _LC.aF.apply(_LC, actArgs);
                    }else{
                        return this["$"+fnName].apply(this,actArgs);
                    }
                };
            })();
        }
    },
    "render" : function(componentName, data, outlet, _lyteOptions) {
        var component;
        ltCf.fromV4Render = true;
        let oldLyteV4 = ltCf.lyteV4;
        if(_LC.validateRenderData(data)) {
            var currentReg = _LC.getCurrentRegistryIns();
            var currentRegClass = _LC.getCurrentRegistryIns();
            _LC.setCurrentRegistryIns(_lyteOptions && _lyteOptions.registryInstance ? _lyteOptions.registryInstance : this);
            _LC.setCurrentRegistry(_lyteOptions && _lyteOptions.registry ? _lyteOptions.registry : undefined);
            if(data && data.lyteV4){
                ltCf.lyteV4 = true;
            }
            if(componentName && typeof componentName == "string") {
                //@Slicer.developmentStart
                if(!this._registeredComponents[componentName]){
                    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Invalid Lyte Component name : '" + componentName + "'. It is not registered with Lyte.");
                }
                _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Passing component name '" +componentName+ "' as string is depricated.");
                //@Slicer.developmentEnd
                component = createElement(componentName);
            } else if(componentName && componentName._compName) {
                componentName._lyteOptions = _lyteOptions;
                component = createElement(componentName._compName);
                if(componentName._lyteOptions && componentName._lyteOptions.attributes && componentName._lyteOptions.attributes.length){
                    componentName._lyteOptions.attributes.forEach(function(attr){
                        if(typeof attr == "object"){
                            component.setAttribute(attr.name,attr.value);
                        }else{
                            component.setAttribute(attr,"");
                        }
                    })
                }
                componentName._lyteOptions = undefined;
            } else {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC003");    
                //@Slicer.developmentEnd
                _LC.setCurrentRegistryIns(currentReg); 
                _LC.setCurrentRegistry(currentRegClass);
                ltCf.fromV4Render = false;
                ltCf.lyteV4 = oldLyteV4
                return;
            }
        } else {
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC0010");
            //@Slicer.developmentEnd
            _LC.setCurrentRegistryIns(currentReg);
            _LC.setCurrentRegistry(currentRegClass)
            ltCf.fromV4Render = false;
            ltCf.lyteV4 = oldLyteV4
            return;
        }
        
        if(data){ 
            component.setData(data);
        }
        if(_lyteOptions && _lyteOptions.methods){
            component.setMethods(_lyteOptions.methods);
        }
        if(outlet) {
            let actOutlet;
            if(typeof outlet == "string"){
                actOutlet = document.querySelector(outlet);
            }else{
                actOutlet = outlet;
            }
            if(actOutlet) {
                if(_lyteOptions && _lyteOptions.clearOutlet){
                    actOutlet.innerHTML = "";    
                }
                actOutlet.appendChild(component);
                component._callee = component.getCallee ? component.getCallee(actOutlet) : undefined;
            } 
            //@Slicer.developmentStart
            else {
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ApiError.error("LC004", outlet);
            }
            //@Slicer.developmentEnd
        }
        _LC.setCurrentRegistryIns(currentReg);
        _LC.setCurrentRegistry(currentRegClass);
        ltCf.fromV4Render = false;
        ltCf.lyteV4 = oldLyteV4
        return component;
    },
    // "renderHTML" : function(string,outlet,options){
    //     var currentReg = _LC.getCurrentRegistryIns();
    //     _LC.setCurrentRegistryIns(options && options.registryInstance ? options.registryInstance : this)
    //     if(typeof string == "string") {
    //         if(outlet) {
    //             let actOutlet;
    //             if(typeof outlet == "string"){
    //                 actOutlet = document.querySelector(outlet);
    //             }else{
    //                 actOutlet = outlet;
    //             }
    //             if(actOutlet) {
    //                 actOutlet.innerHTML = string;
    //             } else {
    //                 Lyte.error("LC008", outlet);
    //             }
    //         }
    //     }
    //     _LC.setCurrentRegistryIns(currentReg);
    // },
    "removeForContent" : function(node){
        for(let s=0;s<node._forContent.length;s++) {
            for(let i=0;i<node._forContent[s].length; i++ ) {
                node._forContent[s][i].remove();
            }
        }
    },
    "removeForInContent" : function(node){
        for(var ind in node._forContent) {
            for(let i=0;i<node._forContent[ind].length; i++ ) {
                node._forContent[ind][i].remove();
            }
        }
    },
    "removeIfContent" : function(node){
        for(let i=0;i<node._caseContent.length; i++ ) {
            node._caseContent[i].remove();
        }
    },
    "removeIfCaseContent" : function(comp,node,direct){
        if(!direct){
            for(let tempName in node._tempList) {
                this.removeDynamicNodes(node._tempList[tempName],comp);
            }
        }
    },
    "removeYieldContent" : function(node){
        if(!direct){
            for(let tempName in node._tempList) {
                this.removeDynamicNodes(node._tempList[tempName]);
            }
        }
    },
    "removeDynamicNodes" : function(node,comp){
        for(let key in node._dynamicProperty) {
            if(node._dynamicProperty[key].isActualNode) {
                node._dynamicProperty[key].isActualNode._helperNodes[del](node);
            }else {
                let helperNodes = comp.getProperty(key)._helperNodes;
                if(helperNodes) {
                    helperNodes.delete(node);
                }
            }
        }
        node._dynamicProperty = {};
    },
    "insertInDom" : function(placeHolder,lastNode,toAppendMain){
        if(placeHolder) {
            _LC.insertBeforeNative(placeHolder.parentNode, toAppendMain, placeHolder);                	
        } else {
            _LC.insertBeforeNative(lastNode.parentNode,toAppendMain, lastNode);                
        } 
    },
    "appendInDom" : function(comp,content){
        comp.appendChild(content);
    },
    "instantiateSecurity" : function(lyteIns){
        lyteIns.Security = {
            "_ourSanitizerInstance_" :{},
            "_userSanitizerInstance_":{}, 
            "_eM" : {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '`': '&#x60;',
                '=': '&#x3D;'
              }, 
            "_eR" : /[&<>"'`=]/g,
            "_eF" : function(str) {
                return this._eM[str];
            }, 
            "escape" : function(string) {
                if (typeof string !== 'string') {
                    string = '' + string;
                }
                return string.replace(this._eR, this._eF.bind(this));
            }
        };
        var sec = {};
        lyteIns.Security._ourSanitizerInstance_ = _LC.Security.createSanitizer(sec);
        lyteIns.Security.createSanitizer = function (obb) {
            return _LC.Security.createSanitizer(obb);
        };
    },
    "setAttribute" : function(node,name,val){
        node.setAttribute(name,val);
    }
}
_LC.setData = function(arg0, arg1) {
    this._initProperties = this._initProperties || {};
    if(typeof arg0 === "string") {
        this._initProperties[arg0] = arg1
    } else if(typeof arg0 === "object") {
        for(let key in arg0) {
            this._initProperties[key] = arg0[key];
        }
    }
}
_LC.setMethods = function(arg0, arg1) {
    this._initMethods = this._initMethods || {};
    if(typeof arg0 === "string") {
        this._initMethods[arg0] = arg1
    } else if(typeof arg0 === "object") {
        for(let key in arg0) {
            this._initMethods[key] = arg0[key];
        }
    }
}
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.shadowDiv._duplicateStyle = [];
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.assetsDiv._duplicateStyle = [];
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.shadowDiv._compList = [];
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.shadowDiv._shadowChild = [];
var div = document.createElement("div");
div.setAttribute("id","lessDiv");
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.shadowDiv._lessDiv = div;
div._impNames = [];

_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte._component.init = function(lyteIns){
    _LC.instantiateSecurity(lyteIns);
    lyteIns.addEventListener("afterRouteTransition", function() {
        _LC.chromeBugFix();
    });
}
_slyte_core__WEBPACK_IMPORTED_MODULE_9__.LyteAddon._component.init = function(addOnIns){
    _LC.instantiateSecurity(addOnIns);
}
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte._component.didConnect = function(lyteIns){
    //will be called after afterlookups
    if(lyteIns.getDefaultRegistry){
        let regIns = lyteIns.getDefaultRegistry();
        if(!_LC.isValidReg(regIns)){
            let name =  regIns ? regIns.constructor ? regIns.constructor.name : regIns : regIns ;
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC008", name, name);
            //@Slicer.developmentEnd
            return false;
        }
        _LC.setDefaultRegistryIns(regIns);
    }
}
//var toArrayLyte = "toArrayLyte";
//var bindStr = "_bindings";
//var compStr = "component";
//var forHelperStr = "_forHelpers";
//var dynamicNodesStr = "_dynamicNodes";
//var calleeStr = "_callee";
//var getAttributeStr = "getAttribute";
//var hasAttributeStr = "hasAttribute";
//var removeAttributeStr ="removeAttribute";
//var setAttributeStr = "setAttribute";
//var parentNodeStr = "parentNode";
//var nodeNameStr = "nodeName";
//var ownerElementStr = "ownerElement";
var globalDOMEvents = [
    "focus",
    "focusin",
    "focusout",
    "resize",
    "scroll",
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mousemove",
    "mouseover",
    "mouseout",
    "change",
    "select",
    "submit",
    "keydown",
    "keypress",
    "keyup",
    "contextmenu"
];
// var registerHelperStr = "registerHelper";
var delStr = "delete";

function defProp() {
	Object.defineProperty.apply(Object, arguments);
}

function makeSet(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : new Set(),
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}
function addBindings(bindings, property) {
    bindings.add(property);
}

function makeArray(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : [],
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}

function createDocFragment() {
	return document.createDocumentFragment();
}

function createElement(elm) {
	return document.createElement(elm);
}

// function insertBefore(parent, newNode, refNode) {
// 	parent.insertBefore(newNode, refNode);
// }

function deleteBindingCheckSize(obj, key, valToDelete) {
	obj[key][delStr](valToDelete);
	if(!obj[key].size) {
		delete obj[key];
	}
}

/*	IE Browser
	Lyte._ie 
	Edge Browser
	Lyte._ed 
	Replace with needed;
	Lyte._rwpf 
	IE / Edge Browser
	Lyte._ms
*/

let userAgent = navigator.userAgent;
// //temporary fix for IE 11
// if(userAgent.match(/rv:11\.0/) && userAgent.match(/Trident/)) {
// 	Lyte._ie = true;
//     window.action = function() {
//         return;
//     }
// }
// if(userAgent.match('Edge')) {
//     var s = createElement("div");
//     s.innerHTML= "<template><div>c</div></template>";
//     if(s.querySelector("template").childNodes.length) {
//         Lyte._ie = true;
//     } else {
//         Lyte._ed = true;    
//     }
//     s.remove()
// }

class Test extends HTMLElement {
    constructor() {
        super();
        if(!this.attributes.t) {
            _LC.frSpecial = true;
        }
    }
}

// if(Lyte._ie || Lyte._ed) {
// 	var doc = createDocFragment();
// 	doc.appendChild(document.createTextNode("  dummy "));
// 	doc.childNodes[0].replaceWith(document.createTextNode("changed"));
// 	if(doc.childNodes[0].textContent !== "changed") {
// 		Lyte._rwpf = true;
// 	}
// 	Lyte._ms = true;
// }

// Lyte.Component = {}//mainClass;
// Lyte.compile = {};//af check
// var _LyteComponent = Lyte.Component;

// let arrayUtils =  function() {
// 	//arrayFunctions
//     return _LC.aF.apply(_LC, arguments);
// };
// let objectUtils =  function() {
// 	//objectFunctions
//     return _LC.oF.apply(_LC, arguments);
// }

_LC.errorNodeDetails = function(node) {
    var str = node.cloneNode(true);
    str.innerHTML = ".....";
    return str.outerHTML;
}
// _LyteComponent.register = function() {
//     _LC.registerComponent.apply(_LC, arguments);
// }
// _LyteComponent.directive = {
//     register : function() {
//         _LC.registerDirective.apply(_LC, arguments);
//     }
// }
// _LyteComponent.destroy = function() {
//     _LC.destroy.apply(_LC, arguments);
// }

// _LyteComponent.registerDirective = function() {
//     _LC.registerDirective.apply(_LC, arguments);
// }

// _LyteComponent.registerHelper = function() {
//     _LC.registerHelper.apply(_LC, arguments);
// }
// _LyteComponent.set = function() {
//     _LC.set.apply(_LC, arguments);
// }
// _LyteComponent.registeredHelpers = {};
// _LyteComponent.registeredComponents = {};
// _LyteComponent.registeredDirectives = [];
function noop() {

}
_LC.registerCustomPropHandler = function(propName) {
    let dasherized = _LC.String.dasherize(propName);
    propName = _LC.String.toCamelCase(propName);
    if(this.customPropHandlers.indexOf(propName) === -1) {
        this.customPropHandlers.$push(propName);
        customElementPrototype.prototype[propName] = function() {
            _LC.customPropRegex = this.component._registryClass.customPropRegex;
            let argsLength = arguments.length;
            let arg0 = arguments[0];
            let options = arguments[2];
            let compData = this.component.data;
            if(!arg0) {
                //Read all the values
                let obj = {};
                for(let key in compData) {
                    if(key.startsWith(propName)) {
                        let objKey = key.substring(propName.length);
                        objKey = _LC.String.lowerCaseFirstLetter(objKey);
                        obj[objKey] = compData[key];
                    }
                }
                return obj;
                
            } else if(typeof arg0 === "string") {
                if(argsLength > 1) {
                    //Set a value
                    this.set(propName+ _LC.String.upperCaseFirstLetter(arg0), arguments[1], options);
                } else {
                    //Read a value
                    let actKey = propName + _LC.String.upperCaseFirstLetter(arg0);
                    return compData[actKey];
                }
            } else if(typeof arg0 === "object") {
                //Write a set of values
                for(let key in arg0) {
                    let objKey = propName + _LC.String.upperCaseFirstLetter(key);
                    this.set(objKey, arg0[key], arguments[1]);
                }
            }
            _LC.customPropRegex  = "";
        }
        this.customPropRegex = new RegExp("^(" + this.customPropHandlers.join("|")+ ")");
    }
}
_LC.unregisterComponent = function(componentName) {//af check
    if(this._registeredComponentClass[componentName]) {
        var compClass = this._registeredComponentClass[componentName];
        var commonClass = this._registeredCommonClass[componentName];
        if(compClass.activeInstances > 0) {
            //@Slicer.developmentStart
            _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn(
                "There are active instances of the component " + componentName + " and hence cannot be unregistered"
            );
            //@Slicer.developmentEnd
        } else {
            // comp._properties = {};
            let ind = commonClass.component.list.indexOf(compClass);
            if(ind != -1){
                commonClass.component.list.splice(ind,1);
            }
            delete commonClass.componentClass;
            compClass._actions = compClass._template = compClass._dynamicNodes = compClass.__observers = null;            
            compClass._callBacks = {};
            compClass._observers = [];
            compClass._data = undefined;
            compClass._methods = {};
            compClass._classFunc = null;
            compClass._registered = false
            compClass.prototype.get = noop;
            compClass.prototype.set = noop;
            Object.defineProperty(commonClass.prototype, "setData", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initProperties = this._initProperties || {};
                    if(typeof arg0 === "string") {
                        this._initProperties[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initProperties[key] = arg0[key];
                        }
                    }
                }
            });

            Object.defineProperty(commonClass.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initMethods = this._initMethods || {};
                    if(typeof arg0 === "string") {
                        this._initMethods[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initMethods[key] = arg0[key];
                        }
                    }
                }
            });

            delete this._registeredComponentClass[componentName];
            this._instanceList.forEach(function(registryIns){
                delete registryIns._registeredComponents[componentName];
                delete registryIns.registeredComponents[componentName];
            })
            // var template = document.querySelector("template[tag-name="+componentName+ "]")
            var lyteComponentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv, this.name);
            var template = lyteComponentsDiv.querySelector("template[tag-name="+componentName+ "]");
            if(template) {
                template.remove();
            }
            // lyteht -> lyteHelperTemplates
            var helperTemplate = compClass._helperTemplate;
            if(helperTemplate) {
                helperTemplate.remove();
            }
            if(commonClass._depthTemp) {
                commonClass._depthTemp.remove();    
            }
            if(compClass._style){
                compClass._style = undefined;
            }
        }
        ComponentRegistry._unRegisteredComponents[componentName] = true;
    } 
    //@Slicer.developmentStart
    else {
        _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Component "+ componentName + " not yet registered");
    }
    //@Slicer.developmentEnd
}

var elementPrototype = typeof HTMLElement !== "undefined" ? HTMLElement : Element;

_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.appendTemplateDiv = function() {
    document.body.appendChild(_LC.tDiv);
    document.body.appendChild(_LC.h1Div);
}

function onDomContentForLyte() {
    // if(!Lyte._ie){//_ie
    	document.body.appendChild(_LC.lyteComponentsDiv);
        //document.body.appendChild(_LC.tDiv);
    // }
    document.body.appendChild(_LC.hDiv);
    let bodyEvents = globalDOMEvents;    
    for(let i=0; i<bodyEvents.length; i++){    
        var evnt = bodyEvents[i];    
        document.body.addEventListener(evnt,globalEventHandler, true);    
    }    
    
    let comp = _LC.toBeRegistered;    
    if(comp.length){    
        for(let j=0; j<comp.length;j++){
            customElements.define(comp[j].name, comp[j].def, undefined, comp[j]._lyteOptions);    
        }    
        _LC.toBeRegistered = [];    
    }
    if(/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        var style = createElement("style");
        style.innerHTML = "* { cursor : pointer}";
        document.head.appendChild(style);
    }
    document.head.appendChild(_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.shadowDiv._lessDiv);
}

var changeEventhandler = function(event) {
	var target = event.target || event.srcElement;
	if(!target._attributeDetails) {
		return;
	}
	var attributeName = "value";
	if(target.type === "checkbox" || target.type=== "radio") {
		attributeName = "checked";
	}
	let contextSwitchArray = [];
	var attrNode ;
	var attrDetail = target._attributeDetails[attributeName]
	if(!attrDetail || !attrDetail.isLbind) {
		return;
	}
	//attrNode = (attributeName === "checked") ? target._attributeDetails[attributeName].bindedNode : target.getAttributeNode(attributeName);
	var callee = target;
	if(!target._callee){
		while(callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee;
		}
	}
	let self = target._callee;
	if(target) {
		_LC.adCx(target, contextSwitchArray);
	}
    let obj = _LC.getNew(self.component.data, attrDetail.dynamicValue);
    if(!obj.context){
        return;
    }
    let lastKeyIndex = +obj.lastKey;
    if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
        _LC.aF(obj.context, lastKeyIndex < obj.context.length ? "replaceAt" : "insertAt", lastKeyIndex, target[attributeName]);
    } else {
        _LC.set(obj.context, obj.lastKey, target[attributeName]);
    }
	// _LC.set(obj.context, obj.lastKey, target[attributeName]);
	if(target) {
		_LC.rmCx(target, contextSwitchArray);
	}		
}
document.addEventListener("change", changeEventhandler);
var globalEventHandler = function(ev){
	var evnt = ev.type;
    var target = ev.target,toRemove;
    if(ev.target.shadowRoot){
        return;
    }
    if(/^(click|dblclick|mouseover|mouseout|mousemove|mousedown|mouseup|contextmenu|keydown|keyup|keypress|submit|reset|focus|blur|input|change|select|load|resize|scroll|unload|beforeunload|DOMContentLoaded|readystatechange|touchstart|touchmove|touchend|touchcancel|play|pause|ended|volumechange|durationchange|ratechange|dragstart|drag|dragenter|dragleave|dragover|drop|dragend)$/g.test(evnt) && target.getAttribute && target.getAttribute("lyte-state") != null){
        ev.preventDefault();
		return;
	}
    if(ev.currentTarget !== document.body && !_LCSD.getHostElement(ev.currentTarget)) {
        target = ev.currentTarget;
    }
	if(!window.event){
		toRemove = true;
		window.event = ev;
	}
    let eventStopped = false;
    while(target && target.getAttribute && (!target.getAttribute(evnt) || (target.hasAttribute("disabled") && evnt != "blur")) && target.tagName != "BODY"){
		if(_LC.hasLyteEvents(target, evnt)) {
            eventStopped = _LC.handleLyteEvents(target, ev);
            if(eventStopped) {
                break;
            }
        }
        target = target.parentNode;
	}
    if(eventStopped || !target) {
        return;
    }
 	var callee = target;
    if((target._callee && target._callee.component && target._callee.component.constructor._v3) || (target.component && target.component.constructor && target.component.constructor._v3)){
        return;
    }
	if(!target._callee){
		while(callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee === target ? undefined : callee;
		}
	}
    if(target._callee && !target._callee.component){
        _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Component of the target node is destroyed and so "+ evnt +" wont be triggered.");    
        return;
    }
    event.$lTarget = target;
	if(target._evBoundEvents && target._evBoundEvents[evnt]) {
        //Not needed - but check and remove
		// let actions = target._callee? target._callee.component.constructor._actions : target.component.constructor._actions ;
        //let actions = target.component.constructor._actions;
		let actObj = target._evBoundEvents[evnt];
        let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(actObj);
        _LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target,target,evnt,cloneActObj, undefined, undefined, target, ev, undefined, true);
	} else if(target.getAttribute && target.getAttribute(evnt) && target._boundEvents && target._boundEvents[evnt]){
		// let actions = target._callee.component.constructor._actions;
        // let func = target.getAttribute(evnt).split(" => ")[1];
        let actObj = target._boundEvents[evnt];
		let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(actObj);
		_LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, target, ev);
	}
	if(target.tagName === "LABEL"){
		var input = target.querySelector("input");
		if(input && input.getAttribute(evnt)){
			// let actions = target._callee.component.constructor._actions;
			// let func = input.getAttribute(evnt).split(" => ")[1];
			//	let actObj = target._callee.constructor.getHelper(func);
            let actObj = target._boundEvents[evnt];
            let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(actObj);
			_LC.skipArgProcessing(cloneActObj, ev, target);
			_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, input,ev);
		}
	}
	if(toRemove){
		window.event = undefined;
	}
}
class LyteYield extends HTMLElement {
    constructor() {
        super();   
        this.decideConstructor();
    }
    decideConstructor(){
        if(ltCf.versionBridge){
            let V3Registry = ltCf.versionBridge.component.V3Registry;
            let foundInV3List = V3Registry.allList.v3[this.localName]
            let foundInV4List = V3Registry.allList.v4[this.localName]
            if(foundInV3List){
                if(!foundInV4List || (!this.hasAttribute("lyte-v4") && !ltCf.lyteV4 && !ltCf.v4Render && (ltCf.fromV3Render || _LC.getCurrentRegistry() == V3Registry || foundInV3List))){
                    //v3
                    let v3CompClass = foundInV3List;
                    let self = this;
                    LyteYield._V3InsApi.forEach(function(apiName){
                        self[apiName] = v3CompClass.prototype[apiName];
                    })
                }
            }
        }
    }
    connectedCallback(){
        this._connectedCallback();
    }
    _connectedCallback() {
        this._callee = this._callee || _LC.getCallee(this.parentNode, this);
        let registry,shadowObj,directiveObj;
        if(this._callee){
            registry = this._callee.$component;
           if(registry){
            shadowObj = registry._shadow;
            directiveObj = registry._directive;
           }
        }
        if(directiveObj){
            this._transitionAppend = []
        }
        if(shadowObj && this.shadowRoot){
            shadowObj.insertInLessDiv(this._shadowParent,this._lessDiv)
            shadowObj.updateLessDiv(this._lessDiv,this.shadowRoot._compList);
        }
        if(!this._registerYield && this._callee) {
            var yieldName;
            if(this._callee._fR && this._callee._fR._yieldCallee) {
                this._registerYield = {"_callee" : this._callee._fR._yieldCallee.component.$node};
            } else if(this._callee._yields &&  (yieldName=this.attributes["yield-name"]) && (yieldName = yieldName.nodeValue) && this._callee._yields[yieldName]) {
                this._registerYield = {"_callee" : this._callee._yields[yieldName]._callee};
            }
        }
    }
    disconnectedCallback(){
        this._disconnectedCallback();
    }
    _disconnectedCallback(){
        if(_LC.ignoreDisconnect || this._deleted) {
            return;
        }
        let shadowObj = this._callee.getShadowObj();
        shadowObj && shadowObj.destroyRef(this);
        let registry = this._callee.$component;
        let directiveObj = registry._directive;
        this._deleted = true;
        if(!this._properties) {
            return;
        }
        var nodeContextSwitchArray = [];
        _LC.adCx(this, nodeContextSwitchArray);
        _LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
        let node = this._registerYield;
        if(!node) {
        _LC.rmCx(this, nodeContextSwitchArray);
        return;
        }
        var toAppendContextSwitchArray = [];
        //newContext not needed
        var del = "delete";//for ie 11.0
        _LC.adCx(node, toAppendContextSwitchArray);
        for(let key in this._dynamicProperty) {
            if(this._dynamicProperty[key].isActualNode) {
                this._dynamicProperty[key].isActualNode._helperNodes[del](this);
            }else {
                let helperNodes = node._callee.getProperty(key)._helperNodes;
                if(helperNodes) {
                    helperNodes[del](this);
                }
            }
        }
        this._dynamicProperty = {};
        for(let i=0;i<this._helpers.length;i++) {
            node._callee.removeHelpers(this._helpers[i]);
        }
        this._helpers = [];
        _LC.rmCx(node, toAppendContextSwitchArray);
        _LC.rmCx(this, nodeContextSwitchArray);
        directiveObj && directiveObj.destroyPromises(this);
        // var self = this;
        // setTimeout(function() {
        //     self._registerYield = null
        //     self._callee = null;
        // },0);
    }
    getProperty(key) {
            var arr = key.match(/([^[\].]+|\[\])/g);
            let property = this;
            if(!property._properties[arr[0]]) {
                    property._properties[arr[0]] = {};
            } 
            property = property._properties[arr[0]];
        
            defProp(property, '_path', {enumerable: false, value : arr[0]});
            for(let i=1;i<arr.length;i++) {
                if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
                    arr[i] = arr[i].substring(1, arr[i].length -1);
                }
                    if(!property[arr[i]]) {
                        property[arr[i]] = {};
                        defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
                }
                property = property[arr[i]];
            }
            return property;
        }
}
LyteYield._V3InsApi = ["_connectedCallback", "getProperty","_disconnectedCallback"]; //no i18n
ltCf._LyteYield = LyteYield;
customElements.define("lyte-yield", LyteYield, undefined, {v4 : true});
ltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();
//v4 class code
class LyteCustomElement extends HTMLElement {
    constructor(){
        super();
        this.decideConstructor();
    }
    decideConstructor(){
        if(ltCf.versionBridge){
            let V3Registry = ltCf.versionBridge.component.V3Registry;
            let foundInV3List = V3Registry.allList.v3raw[this.localName];
            let foundInV4List = V3Registry.allList.v4raw[this.localName];
            if(foundInV3List){
                if(!foundInV4List || (!this.hasAttribute("lyte-v4") && !ltCf.lyteV4 && !ltCf.fromV4Render && (ltCf.fromV3Render || _LC.getDecidedRegistry() == V3Registry || foundInV3List))){
                    //v3
                    let v3CompClass = V3Registry.allList.v3raw[this.localName];
                    let self = this;
                    LyteCustomElement._V3InsApi.forEach(function(apiName){
                        self[apiName] = v3CompClass.prototype[apiName];
                    })
                }
            }
        }
        //v4 
        this.actualConstructor();
    }
    actualConstructor(){
        this.__lyteCustomElement = true;
        if(this.isClonedNode()){
            this.__cloned = true;
            let attrList = this.attributes;
            for(let i=0; i<attrList.length; i++){
              let attrNode = attrList[i];
              attrNode._lyte = {cloned : true,userCloned : true, name : attrNode.nodeName ,value : attrNode.nodeValue};
            }
        }
        if(!_LC.getDefaultRegistry()){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC009");
            //@Slicer.developmentEnd
            return;
        }
        var obj = {compName : this.localName, type : "customComponent"};
        _LC.getCompRegistry(obj,this);
        if(!_LC.verifyDetails(obj)){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC010", "Raw Component", this.localName);
            //@Slicer.developmentEnd
            return
        }
        var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;
        var compInstance;
        lIns.scopedInstance(compClass,[this],function(ins){
            compInstance = ins;
        },[regIns])
        this.$component = this.$registry = regIns;
        compInstance.$component = compInstance.$registry = regIns;
        compInstance._registryClass = compClass._registryClass;
        this._registryClass = compClass._registryClass;
        _LC.setAddedRegistries(compInstance,this.localName);
        this.component = compInstance;
        compInstance.$node = this;
        let options = compClass._options;
        if(options && options.clone){
            this._allCallbacks = options.clone.allCallbacks;
            if(typeof options.clone.attributeChangedCallback == "object"){
                this._duringClone = options.clone.attributeChangedCallback.duringClone;
                this._afterClone = options.clone.attributeChangedCallback.afterClone;
            }else{
                this._allAttributesCallback = options.clone.attributeChangedCallback;
            }
            this.__connectedCallback = options.clone.connectedCallback;
            this.__disconnectedCallback = options.clone.disconnectedCallback;
        }
        this._actualConnectedCallback = compClass.prototype.connectedCallback;
        this._actualAttributeChangedCallback = compClass.prototype.attributeChangedCallback;
        this._actualDisconnectedCallback = compClass.prototype.disconnectedCallback;
        this._reconnectedCallback = compClass.prototype.reconnectedCallback;
        this._removedCallback = compClass.prototype.removedCallback;
    }
    executeLyteCallbacks(callBack,argArr){
        if(callBack) {
            callBack.apply(this.component, Array.from(argArr));
        }
    }
    isClonedNode(){
        if(this.hasAttribute("lyte-rendered-ce") && !this.LyteConnected || this.__cloned){
            return true;
        }
        return false;
    }
    _isClonedAttribute(attrName,oldVal,newVal){
        let attrNode = this.attributes[attrName];
        if(attrNode._lyte && attrNode._lyte.cloned && attrNode._lyte.name == attrName && attrNode._lyte.value == newVal && oldVal === null){
            return true;
        }
        return false;
    }
    isClonedAttribute(attrName){
        let attrNode = this.attributes[attrName];
        if(attrNode._lyte && attrNode._lyte.userCloned){
            return true;
        }
        return false;
    }
    connectedCallback(){
        this._connectedCallback();
    }
    _connectedCallback(){
        if(_LC.ignoreDisconnect || _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.ignoreDisconnect){
            if(this._reconnectedCallback){
                this.executeLyteCallbacks(this._reconnectedCallback,arguments);
            }
            return;
        }
        if(this.isClonedNode() && (this._allCallbacks == false || this.__connectedCallback == false)){
            return;
        }
        this.executeLyteCallbacks(this._actualConnectedCallback,arguments);
        this.setAttribute("lyte-rendered-ce", "");
        this.LyteConnected = true;
    }
    static get observedAttributes() {
        return this._observedAttributes;	
    }
    attributeChangedCallback(attr, oldValue, newValue) {
        this._attributeChangedCallback(attr, oldValue, newValue);
    }
    _attributeChangedCallback(attr, oldValue, newValue){
        var cloneStatus;
        var clonedNode = this.isClonedNode();
        if(clonedNode){
            if(this._allCallbacks == false || this._allAttributesCallback == false){
                return;
            }else{
                let attrName = arguments[0];
                let oldVal = arguments[1];
                let newVal = arguments[2];
                let attrNode = this.attributes[attrName];
                cloneStatus = this.attributes[arguments[0]]._lyte.userCloned;
                let isClonedAttribute = this._isClonedAttribute(attrName,oldVal,newVal,attrNode);
                if(isClonedAttribute){
                    this.attributes[arguments[0]]._lyte.userCloned = true;
                    if(this._duringClone == false){
                        return;
                    }
                }else{
                    this.attributes[arguments[0]]._lyte.userCloned = false;
                    if(this._afterClone == false){
                        return;
                    }
                }
            }
        }
        this.executeLyteCallbacks(this._actualAttributeChangedCallback,arguments);
        if(clonedNode && this.attributes[arguments[0]] && this.attributes[arguments[0]]._lyte){
            this.attributes[arguments[0]]._lyte.userCloned = cloneStatus;
        }
    }
    disconnectedCallback() {
        this._disconnectedCallback();
    }
    _disconnectedCallback(){
        if(_LC.ignoreDisconnect || _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.ignoreDisconnect){
            if(this._removedCallback){
                this.executeLyteCallbacks(this._removedCallback,arguments);
            }
            return;
        }
        if(this.isClonedNode() && (this._allCallbacks == false || this.__disconnectedCallback == false)){
            return;
        }
        this.executeLyteCallbacks(this._actualDisconnectedCallback,arguments);
    }
}
LyteCustomElement._V3InsApi = ["_connectedCallback", "_attributeChangedCallback" ,"_disconnectedCallback","actualConstructor","executeCallbacks","isNewComp"];
ltCf._LyteCustomElement = LyteCustomElement;
ltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();
//v4 class code
class customElementPrototype extends elementPrototype {
    constructor() {
        super();
        this.decideConstructor();
    }
    decideConstructor(){
        let self = this;
        if(ltCf.versionBridge){
            let V3Registry = ltCf.versionBridge.component.V3Registry;
            let foundInV3List = V3Registry.allList.v3[this.localName]
            let foundInV4List = V3Registry.allList.v4[this.localName]
            if(foundInV3List){
                if((!foundInV4List) || (!this.hasAttribute("lyte-v4") && !ltCf.lyteV4 && !ltCf.fromV4Render && (ltCf.fromV3Render || _LC.getDecidedRegistry() == V3Registry || foundInV3List ))){
                    //v3
                    let v3CompClass = foundInV3List;
                    customElementPrototype._V3InsApi.forEach(function(apiName){
                        self[apiName] = v3CompClass.prototype[apiName];
                    })
                    self.component = self.constructor.component = v3CompClass.component;
                    this.setData = v3CompClass.component.prototype.setData;
                    this.setMethods = v3CompClass.component.prototype.setMethods;
                }else if(foundInV4List){
                    //v4
                    let v4CompClass = foundInV4List;
                    customElementPrototype._v4RegClassApi.forEach(function(apiName){
                        self.constructor[apiName] = v4CompClass[apiName];
                    })
                    customElementPrototype._v4RegProtoApi.forEach(function(apiName){
                        self[apiName] = v4CompClass.prototype[apiName];
                    })
                }
            }
        }
        //v4 
        this.actualConstructor();
    }
    actualConstructor() {
        // this.setData = _LC.setData;
        // this.setMethods = _LC.setMethods;
        if(this.hasAttribute("lyte-rendered") || this._ccCalled) {//aaf check
            this.__lyteIgnore = true;
        	return;
        } else if(ComponentRegistry._unRegisteredComponents[this.localName]){
            this.__lyteIgnore = true;
            var origClass = ComponentRegistry._registeredCommonClass[this.localName];
            origClass._pendingComponents = origClass._pendingComponents || [];
            origClass._pendingComponents.push(this);
            return;
        }
        if(!_LC.getDefaultRegistry()){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC009");
            //@Slicer.developmentEnd
            return;
        }
        let fastRenderIndex;
        let lytePropAttr = this.attributes._lyteprop;
        lytePropAttr = lytePropAttr ? lytePropAttr.nodeValue : undefined;
        let fastRenderedProp = (fastRenderIndex = lytePropAttr) ? _LC.fRP[fastRenderIndex] : undefined;
        let compInstance;// = this.component = new this.constructor.component.list[0]();//this.component = fastRenderedProp ? fastRenderedProp.component : new this.constructor.component();
        var self = this;
        if(!fastRenderedProp){
            var obj = {compName : this.localName, type : "component"};
            _LC.getCompRegistry(obj,this);
            if(!_LC.verifyDetails(obj)){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.RegistryError.error("LC010", "Component", this.localName);
                //@Slicer.developmentEnd
                return
            }
            var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;
            lIns.scopedInstance(compClass,[],function(ins){
                compInstance = self.component = ins
            },[regIns])
            this.$component = this.$registry = regIns;
            compInstance.$component = compInstance.$registry = regIns;
            compInstance._registryClass = compClass._registryClass;
            this._registryClass = compClass._registryClass;
            _LC.setAddedRegistries(compInstance,this.localName);
        }else{
            compInstance = self.component = fastRenderedProp.component;
            var compClass = this.constructor.component.list[0];
            this.$component = this.$registry = compInstance.$component;
            this._registryClass = compInstance._registryClass;
        }
        this._properties = {};
        this._compClass = compClass;
        this._tagDirectives = [];
        _LC.directive.setTagDirectives(compClass,this);
        _LC.directive.setAttrFromRender(this,this._tagDirectives);
        compInstance._methods = {};
        
        compInstance._config = this.constructor._config;
        compInstance.actions = Object.assign({},compClass._actions);
        //@Slicer.developmentStart
        var act = compInstance.actions;
        Object.defineProperty(compInstance,"actions",{
            get : function() {
        		_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Accessing actions directly is deprecated. Move the required common code from action block to a common function and access it.");
        		return act;
        	}   
        });
        var met = compInstance.methods;
        Object.defineProperty(compInstance,"methods",{
            get : function() {
        		_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn("Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.");
        		return met;
        	}   
        });
        //@Slicer.developmentEnd
        compClass.activeInstances++; 
        let compData;
        
        if(!fastRenderedProp) {
            compData = compInstance.data = {};
            let data = compClass._data ? compClass._data.apply(compInstance) : {};
            var def = "default";
            defProp(compData, '__component__', {
                value : this,
                configurable : true,
                writable: true,
                enumerable : false
            });
            compInstance.__data = data;
            compData.errors = {};
            for(let key in data) {
                var obj = data[key];
                compData[key] = obj[def];
                if(/^(object|array)$/.test(obj.type) && (obj.watch || (obj.hasOwnProperty("items") || obj.hasOwnProperty("properties")) )){
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.establishObjectBinding)(compData, key, false,undefined,undefined,obj.watch?true:undefined);
                }
            }
            compData.errors = {};
            compInstance.__data = data;
        }
        
        for(let key in compClass._methods) {
            compInstance._methods[key] = compClass._methods[key];
        }
        if(compInstance.$node) {    
            for(var key in compInstance.$node) {
                if(key != "localName"){
                    this[key] = compInstance.$node[key];
                }
            }
        }
        compInstance.$node = this;
        let _overrides;
        let _config_flag;
        if(compInstance._ssr && compInstance._ssr.config){
            if( compInstance._ssr.config.clientLifeCycleHooks != undefined ){
                _config_flag = compInstance._ssr.config.clientLifeCycleHooks == true || ( typeof compInstance._ssr.config.clientLifeCycleHooks == 'object' ? compInstance._ssr.config.clientLifeCycleHooks.includes('init') : false );
            }
        }
        
        if(!fastRenderedProp) {
            // this.callback("constructor"); //af check // no need
            this._actions = this._actions ? this._actions : {};
            this._callee = this._callee || this.getCallee(this.parentNode);

            //check if it is called from server || to ssr bind
            
            //check if it has ssr contructor for ssr
            //ssrcode_client
            if( _config_flag || !this.hasAttribute( 'server-rendered' ) ){
                if( _overrides && _overrides.constructor && this.serverCall ){
                    _overrides.constructor.apply( this.component );
                }
            } 

            //checking lyte.attr ytpe and given default value type
            for (var key in compData) {
                var field = compData.__component__.component.__data[key];
                var error = _LC.handleValidation(compData, key, compData[key], compInstance ,true);
                if (error) {
                    compData[key] = undefined;
                    var field = compData.__component__.component.__data[key]; 
                    if(field && /^(object|array)$/.test(field.type)){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.establishObjectBinding)(compData, key, undefined,undefined,undefined,field.watch ? true:undefined);
                    }
                }
            }
            // if(compData.errors && Object.keys(compData.errors).length){
            //     Lyte.error("Error in data passed to component '"+ this.localName +"' for the properties - "+Object.keys(compData.errors).toString());
            // }
        } else {
            this._fR = fastRenderedProp;
            delete _LC.fRP[fastRenderIndex];
            // _LC.$pushFrc(fastRenderIndex);
        }
    }
    getDirectiveObj(){
        if(!_LC.directive.bundled){
            return false;
        }
        return _LC.directive;
    }
    getShadowObj(){
        if(this.$registry._shadow){
            return this.$registry._shadow;
        }
        return false;
    }
    getFastObj(){
        if(this.$registry["_turbo"]){
            return this.$registry["_turbo"];
        }
        return false;
    }
    getViewObj(){
        if(this.$registry["_view"]){
            return this.$registry["_view"];
        }
        return false;
    }
    getMethods(arg0) {
        return this.component.getMethods(arg0);
    }
    hasAction(arg0) {
        return this.component.hasAction(arg0);
    }
    setActions(arg0,arg1){
        return this.component.setActions(arg0,arg1);
    }
    getActions(arg0) {
        return this.component.getActions(arg0);
    }
    getObservers() {
        return this.component.getObservers();
    }
    setMethods(arg0, arg1) {
        return this.component.setMethods(arg0, arg1);
    }
    // getData(arg0) {
    //     return this.component.getData(arg0);
    // }
    // setData(arg0, arg1 ,options) {
    //     return this.component.setData(arg0, arg1, options);
    // }
    getCallee(callee){
        return _LC.getCallee(callee, this);
    }
    afterConnected(fastRenderProp,ssrBind) {
        let constr = this.component.constructor;
        //initProperties is used because, we may have cases where the component wouldn't have been registered but 
        //it would be in dom already with some attributes. In those cases we can store the data in _initProperties as key, value.
        //These properties would then be applied to the component, once it gets instantiated. 
        
        //This is done, in order to solve when on a string value update of an if helper, the binding in the true or false case must be established. 
        //Without this, we won't establish the _properties in the component to the actual Data. 
        if(this.getAttribute("_lyteprop")) {
        	return "";
        }
        let obsattr = this.constructor._observedAttributes;
        for(let i=0;i<obsattr.length;i++){
            let key = obsattr[i];
            let prop = this.getProperty(key);
            defProp(prop, '__fromComponent', {
            	value : true,
                enumerable : false
            });
        }
        this.getProperty("errors");
        let app = this.component.getAppOrAddon();
        var $lg = app.__gl, 
        compInstance = this.component,
        compData = compInstance.data;
        compData.$lg = $lg;
        this.component.constructor.prototype.$lg = $lg;
        if(this._initProperties) {
            let initProperties = this._initProperties;
            // if(initProperties["lyteUnbound"] && _LC.migratedv2(app)){ //devmode
            //     Lyte.error("lyteUnbound is moved to directive. so please make use of @unbound");
            // }
            for(let key in initProperties) {
                let actVal;
                let field = compInstance.__data[key]; 
                if(field && field.type !== _LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || field.type === "boolean")) {
                    actVal = _LC.typeCast(initProperties[key], compInstance.__data[key].type);
                } else {
                     actVal = initProperties[key];
                }
                let error = _LC.handleValidation(compData, key, actVal, compInstance ,true);
                if(!error) {
                    compData[key] = actVal;    
                    if(field && /^(object|array)$/.test(field.type) && (field.watch || (field.hasOwnProperty("items") || field.hasOwnProperty("properties")))){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.establishObjectBinding)(compData, key, undefined,undefined,undefined,field.watch?true:undefined);
                    }
                }
            }
            this._initProperties = undefined;
        }
        //@Slicer.developmentStart
        if(compData.errors && Object.keys(compData.errors).length){
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC006",this.component.$node.localName,+Object.keys(this.component.data.errors).toString())
        }
        //@Slicer.developmentEnd
        if(this._initMethods) {
            let initMethods = this._initMethods;
            for(let key in initMethods) {
                compInstance._methods[key] = initMethods[key];
            }
            this._initMethods = undefined;
        }
        let _config_flag;
        if( compInstance._ssr && compInstance._ssr.config ){
            if( compInstance._ssr.config.clientLifeCycleHooks != undefined ){
                _config_flag = compInstance._ssr.config.clientLifeCycleHooks == true || ( typeof compInstance._ssr.config.clientLifeCycleHooks == 'object' ? compInstance._ssr.config.clientLifeCycleHooks.includes('init') : false );
            }
        }
        let _overrides;      
        
        //ssrcode client        
        ssrBind && this.cmpBind(fastRenderProp);
        if( _config_flag || !this.hasAttribute( 'server-rendered' ) )
        {
            if( _overrides && _overrides.init && this.serverCall ){
                _overrides.init.apply( this.component );
            }else{        
                this.callback('init');
            }
            this.onCallBack('init');
        }
        // this.callback('init');
        // this.onCallBack('init');
        let templateAttributes = this.component.constructor._templateAttributes;
        if(templateAttributes && templateAttributes.a) {
        	for(let key in templateAttributes.a) {
//        		let attr = templateAttributes.attr[i];
				let attr = templateAttributes.a[key];
        		if((!this.hasAttribute(attr.name) && !compData.hasOwnProperty(attr.name) ) || attr.globalEvent) {
        			if(attr.helperInfo && attr.helperInfo.name === "action") {
                        this._evBoundEvents = this._evBoundEvents || {};
                        let actionName = attr.helperInfo.args[0];
					    let boundName;
					    if(actionName.startsWith('"') || actionName.startsWith("'")) {
						boundName = actionName.substring(1, actionName.length - 1);
					    } else {
						//Lyte.warn("Deprecation warning. Action name should be in quotes");
						boundName = actionName;
                        }
                        let actualAttrName = attr.globalEvent ? attr.name : (attr.name.indexOf("-") !== -1)? attr.name : attr.name.substr(2);
                        this._evBoundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args, "from" : "component"};
                        let prevAttribute = this.getAttribute(attr.name);
                        let currentAttribute = this.component.constructor._template.getAttribute(attr.name);
                        //this.setAttribute("ev:"+attr.name, this.component.constructor._template.getAttribute(attr.name));
                        this.setAttribute(attr.name, currentAttribute + (prevAttribute ? " ; " + prevAttribute : ""));
                    }
                    if(!attr.globalEvent) {
                        attr.from = "component";
                        if(attr.staticValue) {
                            this.setAttribute(templateAttributes.a[key].name, attr.staticValue);
                        }
                        else if(_LC.directive.isDirectiveNode(attr)){
                            let actAttrName = attr.name;
                            let attrName = actAttrName;
                            let duplicateFound;
                            if(!this._specialAttributeDetails){
                                this._specialAttributeDetails = [];
                            }else{
                                this._specialAttributeDetails.forEach(function(oldAttr){
                                    if(oldAttr.hookName == actAttrName){
                                        duplicateFound = true;
                                    }
                                })
                            }
                            if(attr.hasOwnProperty("stringValue")){
                                
                                if(!duplicateFound){
                                    let strAttr = {
                                        hookName : attr.hookName,
                                        hookNode : attr.hookNode,
                                        name : attr.name,
                                        stringValue : attr.stringValue
                                    }
                                    this._specialAttributeDetails.push(strAttr);
                                }
                            }else if(attr.hasOwnProperty("dynamicValue")){
                                this.setAttribute(attr.hookName, "{{dummy}}");
                                let attrNode = this.attributes.getNamedItem(attr.hookName);
                                attr._isDirectiveNode = true;
							    this.bindNode(attrNode, [], undefined, {}, attr, undefined, undefined, true );
                                if(!this._specialAttributeDetails){
                                    this._specialAttributeDetails = [];
                                }
                                let dynAttr = {
                                    hookName : attr.hookName,
                                    hookNode : attr.hookNode,
                                    name : attr.name,
                                    dynamicValue : attr.dynamicValue
                                }
                                this._specialAttributeDetails.push(dynAttr);
                            }
                            
                        }
                        //@Slicer.developmentStart
                        else if(key.startsWith("@")){
                            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC007")
                        }
                        //@Slicer.developmentEnd
                        else{
                            this.setAttribute(templateAttributes.a[key].name, "{{dummy}}");
							this.bindNode(this.attributes.getNamedItem(templateAttributes.a[key].name), [], undefined, {}, templateAttributes.a[key], undefined, undefined, true );
                        }
                    }
        			
        		}
        	}
        }
        this.registerYields();
        let dumFlg;
        if(compData.lyteUnbound && !_LC.migratedv2(app)) {
        	_LC.unbound = true;
            dumFlg = true
        }
        let unboundDirective = _LC.directive.getTransitionArg(this,"unbound");
        if(unboundDirective){
            _LC.unbound = true;
        }
        if(!dumFlg){
            this.component.data.lyteUnbound = unboundDirective;//add in future   
        }
        let content = "";
        let fastRender,fastRenderSupported
        let unboundBeta = compData.lyteFastRender;
        fastRender = _LC.directive.getTransitionArg(this,"turbo");
        this.component.data.lyteFastRender = fastRender;
        if(fastRender){
            fastRenderSupported = _LC.directive.getTransitionArg(this,"unbound-supported") || _LC.directive.getTransitionArg(this,"turbo-supported");
            if(!fastRenderSupported){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC008", this.localName)
                //@Slicer.developmentEnd
                this.component.data.lyteFastRender = false;
            }
        }
        
        let fastObj = this.getFastObj();
        if((unboundBeta && !(_LC.migratedv2(app))) || (fastRender && fastRenderSupported && fastObj)){
            content = fastObj.renderFast(constr._dynamicNodes, constr._sta, compInstance, undefined, this);
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.callCC();
                });
            });
        }
        else {
            content = this.renderNodes(constr._template, constr._dynamicNodes,undefined,undefined, undefined, undefined, this.component.constructor._tC);
        }
        return content;
    }

    //RN
    renderNodes(toAppend, dynamicNodes, helperNode, options, establishBindings, returnVal, templateContent ,yieldComp) {
        options = options || {};
        let content;
        let constr = this.constructor;
        // let Compile = this.component.constructor.Compile;
        let directiveObj = this.getDirectiveObj();
        /*if(Lyte._ie){
            let newFrag = toAppend.cloneNode(true, "lyte");
            this.constructor.splitTextNodes(newFrag);
            content = newFrag;
        }
        else{
            content = toAppend.cloneNode(true, "lyte");
        }*/
        let templateDepthHandlingNeeded = false;
        if (!toAppend) {
            templateDepthHandlingNeeded = true;
            content = _LC.getContentForIE(templateContent , constr);
        } else if(toAppend.hasAttribute("depth")) {
        	templateDepthHandlingNeeded = true;
        	content = _LC.getContentForIE(toAppend , constr);
        } else {
            content = toAppend.content.cloneNode(true, "lyte");
        }
        let updateHelpers = [],processLast = [],helperFunc,stoppedNode;
        
        let toBeInsMap = new Map();
        for(let i=0;i<dynamicNodes.length;i++) {
            let info = dynamicNodes[i], type = info.t, pos = info.p, dynamicN = content, helperInfo;
            dynamicN = getDynamicNode(dynamicN,pos);
            if(directiveObj && info.trans){
                dynamicN._hooksPresent = true;
            }
            if(!dynamicNodes._cache){
                dynamicNodes._cache = {};
            }
            if(type ===  "cD") {
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                  
                if(directiveObj){
                    directiveObj.infoCD(this,info,dynamicN,helperNode,options);
                }
                // dynamicN._callee = this//af check
            } 
            else if(type === "tX"){
                 this.bindNode(dynamicN, undefined, helperNode, options, dynamicNodes[i], processLast, establishBindings,undefined,dynamicNodes._cache,type,undefined,toBeInsMap);
            }
            else if(type === "a"){
            	dynamicN._attributeDetails = info.a;            	
                if(dynamicN.nodeName === "LYTE-YIELD") {
                    dynamicN._callee = this;
                    dynamicN.component = {}
                    dynamicN.component.data = {};
                    defProp(dynamicN.component.data, "__component__", {
                    	value : dynamicN,
                    	configurable : true,
                    	writable : true,
                        enumerable : false
                    });
                    dynamicN._properties = {};
                    for(let j=0;j<dynamicN.attributes.length;j++) {
                        let attr = dynamicN.attributes[j];
                        if(attr.nodeName !== "is" && attr.nodeName !== "yield-name") {
                            dynamicN._properties[_LC.String.toCamelCase(attr.nodeName)] = {};
                        }
                    }
                }
                let toBeRemoved = [];
				for(let key in info.a) {
                	let attr = info.a[key];
                	attr._depthTemp = info._depthTemp;
                	let attrName = key;
                    if(attr && (attr.dynamicValue || attr.helperInfo)) {
                        if(options.node) {
                                dynamicN._cx = options;
                        }
                        else if(helperNode) {
                            dynamicN._cx = helperNode._cx;
                        }
                        let actionName, boundName;
                        if(attr.helperInfo && attr.helperInfo.name === "action") {
                            dynamicN._boundEvents = dynamicN._boundEvents || {};
                            actionName = attr.helperInfo.args[0];
                            if(actionName.startsWith('"') || actionName.startsWith("'")) {
                                boundName = actionName.substring(1, actionName.length - 1);
                            } else {
                                // Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
                                boundName = actionName;
                            }
                            let actualAttrName = attr.globalEvent ? attrName : (attrName.indexOf("-") !== -1)? attrName : attrName.substr(2);
                            dynamicN._boundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args};
                            //to bind actions in ssr components
                            let id;
                               
                        }            
			            if(!attr.globalEvent) {
                            /*this.bindNode(dynamicN.getAttributeNode(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings);
                             */
                            if(!dynamicN.hasAttribute(attrName)) {
                                dynamicN.setAttribute(attrName, "{{dummy}}");
                            }
                        	var node = this.bindNode(dynamicN.attributes.getNamedItem(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings,undefined,dynamicNodes._cache,type,i);
                            if(node !== dynamicN.attributes.getNamedItem(attrName)) {
                            	dynamicN._removedAttributes = dynamicN._removedAttributes || {};
                            	dynamicN._removedAttributes[attrName] = node;
                            }
                        }
                    }
                    if(directiveObj && attr.hookNode){
                        directiveObj.infoA(this,info,dynamicN,helperNode,attr,yieldComp,options);
                    }
                }
                //Added now
                if(info.a && Object.keys(info.a).length) {
                	dynamicN._callee = this;
                }
                for(let d=0;d<toBeRemoved.length;d++) {
                    dynamicN.removeAttribute(toBeRemoved[d]);
                }
            }
            else if(/^(f|fI|cM)$/.test(type)){
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                if(directiveObj){
                    directiveObj.infoF(this,info,dynamicN,helperNode,type,options);
                }
                dynamicN._dynamicNodes = info.dN;
                // if(Lyte._ms) {
                //     dynamicN._tC = info.templateContent;  
                // }
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                }
                let returnVal;
                switch(type) {
                case "f" : 
                    dynamicN._ht = info._ht;
                	returnVal = this.updateForHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings, info._sta ,yieldComp);
                	break;
                case "fI" : 
                    dynamicN._ht = info._ht;
                	returnVal = this.updateForInHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings ,yieldComp);
                	break;
                case "cM" : 
                	returnVal = this.updateDynamicComponent(dynamicN, false, options.node ? options : undefined, establishBindings ,yieldComp);
                }
                if(returnVal) {
                	updateHelpers.$push(returnVal);
                }
            }
            else if(/^(e|s)$/.test(type)){
                var def ="default";
                dynamicN._cases = info.c; 
                dynamicN._hd = info.hd;
                dynamicN._co = info.co
                dynamicN._default = info.d;
                dynamicN._ht = info._ht;
                if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                if(directiveObj){
                    directiveObj.infoE(this,helperNode,dynamicN,info,options);
                }
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                    if(!dynamicN._origTemplate) {
                    	// if(Lyte._ie) {
                    	// 	dynamicN._origTemplate = createElement("template")
                    	// } else {
        	            	dynamicN._origTemplate = info._depthTemp.cloneNode(true);
                    	// }
                    	if(dynamicN.hasAttribute("value")) {
                    		dynamicN._origTemplate.setAttribute("value", dynamicN.getAttribute("value"));
                    	}
                        if(dynamicN.hasAttribute("l-c")) {
                    		dynamicN._origTemplate.setAttribute("l-c", dynamicN.getAttribute("l-c"));
                    	}
                    }
                }
                let id,obj;
                
                
                let returnVal = this.updateSwitchHelper(type, dynamicN, options.node ? options : undefined, undefined, establishBindings ,yieldComp,undefined,helperNode,id,i);
                if( !_LC.unbound && ( this._ssrBind || ( this._callee && this._callee._ssrBind ) )){
                    // delete obj.node;
                    // obj.case = dynamicN._currentCase || dynamicN._currentScope; 
                    if(dynamicN.getAttribute("l-c")){
                        obj._new = dynamicN.getAttribute("_new") ? true:undefined;
                        obj.lc = true;
                        obj.case = dynamicN._currentScope;
                    }else{
                        obj.case = dynamicN._currentCase; 
                    }
                }
                if(returnVal) {
                	updateHelpers.$push(returnVal);
                	let isBreak = returnVal.toAppendMain.querySelector("template[is=break]");
                	if(isBreak) {
                		dynamicN._isStopped = "break";
                		content = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getTrimmedContent(content, info.p,undefined);
                		stoppedNode = info.p;
                		break;
                	}
                	let isContinue = returnVal.toAppendMain.querySelector("template[is=continue]");
                	if(isContinue) {
                		dynamicN._isStopped = "continue";
                		content = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getTrimmedContent(content, info.p,undefined);
//                		stoppedNode = info.position;
                		break;
                	}
                }
            } else if(type === "r") {
                dynamicN._childPromise = [];
                
                dynamicN._dynamicNodes = info.dN;
                dynamicN._sta = info._sta;
                dynamicN._ht = info._ht;
                // if(Lyte._ms) {
                //     dynamicN._tC = info.templateContent;  
                // }
//                updateHelpers.$push(dynamicN);
                if(directiveObj){
                    dynamicN._childPromise = [];
                    directiveObj.infoE(this,helperNode,dynamicN,info,options);
                }
                if(options.node) {
                    dynamicN._cx = options;
                }
                else if(helperNode) {
                    dynamicN._cx = helperNode._cx;
                }
                //Added now                
                dynamicN._callee = this;
            } else if(type === "i") {
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                
                dynamicN.component = dynamicN.component || {"data" : {}};
                dynamicN._properties = dynamicN._properties || {};
                if(directiveObj){
                    directiveObj.infoI(this,info,dynamicN,helperNode,options);
                }
                for(let x=0; x<dynamicN.attributes.length; x++) {
                    let attrObj = dynamicN.attributes[x];
                    let attrName = attrObj.name;
                    let attrValue = attrObj.value;
                    if(attrName !== "yield-name") {
                        if(dynamicN._properties && !dynamicN._properties[attrName]){
                            dynamicN._properties[attrName] = {};
                        }
                        if(dynamicN._attributeDetails && !dynamicN._attributeDetails[attrName]){
                            dynamicN.component.data[attrName] = attrValue;
                        }
                    }
                }
                this.updateYield(dynamicN, false, options.node? options : undefined,helperNode);
                if(info.chld){
                    dynamicN._chld = info.chld;
                }
                if(info.sibl){
                    dynamicN._sibl = info.sibl;
                }
            }
        }
        dynamicNodes._cache = undefined;
        for(let i=0;i<processLast.length;i++) {
             let dynamicPosition = processLast[i].dynamicPositions;
                 let processNode = dynamicPosition.initialNode;
                 let nodeValue = dynamicPosition.dynamicNodeValue;
                 let childLen = nodeValue.childNodes.length;
                 if(!childLen) {
                    nodeValue.appendChild(document.createTextNode(""));
                        childLen = 1;
                 }
                 let startingNode = nodeValue.childNodes[0];
                 if(processNode.parentNode.nodeName === "#document-fragment") {
                 	while(nodeValue.childNodes.length) {
                 		_LC.insertBeforeNative(processNode.parentNode, nodeValue.childNodes[0], processNode);
                    }
                 	processNode.remove();
                 } else {
                	 processNode.replaceWith.apply(processNode,nodeValue.childNodes);
                 }
                 processLast[i].dynamicPositions = {startingNode : startingNode, length: childLen}
        }
        if(toBeInsMap.size){
            toBeInsMap.forEach(function(val, key){
                val.pN.insertBefore(key, val.cN);
                if(val.cN.nextSibling){
                    val.pN.insertBefore(document.createElement("textend"), val.cN.nextSibling);
                }
                else{
                    val.pN.appendChild(document.createElement("textend"));
                }
            })
        }  
        if(stoppedNode) {
        	returnVal = returnVal || {};
        	returnVal.stop = true;
        }
        if(helperNode) {
            if(options.type) {
                helperNode._helpers[options.itemIndex] = updateHelpers;
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            } else {
                helperNode._helpers = helperNode._helpers || [];
                helperNode._helpers.$push.apply(helperNode._helpers, updateHelpers);
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            }
        }
        this.executeBlockHelpers(updateHelpers);
        if(templateDepthHandlingNeeded) {
            content = constr.createDocFragment1(content);  
        }
        return content;
    }

    executeBlockHelpers(updateHelpers, node) {
	    for(let i=0;i<updateHelpers.length;i++) {
            var lastNode = updateHelpers[i].lastNode;
            var parentNode = lastNode.parentNode; 
                
            if(lastNode._placeHolder) {
                lastNode = lastNode._placeHolder;
                parentNode = lastNode.parentNode;
            }
            //parentNode = updateHelpers[i].lastNode.parentNode || updateHelpers[i].lastNode._placeHolder.parentNode;
            _LC.insertBeforeNative(parentNode, updateHelpers[i].toAppendMain, lastNode);
            updateHelpers[i] = updateHelpers[i].lastNode;
	    		// updateHelpers[i].lastNode.parentNode.insertBefore(updateHelpers[i].toAppendMain, updateHelpers[i].lastNode);
	    		// updateHelpers[i] = updateHelpers[i].lastNode;
	    		//updateHelpers[i]._parentIf = node;
//	    		if(!updateHelpers[i]._cx && node) {
//	    			updateHelpers[i]._cx = node._cx;
//	    		}
	    }	
    }

    updateBlockHelpers(updateHelpers,contextSwitchInfo){
        for(let i=0;i<updateHelpers.length;i++) {
            switch(updateHelpers[i].getAttribute('is')) {
            case "f" :
                this.updateForHelper(updateHelpers[i], {"type" : "default"},contextSwitchInfo);
                break;
            case "e" : 
                this.updateSwitchHelper("e",updateHelpers[i],contextSwitchInfo);
                break;
            case "fI" : 
                this.updateForInHelper(updateHelpers[i] , {"type" : "default"},contextSwitchInfo);
                break;
            case "s" :
                this.updateSwitchHelper("s",updateHelpers[i],contextSwitchInfo);
                break;
            case "cM" : 
                this.updateDynamicComponent(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "i" : 
//              this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "yield" : 
            case "r" : 
                if(contextSwitchInfo) {
                    updateHelpers[i]._cx = contextSwitchInfo;
                }
                break;
            default: 
                if(updateHelpers[i].tagName === "LYTE-YIELD") {
                    this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                }
                
            }
         }
    }
    //AttributeChangedCallback will be called for the attributes mentioned in the this._observedAttributes array. 
    static get observedAttributes() {
    		let newArr = [];
            for(let i=0;i<this._observedAttributes.length;i++) {
                newArr[i] = _LC.String.dasherize(this._observedAttributes[i]);
            }
            let customPropHandlers;
            if(this.componentClass){
                customPropHandlers = this.componentClass._registryClass.customPropHandlers
            }else{
                customPropHandlers = _LC.customPropHandlers;
            }
            customPropHandlers.forEach(function(item,index) {
                newArr.$push(_LC.String.dasherize(item));
            })
            return newArr;	
    }

    //Callback from browser, whenever any of the observed attribute changes. 
    //We call the component set, in order to affect the related changes. 
    attributeChangedCallback(attr, oldValue, newValue) {
        this._attributeChangedCallback(attr, oldValue, newValue);
    }
    _attributeChangedCallback(attr, oldValue, newValue){
        if(!this._registryClass || !this.$registry.registeredComponents[this.localName]) {
            return;
        }
        let constr = this.constructor;
       	if((constr._observedMethodAttributes && constr._observedMethodAttributes[attr]) || this.__lyteIgnore) {
   		 	return;
    	}
        let actualAttr = _LC.String.toCamelCase(attr);
        let isCustomProp = this.component._registryClass.customPropHandlers.indexOf(actualAttr);
        if(isCustomProp !== -1) {
            let propValue = this.component._registryClass.customPropHandlers[isCustomProp];
            let lyteProps = newValue;
            if(lyteProps) {
                try{
                    lyteProps = JSON.parse(lyteProps);
                    for(let key in lyteProps) {
                        let actKey = propValue + _LC.String.upperCaseFirstLetter(key);
                        this.set(actKey, lyteProps[key]);
                    }
                } catch (e) {
                    //@Slicer.developmentStart
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC001", attr, this.localName);
                    //@Slicer.developmentEnd
                }
            }
            return;
        }
        if(oldValue === newValue) {
            return;
        }
        var attrNode = this.attributes.getNamedItem(attr);
        if(attrNode) {
            if(attrNode.__lyteIgnore) {
                this.attributes.getNamedItem(attr).__lyteIgnore = false;
                return;    
            }
        } else if(this["__"+attr]) {
            this["__"+attr] = false;
            return;
        }
        let compInstance = this.component;
        let dataType = compInstance.__data[actualAttr].type;
        if(dataType !== "string") {
        	let obj = {"attr" : attr, "tagName" : this.tagName};
        	newValue = _LC.typeCast(newValue, dataType, obj);
        	if(obj.isError) {
                //@Slicer.developmentStart
        		_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn(
                    "data type of the value provided for attribute "+attr+ " of " + this.tagName + " is not valid"
                );
                //@Slicer.developmentEnd
        		return;
        	}
        }
        let compData = compInstance.data;
        if(compData[actualAttr] !== newValue) {
            // Null check is done because when we do a removeAttribute directly on a component, the corresponding value expected is that of undefined and not null.
            this.set(actualAttr, newValue === null ? undefined: newValue);
        } else {
            _LC.clearError(compData, actualAttr);
        }
    }

    //Used to remove helpers of specific index in a for helper. 
    removeHelpersSpecificIndex(node, index,totalProms,fakeRemove,previousPromise) {
        if(node.hc){
            fakeRemove = true;
        }
        if(node._helpers[index]) {
            for(let j=0;j<node._helpers[index].length;j++) {
                    this.removeHelpers(node._helpers[index][j],undefined,undefined,totalProms,fakeRemove,previousPromise);
            }
        }
        let directiveObj = this.getDirectiveObj();
        if(directiveObj && node.hc && node._forContent[index] && node._specialNodes){
            directiveObj.removeForIndexContent(this,node,totalProms,previousPromise,index);
        }else if(node._forContent[index]) {
            if(!fakeRemove){
                // this.rmOtherNodes(node,node._forContent[index],totalProms);
                // if(node._helpers[index]) {
                //     for(let j=0;j<node._helpers[index].length;j++) {
                //         directiveObj.removeFromDomNormal(node._helpers[index][j]);
                //     }
                // }
                if(node._forContent[index]) {
                    for(let i=0;i<node._forContent[index].length; i++ ) {
                        node._forContent[index][i].remove();
                    }
                }
            }
            var self = this;
            Object.keys(node._items[index]._dynamicProperty).forEach(function(key) {
                node._dynProps[key]--;  
                if(!node._dynProps[key]) {
                    let prop  = self.getProperty(key);
                    if(prop._helperNodes) {
                        prop._helperNodes[delStr](node);
                    }
                }
            });
            node._items[index] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
        }
    }
    //Used to remove all the helpers within an helper. 
    removeHelpers(node, update, direct,totalProms,fakeRemove,previousPromise) {
        
        if(!direct) {
            node.remove();
            var helpersObj = node.getAttribute("is") === "component" ? this.__dc : this.__h;
            let nodeId = node.__lyteId;
            delete helpersObj[nodeId];
        }
        if(direct && node.hc){
            fakeRemove = true;
        }
        var del = "delete";
        let parent;
        var contextSwitchArray = [];
        let directiveObj = this.getDirectiveObj();
        _LC.adCx(node, contextSwitchArray);
        if(node._forContent) {
            if(node.getAttribute("is") === "for") {
        	if(node._helpers) {
                for(let i=0;i<node._helpers.length;i++) {
                    for(let j=0;j<node._helpers[i].length;j++) {
                            this.removeHelpers(node._helpers[i][j],undefined,undefined,totalProms,fakeRemove,previousPromise);
                    }
                    directiveObj && directiveObj.checkFakeForAndRemove(fakeRemove,node,i);
                }
            }
            if(directiveObj){
                directiveObj.removeForContent(this,direct,fakeRemove,node,totalProms);
            }else{
                _LC.removeForContent(node);
            }
            let key = node.getAttribute("item");
            if(node._items.length) {
                let prop = node._items[0].itemProperty;
                for(let i=0;i<node._items.length;i++) {
                    let dynProp = node._items[i]._dynamicProperty;
                    for(let dP in dynProp) {
                        let property = this.getProperty(dP); 
                        if(property._helperNodes){
                            property._helperNodes[del](node);                    
                        }
                    }    
                }
                if(prop) {
                    for(let i=0;i<node._items.length;i++) {
                        this.removeBindings({[key] : node._items[i].itemProperty}, {[key] : node._attributes.items[i]});
                    }
                }
            }
            if(!update) {
            	if(node._actualBinding) {
            		if(node._attributes.items && node._attributes.items._bindings && node._actualBinding._createdBinding) {
                        node._attributes.items._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                    var multiplePrpty = node._removedAttributes.items._multipleProperty;
                    if(node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    	multiplePrpty[0].actProp._forHelpers[del](node);
                    }
            	}
            }
            node._items = [];
        } else {
        	if(node._helpers) {
                let keys = Object.keys(node._helpers);
                for(let i=0;i<keys.length;i++) {
                    for(let j=0;j<node._helpers[keys[i]].length;j++) {
                        this.removeHelpers(node._helpers[keys[i]][j],undefined,undefined, totalProms, fakeRemove, previousPromise);
                    }
                    directiveObj && directiveObj.checkFakeForAndRemove(fakeRemove,node,keys[i]);
                }
            }
            if(directiveObj){
                directiveObj.removeForInContent(this,direct,fakeRemove,node,totalProms);
            }else{
                _LC.removeForInContent(node);
            }
            let items = node._items;
            let key = node.getAttribute("key");
            for(let index in items){
                let item = items[index];
                let prop = item.itemProperty;
                let dynamicProp = item._dynamicProperty;
                for(let dP in dynamicProp) {
                    let property = this.getProperty(dP); 
                    if(property._helperNodes){
                        property._helperNodes[del](node);                    
                    }
                }
                if(prop) {
                    this.removeBindings({[key] : node._items[index].itemProperty}, {[key] : node._attributes.object[index]});
                }

            }
            if(!update) {
                if(node._actualBinding) {
                    if(node._attributes.object && node._attributes.object._bindings && node._actualBinding._createdBinding) {
                        node._attributes.object._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                }
                var multiplePrpty = node._removedAttributes.object._multipleProperty;
                if(node._removedAttributes.object && !node._removedAttributes.object.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    multiplePrpty[0].actProp._forHelpers[del](node);
                }
                if(node._propBindingObject && node._attributes.object && node._attributes.object._bindings) {
                    node._attributes.object._bindings[del](node._propBindingObject);
                }
            }
            node._items= {};
          }
        } else if(node._caseContent || node._yieldContent) {
        	if(node._helpers) {
                for(let j=0;j<node._helpers.length;j++) {
                    this.removeHelpers(node._helpers[j],undefined,undefined, totalProms, fakeRemove, previousPromise);
                }
                directiveObj && directiveObj.checkFakeIfAndRemove(fakeRemove,node);
            }
            if(directiveObj){
                directiveObj.removeIfContent(this,direct,fakeRemove,node,totalProms,previousPromise,this);
            }else{
                _LC.removeIfContent(node)
                _LC.removeIfCaseContent(this,node,direct);
                if(node._yieldContent){
                    for(let i=0;i<node._yieldContent.length; i++ ) {
                        node._yieldContent[i].remove();
                    }
                }
            }
            if(node._caseContent){
                for(let key in node._dynamicProperty) {
                    if(node._dynamicProperty[key].isActualNode) {
                        node._dynamicProperty[key].isActualNode._helperNodes[del](node);
                    }else {
                        let helperNodes = this.getProperty(key)._helperNodes;
                        if(helperNodes) {
                            helperNodes[del](node);
                        }
                    }
                }
            }
            node._dynamicProperty = {};
            let viewObj = this.getViewObj()
            if(viewObj){
                viewObj.rmCaseContent(node)
            }
        } else if(node._renderedComponent) {
            for(let key in node._renderedComponent) {
                if(node._renderedComponent[key]) {
                    var renderedComponent = node._renderedComponent[key];
                    if(directiveObj && direct && renderedComponent._hooksPresent){
                        directiveObj.removeRenderedComponent(comp,node,previousPromise);
                    }else{
                        if(!fakeRemove){
                            node._renderedComponent[key].remove();
                            node._renderedComponent[key] = null;
                        }
                    }
                }
            }
        }
          _LC.rmCx(node, contextSwitchArray);
          if(!fakeRemove){
            node._helpers = [];
          }
    }
    updateYield(node, update, contextSwitchInfo,helperNode) {
        let shadowObj = this.getShadowObj();
        let directiveObj = this.getDirectiveObj();
        let app = this.component.getAppOrAddon();
        if(directiveObj){
            node._childPromise = [];
            node._specialNodes = [];
        }
        let constr = this.constructor;
        if(!node._callee) {
            node._callee = this;
        }        
        let toAppend = node._callee._yields[this.getYieldName(node)];
        if(!toAppend) {
        	return;
        }
        node._registerYield = toAppend;
        //ADded now
        let parentScope = toAppend._callee || node._callee._callee;
        if(!parentScope) {
            // if(Lyte._ms) {
            //     var div = createElement("div");
            //     div.innerHTML = toAppend.outerHTML;
            //     // if(Lyte._ie){
            //     //     div.firstChild.innerHTML = toAppend.innerHTML;
            //     //  }
            //     var content1 = div.childNodes[0];
            //     constr.splitTextNodes(content1);
            //     content1 = constr.createDocFragment1(content1);
            //     if(shadowObj && directiveObj && directiveObj.getTransitionArg(this,"shadow-supported") && directiveObj.getTransitionArg(this,"shadow") == true){
            //         shadowObj.updateYield(this,node,toAppend,content1);
            //     }else if(content1){
            //         node.appendChild(content1);
            //     }
            //     else{
            //         node.appendChild(toAppend.content.cloneNode(true, "lyte"));
            //     }
            // } else {
                 if(shadowObj && directiveObj && directiveObj.getTransitionArg(this,"shadow-supported") && directiveObj.getTransitionArg(this,"shadow") == true){
                    shadowObj.updateYield(this,node,toAppend);
                }else{
                    node.appendChild(toAppend.content.cloneNode(true, "lyte"));
                }
            // }
            
            node._helpers = [];
            return;
        }    
	    if(!toAppend._callee) {
    		toAppend._callee = parentScope;
    	} 
        node._dynamicProperty = node._dynamicProperty || {};
        //set values from child component. 
        let obj = {},contextSwitchingArray = {},self = this,contextSwitchArray = [];
        _LC.adCx(toAppend, contextSwitchArray);
        Object.keys(node._properties).forEach(function(key) {
            contextSwitchingArray[key] = {};
            contextSwitchingArray[key].value = parentScope.component.data[key];
            contextSwitchingArray[key].property = parentScope._properties[key];
            parentScope._properties[key] = node._properties[key];
            parentScope.component.data[key] = node.component.data[key];
        }); 
        // htA -> helpertemplateApplied
        if(toAppend._ht && !toAppend._htA) {
            toAppend._htA = true;
            toAppend.content.append(toAppend._ht.content.cloneNode(true));
        }
        let yieldComp = node._callee;
        let content = parentScope.renderNodes(toAppend, toAppend._dynamicNodes || [], node, {"node" : node}, true, undefined, toAppend._tC , yieldComp);
        directiveObj && directiveObj.updateSpecialNodeRef(this,node,toAppend,helperNode);
        if(!_LC.directive.getTransitionArg(node,"unbound")) {
        	_LC.establishBindings(node._properties, node.component.data);
        }else if(!node.component.data.lyteUnbound && !_LC.migratedv2(app)) {        	
        	_LC.establishBindings(node._properties, node.component.data);
        }
        parentScope.executeBlockHelpers(node._helpers);
        Object.keys(node._properties).forEach(function(key) {
            parentScope.component.data[key] = contextSwitchingArray[key].value;
            parentScope._properties[key] = contextSwitchingArray[key].property;
        });
        _LC.rmCx(toAppend, contextSwitchArray); 
        if(shadowObj  && _LC.directive.getTransitionArg(this,"shadow-supported") && _LC.directive.getTransitionArg(this,"shadow") == true){
            shadowObj.updateYield(this,node,toAppend,content,parentScope);
        }else if(content){
            node.appendChild(content);
        }
        else{
            node.appendChild(toAppend.content.cloneNode(true, "lyte"));
        }
    }
    //upddc
    updateDynamicComponent(node, update, contextSwitchInfo, establishBindings) {
    	let returnVal;
        // let registryClass = this._registryClass;
        let directiveObj = this.getDirectiveObj();
        node._callee = this;
        let keepAlive = node.hasAttribute("lyte-keep-alive");
        if(!node._renderedComponent) {
            node._renderedComponent = {};
            let id = _LC.createLyteId(this);
            this.__dc[id] = node;
            node.__lyteId = id;
        }
        
        node._cx = contextSwitchInfo || node._cx;
        node._dynamicProperty = node._dynamicProperty || {};
        let componentName = node.getAttribute("component-name") || (node._attributes ? node._attributes["component-name"] : undefined);
        let componentClass =  node._attributes ? node._attributes["component-class"] : undefined;
        let registryInstance = (node._initProperties ? node._initProperties.lyteRegistry : undefined) || (node._attributes ? node._attributes["lyte-registry"] : undefined);
        let regClass;
        if(!componentName && !componentClass) {
            return;
        }
        //@Slicer.developmentStart
        // else if(componentName){
        //     ComponentError.warn("LC016",componentName);
        // }
        //@Slicer.developmentEnd
        else if(componentClass){
            componentName = componentClass._compName;
            regClass = componentClass._registryClass
        }
        if(directiveObj){
            node._childPromise = []
            directiveObj.checkOngoingPromises(node);
            node._totalPromise = [];
        }
        let component,newComponent = false;
        if(update) {
        	if(keepAlive) {
        		_LC.ignoreDisconnect = true;
        	}
            if(node._renderedComponent[node._currentComponent]) {
                var activeComponent = node._renderedComponent[node._currentComponent];
                if(activeComponent){
                    if(directiveObj && activeComponent._specialNodes && activeComponent._specialNodes.length>0){
                        directiveObj.updateRenderedComp(this,activeComponent,node,keepAlive)
                    }else{
                        if(keepAlive){
                            _LC.hDiv.content.appendChild(activeComponent) 
                        }else{
                            activeComponent.remove();
                        }
                        
                    }
                }
            }
            _LC.ignoreDisconnect = false;
            if(!keepAlive) {
                node._dynamicProperty = {};
            }
            if(node._renderedComponent[componentName] && keepAlive) {
                component = node._renderedComponent[componentName];
            } else {
                if(registryInstance){
                    component = registryInstance.render(componentClass,{});
                }else if(regClass && regClass._instanceList && regClass._instanceList[0]){
                    component = regClass._instanceList[0].render(componentClass,{});
                }
                else{
                    component = createElement(componentName);
                }
                newComponent = true;
            }
        }  else {
            // var flag = false;
            // if(node._initProperties && node._initProperties.lyteRegistry){
            //     _LC.setCurrentRegistryIns(node._initProperties.lyteRegistry);
            //     flag = true;
            // }
            // component = createElement(componentName);
            // if(flag){
            //     _LC.setCurrentRegistryIns(undefined);
            // }
            if(registryInstance){
                component = registryInstance.render(componentClass,{});
            }else if(regClass && regClass._instanceList && regClass._instanceList[0]){
                component = regClass._instanceList[0].render(componentClass,{});
            }
            else{
                component = createElement(componentName);
            }
            newComponent = true;
        }
        if(!keepAlive && node._currentComponent) {
            node._renderedComponent[node._currentComponent] = null;
        }
        if(newComponent) {
//          let componentData = {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].name !== "is" && node.attributes[i].name !== "component-name" && node.attributes[i].name !== "component-class" && node.attributes[i].name !== "lyte-keep-alive" && !node.attributes[i].name.startsWith("@")) {
                    component.setAttribute(node.attributes[i].name, node.attributes[i].value);
                }
            }
//          componentData = component._attributes;
            if(node._attributes) {
                for(var key in node._attributes) {
                    // if(key == "component-data"){
                    //     component.setData(node._attributes[key]);
                    // }
                	// else 
                    if(key!== "component-name" && key!== "component-class") {
                		component.setData(_LC.String.toCamelCase(key), node._attributes[key]);
                	}
                }
            }
            let toAppend = this.renderNodes(node, node._dynamicNodes, node, undefined, establishBindings, undefined, node._tC);
            component.appendChild(toAppend);
            if(directiveObj && activeComponent){
                component._dependentPromise = activeComponent._totalPromise;
            }
            component._toRegEvnts = node._toRegEvnts;
        }
        if(directiveObj){
            returnVal = directiveObj.updateDynamicComp(this,update,component,activeComponent,node,newComponent);
        }else{
            if(!update) {
                returnVal = {"toAppendMain" : component, "lastNode" : node};
            } else {
                _LC.ignoreDisconnect = true;
                _LC.insertBeforeNative(node.parentNode,component, node);
                _LC.ignoreDisconnect = false;
            }
        }
        component._dynComp = true;
        node._renderedComponent[componentName] = component;
        node._currentComponent = componentName;
	    component._callee = this;
        
	    component._actions = node._actions;
        component.setMethods(node._initMethods);
        component._attributeDetails = node._attributeDetails;
        component._boundEvents = node._boundEvents;
        component._cx = node._cx;
        return returnVal;
    }
    // It constructs/updates the for helper. 
    updateForHelper(node, options, contextSwitchInfo, establishBindings, staticTempArr,yieldComp) {
        let directiveObj = this.getDirectiveObj();
        directiveObj && directiveObj.instanciateForPromises(node);
        let app = this.component.getAppOrAddon();
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
            	if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            // if(Lyte._ie) {
            // 	var div = createElement("div");
            //     div.innerHTML = node._tC;
            //     node._origTemplate.innerHTML = div.children[0].innerHTML;
            //     this.constructor.splitTextNodes(node._origTemplate);
            //     if(node.hasAttribute("depth")) {
            //         node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
            //     }
            // }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("item", node.getAttribute("item"));
            node._origTemplate.setAttribute("index", node.getAttribute("index"));
            
            if(!_LC.migratedv2(app) && node.hasAttribute("unbound")) {
                //What if unbound is dynamic attribute ? It will be set in _attributes of node._origTemplate -> So No worries (y)
                node._origTemplate.setAttribute("unbound", "true");
            }
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder);
            // node = _LC.replaceWithOrigTemplate(node)
            node = node._origTemplate;
            node.setAttribute("is", "for");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
            
        } else if(!node._placeHolder){
            var emptyTextNode;
            
                emptyTextNode = document.createTextNode("");
                
            //node.replaceWith(emptyTextNode);
            _LC.replaceWithPf(node, emptyTextNode)
            node._placeHolder = emptyTextNode;
            emptyTextNode._helper = node;
            _LC.apdNode(node, this);
        }
        node._sta = node._sta || staticTempArr;
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentItems === node._attributes.items) {
            return {};
        }
        node._cx = contextSwitchInfo || node._cx;
        let  indexValue = node.getAttribute("index");
        if(!indexValue) {
            node.setAttribute("index", "index");
            indexValue = "index";
        }
        let itemValue = node.getAttribute("item");
        if(!itemValue) {
            node.setAttribute("item", "item");
            itemValue = "item";
        }
        let initialItemValue = callee.component.data[itemValue],initialIndexValue = callee.component.data[indexValue];
        let initialItemProp = callee._properties[itemValue],initialIndexProp = callee._properties[indexValue];
        callee._properties[itemValue] = callee._properties[indexValue] = {};
        let items = node._attributes.items,content = node.content,dynamicNodes = node._dynamicNodes,lastNode = node;
        if(!node._items) {
            node._items = [];
        }
        node._dynProps = node._dynProps || {};
        let lastIndexForIteration;
        let firstIndexForIteration;
        let firstIndex = options.firstIndex;
        let secondIndex = options.secondIndex;
        let thirdIndex = options.thirdIndex;
        var totalNodeIndex = firstIndex + secondIndex;
        var updateIndexProperty = true;
        var indexPropertyStartIndex = 0;
        if(options) {
            switch(options.type) {
            case "remove"  :{
                lastIndexForIteration = firstIndex;
                indexPropertyStartIndex = firstIndex;
                let totalProms = node._totalPromise;
                for(let i=secondIndex; i>0; i--) {
                    let ind = firstIndex + i-1;
                    directiveObj && directiveObj.onGoingForPromise(node,ind)
                    this.removeHelpersSpecificIndex(node, ind, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
                //ln
                /*for(let i=(firstIndex)?firstIndex-secondIndex:firstIndex;i<node._items.length;i++) {
                    let forItem = node._items[i].itemProperty;
                    if(forItem._helperNodes){
                        for (var item of forItem._helperNodes){
                            let ind = item._cx.itemIndex;
                            item._cx.itemIndex = (ind)? ind- secondIndex : ind;
                        }
                    }
                }*/
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {        
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex - secondIndex;        
                }
                node._items.$splice(firstIndex, secondIndex);
                node._helpers.$splice(firstIndex, secondIndex);
                node._forContent.$splice(firstIndex, secondIndex);
                node._specialNodes && node._specialNodes.$splice(firstIndex, secondIndex);
                break;
            }
            case "insert" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                if(node._forContent[firstIndex]) {
                    lastNode = node._forContent[firstIndex][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.$push([]);
                    newObj.$push({});
                    newArr1.$push([]);
                }
                node._helpers.$splice.apply(node._helpers, [firstIndex, 0].$concat(newArr));
                node._items.$splice.apply(node._items, [firstIndex, 0].$concat(newObj));
                //ln
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty;
//                      for (var item of forItem._helperNodes){
//                          item._cx.itemIndex = item._cx.itemIndex + secondIndex;
//                      }
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex;
                }
                node._forContent.$splice.apply(node._forContent, [firstIndex, 0].$concat(newArr1));
                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, 0].$concat(newArr1));
            }
                break;
            case "replace" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                let totalProms = node._totalPromise;
                directiveObj && directiveObj.onGoingForPromise(node,firstIndex)
                this.removeHelpersSpecificIndex(node, firstIndex, totalProms, undefined, totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+1]) {
                    lastNode = node._forContent[firstIndex+1][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.$push([]);
                    newArr1.$push([]);
                    newObj.$push({});
                }
                node._helpers.$splice.apply(node._helpers,[firstIndex, 1].$concat(newArr));
                node._items.$splice.apply(node._items, [firstIndex, 1].$concat(newObj));
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - 1;
                }
                node._forContent.$splice.apply(node._forContent, [firstIndex, 1].$concat(newArr1));
                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, 1].$concat(newArr1));
                if(options.secondIndex == 1){
                    updateIndexProperty = false;
                }
                break;
            }
            case "splice" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                let totalProms = node._totalPromise;
                for(let i=thirdIndex;i>0;i--) {
                    let ind = i + firstIndex-1;
                    directiveObj && directiveObj.onGoingForPromise(node,ind)
                    this.removeHelpersSpecificIndex(node, ind, totalProms, undefined, totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+thirdIndex]) {
                    lastNode = node._forContent[firstIndex+thirdIndex][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.$push([]);
                    newArr1.$push([]);
                    newObj.$push({});
                }
                node._helpers.$splice.apply(node._helpers,[firstIndex, thirdIndex].$concat(newArr));
                node._items.$splice.apply(node._items, [firstIndex, thirdIndex].$concat(newObj));
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - thirdIndex;
                }
                node._forContent.$splice.apply(node._forContent, [firstIndex, thirdIndex].$concat(newArr1));
                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, thirdIndex].$concat(newArr1));
                if(options.secondIndex == options.thirdIndex){
                    updateIndexProperty = false;
                }
                break;
            }
            break;
            case "update" : 
            {
                let key = node.getAttribute("item");
//                  this.removeHelpers(node, true);
                let totalProms = node._totalPromise;
                for(let i=node._items.length-1;i>=0;i--) {
                    directiveObj && directiveObj.onGoingForPromise(node,i)
                    this.removeHelpersSpecificIndex(node, i, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
//                  if(node._attributes.items) {
//                      for(let i=0;i<node._attributes.items.length && node._items[i];i++) {
//                          _LC.removeSelectedBindingDeep(node._items[i].itemProperty[key], node._attributes.items[i]);
//                      }
//                  }
                node._items = [];
        }
            case "default" : 
            {
                node._forContent = [];
                if(directiveObj){
                    node._specialNodes = [];
                }
                node._helpers = [];
                firstIndexForIteration = 0;
                lastIndexForIteration = items? items.length : 0 ;
                indexPropertyStartIndex = items? items.length : 0 ;
            }
            //@Slicer.developmentStart
            break;
            default: 
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC009","updateForHelper")
            //@Slicer.developmentEnd
            }
        }
        if(!lastNode) {
            lastNode = node;
        }
        if(lastNode != node && node._helpers.length > 0  && (options.type == "insert" ||"replace"|| 0) ){
            lastNode = _LC.findLastNodeL(lastNode,totalNodeIndex,node);
        }
        let returnVal;
        var localUnbound = false;
        var initialUnbound = _LC.unbound;
        if((node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound && node._attributes.unbound !== "false")) && !_LC.migratedv2(app)) {
            localUnbound = true;
            _LC.unbound = true;
        }
        if((!node._fRender && (node.getAttribute("unbound") == "lyteFastRender" || (node._attributes && node._attributes.unbound == "lyteFastRender"))) && !_LC.migratedv2(app)) {
            node._fRender = true;
        }
        let unboundDirective = _LC.directive.getTransitionArg(node,"unbound");
        if(unboundDirective){
            if(unboundDirective == "lyteFastRender"){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC010", _LC.errorNodeDetails(node))
                //@Slicer.developmentEnd
            }else{ // if(unboundDirective !== "false")
                localUnbound = true;
                _LC.unbound = true;
            }
        }
        let fastDirective = _LC.directive.getTransitionArg(node,"turbo");
        if(fastDirective){
            if(!node._fRender ){//&& fastDirective !== "false"
                node._fRender = true;
                localUnbound = true;
                _LC.unbound = true;
            }
        }
        node._currentItems = items;        
        if((lastIndexForIteration - firstIndexForIteration) > 0) {
            if(node._ht && !node._htA) {
                node.content.append(node._ht.content.cloneNode(true));
                node._htA = true;
            }
        }
        if(options.type !== "remove") {
            var totalString = "";
            var domArr = [];
            var toAppendMain = createDocFragment();
            for(let k = firstIndexForIteration,v=lastIndexForIteration;v>0; k++, v--) {
                node._helpers[k] = [];
                if(directiveObj){
                    node._specialNodes[k] = [];
                }
                node._items[k] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
                callee.component.data[itemValue] = items[k];
                callee.component.data[indexValue] = k;
                var cacheData = {};
                cacheData[itemValue]={}
                cacheData[itemValue]._data = items[k];
                cacheData[itemValue]._dyn = [itemValue];
                cacheData[indexValue]={}
                cacheData[indexValue]._data = k;
                cacheData[indexValue]._dyn = [indexValue];
                callee._properties[itemValue] = {};
                callee._properties[indexValue] = {};
                let optns = {"itemValue" : itemValue, "itemIndex" : k, "type" : "for", "node" : node, "indexValue" : indexValue};
//                  defProp(callee._properties[itemValue], '_forItem', {
//                      enumerable: false, 
//                      writable: true, 
//                      configurable: true, 
//                      value : optns
//                  });
                node._items[k]._cx = optns;
                let breakCheck = {};
                let toAppend;
                if(node._fRender) {
                    let fastObj = this.getFastObj();
                    let str = fastObj.renderFast(dynamicNodes, node._sta, this.component, undefined, this);
                    totalString = totalString + str;
                    // var template = document.createElement("template");
                    // template.innerHTML = str;
                    // toAppend = template.content;
                } else {
                    dynamicNodes._cache = cacheData;
                    toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, breakCheck, node._tC,yieldComp);
                }
                //to bind in ssr components
                
                let dynProps = Object.keys(node._items[k]._dynamicProperty);
                for(let d=0;d<dynProps.length;d++) {
                    let key = dynProps[d];
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                }
                node._items[k].itemProperty = this.getProperty(itemValue);
                node._items[k].indexProperty = this.getProperty(indexValue);    
//                  if(options.type !== "default") {
                if(!_LC.unbound) {
                	_LC.establishBindings({[itemValue] : node._items[k].itemProperty},{[itemValue]:node._attributes.items[k]});
                }
//                  }
                if(!node._fRender){
                    node._forContent[k] = Array.from(toAppend.childNodes);
                } else {
                    domArr.$push(node._forContent[k] = []);
                }
                //Needs to revisit this and make sure it happen within renderNodes function itself;
//                  if(options.type !== "update") {
                this.executeBlockHelpers(node._helpers[k], node);
                if(!node._fRender) {
                    toAppendMain.appendChild(toAppend);
                }
                if(breakCheck.stop) {
                    break;
                }
            }
            if(node._fRender) {
                var s = document.createElement("template");
                s.innerHTML = totalString;
                toAppendMain.appendChild(s.content);
                _LC.processAction(toAppendMain);
                var childrenArr;
                // if(Lyte._ie) {
                //     childrenArr = [];
                //     var childNodes = toAppendMain.childNodes;
                //     for(var i=0;i<childNodes.length;i++) {
                //         if(childNodes[i].nodeType == 1) {
                //             childrenArr.$push(childNodes[i]);
                //         }
                //     }
                // } 
                // else {
                    childrenArr = toAppendMain.children;
                // }
                for(var i=0;i<domArr.length;i++) {
                    domArr[i].$push(childrenArr[i]);
                }
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.callCC();
                    });
                });
            }
            //Provided so that before appending the component to DOM it is reset to previous value
            _LC.unbound = initialUnbound;
            if(options.type === "default") {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            } else {
                if(directiveObj){
                    var dependentPromises = [];
                    directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);
                    directiveObj.insertInDom(this,lastNode._placeHolder,lastNode,toAppendMain,undefined,undefined,dependentPromises);
                }else{
                    _LC.insertInDom(lastNode._placeHolder,lastNode,toAppendMain);
                }
            }
            if(!localUnbound && node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && node._removedAttributes.items._multipleProperty && node._removedAttributes.items._multipleProperty[0]) {
            	_LC.establishBindings({"items" : node._removedAttributes.items._multipleProperty[0].actProp}, {"items" : items});
            }
        }
        _LC.unbound = initialUnbound;
        if(updateIndexProperty){
            for(let i=indexPropertyStartIndex; i<node._items.length; i++) {
                if(node._items[i].indexProperty) {
                    _LC.affectChanges(node._items[i].indexProperty);
                }
            }
        }
        callee.component.data[itemValue] = initialItemValue;
        callee.component.data[indexValue] = initialIndexValue;
        callee._properties[itemValue] = initialItemProp;
        callee._properties[indexValue] = initialIndexProp;
        node._currentItems = items;
        return returnVal;
    }
    //It constructs/updates forIn Helper.
    //updFIH
    updateForInHelper(node, options, contextSwitchInfo, establishBindings,yieldComp) {
        let directiveObj = this.getDirectiveObj();
        directiveObj && directiveObj.instanciateForPromises(node);
        let app = this.component.getAppOrAddon();
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
                if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            // if(Lyte._ie) {
            // 	var div = createElement("div");
            //     div.innerHTML = node._tC;
            //     node._origTemplate.innerHTML = div.children[0].innerHTML;
            //     this.constructor.splitTextNodes(node._origTemplate);
            //     if(node.hasAttribute("depth")) {
            //         node._origTemplate.setAttribute("depth", node.getAttribute("depth"));
            //     }
            // }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("key", node.getAttribute("key"));
            node._origTemplate.setAttribute("value", node.getAttribute("value"));
            if(node.hasAttribute("unbound") && !_LC.migratedv2(app)) {
                //What if unbound is dynamic attribute ? 
                node._origTemplate.setAttribute("unbound", "true");
            }
            
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder)
            // node = _LC.replaceWithOrigTemplate(node)
            node = node._origTemplate;
            node.setAttribute("is", "forIn");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
        } else if(!node._placeHolder){
            var emptyTextNode;
            
                emptyTextNode = document.createTextNode("");
                
            //node.replaceWith(emptyTextNode);
            _LC.replaceWithPf(node, emptyTextNode);
            node._placeHolder = emptyTextNode;
            _LC.apdNode(node, this);
            emptyTextNode._helper = node;
        }
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentObject === node._attributes.object) {
            return {};
        }
        contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
        node._cx = contextSwitchInfo;
        let key = node.getAttribute("key");
        if(!key) {
            key = "key";
            node.setAttribute("key", "key");
        }
        let value = node.getAttribute("value");
        if(!value) {
            value = "value";
            node.setAttribute("value", "value");
        }
        let initialKeyValue = callee.component.data[key];
        let initialValueValue = callee.component.data[value];
        let initialKeyProp = callee._properties[key];
        let initialValueProp = callee._properties[value];
        callee._properties[key] = callee._properties[value] = {};
        let object = node._attributes.object;
        let content = node.content;
        let dynamicNodes = node._dynamicNodes;
        let lastNode = node;
        let keysArray = [];
        if(!node._items) {
            node._items = {};
        }
        node._dynProps = node._dynProps || {};
        if(options) {
            switch(options.type) {
            case "delete"  :{
                let totalProms = node._totalPromise;
                directiveObj && directiveObj.onGoingForPromise(node,options.property)
                this.removeHelpersSpecificIndex(node, options.property, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                var delIndex = node._keysArray.indexOf(options.property);
                if(delIndex > -1) {
                  node._keysArray.$splice(delIndex,1);
                }
                if(node._helpers) {
                    delete node._helpers[options.property];    
                }
                delete node._propBindingObject[options.property];
            }
            break;
            case "add" : {
                keysArray = [options.property];
                node._keysArray.$push(options.property);
            }
            break;
            case "update" : 
            {
                let totalProms = node._totalPromise;
                let keyObjArr = node._keysArray;
                for(let i=keyObjArr.length-1; i>=0; i--){
                    directiveObj && directiveObj.onGoingForPromise(node,keyObjArr[i])
                    this.removeHelpersSpecificIndex(node, keyObjArr[i], totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
                node._keysArray = keysArray = object ? Object.keys(object) : [];
                node._helpers = {};
                node._items = {};
                node._propBindingObject = {};
            }
            break;
            case "default" : 
            {
                node._forContent = {};
                if(directiveObj){
                    node._specialNodes = {};
                }
                node._helpers = {};
                node._keysArray = keysArray = object? Object.keys(object) : [];
//                  keysArray = Object.keys(object);

            }
            //@Slicer.developmentStart
            break;
            default: 
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC009","updateForInHelper")
            //@Slicer.developmentEnd

            }
        }
        let returnVal;
        if(!object) {
            let toAppendMain = createDocFragment();
            if(options.type !== "default") {
            	_LC.insertBeforeNative(lastNode.parentNode,toAppendMain, lastNode);
            } else {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            }    
        }
        let localUnbound = false;
        let initialUnbound = _LC.unbound;
        if((node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound)) && !_LC.migratedv2(app)) {
            localUnbound = true;
            _LC.unbound = true;
        }
        let unboundDirective = _LC.directive.getTransitionArg(node,"unbound")
        if(unboundDirective){
            localUnbound = true;
            _LC.unbound = true;
        }
        node._currentObject = object;
        if(keysArray.length && node._ht && !node._htA) {
            node.content.append(node._ht.content.cloneNode(true));
            node._htA = true;
        }
        if(object && options.type !== "remove") {
            var toAppendMain = createDocFragment();
            node._propBindingObject = node._propBindingObject || {};
            keysArray.forEach(function(itemKey, index, array) {
                node._helpers[itemKey] = [];
                if(directiveObj){
                    node._specialNodes[itemKey] = [];
                }
                node._items[itemKey] = {"_dynamicProperty" : {}, "itemProperty" : {}};
                callee.component.data[key] = itemKey;
                callee.component.data[value] = object[itemKey];
                callee._properties[key] = {};
                callee._properties[value] = {};
                var cacheData = {};
                cacheData[key] = {}
                cacheData[key]._data = itemKey;
                cacheData[key]._dyn = [key];
                cacheData[value] = {}
                cacheData[value]._data = object[itemKey];
                cacheData[value]._dyn = [value];
                let optns = {"itemIndex" : itemKey, "itemValue" : value, "keyValue" : key, "type" : "forIn", "node" : node};
                node._items[itemKey]._cx = optns;
                dynamicNodes._cache = cacheData;
                let toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, undefined, node._tC,yieldComp);
                Object.keys(node._items[itemKey]._dynamicProperty).forEach(function(key) {
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                })
                node._items[itemKey].itemProperty = this.getProperty(value);
                node._propBindingObject[itemKey] = node._items[itemKey].itemProperty;
                node._forContent[itemKey] = Array.from(toAppend.childNodes);
//                    this.updateBlockHelpers(node._helpers[itemKey], optns);
                this.executeBlockHelpers(node._helpers[itemKey], node);
                //to bind in ssr components
                
                toAppendMain.appendChild(toAppend);
            }, this); 
//              if(options.type !== "update") {
                if(!_LC.unbound && typeof node._attributes.object =='object' && !Array.isArray(node._attributes.object)) {
            		makeSet(node._attributes.object, "_bindings");
                    addBindings(node._attributes.object._bindings,node._propBindingObject);
                    _LC.establishBindings(node._propBindingObject, node._attributes.object);
            	}
//              }
				_LC.unbound = initialUnbound;
                if(options.type !== "default") {
                    if(directiveObj){
                        let dependentPromises = [];
                        directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);
                        directiveObj.insertInDom(this,lastNode._placeHolder,lastNode,toAppendMain,undefined,undefined,dependentPromises);
                    }else{
                        _LC.insertInDom(lastNode._placeHolder,lastNode,toAppendMain);
                    }
                } else {
                    returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
                }

        }
        _LC.unbound = initialUnbound; 
        callee.component.data[key] = initialKeyValue;
        callee.component.data[value] = initialValueValue;
        callee._properties[key] = initialKeyProp;
        callee._properties[value] = initialValueProp;
        node._currentObject = object;
        return returnVal;
    }
    rmCaseBindings(node,templInd,currentInd){
        let casesList = node._co;
        for(let i=templInd+1;i<=currentInd;i++){
            let temp = node._tempList[casesList[i]];
            if(temp){
                _LC.removeDynamicNodes(temp,this);
                node._bindedList[casesList[i]] = false;
            }
        }
    }
    getCaseTemplate(node,nodeTemp,caseName,caseStr){
        var dummyTemp;
        var obj = {};//check
        if(!node._tempList[caseName]){
            // if(Lyte._ms){
            //     dummyTemp = _LC.getContentForIE(node._cases[caseName].templateContent , this.constructor,undefined,obj);
            //     if(obj._content){
            //         dummyTemp = obj._content.childNodes[0];
            //     }
            // }else{
                dummyTemp = nodeTemp.content.querySelector(caseStr+_LC.cssEscape(caseName)+'\']');
            // }
            node._tempList[caseName] = dummyTemp;
        }else{
            dummyTemp = node._tempList[caseName];
        }
        return dummyTemp;
    }
    getCaseIndexScope(node,templateCaseNode,casesList,caseName,switchValue,lyteConvertedSwitch){
        var caseName = templateCaseNode.getAttribute("lc-id");
        var templInd = casesList.indexOf(caseName);
        let val = templateCaseNode._attributes.case;
        var currentInd = casesList.indexOf(node._currentScope);
        var scope;
        if(node._currentScope != "default"){
            if(templInd == currentInd){
                if(val){
                    if(lyteConvertedSwitch){
                        return false;
                    }else if(val==templateCaseNode._prevDataVal){ //second check for lyteconvertedtemp
                        return false;
                    }
                    else if(val == switchValue){
                        scope  = node._cases[caseName];
                    }
                }
            }
            else if(templInd > currentInd){
                return false;
            }
            else if(templInd < currentInd){
                if(val){
                    this.rmCaseBindings(node,templInd,currentInd);
                    scope  = node._cases[caseName];
                    scope.cn = caseName;
                }else{
                    return false;
                }
            }
        }else{
            this.rmCaseBindings(node,templInd,casesList.length-1);//templInd+1
        }
        return scope;
    }
    getSwitchScope(node,templateCaseNode,scope,nodeTemp,helperNode,contextSwitchInfo,switchValue,lyteConvertedSwitch,idx,id){
        var caseStr;
        var casesList = node._co;
        var currentInd = -1;//casesList.indexOf(node._currentScope);
        if(templateCaseNode){
            scope = this.getCaseIndexScope(node,templateCaseNode,casesList,caseName,switchValue,lyteConvertedSwitch);
            if(scope == false){
                return false;
            }
        }
        // else{
        //     currentInd = -1;
        // }
        if(!scope){
            var indexStart = node._currentScope ? currentInd + 1 : 0;
            for(var i=indexStart; i<casesList.length; i++){
                var caseName = casesList[i];
                var dummyTemp;
                if(node._cases[caseName].dcn){
                    caseStr = '[lc-id=\'';
                    dummyTemp = this.getCaseTemplate(node,nodeTemp,caseName,caseStr);
                    dummyTemp._parentSwitch = node;
                    dummyTemp._callee = this;
                    if(node._bindedList[caseName]){
                        if((lyteConvertedSwitch && dummyTemp._attributes.case) || (!lyteConvertedSwitch && dummyTemp._attributes.case == switchValue)){
                            scope  = node._cases[caseName];
                            scope.cn = caseName;
                            dummyTemp._prevDataVal = dummyTemp._attributes.case;
                            if(!templateCaseNode && !lyteConvertedSwitch){
                                this.rmCaseBindings(node,i,casesList.length);
                            }
                            break;
                        }
                    }else{
                        var toBeRemoved = [];
                        dummyTemp._dynamicProperty = dummyTemp._dynamicProperty || {};
                        if(lyteConvertedSwitch && helperNode && i==0){
                            this.bindNode(dummyTemp.attributes.getNamedItem("case"), toBeRemoved,  helperNode , helperNode.getAttribute("is")!="switch" && contextSwitchInfo ? contextSwitchInfo :{}, node._cases[caseName].cdp.a.case,undefined,undefined,undefined,undefined,lyteConvertedSwitch?"l":undefined,idx,undefined,id);
                        }else{
                            this.bindNode(dummyTemp.attributes.getNamedItem("case"), toBeRemoved, dummyTemp ,{}, node._cases[caseName].cdp.a.case,undefined,undefined,undefined,undefined,lyteConvertedSwitch?"l":undefined,idx,undefined,id);
                        }
                        // if(this._ssrBind && textNode){
                        //     textNode.setAttribute( "placeHolderId", dummyTemp.getAttribute( 'bindId' ) );
                        // }
                        
                        // debugger;
                        // if(helperNode){
                        //     helpId = helperNode.getAttribute("bindId");
                            
                        //     obj._helperId = helpId;
                        //     if(/^(for|forIn)$/.test(helperNode.getAttribute("is"))){
                        //         obj._forType = this.getssrType(helperNode.getAttribute("is"));
                        //         obj._forIndex = dynamicN._cx.itemIndex;
                        //     }
                        // }
                        // this.component.data.bindIds.push( obj );
                        dummyTemp._cx = contextSwitchInfo;
                        node._bindedList[caseName] = true;
                        dummyTemp._parentSwitch = node;
                        let val;
                        if(dummyTemp.getAttribute("case")=== "" || dummyTemp.getAttribute("case")) {
                            val = dummyTemp.getAttribute("case");
                        }if(dummyTemp._attributes) {
                            val = dummyTemp._attributes.case;
                        }
                        if((lyteConvertedSwitch && val) || (!lyteConvertedSwitch && val == switchValue)){
                            scope  = node._cases[caseName];
                            scope.cn = caseName;
                            dummyTemp.cn = val;
                            break;
                        }
                    }
                }else if(!lyteConvertedSwitch){
                    //might br stattic caseinbetween
                    caseStr = "[case='";
                    dummyTemp = this.getCaseTemplate(node,nodeTemp,caseName,caseStr);
                        let val = dummyTemp.getAttribute("case");
                        if(val == switchValue){
                            scope  = node._cases[caseName];
                            scope.cn = caseName;
                            dummyTemp._prevDataVal = val;
                            break;
                        }
                }
            }      
        }  
        return scope;
    }
    //updSH
    updateSwitchHelper(type,node, contextSwitchInfo, update, establishBindings,yieldComp,templateCaseNode,helperNode,id,idx){
         var lyteConvertedSwitch = node.getAttribute("l-c");
         let directiveObj = this.getDirectiveObj();
         if(directiveObj){
             directiveObj.checkOngoingPromises(node);
             directiveObj.instanciateForPromises(node);//af
         }
         if(node._ht && !node._htA) {
             node.content.append(node._ht.content.cloneNode(true));
             node._htA = true;
         }
         if(node.tagName !== "TEMPLATE") {
             Object.keys(node).forEach(function(item) {
                 if(item !== "innerHTML" && item !== "innerText") {
                     node._origTemplate[item] = node[item];
                 }
             });
             // if(Lyte._ie) {
             // 	var div = createElement("div");
             //     div.innerHTML = node._tC;
             //     node._origTemplate.innerHTML = div.children[0].innerHTML;
             //     this.constructor.splitTextNodes(node._origTemplate);
             //     if(node.hasAttribute("depth")) {
             //         node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
             //     }
             // }
             let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
             //node.replaceWith(node._origTemplate._placeHolder);
             _LC.replaceWithPf(node, node._origTemplate._placeHolder);
             node = node._origTemplate;
             // node = _LC.replaceWithOrigTemplate(node)
             node.setAttribute("is", _LC.mappy[type]);
             _LC.apdNode(node, this);
             placeHolder._helper = node;
         } else if(!node._placeHolder){
             var emptyTextNode;
             
                 emptyTextNode = document.createTextNode("");
                 
             //node.replaceWith(emptyTextNode);
             _LC.replaceWithPf(node, emptyTextNode);
             node._placeHolder = emptyTextNode;
             emptyTextNode._helper = node;
             _LC.apdNode(node, this);
         }
         let isNew = false;
         let lastNode = node;
         if(!node._callee) {
             node._callee = this;
             isNew = true;
         }
         node._bindedList = node._bindedList || {};
         node._tempList = node._tempList || {};
         contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
         node._cx = contextSwitchInfo;
         node._dynamicProperty = node._dynamicProperty ? node._dynamicProperty : {};
         var switchValue;
         if(node.getAttribute("value")=== "" || node.getAttribute("value")) {
             switchValue = node.getAttribute("value");
         } else if(node._attributes) {
             switchValue = node._attributes.value;
         }
         if(!lyteConvertedSwitch && !node._hd){
             if(switchValue) {
                 switchValue = switchValue.toString();
             } else {
                 switch(switchValue) {
                     case undefined : 
                         switchValue = "undefined";
                         break;
                     case null : 
                         switchValue = "null";
                         break;
                     case false: 
                         switchValue = "false";
                         break;
                     case "": 
                         switchValue = '""';
                         break;
                     case 0 : 
                         switchValue = '0';
                 }
             }
         }
         if((!lyteConvertedSwitch && !node._hd) && switchValue === node._currentCase) {
             return;
         }
         let scope,caseStr;
         node._currentCase = switchValue;
         var nodeTemp = node._depthTemp || node;
         if(node._hd){
             scope = this.getSwitchScope(node,templateCaseNode,scope,nodeTemp,helperNode,contextSwitchInfo,switchValue,lyteConvertedSwitch,idx,id);
             if(scope){
                 node._currentCase = scope.cn;
             }
         }
         else{
             caseStr = '[case=\''
             scope = node._cases[switchValue];
         }
         if(scope === false || (!scope && node._previousScope == "default")){
             return;
         }
         if(node._caseContent && node._caseContent.length) {
             this.removeHelpers(node, undefined, true,node._totalPromise);//, node._hd ?{start:templInd+1,end:node._currentScope != "default"?currentInd:casesList.length-1}:false
         }
         node._currentScope = scope && scope.cn;
         let defaultContent;
         if(!scope){
             scope = node._default;
             node._currentScope = "default";
             defaultContent = nodeTemp.content.querySelector('[default]');
             if(scope._ht && !defaultContent._htA) {
                 defaultContent._htA = true;
                 defaultContent.content.append(scope._ht.content.cloneNode(true));
             }
             node._isDefault = true; 
             if(!defaultContent) {
                 // if(node._caseContent && node._caseContent.length) {
                 //     this.removeHelpers(node, undefined, true ,node._totalPromise);
                 // }
                 // node._previousCase = node._currentCase;
                 node._caseContent = [];
                 let emptyTextNode = document.createTextNode("");
                 node._caseContent.$push(emptyTextNode);
                 node._currentCaseName = switchValue;
                 node._helpers = node._helpers || [];
                 if(update) {
                     //lastNode.parentNode.insertBefore(emptyTextNode, node);
                     if(lastNode._placeHolder) {
                         _LC.insertBeforeNative(lastNode._placeHolder.parentNode,emptyTextNode, lastNode._placeHolder);                    
                     } else {
                         _LC.insertBeforeNative(lastNode.parentNode,emptyTextNode, node);
                     }
                     return;
                 } else {
                     let toAppendMain = createDocFragment();
                     toAppendMain.append(emptyTextNode);
                     return {lastNode : lastNode, toAppendMain : toAppendMain};
                 }
             }
         }
         
 //        if(currentCase) {
 //              if(currentCase.tagName === "TEMPLATE" && !currentCase.getAttribute("is")){
 //                  currentCase = currentCase.content;
 //              } else {
 //                  let temp = createElement('template');
 //                  let clone = currentCase.cloneNode(true);
 //                  temp.content.appendChild(clone);
 //                  currentCase.removeAttribute('slot');
 //                  currentCase = temp.content;
 //              }
 //              scope.content = currentCase;
 //        }
  
         // if(node._caseContent && node._caseContent.length) {
         //     this.removeHelpers(node, undefined, true ,node._totalPromise);
         // }
         let dummyScope = scope;
         let additionalContentArr = [];
         let cnt=0;
         let dummyCaseName = switchValue;
         let template;
         if(defaultContent) {
             template = defaultContent
         } else {
             template = nodeTemp.content.querySelector((scope.dcn ? '[lc-id=\'' : '[case=\'') +_LC.cssEscape(scope.cn ? scope.cn : dummyCaseName)+'\']');
         }
         // if(!template._callee){
         //     template._callee = this;
         // }
         let contentArr = [];
         if(directiveObj){
             node._specialNodes = [];
         }
         let nextCaseName;
         while(dummyScope) {
             if(dummyScope._ht && !template._htA) {
                 template._htA = true;
                 template.content.append(dummyScope._ht.content.cloneNode(true));
             }
             let dynamicNodes = dummyScope.dN;
             if(nextCaseName && node._cases[nextCaseName].dcn){
                 caseStr = '[lc-id=\'';
                 var tempNode = this.getCaseTemplate(node,nodeTemp,nextCaseName,caseStr);
                 if(!node._bindedList[nextCaseName]){
                     var toBeRemoved = [];
                     tempNode._dynamicProperty = tempNode._dynamicProperty || {};
                     this.bindNode(tempNode.attributes.getNamedItem("case"), toBeRemoved, tempNode ,{}, node._cases[nextCaseName].cdp.a.case);
                     tempNode._cx = contextSwitchInfo;
                     node._bindedList[nextCaseName] = true;
                     tempNode._parentSwitch = node;
                 }
             }
             let processedContent = this.renderNodes(template, dynamicNodes, node, undefined, establishBindings, undefined, dummyScope.templateContent,yieldComp);
             
             contentArr.$push(processedContent);
             if(dummyScope.additional) {
                 if(node._cases[dummyScope.additional.next] && node._cases[dummyScope.additional.next].dcn){
                     caseStr = '[lc-id=\'';
                 }else{
                     caseStr = '[case=\''
                 }
                 if(dummyScope.additional.next) {
                     nextCaseName = dummyScope.additional.next;
                     template = node.content.querySelector(caseStr+_LC.cssEscape(dummyScope.additional.next)+'\']');
                     dummyScope = node._cases[dummyScope.additional.next];
                 } else {
                     template = node.content.querySelector('[default]');
                     dummyScope = node._default;
                 }
             } else {
                     break;
             }
         }
         node._caseContent = [];
         let toAppendMain = createDocFragment();
         for(let i=0;i<contentArr.length;i++) {
             if(contentArr[i].nodeType == 11){
 //                for(let j=0;j<contentArr[i].childNodes.length;j++) {
 //                    node._caseContent.$push(contentArr[i].childNodes[j]);
 //                }
                 node._caseContent = node._caseContent.$concat(Array.from(contentArr[i].childNodes));
             }
             else{
                 node._caseContent.$push(contentArr[i]);
             }
                 toAppendMain.append(contentArr[i]);
 //            node.parentNode.insertBefore(contentArr[i], node);
         }
           this.executeBlockHelpers(node._helpers, node);
           if(update) {
               let returnVal;
               if(toAppendMain.querySelector("template[is=break]")) {
                   returnVal = "break";
               } else if(toAppendMain.querySelector("template[is=continue]")) {
                   returnVal = "continue";
               }
               if(directiveObj){
                 let dependentPromises = [];
                 directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);
                 directiveObj.insertInDom(this,node._placeHolder,node,toAppendMain,node._previousCase ?false:true,undefined,dependentPromises);
               }else{
                 _LC.insertInDom(node._placeHolder,node,toAppendMain);
               }

               node._previousCase = node._currentCase;
               node._previousScope = node._currentScope;
               return returnVal;
           } else {
                 node._previousCase = node._currentCase;
                 node._previousScope = node._currentScope;
               return {"toAppendMain" : toAppendMain, "lastNode" : node};
           }
     }

    dummy(a,b) {
        let dummy = this.component.constructor._properties[boundValue].observer;
    }

    callObservers(boundValue, key) {
        let property = this.component.constructor._properties[boundValue];
        let observers = property?property.observer: undefined;
        if(observers) {
            for(let i=0;i<observers.length;i++) {
                if(key.indexOf('.') === -1 || observers[i].path === key) {
                    this["_"+observers[i].functionName].apply(this);
                }
            }
        }
    }

    // static updateValue(property, path, value) {
    //     let pathVals = path.split('.');
    //     let context = property;
    //     for(let i=0;i<pathVals.length -1;i++) {
    //         context = context[pathVals[i]];
    //     }
    //     context[pathVals[i]] = value;
    // }

    //    static createDocFragment(template){
    //        let childNodes = template.cloneNode(true,"lyte").childNodes;
    ////           let childNodes = template.childNodes;
    //        let frag = document.createDocumentFragment();
    //        let len = childNodes.length;
    //        for(let i=0; i<len; i++){
    //            frag.appendChild(childNodes[0]);
    //        }
    //        return frag;
    //    }

    static createDocFragment1(template) {
        if(template.content) {
            return template.content;
        }
    	let childNodes = template.childNodes;
    	let frag = createDocFragment();
    	let len = childNodes.length;
    	for(let i=0; i<len; i++){
            frag.appendChild(childNodes[0]);
        }
    	return frag;
    }
    static seperateStyle(componentClass,componentsDiv){
        componentClass._template.replace(/\\'/g,"'");
        let div = createElement("div");
        div.innerHTML = componentClass._template;
        while(div.firstChild){
            if(div.firstChild.nodeName === "STYLE") {
                componentClass._style = div.firstChild.outerHTML;
                div.firstChild.remove();
            } else {
                // div.firstChild.setAttribute("lyte-registry",componentClass._registryClass.name);
                componentsDiv.appendChild(div.firstChild);
            }
        }
    }
    static _registerComponent(a,b,componentClass,registry,registryInstance) {
        let componentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv ,registry.name);
        let origTemplateValue = componentClass._template;
        let app = _LC.getAppOrAddon(registryInstance);
        var clonedDummyTemp;
        if(componentClass._template && typeof componentClass._template === "string"){
            this.seperateStyle(componentClass,componentsDiv);
        }else if(componentClass.template && typeof componentClass.template === "object"){
            componentClass._template = componentClass.template._template;
            componentClass._dynamicNodes = componentClass.template._dynamicNodes;
            componentClass.template = undefined;
            this.seperateStyle(componentClass,componentsDiv);
        }
        componentClass._template = componentsDiv.querySelector("template[tag-name='"+a+"']");
        componentClass._helperTemplate = document.createElement("template");
        componentClass._helperTemplate.setAttribute("_lyteht", a );
        _LC.h1Div.content.appendChild(componentClass._helperTemplate);
        if(!componentClass._template) {
            //@Slicer.developmentStart
            console.error("Template not found for the component : '"+a+"'");
            //@Slicer.developmentEnd
        	return;
        }
        if((_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().needDummyComponentsDiv)) {
            // if(Lyte._ie) {
            //     let temp = Compile.getTemplateFromString(origTemplateValue);
            //     // let dummyLyteComponentsDiv = _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name);
            //     _LC.getComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name)
            //     dummyLyteComponentsDiv.appendChild(temp);
            // } else {
                clonedDummyTemp = componentClass._template.cloneNode(true);   
            // }
        }
        if(componentClass._template && !componentClass._template.content){
//            var frag = document.createDocumentFragment();
//            let childNodes = this._template.cloneNode(true,"lyte").childNodes;
//            //let childNodes = this._template.childNodes;
//            let len = childNodes.length;
//            for(let i=0; i<len; i++){
//                frag.appendChild(childNodes[0]);
//            }
//            this._template.content = frag;
        }
        // var s = Lyte._ie ? componentClass._template : componentClass._template.content;//)?this._template.content:document.createDocumentFragment(this._template);
        var s = componentClass._template.content; //)?this._template.content:document.createDocumentFragment(this._template);
        //This is used to split text nodes which contain multiple dynamic values 
        //Eg." Name is {{name}} and age is {{age}} "
        //This is used to find the dynamicNodes and helper nodes for the given component. 
        if(!componentClass._dynamicNodes){
            if((_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getDynamicNodes)) {
                var returnVal = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getDynamicNodes(a);
                if(returnVal.errors){
                    //@Slicer.developmentStart
                    console.error("Error in the component", returnVal.componentName, returnVal.errors);
                    //@Slicer.developmentEnd
                    return false;
                }else{
                    componentClass._dynamicNodes = returnVal.dynamicNodes;
                    if(componentClass._dynamicNodes && componentClass._dynamicNodes.length && componentClass._dynamicNodes[componentClass._dynamicNodes.length-1].type == "dc"){
                        b.dc = componentClass._dynamicNodes.$pop();
                    }
                }
            } 
            //@Slicer.developmentStart
            else {
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC002", a);  
            }
            //@Slicer.developmentEnd
	    } 
        if(componentClass._dynamicNodes) {
            this.setTemplateAttributes(a, componentClass, clonedDummyTemp);
            var hasUnbound = this.getFastRenderSupported(componentClass._templateAttributes);
            let fastRenderClass = registry.getFastObj();
            // var hasUnbound = b._observedAttributes.indexOf("lyteUnbound") !== -1;
            if(!hasUnbound && !_LC.migratedv2(app)){
                hasUnbound = b._observedAttributes.indexOf("lyteUnbound") !== -1;
            }
            var newCompile;
            if(hasUnbound) {
                if(fastRenderClass){
                    newCompile = fastRenderClass.getNewCompile(componentClass);
                }
                //@Slicer.developmentStart
                else{
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC011")
                }
                //@Slicer.developmentEnd
                // if(Lyte._ie) {
                //     newCompile = document.createElement("div");
                //     newCompile.innerHTML = componentClass._template.outerHTML;
                //     newCompile = newCompile.childNodes[0];
                // } else {
                //     newCompile = componentClass._template.cloneNode(true);
                // }
            }
            this.splitTextNodes(s);
            if(hasUnbound && fastRenderClass) {
                this.splitTextNodes(newCompile);
            }
            doCompile(s, componentClass._dynamicNodes, a, b, newCompile ? newCompile.content : undefined, componentClass, fastRenderClass);
            // if(Lyte._ed) { 
            //     componentClass._tC = componentClass._template.outerHTML;
            // } 
            // else if(Lyte._ie) {
            //     componentClass._tC = s.outerHTML;
            // }
        }
        clonedDummyTemp && _LC.getComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name).appendChild(clonedDummyTemp);
        componentClass._sta = newCompile ? _LC.processStatic(newCompile) : undefined;
    }
    static getFastRenderSupported(templateAttributes){
        if(templateAttributes && templateAttributes.a){
            for(let attrName in templateAttributes.a){
                if(attrName == "@unbound-supported" || attrName == "@turbo-supported" ){
                    return true;
                }
            }
        }

    }
    static setTemplateAttributes(a, componentClass,clonedDummyTemp){
        componentClass._templateAttributes = {t : "a", "a" : {}, p: []};
        var ta = [componentClass._templateAttributes];
        doCompile(componentClass._template, ta, a, this, undefined, componentClass);
        componentClass._templateAttributes = ta[0];
        if(componentClass._templateAttributes && componentClass._templateAttributes.a) {
            var attributesT = componentClass._template.attributes;
            try{
                for(let i=0;i<attributesT.length;i++) {
                    let attrName = attributesT[i].name;
                    if(!componentClass._templateAttributes.a[attrName] && attrName !== "tag-name" && attrName !== "use-strict" && attrName !== "lyte-registry" && attrName !== "__vp") {
                        componentClass._templateAttributes.a[attrName] = {"name" : attrName, "staticValue" :  attributesT[i].value};
                        componentClass._template.removeAttribute(attrName);
                        clonedDummyTemp && clonedDummyTemp.removeAttribute(attrName);
                        i--;
                    }
                }    
            } catch(e) {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC012")
                //@Slicer.developmentEnd
            }
        }
    }
    //This is used to split text nodes which contain multiple dynamicNodes. 
    static splitTextNodes(node) {
        if(node && node.childNodes && node.childNodes.length) {
            for(let i=node.childNodes.length-1;i>=0;i--) {
                this.splitTextNodes(node.childNodes[i]);
            }
        }
        if(node.tagName === "TEMPLATE") { // && !Lyte._ie
            this.splitTextNodes(node.content);
        }
        if(node.nodeType === node.TEXT_NODE) {
            let nodeValue = node.nodeValue;
            if(nodeValue){
                let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
                if(!mustacheValues) {
                    return;
                }
                let newNodeArray = [];
                for(let i=0;i<mustacheValues.length;i++) {
                    let mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);
                    let mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                    if(mustacheStartIndex) {
                            newNodeArray.$push(document.createTextNode(nodeValue.substring(0, mustacheStartIndex)));
                    }
                    newNodeArray.$push(document.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
                    nodeValue = nodeValue.substring(mustacheEndIndex);
                }
                if(!(!nodeValue.trim() && node.nextSibling && node.nextSibling.nodeType === 3 && !node.nextSibling.nodeValue.trim())) {
                    newNodeArray.$push(document.createTextNode(nodeValue));
                }
                //Fix for IE Edge issue with higher versions where node.replaceWith is not working when the parent is a doc fragment.
                if(node.parentNode.nodeName === "#document-fragment") {
                	for(let i=0;i<newNodeArray.length;i++) {
                		_LC.insertBeforeNative(node.parentNode,newNodeArray[i],node);
                      }
                    node.remove();
                } else {
                	node.replaceWith.apply(node, newNodeArray);
                } 
            }
        }
    }
    //It registers the binding of the node with the properties with which the dynamicNode depends. 
    bindNode(node, toBeRemoved, helperNode, options, nodeInfo, processLast, establishBindings, isTemplate,cache,type,idx,toBeInsMap,bId) {
        let lyteConvertedSwitch = false;
        if(type == "l"){
            lyteConvertedSwitch = true;
            type = "a";
        }
        let itemValue = options.itemValue;
        let forIndex = options.itemIndex;
        let forType = options.type;
        let indexValue = options.indexValue;
        let dynamicValue = nodeInfo.dynamicValue;
        let helperFunc = nodeInfo.helperInfo;
        let nodeValue, ownerElement = node.ownerElement;
        let dynamicValuesArray = [];
        let isDirectiveNode;
        let directiveObj = this.getDirectiveObj();
//        if(node.nodeType === 2 && _LC.isCustomElement(node.ownerElement,true) ) {
//          node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue};
//        }
        if(node.nodeType === 2) {
            node = {nodeName : node.nodeName, ownerElement : node.ownerElement, nodeType : 2, nodeValue : node.nodeValue, _attributeDetails : node._attributeDetails, _isDirectiveNode : nodeInfo._isDirectiveNode};
            // if(directiveObj){
            isDirectiveNode = _LC.directive.isDirectiveNode(node)
            // }
        }
        //to get bindings in ssr components
        
        node._callee = this;
        let isHelper = false;
        if(helperFunc && Object.keys(helperFunc).length) {
            isHelper = true;
            if(helperFunc._t){
                node._sq = true;
            }
            let attrName = node.nodeName;
            nodeValue = node.helperValue = helperFunc;
            let helperArgs = [];
            if(helperFunc.name === "action"){
                let actName = helperFunc.args[0];
                helperFunc.args[0] = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                // if(forType) {
                //     ownerElement._cx = options;
                // } else if(helperNode) {
                //     ownerElement._cx = helperNode._cx;
                // }
                actName = helperFunc.args.slice(0,1)[0];
                let args = helperFunc.args.slice(1,helperFunc.args.length), isCustom = false;
                let attrName = node.nodeName;
                if(attrName.indexOf("-") != -1){
                    isCustom = true;
                }
                helperArgs = [ownerElement,attrName,isCustom,{name:actName,args:args}];
                this.processHelper(this, {"name" : helperFunc.name, "args" : helperArgs}, node);
                return;
            } else{
                if(helperFunc.name === "method") {
                    helperArgs = helperFunc.args;
                         
                } else {  
                    helperArgs = this.processArgs(this,{"helperInfo" : helperFunc} ,dynamicValuesArray,undefined,node,false,helperFunc._t ?undefined:cache);
                }
            }
            if(helperFunc._t == "sq"){
                nodeValue = this.processArray(this,{"name" : helperFunc.name, "args" : helperArgs},dynamicValuesArray,helperFunc.extra,event, node, undefined);
            }
            else{
                nodeValue = this.processHelper(this, {"name" : helperFunc.name, "args" : helperArgs}, node);
            }
            if(helperFunc.name === "unescape"){
//              let test = node.replaceWith.apply(node,nodeValue.childNodes);
                let obj = {
                    initialNode : node,
                    dynamicNodeValue : nodeValue
                };
                node = {dynamicPositions : obj, "_callee" : node._callee, helperValue : node.helperValue};
                nodeValue = undefined;
                processLast.$push(node);
            }
        } else {
            helperFunc = {};
            node.syntaxValue = dynamicValue;
            let dynamicValues = [];
            nodeValue = _LC.get(this.component.data, dynamicValue, dynamicValues,cache);
            dynamicValuesArray.$push(dynamicValues);
        }
        //if(node.nodeType === 2 && ( (typeof nodeValue !== "string" && (_LC.isCustomElement(node.ownerElement,true) || typeof nodeValue === "boolean") ) || _LC.isControlHelper(node.ownerElement) )) {
        //	let bindedNode = node;
            //node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue, _callee : this, syntaxValue : node.syntaxValue, helperValue : node.helperValue, _attributeDetails : node._attributeDetails};
        if(node.nodeType == 2) {
            let tagName = node.ownerElement.tagName;
            if(tagName == "INPUT" || tagName == "TEXTAREA" || (tagName == "DIV" && node.ownerElement.hasAttribute("contenteditable") )) {
                var rA = node.ownerElement._rA = node.ownerElement._rA || [];
                node.ownerElement._rA.$push(node);
            }
            if(!ownerElement._origTemplate) {
                if(( ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") ) && ownerElement.tagName !== "TEMPLATE") {
                    // if(Lyte._ie) {
                    //     node.ownerElement = createElement("template");
                    //     node.ownerElement.setAttribute("is", nodeInfo._depthTemp);
                    // } else {
                        node.ownerElement = nodeInfo._depthTemp.cloneNode(true);
                    // }
                    ownerElement._origTemplate = node.ownerElement;
                }
            } else {
                node.ownerElement = ownerElement._origTemplate;
            }
        //	node.ownerElement._attributeDetails[node.nodeName].bindedNode = node;
        //}
        }
        let actMultiProp; 
        if(helperFunc.name !== "unbound" && !_LC.unbound) {
            let dynamicProp;
            if(helperNode) {
                dynamicProp = forType? helperNode._items[forIndex]._dynamicProperty : helperNode._dynamicProperty;
            }
            let obj, helperId;
            for(let d=0;d<dynamicValuesArray.length;d++) {
            	let dynamicValues = dynamicValuesArray[d];
                
            	for(let v=0;v<dynamicValues.length;v++) {
                    //to get binding in ssr components
                    var _nes = false;
                    
            		let actProperty = this.getProperty(dynamicValues[v]);
            		if(helperNode) {
            			let ind = dynamicValues[v].search(/\W/);
            			let boundValue;
            			if(ind !== -1) {
            				boundValue = dynamicValues[v].substring(0, ind);
            			} else {
            				boundValue = dynamicValues[v];
            			}
            			if(boundValue !== itemValue && boundValue !== indexValue && (!options.node || !options.node._properties || !options.node._properties[boundValue])) {
            				//to bind for in ssr
                            
                            makeSet(actProperty, "_helperNodes");
            				actProperty._helperNodes.add(
            						helperNode
            				);
            				dynamicProp[dynamicValues[v]] ? dynamicProp[dynamicValues[v]].$push(node): (dynamicProp[dynamicValues[v]] = []).$push(node);
            			} 
            			else {
            				node._cx = options;
//            				if(!actProperty._dynamicNodes) {
//            					actProperty._dynamicNodes = [];
//            					defProp(actProperty, '_dynamicNodes', {
//            						value: [],
//            						enumerable: false, 
//            						writable: true, 
//            						configurable: true
//            					});
//            				}
            				makeArray(actProperty, "_dynamicNodes");
                            if(actProperty._dynamicNodes.indexOf(node) == -1){
            				    actProperty._dynamicNodes.$push(node);
                            }
            				if(boundValue !== indexValue) {
            					actMultiProp = actProperty;
            				}
            			}
            		} else {
//            			if(!actProperty._dynamicNodes) {
//            				defProp(actProperty, '_dynamicNodes', {
//            					value : [], 
//            					enumerable: false, 
//            					writable: true,
//            					configurable: true
//            				});
//            			}
            			makeArray(actProperty, "_dynamicNodes");
                        if(actProperty._dynamicNodes.indexOf(node) == -1){
            			    actProperty._dynamicNodes.$push(node);
                        }
            		}
            		if ((ownerElement && (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") )) || (ownerElement && ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(ownerElement.getAttribute("is")) && !isHelper)) {
            			let type= ownerElement.getAttribute("is");
            			if( (type=== "for" && node.nodeName === "items") || (type==="forIn" && node.nodeName === "object")) {
            				if(!actProperty._forHelpers) {
            					makeSet(actProperty, "_forHelpers");
            				}
                            //to bind for in ssr
                            
            				node.ownerElement._actualBinding = actProperty;
            				actProperty._forHelpers.add(node.ownerElement);
            			}
            		}
            		if(establishBindings) {
            			_LC.establishSelectedBinding(actProperty, this.component.data, this );
            		}
                    //to get ssr bindings 
                     
            	}
                
                if(dynamicValues.length > 1 || helperFunc._t) {
            		node._multipleProperty = node._multipleProperty || [];
            		node._multipleProperty.$push({"dynamicProp" : actMultiProp ? undefined : dynamicProp, "actProp" : this.getProperty(dynamicValues[0]), "helperNode" : helperNode, "dynamicValues" : dynamicValues, index:d});
            	}
                
            }
        }
        nodeValue = !typeof nodeValue === "boolean" && !typeof nodeValue === "number" ? (nodeValue? nodeValue : ""): nodeValue;
        if(isDirectiveNode){
            _LC.directive.setNodeArgs(node,nodeValue);
        }
        else if(node.nodeType === 2) {
            let parentNode = node._parentNode? node._parentNode : node.ownerElement;
            if(parentNode.tagName) {
                let is = parentNode.getAttribute("is");
            }
            let isCustomElement = _LC.isCustomElement(parentNode,true);
            if(isCustomElement && !isDirectiveNode) {
                 if(parentNode.set) {
                    parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue);
                 } else {
                    parentNode._initProperties = parentNode._initProperties || {};
                     parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] =nodeValue;
                }
            }
            let origNodeValue = nodeValue;
            // if(directiveNode){
            //     node.ownerElement._transitionArgs = origNodeValue;
            //     node.ownerElement.removeAttribute(node.nodeName);
            //     node.nodeName = node.nodeName.slice(1,node.nodeName.length);
            // }
            //!== "string"
            if(isCustomElement && typeof nodeValue !== "string" && !isTemplate) {
                parentNode._attributes = parentNode._attributes || {};
                parentNode._attributes[node.nodeName] = nodeValue;
                if(parentNode.nodeName === "TEMPLATE" && isHelper) {
                    if((parentNode.getAttribute("is") === "for" && node.nodeName === "items") || (parentNode.getAttribute("is") === "forIn" && node.nodeName === "object") && !_LC.unbound) {
                        //node._actualBinding = {"_forHelpers" : new Set().add(parentNode)};
                        node.ownerElement._actualBinding = {
                            "_forHelpers" : new Set().add(parentNode),
                            "_createdBinding" : true
                        };
                        if(nodeValue && typeof nodeValue !== "number"){
                            makeSet(nodeValue, "_bindings");
                            addBindings(nodeValue._bindings,node.ownerElement._actualBinding);
                        }
                    }
                }
                toBeRemoved.$push(node.nodeName);
            }
            else {
                if(typeof nodeValue === "boolean") {
                    parentNode._attributes = node.ownerElement._attributes || {};
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(!nodeValue) {
//                      node.ownerElement.removeAttribute(node.nodeName);
                        toBeRemoved.$push(node.nodeName);
                    } else {
                        parentNode.setAttribute(node.nodeName, "");
                    }
                } else {
                    if(nodeValue && typeof nodeValue === "object"){
                        var res;
                        if(typeof Record != "undefined" && nodeValue instanceof Record){
                            res = JSON.stringify(nodeValue.$.toJSON())
                        }
                        else{
                            try{
                                res = JSON.stringify(nodeValue)
                            }
                            catch(exp){
                                //@Slicer.developmentStart
                                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error(
                                    "LC013",
                                    node.nodeName,
                                    node.ownerElement.nodeName.toLocaleLowerCase(),
                                    node.ownerElement.nodeName.toLocaleLowerCase()
                                )
                                //@Slicer.developmentEnd
                            }
                        }
                    }
                    else if(nodeValue== null || nodeValue == undefined){
                        res = ""
                    }
                    else{
                        res = nodeValue;
                    }
                    nodeValue = res;
                    if(_LC.isControlHelper(node.ownerElement)) {
                    	 parentNode._attributes = node.ownerElement._attributes || {};
                         parentNode._attributes[node.nodeName] = nodeValue;
                         toBeRemoved.$push(node.nodeName);
                    } else {
                         let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                         //if(node.nodeName === "style") {
                         //   node.ownerElement.setAttribute("style",locNodeVal);
                         //} else {
                         //   node.nodeValue = locNodeVal;
                         //}
                         node.ownerElement.setAttribute(node.nodeName, locNodeVal);
                    }
                    
                }
            }
            if(parentNode.tagName === "LYTE-YIELD" /*parentNode.getAttribute("is") === "insertYield"*/) {
                parentNode.component.data[_LC.String.toCamelCase(node.nodeName)] = origNodeValue;
            }
            if (/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if (node.nodeName === "value") {
                            parentNode.value = (nodeValue === undefined) ? "" : nodeValue;
                        } else if (node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
            }
            if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                toBeRemoved.$push(node.nodeName);
            }
        } 
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
	return node;
    }

    debounce(func, threshold) {
        var timeout;
        return function debounced() {
            var obj = this, args = arguments;
            function delayed() {
            	func.apply(obj, args);
                timeout = null;
            };
            if (timeout){
            	clearTimeout(timeout);
            }
            timeout = setTimeout(delayed, threshold || 100);
            //console.log(timeout,threshold);
        };
    }
    getProperty(key) {
        var arr = key.match(/([^[\].]+|\[\])/g);
        let property = this;
        if(!property._properties[arr[0]]) {
            property._properties[arr[0]] = {};
        } 
        property = property._properties[arr[0]];
        
        defProp(property, '_path', {enumerable: false, value : arr[0]});
        for(let i=1;i<arr.length;i++) {
            if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
			    arr[i] = arr[i].substring(1, arr[i].length -1);
		    }
            if(!property[arr[i]]) {
                property[arr[i]] = {};
                defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
            }
            property = property[arr[i]];
        }
        return property;
    }
    //updN
    updateNode(node, updatePath) {
        let compInstance = this.component;
        var del = "delete";
        let multiplePropNode = [];
        let multipleProp;
        let nodeHasHelperNode;
        let isDirectiveNode;
        if(node.nodeType == 2){
            isDirectiveNode = _LC.directive.isDirectiveNode(node)
        }
        if(node._multipleProperty) {
        	for(var i=0;i<node._multipleProperty.length;i++) {
        		if(node._multipleProperty[i]  && node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) > 0 ) {
                    var dynStartIndex = node._sq ? node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) : 1;
                    multiplePropNode[i] = false;
                    multipleProp = node._multipleProperty[i];
		            let nodes;
                    for(var j=0;j<dynStartIndex;j++){
                        var pathName = node._sq ? multipleProp.dynamicValues[j] : multipleProp.actProp._path;
                        if(multipleProp.dynamicProp){
                            nodeHasHelperNode = true;
                            if(!node._sq || multipleProp.dynamicProp[multipleProp.dynamicValues[j]]){
                                multiplePropNode[i] = multipleProp;
                                nodes = multipleProp.dynamicProp[pathName];
                                if(nodes  && pathName.indexOf('.') != -1) {
                                    let index = nodes.indexOf(node);
                                    if(index != -1){
                                        nodes.$splice(index, 1);
                                    }
                                }
                                let helperNode = multipleProp.helperNode;
                                if(nodes.length === 0) {
                                    if(helperNode.getAttribute("is") === "if" || helperNode.getAttribute("is") === "switch" || (helperNode.hasAttribute("lc-id") && helperNode.getAttribute("is") === "case")) {
                                        multipleProp.actProp._helperNodes[del](helperNode);
                                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
                                    } else {
                                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
                                        if(helperNode._items) {
                                            let removeHelper = true;
                                            for(let i=0;i<helperNode._items.length;i++) {
                                                if(helperNode._items[i]._dynamicProperty && helperNode._items[i]._dynamicProperty[pathName]) {
                                                    removeHelper = false;
                                                    break;
                                                }
                                            }
                                            if(removeHelper) {
                                                multipleProp.actProp._helperNodes[del](helperNode);
                                                //console.log('for helper is removed');
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if(!nodeHasHelperNode) {
                            if(multiplePropNode[i] == false){
                                multiplePropNode[i] = ["dynamicNodes"];
                            }else{
                                multiplePropNode[i].$push("dynamicNodes");
                            }
                            var prop = this.getProperty(pathName);
                            nodes = prop._dynamicNodes;
                            if(nodes) {
                                let index = nodes.indexOf(node);
                                if(index != -1 && pathName!=updatePath && pathName.indexOf('.') != -1){
                                    nodes.$splice(index, 1);
                                    if(!nodes.length) {
                                        delete prop._dynamicNodes;
                                    }
                                }
                            }
                        }else{
                            nodeHasHelperNode=false; 
                        }
                    }
		        }
			}
		}
        if(!node.syntaxValue && !node.helperValue) {
            return;
        }
        let contextSwitchInfo;
        let isYieldContext;
        if(node._cx || (node.nodeType === 2 && node.ownerElement._cx)) {
            contextSwitchInfo = node._cx || node.ownerElement._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo );
        } else if(node.tagName === "LYTE-YIELD" && node._callee._cx) {
        	isYieldContext = true;
        	contextSwitchInfo = node._callee._cx;
        	var contextSwitchArray = [];
        	_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
        }
        let nodeValue;
        let dynamicValues = [];
        var isHelper = false;
        let helperRetVal;
        if(node.helperValue){
            isHelper = true;
            nodeValue = node.helperValue;
                    let helperFunc = nodeValue;
                    if(helperFunc._t){
                        node._sq = true;
                    }
                    let helperArgs = this.processArgs(this,{"helperInfo" : helperFunc} ,dynamicValues,undefined,node);    
                    if(helperFunc._t == "sq"){
                        helperRetVal = this.processArray(this,{"name" : helperFunc.name, "args" : helperArgs},dynamicValues,helperFunc.extra,undefined, node, undefined);
                    }else{
                        helperRetVal = this.processHelper(this,{"name" : helperFunc.name, "args" : helperArgs}, node);
                    }
                    nodeValue = helperRetVal;
                    if(helperFunc.name === "unescape") {
                        let oldDynamicPosition = node.dynamicPositions;
                        let oldStartingNode = oldDynamicPosition.startingNode;
                        let oldChldLen = oldDynamicPosition.length;
                        while(oldChldLen > 1) {
                            let next = oldStartingNode.nextSibling;
                            oldStartingNode.remove();
                            oldStartingNode = next;
                            oldChldLen--;
                        }
                        let childLen = nodeValue.childNodes.length;
                        if(!childLen) {
                            nodeValue.appendChild(document.createTextNode(""));
                            childLen = 1;
                        }
                        let startingNode = nodeValue.childNodes[0];
                        oldStartingNode.replaceWith.apply(oldStartingNode,nodeValue.childNodes);
                        let obj = {startingNode : startingNode, length: childLen};
                        node.dynamicPositions = obj;
                        nodeValue = undefined;
                    }
        } else {
            let boundValue = node.syntaxValue;
            let path;
            if(boundValue.indexOf('.') !== -1 || boundValue.indexOf('[') !== -1) {
                path = boundValue;
                boundValue = boundValue.substring(0,boundValue.indexOf('.'));
            }
            let value = path ? _LC.get(compInstance.data, path, dynamicValues) : compInstance.data[boundValue]; 
            nodeValue = !typeof value === "boolean" && !typeof value === "number" ? (value? value : ""): value;
        }
        let origNodeValue = nodeValue;
		if(!(dynamicValues[0] instanceof Array)) {
        	dynamicValues = [dynamicValues];
		}
        
        if(multiplePropNode) {
        	for(var i=0;i<multiplePropNode.length;i++) {
        		if(multiplePropNode[i]) {
                    var ind = node._sq ? node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) : 1;
					let multipleProp = node._multipleProperty[i];
                    let dynamicValIndex = node._multipleProperty[i].index;
                    for(var j=0;j<ind;j++){
                        if(node._sq && dynamicValues[dynamicValIndex][j].indexOf('.') == -1){
                            continue;
                        }
                        let prop = this.getProperty(dynamicValues[dynamicValIndex][j]);
                        let totalProp = this.getProperty(dynamicValues[dynamicValIndex][j].substring(0, dynamicValues[dynamicValIndex][j].indexOf('.')));
                        var value = this.getData(dynamicValues[dynamicValIndex][j].substring(0, dynamicValues[dynamicValIndex][j].indexOf('.')));                            
                        if(Array.isArray(multiplePropNode) && multiplePropNode[dynamicValIndex] && multiplePropNode[dynamicValIndex][j] && (multiplePropNode[dynamicValIndex][j] === "dynamicNodes")) {
                            makeArray(prop, "_dynamicNodes");
                            if(prop._dynamicNodes.indexOf(node) == -1){
                                prop._dynamicNodes.$push(node);
                            }
                        } else {
                            makeSet(prop, "_helperNodes");
                            prop._helperNodes.add(
                                    multipleProp.helperNode
                            );
                            let dynamicProp = multipleProp.dynamicProp;
                            dynamicProp[prop._path] ? dynamicProp[prop._path].$push(node): (dynamicProp[prop._path] = []).$push(node);
                        }
                        if(value != undefined){
                            _LC.establishBindings(totalProp, value);
                        }
                        if(j==0){
                            if(node.ownerElement && (node.ownerElement.hasAttribute("lyte-for") || node.ownerElement.hasAttribute("lyte-if") || node.ownerElement.hasAttribute("lyte-switch") || node.ownerElement.hasAttribute("lyte-forIn")) || node.ownerElement && node.ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(node.ownerElement.getAttribute("is")) && !isHelper) {
                                var type = node.ownerElement.getAttribute("is");
                                if (type === "for" && node.nodeName === "items" || type === "forIn" && node.nodeName === "object") {
                                    if(multipleProp.actProp._forHelpers.has(node.ownerElement)){
                                        multipleProp.actProp._forHelpers.delete(node.ownerElement);
                                    }
                                    if(!multipleProp.actProp._forHelpers.size) {
                                        delete multipleProp.actProp._forHelpers;
                                    }
                                    if (!prop._forHelpers) {
                                        makeSet(prop, "_forHelpers");
                                    }
                                    node.ownerElement._actualBinding = prop;
                                    prop._forHelpers.add(node.ownerElement);
                                }
                            }
                            node._multipleProperty[i].actProp = prop;
                            node._multipleProperty[i].dynamicValues = dynamicValues[dynamicValIndex];
                        }
                    }
	        	}
	        }
		}
        if(isDirectiveNode){
            _LC.directive.setNodeArgs(node,origNodeValue);
        }
        else if(node.nodeType === 2) {
        	let parentNodes = [];
            let pN = node._parentNode ? node._parentNode :  node.ownerElement;
            if(pN.tagName === "TEMPLATE" && pN.getAttribute("is") === "component" && node.nodeName !== "component-name" && node.nodeName !== "component-class") {
            	let isKeepAlive = pN.hasAttribute("lyte-keep-alive");
            	if(isKeepAlive) {
            		for(var key in pN._renderedComponent) {
            			parentNodes.$push(pN._renderedComponent[key]);
            		}
            	} else {
                    var compName = pN._currentComponent;
                    if(compName && pN._renderedComponent[compName]){
                        parentNodes.$push(pN._renderedComponent[compName]);
                    }
            	}
            }
            parentNodes.$push(pN);
            for(let i=0;i<parentNodes.length;i++) {
            	let parentNode = parentNodes[i];
            	if(parentNode.set) {
                    // if(parentNode._dynComp && node.nodeName == "component-data"){
                    //     parentNode.set(nodeValue , undefined, undefined,true);    
                    // }else{
                        parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue, undefined, true);
                    // }
                    } else {
                        parentNode._initProperties = parentNode._initProperties || {};
                        parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] = nodeValue;
                    }
                    if(parentNode.tagName === "LYTE-YIELD" && parentNode.component.data && node.nodeName && parentNode.component.data[node.nodeName] !== nodeValue /*parentNode.getAttribute("is") === "insertYield"*/) {
                        _LC.set(parentNode.component.data, _LC.String.toCamelCase(node.nodeName), nodeValue,undefined , undefined, parentNode);
                    }
                    parentNode._attributes = parentNode._attributes || {};
                    //!== "string"
                    if(_LC.isCustomElement(parentNode,true) && typeof nodeValue !== "string") {
                        if(node.ownerElement.nodeName === "TEMPLATE") {
                            if(node.helperValue) {
                            	if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		let newValue = nodeValue;
                            		_LC.removeSelectedBindingDeep(node.ownerElement._actualBinding, oldValue);
                            		if(newValue  && typeof newValue !== "number") {
                            			makeSet(newValue, "_bindings");
                                        addBindings(newValue._bindings,node.ownerElement._actualBinding);
                            			_LC.establishBindings(node.ownerElement._actualBinding, newValue);
                            		}
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            		//console.log("old Value ", oldValue, " new Value ", newValue);
                            	}
                            }else{
                                if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            	}
                            }
                            parentNode["__"+node.nodeName] = true;
                            if(node.nodeName != "case"){
                                parentNode.removeAttribute(node.nodeName);
                            }
                        } else {
                            //Needs revisiting
                            //parentNode.removeAttribute(node.nodeName);
                        }

                    } else {
                        if(typeof nodeValue === "boolean") {
                            parentNode._attributes = parentNode._attributes || {};
                            parentNode._attributes[node.nodeName] = nodeValue;
                            if(!nodeValue) {
                                parentNode.removeAttribute(node.nodeName);
                            } else {
                                parentNode.setAttribute(node.nodeName, "");
                            }
                        } else {
                            if(nodeValue && typeof nodeValue === "object"){
                                var res;
                                if(typeof Record != "undefined" && nodeValue instanceof Record){
                                    res = JSON.stringify(nodeValue.$.toJSON())
                                }
                                else{
                                    try{
                                        res = JSON.stringify(nodeValue)
                                    }
                                    catch(exp){
                                        //@Slicer.developmentStart
                                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error(
                                            "LC013",
                                            node.nodeName,
                                            node.ownerElement.nodeName.toLocaleLowerCase(),
                                            node.ownerElement.nodeName.toLocaleLowerCase()
                                        )
                                        //@Slicer.developmentEnd
                                    }                                
                                }
                            }
                            else if(nodeValue== null || nodeValue == undefined){
                                res = ""
                            }
                            else{
                                res = nodeValue
                            }
                            nodeValue = res;
                            let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                            // if(node.nodeName === "style") {
                            //     node.ownerElement.setAttribute("style",locNodeVal);
                            // } else {
                            //     node.nodeValue = locNodeVal;
                            // }

                            // if(node instanceof Node) {
                            //Check safari issue once
                            let oE = node.ownerElement;
                            if(oE.hasAttribute(node.nodeName)) {
                                if(oE.tagName != "INPUT" || node.nodeName != "value" || !oE.validity.badInput) {
                                    oE.setAttribute(node.nodeName, locNodeVal);
                                }
                            } else {
                                node.nodeValue = locNodeVal;                              
                            }
                        }
                    }
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if(node.nodeName === "value") {
                             let val = (nodeValue === undefined) ? "" : nodeValue;
                             if(parentNode.value !== val) {
                                parentNode.value = val;
                             } 
                        } else if(node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
                    }
                    if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                        parentNode.removeAttribute(node.nodeName);
                    }
                    let isStopped = parentNode._isStopped;
                    let result;
                    switch(parentNode.getAttribute("is")) {
                        case "for" :
                            this.updateForHelper(parentNode, {"type" : "update"});
                            break;
                        case "if" : 
                            result = this.updateSwitchHelper("e",parentNode, undefined, true, true);
                            break;
                        case "case" : 
                            result = this.updateSwitchHelper("s",parentNode._parentSwitch, undefined, true, true,undefined,parentNode);
                            break;
                        case "forIn" : 
                            this.updateForInHelper(parentNode , {"type" : "update"});
                            break;
                        case "switch" :
                            this.updateSwitchHelper("s",parentNode, undefined, true, true);
                            break;
                        case "component" : 
                            if(node.nodeName === "component-name" || node.nodeName === "component-class") {
                                this.updateDynamicComponent(parentNode, "update");    
                            }
                            break;
                        default:            
                    }
//                 	let handleBreakOptions;
//                 	if(isStopped &&  isStopped !== result) {
//                 		//console.log("new value is stopped");
//                 		if(!result) {
//                 			//console.log("new value is not stopped");
//                 			if(isStopped === "break") {
//                 				handleBreakOptions = "SM"
//                 			} else {
//                 				handleBreakOptions = "SS"
//                 			}
//                 		} else if(result === "break") {
//                 			handleBreakOptions = "MS";
//                 			//console.log("old value is continue and new value is break");
//                 		} else {
//                 			handleBreakOptions = "SM";
//                 			//console.log("old value is break and new value is continue");
//                 		}
//                 	} else if(result === "break") {
//                 		handleBreakOptions = "MS";
//                 		//console.log("old value not stopped and new value is break");
// //                		this.handleBreak(parentNode._cx, "break");
//                 	} else if(result === "continue") {
//                 		handleBreakOptions = "SS";
//                 		//console.log("old value not stopped and new value is continue");
// //                		this.handleBreak1(parentNode._cx , "continue");
//                 	}
//                 	if(handleBreakOptions) {
//                 		this.handleBreak(parentNode._cx, handleBreakOptions);
//                 	}
            }
        }
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
        if(contextSwitchInfo) {
            _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
        }
    }

    // handleBreak(contextSwitchInfo, options) {
    // 	if(contextSwitchInfo) {
    // 		let forTemplate = contextSwitchInfo.node;
    // 		let breakIndex = contextSwitchInfo.itemIndex;
    // 		let itemValue = forTemplate.getAttribute("item");
    // 		let forContent = contextSwitchInfo.node._forContent;
    // 		let endIndex = options[0] === "M" ? forContent.length : breakIndex + 1;
    // 		for(let j=breakIndex;j<endIndex;j++) {
    // 			let currentForContent = forContent[j];
    // 			for(let i=0;i<currentForContent.length;i++) {
    // 				currentForContent[i].remove();
    // 				if(currentForContent[i]._forContent || currentForContent[i]._caseContent) {
    // 					this.removeHelpers(currentForContent[i]);
    // 				}
    // 			}	
    // 				forContent[j] = [];
    // 				_LC.removeSelectedBindingDeep(forTemplate._items[j].itemProperty, forTemplate._attributes.items[j]);
    // 				forTemplate._helpers[j] = [];
    // 				forTemplate._items[j] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
    // 		}
    // 		let length = forTemplate._attributes.items.length;
    // 		if(options[1] === "M") {
    // 			this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : length - breakIndex, "type" : "replace"}, undefined, {});
    // 		} else {
    // 			this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : 1, "type" : "replace"}, undefined, {});
    // 		}
    // 	}
    // }

    createCustomEvent(eventName, parentNode, actObj){
        const customEvent = new CustomEvent(eventName);
        parentNode._actions[eventName] = customEvent;
        parentNode._actions[eventName].processAction = actObj;
    }

    isEmptyString(str){
        return (!(typeof str === "string") || str === "" );
    }

    processArgs(scope,dynN,dynamicValues,event, node, newCompile,cache,parentSq){
        let args = dynN.newHelperInfo && newCompile ? dynN.newHelperInfo.args : dynN.helperInfo.args;
        if(dynN.helperInfo && dynN.helperInfo._t == "sq")   {
            parentSq = true;
        }
        dynamicValues = dynamicValues || [];
        args = (Array.isArray(args)) ? Array.from(args) : args;
        for(let i=0; i<args.length; i++){
            if(args[i] && args[i].type){
                if(args[i].type == "sq"){
                    this.internalArray(scope, args, i, dynamicValues, event, node, newCompile,parentSq);
                }else{
                    this.internalHelpers(scope, args, i, dynamicValues, event, node, newCompile,cache,parentSq);
                }
            } else {
                if(!this.isEmptyString(args[i])) {
                    if(args[i].startsWith("'") && args[i].endsWith("'")){
                        args[i] = args[i].substr(1,args[i].length-2);       
                    } else {
                        args[i] = args[i].trim();
                        if(args[i] === "event" && event) {
                            args[i] = event;
                        } else if(args[i] === "this" && node) {
                            args[i] = node.nodeType === 2 ? node.ownerElement : node;
                        } else {
                            let dynamicVals = [];
                            args[i] = _LC.get(scope.component.data,args[i],dynamicVals,cache);
                            if(!parentSq || dynamicValues.length == 0){
                                dynamicValues.$push(dynamicVals);
                            }else{
                                if(dynamicVals.length > 1){
                                    for(let s=0; s<dynamicVals.length; s++){
                                        dynamicValues[dynamicValues.length-1].$push(dynamicVals[s]);
                                    }
                                }else{
                                    dynamicValues[dynamicValues.length-1].$push(dynamicVals[0]);
                                }
                            }
                        }
                    }
                } else if(newCompile) {
                    if(args[i] instanceof Array) {
                        args[i] = _LC.getDD(scope.component.data, args[i]);
                    }
                }
            }
            
        }
        return args;
    }

    internalHelpers(scope,args,i,dynamicValues, event, node, newCompile,cache,parentSq){
        let helperFunc = args[i].value;
        var helperVal =  this.processHelper(scope,{"name" : helperFunc.name, "args" : this.processArgs(scope,{"helperInfo" : helperFunc},dynamicValues, event, node, newCompile,cache,parentSq)});
        args[i] = helperVal;
    }
    internalArray(scope, args, i, dynamicValues, event, node, newCompile,parentSq) {
        var helperFunc = args[i].value;
        if(!parentSq){
            dynamicValues.$push([]);
        }
        var helperVal =  this.processArray(this,{"name" : helperFunc.name, "args" : this.processArgs(scope,{"helperInfo" : helperFunc},dynamicValues, event, node, newCompile,undefined,true)},dynamicValues, helperFunc.extra ? Array.from(helperFunc.extra):undefined,event, node, newCompile);
        args[i] = helperVal;
    }
    processArray(scope,helperFunc,dynamicValues,extra,event, node, newCompile){
        var arrVal;
        dynamicValues = dynamicValues || [];
        var dynVal = [];
        var arr = helperFunc.name;
        var len = helperFunc.args.length;
        var str="";
        for(var i=0; i<len; i++){
            str = str + "['"+ helperFunc.args[i] + "']"
        }
        var fullData = arr+str;
        if(extra && extra.length){
            for(var i=0; i<extra.length; i++){
                if(typeof extra[i] == "string"){
                    fullData += extra[i];
                }else{
                    if (extra[i] && extra[i].type) {
                        if (extra[i].type == "sq") {
                            this.internalArray(scope, extra, i, dynamicValues, event, node, newCompile, true);
                        } else {
                            this.internalHelpers(scope, extra, i, dynamicValues, event, node, newCompile, undefined, true);
                        }
                        fullData += extra[i];
                    } 
                }
            }
        }
        if(!helperFunc.name.startsWith('.')){
            arrVal = _LC.get(scope.component.data, fullData, dynVal);
            if(dynamicValues.length == 0){
                dynamicValues.$push(dynVal);
            }else{
                dynamicValues[dynamicValues.length-1].$unshift(dynVal[0]);
            }
            return arrVal;
        }else{
            return fullData;
        }
        
    }
    processHelper(scope,helperFunc, node){
        let args = [];
        let helperName = helperFunc.name;
        if(!scope.$component.registeredHelpers[helperName]){
            //@Slicer.developmentStart
            let app = _LC.getNearestParentApp(this.component);
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error(app, "LC003" , helperFunc.name);
            //@Slicer.developmentEnd
            return;
	    }
        switch(helperFunc.name){
            case "method" : 
                args.$push(this, node);
                break;
            case "lbind" :
                args.$push(this, node.ownerElement);
                break;
            case "lyteViewPort" :
                if(node && node.ownerElement){
                    args.$push(node.ownerElement);
                    if(!helperFunc.args.length){
                        args.$push(false);
                    }
                }else{
                    return true;
                }
        }
        return scope.$component.registeredHelpers[helperFunc.name].apply(scope.component,args.$concat(helperFunc.args));
        // return _LyteComponent.registeredHelpers[helperFunc.name].apply(this,args.$concat(helperFunc.args));
    }

    // getActionProperty(prop){
    //     let hostProp = this._properties;
    //     let value = (hostProp)?hostProp[prop].value:undefined;
    //     return value;
    // }

    // hasInternalBindings(content){
    //     return content.match(/[(]{1}[^)]+[)]{1}/);
    // }

    // getArgValues(argNames, properties) {
    //     let argValueArray = [];
    //     for(let i=0;i<argNames.length;i++) {
    //         argValueArray.$push(properties[argNames[i]].value);
    //     }
    //     return argValueArray;
    // }

    createEventListeners(node,actionType,actObj){
        let self = this;
        if(!node._callee && node !== this) {
            node._callee = this;
        }
        if(globalDOMEvents.indexOf(actionType) == -1){
            let infoAttr = actionType.substr(2);
            let infoAttrVal = node.getAttribute(infoAttr);
            // var evntListener = function(event) {
        	// 	var toRemove;
            //     if(!window.event) {
            //         window.event = event;
            //         toRemove = true;
            //     }
            //     _LC.throwAction.call(self,self,actionType.substr(2),actObj, undefined, undefined, node, event);
            //     if(toRemove) {
            //         window.event = undefined;
            //     }
            // };
            if ((ComponentRegistry._registeredCommonClass[node.localName] && !node.component) || (node.tagName === "TEMPLATE" && node.getAttribute("is") === "component")) {
            	node._toRegEvnts = node._toRegEvnts || {};
            	node._toRegEvnts[actionType.substr(2)] = {"listener" : globalEventHandler , "attrVal" : this.tagName.toLowerCase()+" => "+actObj.name};
            } else {
            	node.setAttribute(infoAttr, this.tagName.toLowerCase()+" => "+actObj.name);
            	//Event is not in capture phase because, in capture phase, multiple event listeners in hierarchy are called from parent to child (since registration is done in that order)
            	node.addEventListener(actionType.substr(2), globalEventHandler);
            }
            if(node.hasAttribute(actionType)){
            	node[actionType] = undefined;
            }
            node.removeAttribute(actionType);
        }
    }

    registerParentYield(yieldName){
        let locYield,parentYield = this._callee._yields[yieldName];
        if(parentYield){
            // if(Lyte._ie) {
            //     locYield = document.createElement("div");
            //     locYield.innerHTML = parentYield.outerHTML;
            //     locYield = locYield.childNodes[0];
            //     this.constructor.splitTextNodes(locYield);
            // } else {
                locYield = parentYield.cloneNode(true);
            // }
            Object.keys(parentYield).forEach(function(item) {  //eslint-disable-line no-loop-func
                locYield[item] = parentYield[item];
            });
            this._yields[yieldName] = locYield;
        }
    }

    getYieldName(node){
        if(node.getAttribute("yield-name")){
            return node.getAttribute("yield-name");
        }else if(node._attributes && node._attributes["yield-name"]){
            return node._attributes["yield-name"];
        }
    }

    registerYields() {
        this._yields = {};
        let yields = this.querySelectorAll('template[is=registerYield],template[is=yield]');
        let lazyYields = [];
        for(let i=0;i<yields.length;i++) {
            while(yields[i].hasChildNodes()) {
                yields[i].content.appendChild(yields[i].childNodes[0]);
            }
            let yieldName = this.getYieldName(yields[i]);
            if(yields[i].hasAttribute("from-parent") && this._callee) {
                if(this._callee._yields){
                    this.registerParentYield(yieldName);
                }
                else{
                    lazyYields.push(yields[i]);
                }
            } else {
                this._yields[yieldName] = yields[i];
            }
        }
        if(lazyYields.length && this._callee){
            var self = this;
            this.lazyYield = function(){
                if(self._callee){
                    for(let j=0;j<lazyYields.length;j++){
                        let lYield = lazyYields[j];
                        self.registerParentYield(this.getYieldName(lYield));
                    }
                    self._callee.removeEventListener("onReady", self.lazyYield);
                    delete self.lazyYield;
                }
            };
            this._callee.addEventListener("onReady", this.lazyYield);
        }
    }

    connectedCallback() {
        this._connectedCallback();
    }
    _connectedCallback(){
        if(this.hasAttribute("lyte-rendered") || this._ccCalled || !this._registryClass || !this.$registry.registeredComponents[this.localName]) {
            return;
        }
        let fastRenderProp = this._fR;
        if(!fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        this.__h = {};
        this.__counter = 0;
        this.__dc = {};
        if(fastRenderProp) {
            let methods = fastRenderProp._methods;
            if(methods) {
                this.setMethods(methods);
            }
            _LC.ccDelay.$push(this);
            this._ccCalled = true;
        } else {
            this.actualConnectedCallback();
        }
        let viewObj = this.getViewObj()
        if(viewObj){
            viewObj.connectedCallback(this)
        }
    }
    cmpBind(fastRenderProp){
        let compData = this.component.data;
        if(!_LC.unbound && !fastRenderProp && !compData.lyteFastRender) {
            _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.establishObserverBindings.call(this,this.component.constructor._observers,undefined,undefined,undefined,_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte);
            _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.establishWatchScope.call(this,this.constructor._deepWatchProperties)
            //this.establishObserverBindings();
            makeSet(compData, "_bindings");
            addBindings(compData._bindings,this._properties);
            _LC.establishBindings(this._properties, compData);
        }
    }
    actualConnectedCallback(){
        let compData = this.component.data;
        if(this.component.constructor.dc){
            this.dc = this.component.constructor.dc.p;
        }
        let directiveObj = this.getDirectiveObj();
        directiveObj && directiveObj.instanciatePromises(this)
        let fastRenderProp = this._fR;
        if(fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        for(let key in this._toRegEvnts) {
        	this.addEventListener(key, this._toRegEvnts[key].listener);
        	if(this.hasAttribute(key)) {
        		this.setAttribute(key, this.getAttribute(key) + " ; "+ this._toRegEvnts[key].attrVal);
        	} else {
        		this.setAttribute(key, this._toRegEvnts[key].attrVal);
        	}
        }
        this._toRegEvnts = {};
        let initialUnbound = _LC.unbound;
        let ssrBind  = this._ssrData || this.getAttribute("ssrbindservernode");
        if(ssrBind && !this.component.data.lyteUnbound){
            this.bindServerData();
            this.removeAttribute("ssrbindservernode");
        }
        let content =  this.afterConnected(fastRenderProp,ssrBind);
        !ssrBind && this.cmpBind(fastRenderProp);

        _LC.unbound = initialUnbound;
        var tagName = this.tagName;
        let dependentPromises = [];
        directiveObj && directiveObj.getDependentPromises(this,dependentPromises,this._dependentPromise);
        if(typeof content === "string") {
            if(content) {
                if(_LC.frSpecial) {
                    let temp = document.createElement("template");
                    temp.innerHTML = content;
                    this.innerHTML = "";
                    this.appendChild(temp.content);
                } else {
                    this.innerHTML = content;
                }
            }
            _LC.processAction(this);
        }
        else{
            let viewObj = this.getViewObj()
            if(viewObj){
                viewObj.actualConnectedCallback(this,content)
            }
            let shadowObj = this.getShadowObj();
            let shadowDeep,shadowMode,shadowParent;
            var shadowSupported = _LC.directive.getTransitionArg(this,"shadow-supported")
            if(shadowObj){
                _LC.directive.setAttrFromRender(this,this._tagDirectives);
                // if(shadowSupported){
                    if(this.$registry._defaultDirectives && this.$registry._defaultDirectives.indexOf("shadow") != -1){
                        var shadowVal = _LC.directive.getTransitionArg(this,"shadow")
                        shadowMode = shadowVal;
                        this.component.data.lyteShadow = shadowVal; //af??
                    }
                    shadowParent = this;
                    if(this.parentNode.shadowRoot){
                        _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.warn(this.tagName +" should not be the direct child of a shadow component "+this.parentNode.tagName)
                    }
                    let rtObj = shadowObj.getShadowParent(this,directiveObj);
                    shadowParent = rtObj.shadowParent;
                    shadowDeep = rtObj.shadowDeep;
                // }
            }
            if(shadowObj && shadowMode == true){
                if(shadowSupported){
                    shadowObj.applyShadow(this,content,shadowParent,dependentPromises);
                }
                //@Slicer.developmentStart
                else{
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC017",this.localName)
                }
                //@Slicer.developmentEnd
            }
            else if(shadowObj && shadowParent){
                if(shadowMode == undefined && shadowDeep == true && this.constructor._observedAttributes.indexOf("lyteShadow")!=-1){
                    shadowObj.applyShadow(this,content,shadowParent,dependentPromises);
                }
                else{
                    this._hasShadowParent=true;
                    this._sw = [];
                    this.component.data.lyteShadow = false;//need to check
                    shadowObj.attachStyleToParentShadow(this, shadowParent, content);
                    if(directiveObj){
                        directiveObj.appendInDom(this,content,true,true,dependentPromises);
                    }else{
                        _LC.appendInDom(this,content);
                    }
                }
            }
            else{
                this.component.data.lyteShadow = false;//need to check
                if(this._compClass._style && _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.assetsDiv._duplicateStyle.indexOf(tagName) == -1){
                    var style = _LCSD.stringToStyle(this._compClass._style);
                    style.setAttribute("lyte-id","global-style-"+tagName);
                    if(this._ssrBind){
                        style.setAttribute("from-ssrComponent",tagName);
                    }
                    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.assetsDiv.appendChild(style);
                    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.assetsDiv._duplicateStyle.$push(tagName);
                }
                if(_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.shadowDiv._compList.indexOf(tagName) == -1){
                    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.shadowDiv._compList.$push(tagName);
                }
                if(directiveObj){
                    directiveObj.appendInDom(this,content,true,true,dependentPromises);
                }else{
                    _LC.appendInDom(this,content);
                }
            }
        }
        if(directiveObj){
            this._transitionAppend = []
        }
        let dataDef = this.component.__data;
        let attributes = this.attributes;
        this.__lyteIgnore = true;
        for(let i=attributes.length-1;i>-1;i--) {
            let camelCase = _LC.String.toCamelCase(attributes[i].nodeName);
            if(dataDef[camelCase] && dataDef[camelCase].hideAttr) {
            this.removeAttribute(attributes[i].nodeName);
            }
        }
        this.__lyteIgnore = false;
	    if( this._callee && this._callee.serverCall ){
            this.serverCall = true;
        }
        //to bind in ssr
        if( this.serverCall && !this.hasAttribute( "server-rendered") ){
            this.setAttribute( "server-rendered", "");
            var newData = _LC.sendtoclient.call(this,this,true,this.component.__data);
            this.setAttribute("component-data", JSON.stringify( newData ) );
        }
        if( !this.hasAttribute( "server-rendered" ) )
        {        
	        this.setAttribute("lyte-rendered", "");
        }
        
        if(!fastRenderProp && !_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte._ignoreOnReady) {
            this.dispatchEvent(new CustomEvent("onReady"));
        }
        
        let _config_flag;
        if( this.component._ssr && this.component._ssr.config ){
            if( this.component._ssr.config.clientLifeCycleHooks != undefined ){
                _config_flag = this.component._ssr.config.clientLifeCycleHooks == true || ( typeof this.component._ssr.config.clientLifeCycleHooks == 'object' ? this.component._ssr.config.clientLifeCycleHooks.includes('didConnect') : false );
            }
        }
        let _overrides = this.component._ssr ? this.component._ssr.overrides : undefined;
        if( !this.hasAttribute( "server-rendered" ) || this.serverCall ||  _config_flag ){
            if( _overrides && _overrides.didConnect && this.serverCall ){
                _overrides.didConnect.apply( this.component );
            }else{        
                this.callback("didConnect");
            }
            this.onCallBack("didConnect");
        }
    
        if( this.serverCall == undefined ){
            this.callback( "didRender" );
        }            
        if(fastRenderProp) {
            this.removeAttribute("_lyteprop");
        }
    }
    onCallBack(name){
        let callbacks = this.component.constructor._callBacks[name];
        if(callbacks){
            for(let i=0;i<callbacks.length;i++){
                try{
                    callbacks[i].value.call(this.component);    
                } catch(e) {
                    //@Slicer.developmentStart
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error(e);
                    //@Slicer.developmentEnd
                }
                
            }
        }
    }
    callback(name){
        var func = this.component[name];
        var args;
        if(func){
            if(arguments.length > 1) {
                args = Array.from(arguments);
                args.$splice(0,1)
            }
            try{
                func.apply(this.component, args || []);    
            } catch(e) {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error(e);
                //@Slicer.developmentEnd
            }
        }
    }
    establishObserverBindings() {
        let observers = this.component.constructor._observers;
        for(let i=0;i<observers.length;i++) {
            let props = observers[i].properties;
            for(let j=0;j<props.length;j++) {
                let actProp;
                let isArrayObserver = false;
                if(props[j].indexOf('.[]') !== -1) {
                    isArrayObserver = true;
                    actProp = this.getProperty(props[j].substring(0, props[j].indexOf('.[]')));
                } else {
                    actProp = this.getProperty(props[j]);
                }
                makeSet(actProp, "_observers");
                actProp._observers.add({callee : this, observer: observers[i], isArrayObserver : isArrayObserver});
            }
        }
    }
    removeBindings(properties, actualData) {
        var del = "delete";
        for(let i in properties) {
            let actData = actualData[i];
            if(actData && actData._bindings) {
                actData._bindings[del](properties[i]);
                //Error while trying to delete _bindings from actData when actData is of type Array
                /*  if(!actData._bindings.size) {
                    delete actData._bindings;
                } */
            }
            if(typeof properties[i] === "object" && actData) {
                this.removeBindings(properties[i], actData);
            }
        }
    }
    actualDisconnected() {
        var self = this;
        if(!self.component) {
            return;
        }
        self._cx = null;
        self._callee = null;
        self.component.$node = null;
        self.component.__data = null;
        self.component.data.__component__ = null;
        self.component.data = null;
        self.component = null;
        self.__dc = self.__dc || {};
        self.__h =  self.__h || {};
        for (key in self.__dc) {
            var helper = self.__dc[key];
            //helper.remove();
            if(helper.hasAttribute("lyte-keep-alive")) {
                var objKeys = Object.keys(helper._renderedComponent);
                for(var j=0;j<objKeys.length;j++) {
                    let key = objKeys[j];
                    if(key !== helper._currentComponent) {
                        // Will remove from hDiv.
                        helper._renderedComponent[key].remove();
                    }
                }
            }
        }
        for (key in self.__h) {
            self.__h[key].remove();
        }
        self.__h = {};
        self.__dc = {};
        let yields = self._yields;
        for(var key in yields) {
            yields[key]._callee = null;
        }
        self = null;
    }
    disconnectedCallback() {
        this._disconnectedCallback();
    }
    _disconnectedCallback(){
        if(_LC.ignoreDisconnect || !this.component) {
	       return;
        }
        let shadowObj = this.getShadowObj();
        let directiveObj = this.getDirectiveObj();
        shadowObj && shadowObj.destroyRef(this);
        let viewObj = this.getViewObj()
        if(viewObj){
            viewObj.disconnectedCallback(this)
        }
        this._destroyed = true;
        if(this.__toRemoveLazy){
            for(var __key in this.__toRemoveLazy){
                var __arr = this.__toRemoveLazy[__key];
                __arr.forEach(function(id){
                    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.toRemoveFromRequiredServices(id);
                });
            }
            delete this.__toRemoveLazy;
        }
        this.component._bindings = null;
        var scpObj = this.__scpObj;
        if(scpObj){
            for(var key in scpObj){
                var propData = this.component.data[key], id = scpObj[key], idArr = id.split("_");
                if(propData){
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.removeNestScp)(this.component.data[key], idArr[0], idArr[1], undefined, this);
                }
            }
        }
        if(!this._fR) {
            _LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
        }
        if(directiveObj){
            directiveObj.destroyHelperPromises([this.__dc,this.__h]);
        }
        var h = this.__h;
        for (key in h) {
            if(h[key]._actualBinding){
                this.removeHelpers(h[key]);
            }
        }
        h = {};
        for(key in this._properties) {
            this._properties[key] = {};
        }
        this.callback('didDestroy');
        this.onCallBack('didDestroy');
        this.component.constructor.activeInstances--;
        if(!_LC.dcc) {
            _LC.dcc = [];
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    if(viewObj){
                        viewObj.actualDisconnected(this)
                    }
                    try{
                        for(var i=0,item;item=_LC.dcc[i];i++) {
                            item.actualDisconnected();
                        }
                    }
                    catch(e) {

                    }
                    _LC.dcc = undefined;
                });
            });
        }
        _LC.dcc.$push(this);
        directiveObj && directiveObj.destroyPromises(this);
        if(this.lazyYield){
            this.removeEventListener("onReady", this.registerParentYield);
        }   
        // var self = this;
        // setTimeout(function() {
        //     self.actualDisconnected();
        // },0);
        // this.constructor.activeInstances--;
    }
}
customElementPrototype._V3InsApi = ["cmpBind","component","actualConstructor","_connectedCallback","actualConnectedCallback", "getMethods","hasAction", "setActions", "setMethods", "getCallee", "afterConnected", "renderComponent", "renderFast", "formatValue", "renderNodes", "executeBlockHelpers", "updateBlockHelpers", "_attributeChangedCallback" , "removeHelpersSpecificIndex", "removeHelpers", "updateYield", "updateDynamicComponent","updateForHelper", "updateForInHelper", "updateSwitchHelper", "callObservers","bindNode","debounce", "getProperty", "updateNode", "handleBreak", "createCustomEvent", "isEmptyString", "processArgs", "internalHelpers", "processHelper", "getActionProperty", "hasInternalBindings", "getArgValues", "createEventListeners", "registerParentYield", "registerYields", "onCallBack", "callback", "establishObserverBindings", "removeBindings", "actualDisconnected" ,"_disconnectedCallback","throwAction","get","set","initializeMethod"];
customElementPrototype._V3StaticApi = ["_observers","_callBacks","_properties","activeInstances","_depthTemp","_bindsIds","_ssr","_config","_mixins","_serviceToBeUsed","_actions","_template","_dynamicNodes","_templateAttributes","_observedAttributes","_observedMethodAttributes","_data","_methods","_pendingComponents","splitTextNodes" ,"_registerComponent", "createDocFragment1" , "updateValue"];
customElementPrototype._v4RegClassApi = ["_reg","_compName","componentClass","_observedAttributes"]; //component
customElementPrototype._v4RegProtoApi = ["setData", "getData", "setMethods", "get", "set", "_pendingComponents"];
customElementPrototype.version = {v3 : {component : undefined}};
ltCf._customElementPrototype = customElementPrototype;
ltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();
// window._customElementPrototype = customElementPrototype;
// var onObj = function(){
//     return {"type": "callBack", "value":(this.type === "observer") ? this.value:this , "properties":arguments, "observes":(this.type === "observer" ? this: undefined)}
// }
// var observesObj = function() {
//     return {"type" : "observer", "value" : this, "properties" : arguments, "on":Function.prototype.on}
// }
// var computedObj = function() {
//     return {"type" : "computed", "value" : this, "properties" : arguments}
// }
// var fnProto = Function.prototype;
// fnProto.on ? fnProto.lyteOn = onObj : fnProto.on = onObj;
// fnProto.observes ? fnProto.lyteObserves = observesObj : fnProto.observes = observesObj;
// fnProto.computed ? fnProto.lyteComputed = computedObj : fnProto.computed = computedObj;


// BaseCompiler(Lyte,_LC);
// if(compConfig.compiler){
//     compConfig.compiler(_LC);
// }

_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.typeCast = _LC.typeCast;
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.getDataType = _LC.getDataType;
// Lyte.Component._get = _LC.get;
_LC.chromeBugFix = function() {
    var version = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);;
    version = version ? parseInt(version[2], 10) : 0;
    if(version > 62) {
        this.chI = [];
        document.addEventListener("focus", function(event) {
            var target = event.target;
            if(target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "DIV") {
                if(_LC.chI.indexOf(target) == -1) {
                    _LC.chI.$push(target);
                }
            }
        } , true);
        this.chromeBugFix = function() {
            var tags = _LC.chI;
            var tagsL = tags.length;
            var toRemove = ["_callee", "_attributeDetails", "_attributes", "_removedAttributes", "_yields" , "_rA", "_cx"];//no i18n
            var toBeRemoved = [];
            var keepAliveInputs = [];
            document.querySelectorAll("[lyte-keep-alive]").forEach(function(item,index){
                for(var key in item._renderedComponent) {
                    keepAliveInputs.$push.apply(keepAliveInputs, Array.from(item._renderedComponent[key].querySelectorAll("input")));
                }
            });
            for(var i= tagsL-1, item;item=tags[i];i--) {
                if((document.compareDocumentPosition(item) % 2) && (keepAliveInputs.indexOf(item) == -1)) {
                    tags.$splice(i,1);
                    item.remove();
                    toBeRemoved.$push(item);
                    item._rA = item._rA || [];
                    item._rA.forEach(function(remAttr) { //eslint-disable-line no-loop-func
                        remAttr.ownerElement = undefined;
                    });
                    toRemove.forEach(function(key) {//eslint-disable-line no-loop-func
                        item[key] = undefined;
                    });
                    Array.from(item.attributes).forEach(function(itemVal) {//eslint-disable-line no-loop-func
                        item.removeAttribute(itemVal.nodeName);
                    });
                }
            }
        }
        // Lyte.addEventListener("afterRouteTransition", function() {
        //     _LyteComponent.chromeBugFix();
        // });
        if(!_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.Router) {
            setInterval(function() {
                // _LC.chromeBugFix();
                _LC.String.cache_c = {};
                _LC.String.cache_d = {};
            },300000)
        }
    }
}
_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.$.chromeBugFix = _LC.chromeBugFix;

// _LC._directives = {};
if(!customElements.get("lyte-safari-test-component")){
    customElements.define("lyte-safari-test-component", Test, undefined, {v4 : true});
}
var divTest = document.createElement("div");
divTest.innerHTML = "<lyte-safari-test-component t></lyte-safari-test-component>";

let _LCSD = _LC.shadow;
// _LyteComponent.render = _LC.render;
//Change it in v3.0 - Remove from _LC scope. 
// _LyteComponent.insertBefore = _LC.insertBefore;
// _LyteComponent.insertAfter = _LC.insertAfter;
// _LyteComponent.replaceWith = _LC.replaceWith;
// _LyteComponent.appendChild = _LC.appendChild;
_LC.tDiv = createElement("template");
_LC.tDiv.setAttribute("id", "dummy-templates-div");
// _LC.tDiv.setAttribute("style", "display:none");
_LC.hDiv = createElement("template");
_LC.hDiv.setAttribute("id", "keep-alive-div");
// _LC.hDiv.setAttribute("style", "display:none");
_LC.h1Div = createElement("template");
_LC.h1Div.setAttribute("id", "lyte-helper-div");
// _LC.h1Div.setAttribute("style", "display:none");

// ComponentRegistry.Compile.componentsDiv = 
_LC.lyteComponentsDiv = createElement("div");
_LC.lyteComponentsDiv.setAttribute("id", "lyte-components-div");
_LC.setComponentsDiv(_LC.lyteComponentsDiv,ComponentRegistry.name);


_LC.dummyLyteComponentsDiv = document.createElement("div");
_LC.dummyLyteComponentsDiv.setAttribute("id", "dummy-lyte-components-div");
_LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,ComponentRegistry.name);

// if(!Lyte._ie) {
if (document.readyState === "complete" || document.readyState === "interactive") {     
    document.body.appendChild(_LC.dummyLyteComponentsDiv);  
}else{
    document.addEventListener("DOMContentLoaded", function(){
        document.body.appendChild(_LC.dummyLyteComponentsDiv);  
    },true);
}
// }

Set.prototype.toArrayLyte = function() {
    if(this.constructor.name === "Set"){
        return Array.from(this);
    }
    else{
        return Array.from(this._values);
    }
}
//_LC.registerListener(function() {
//  
//});

if(document.readyState === "complete" || document.readyState === "interactive") {
    onDomContentForLyte();
} else {
    document.addEventListener("DOMContentLoaded", function(e){
        onDomContentForLyte();
    },true);
}
_LC.mappy = {
    t: "type",
    p: "position",
    dN: "dynamicNodes",
    c: "cases",
    d: "default",
    a: "attr",
    f: "for",
    fI: "for-in",
    e: "if",
    s: "switch",
    i: "insertYield",
    r: "registerYield",
    cM: "component",
    cD: "componentDynamic",
    a: "attr",
    tX: "text"
    // dcn - dynamicCaseName
    // cn - caseName
    // hd - hasDynamicCase
    // hc - hasChildTrans
    // in - indNew
    // l-c - lyte-convertion
    // lc-id - lyte-case-id
    // lc_id - lyte_case_id
    // cdp - casesDeepNodes
    // co - casesOrder
    // dc - _dChild
}

function createSvgDepth(actualTemplate,type){
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    for(var s=0; s<actualTemplate.childNodes.length; s++){
        svg.appendChild(actualTemplate.childNodes[s].cloneNode(true));
    }
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    for(var s=0; s<svg.childNodes.length; s++){
        depthTemp.content.appendChild(svg.childNodes[s]);
        s--;
    }
    return depthTemp;
}
function createDepth(actualTemplate,type){
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    depthTemp.innerHTML = actualTemplate.innerHTML;
    return depthTemp;
}
function appendDepth(depthTemp,constr){
    constr.splitTextNodes(depthTemp);
    constr._depthTemp.content.appendChild(depthTemp);
}
function setHT(dynN,info,dynNewCompile,constr){
    var flag  = true;
    if(dynN.tagName == "TEMPLATE") {
        info._ht = dynN.innerHTML;
        flag = false;
    }
    if(info._ht) {
        if(flag){
            dynN.innerHTML = info._ht;
            constr.splitTextNodes(dynN);
        }
        if(dynNewCompile && dynNewCompile.innerHTML !== info._ht) {
            dynNewCompile.innerHTML = info._ht;
            constr.splitTextNodes(dynNewCompile);
        }
    }
}
function doCompile(dynamicN, dynamicNodes, componentName, constr, newCompile, componentClass, fastRenderClass) {
    for(let j=0;j<dynamicNodes.length;j++) {
        let info = dynamicNodes[j], type = info.t, pos = info.p, helperInfo;
        let dynN = getDynamicNode(dynamicN,pos);
        let dynNewCompile;
        if(newCompile && fastRenderClass) {
            dynNewCompile = fastRenderClass.getDynNewCompile(newCompile,pos);
        }
        switch(type) {
        case "tX" : {
            dynN.nodeValue = dynN.nodeValue.replace('.{}','____lyteinternal____');
            var syn = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().syntaxCheckWorkerNew(dynN.nodeValue);
            let mustache = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getMustache(dynN.nodeValue,syn);
            if(mustache){
                mustache = mustache.replace('____lyteinternal____','.{}');
                actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getArray(mustache);  
            }
            if(!actObj && mustache){
                actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getHelper(mustache);  
            }
            dynN.nodeValue = dynN.nodeValue.replace('____lyteinternal____','.{}');
            let dynamic = mustache;
            if(actObj){
                info.helperInfo = actObj;
                dynNewCompile && fastRenderClass.caseTx(dynNewCompile,mustache,info,j);
           }
            else if(dynamic){
                //deepNodes.$push({type: "text", position:deepN.slice(), dynamicValue: dynamic});
                info.dynamicValue = dynamic;
                info.newDynamicValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getDV(dynamic);
                if(dynNewCompile) {
                    fastRenderClass.replaceWithPf(dynNewCompile,j)
                }
//              LN to do
//              deepNodes.$push({type: "text", position:deepN.slice(), dynamicValue: getDV(dynamic)});                    
            }
        }
        break;
        case "i" : {
            dynNewCompile && fastRenderClass.caseI(dynNewCompile,info,j);
        }
        break;
        case "cD" : {
            dynNewCompile && fastRenderClass.caseCD(dynNewCompile,info,j);
        }
        break;
        case "a" : {
            let add = false, toBeRemoved = [],toBeAdded = [];
            let node = dynN;
            let attr = info.a = info.a || {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].nodeValue.indexOf("{{") !== -1) {
                    node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('.{}','____lyteinternal____');
                    var val = node.attributes[i].nodeValue;
                    var syn = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().syntaxCheckWorkerNew(val);
                    var actObj,actValue,multipleAttr=false;
                    var splittedMus = val.split("{{");
                    var splittedMusLen = splittedMus.length;
                    if(syn.mustache >0){
                        splittedMusLen = splittedMusLen - syn.mustache;
                    }
                    if((splittedMusLen > 2 || !/^{{/.test(val) || !/}}$/.test(val)) && /{{.*}}/.test(val) && !/\\{{.*}}/.test(val)){
                        actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().splitMixedText(val);
                        multipleAttr = true;
                    }
                    else{
                        actValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getMustache(val,syn);
                        if(actValue){
                            actValue = actValue.replace('____lyteinternal____','.{}');
                            actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getArray(actValue);  
                        }
                        if(!actObj && actValue){
                            actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getHelper(actValue);  
                        }
                    }
                    node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('____lyteinternal____','.{}');
                    if( actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|__focus|__focusin|__focusout|__resize|__scroll|__click|__dblclick|__mousedown|__mouseup|__mousemove|__mouseover|__mouseout|__change|__select|__submit|__keydown|__keypress|__keyup|__contextmenu)$/.test(node.attributes[i].name)){
                            var newActObj;
                            if(actValue){
                                newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getArray(actValue);  
                            }
                            if(!newActObj && actValue){
                                newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getHelper(actValue,true);  
                            }
                            attr[node.attributes[i].name.substr(2)] = {
                                name:node.attributes[i].name.substr(2),
                                camelCase : _LC.String.toCamelCase(node.attributes[i].name.substr(2)),
                                helperInfo: actObj,
                                newHelperInfo : newActObj,
                                globalEvent: true
                            };
                            let actArgs = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_5__.deepCopyObject)(actObj.args);
                            let actName = actArgs.$splice(0,1)[0];
                            actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                            let actString = getArgString(actName, actArgs);
                            node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            if(dynNewCompile) {
                                fastRenderClass.setAttribute(dynNewCompile, node.attributes[i].name.substr(2),componentName+" => "+ actString)
                            }
                            toBeRemoved.$push(node.attributes[i].name);                            
                    }
                    else{
                        if(actObj || actValue) {
                            let attrToPush = {};
                            // if(actObj && actObj.name === "method"){
                            //     let actArgs = deepCopyObject(actObj.args);
                            //     let actName = actArgs.$splice(0,1)[0];
                            //     actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                            //     let actString = getArgString(actName, actArgs);
                            //     node.setAttribute(node.attributes[i].name,componentName+" => "+ actString);
                            // }
                            if(node.attributes[i].name.startsWith("lbind:")) {
                                toBeRemoved.$push(node.attributes[i].name);
                                toBeAdded.$push({"name" : node.attributes[i].name.substring(6), "value": node.attributes[i].nodeValue});
                                attrToPush.isLbind = true;
                                attrToPush.name = node.attributes[i].name.substring(6);
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            else {
                                attrToPush.name = node.attributes[i].name;
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            if(actObj) {
                                if(actObj.name === "lbind") {
                                    attrToPush.dynamicValue = actObj.args[0];
                                    attrToPush.newDynamicValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getDV(actObj.args[0]);
                                    attrToPush.isLbind = true;
                                }
                                else {
                                    attrToPush.helperInfo = actObj;
                                    var newActObj;
                                    if(multipleAttr){
                                        newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().splitMixedText(val);
                                    }
                                    else{
                                        if(actValue){
                                            newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getArray(actValue);  
                                        }
                                        if(!newActObj && actValue){
                                            newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getHelper(actValue,true);  
                                        }
                                    }
                                    attrToPush.newHelperInfo = newActObj;
                                }
                            } 
                            else {
                                attrToPush.dynamicValue = actValue;
//                              LN to do
                                attrToPush.newDynamicValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getDV(actValue);
                            }
                            add = true;
                            attr[attrToPush.name] = attrToPush;
                        }                  
                    }
                }
                if(node.attributes[i].name.startsWith("@")){
                    let specialAttr;
                    add = true;
                    node._special = true;
                    let attrToPush = {};
                    attrToPush.name = node.attributes[i].name;
                    if(attr[attrToPush.name] && attr[attrToPush.name].dynamicValue){
                        attrToPush.dynamicValue = attr[attrToPush.name].dynamicValue;
                    }else if(attr[attrToPush.name] && attr[attrToPush.name].helperInfo){
                        attrToPush.helperInfo = attr[attrToPush.name].helperInfo;
                    }else{
                        attrToPush.stringValue = node.attributes[i].nodeValue;
                        let ndName = node.attributes[i].nodeName
                        toBeRemoved.push(ndName);
                        toBeAdded.push({name : "lyte-directive-" + ndName.slice(1,ndName.length), value : ""});
                    }
                    attr[attrToPush.name] = attrToPush;
                    attrToPush.hookNode  = true;
                    let hookName = node.attributes[i].name.slice(1,node.attributes[i].name.length);
                    attrToPush.hookName = hookName;
                    specialAttr = true;
                }
            }
            if(toBeRemoved.length){
                for(let i=0; i<toBeRemoved.length;i++){
                    node.removeAttribute(toBeRemoved[i]);
                }
            }
            if(dynNewCompile) {
                fastRenderClass.removeAttributeArr(dynNewCompile, toBeRemoved);
                fastRenderClass.removeAttributeObj(dynNewCompile, attr, j)
            }
            if(toBeAdded.length) {
                for(let i=0;i<toBeAdded.length;i++) {
                    node.setAttribute(toBeAdded[i].name, toBeAdded[i].value);
                }
            }
        } 
        break;
        case "f" : 
        case "fI" : 
        case "r" : 
            setHT(dynN,info,dynNewCompile,constr);
        case "cM" : {
            var actualTemplate = dynN.content;
            if(!dynNewCompile && (type == "r" || dynN.hasAttribute("unbound"))) { //af check
                if(fastRenderClass){
                    dynNewCompile = fastRenderClass.cMBefore(dynN, info);
                }
            }
            let depthTemp;
            let dnNode;
            let actualTemplateNewCompile = dynNewCompile ? fastRenderClass.cMBefore2(dynNewCompile, info, constr) : undefined;
            if(info.actualTemplate) {
                actualTemplate = _LC.getContentForIE(info.actualTemplate, constr, undefined, _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte._ms? info : undefined);
            }
            doCompile(actualTemplate, info.dN, componentName, constr, actualTemplateNewCompile, componentClass, fastRenderClass);
            if(dynNewCompile){
                fastRenderClass.cMAfter(actualTemplateNewCompile, info, type, j, dynNewCompile);
            }
            // if(Lyte._ms) {
            //     if(info.actualTemplate) {
            //         info.templateContent = actualTemplate.outerHTML;
            //         if(info._content) {
            //             info.actualTemplate = info._content.innerHTML;
            //             delete info._content;
            //         }
            //     } else {
            //         info.templateContent = dynN.outerHTML;
            //     }
            //     dynN.innerHTML = "";  
            // }
            if(info.actualTemplate) {
                depthTemp = type;
                // if(!Lyte._ie ) {
                    if(info.svg){
                        depthTemp = createSvgDepth(actualTemplate,type)
                    }else{
                        depthTemp = createDepth(actualTemplate,type)
                    }
                    appendDepth(depthTemp,constr);
                // }
                if(dynamicNodes[j-1] && (dynamicNodes[j-1].p.toString() === dynamicNodes[j].p.toString())) {
                    dnNode = dynamicNodes[j-1];
                } else {
                    dnNode = dynamicNodes[j];
                }
                dnNode._depthTemp = depthTemp;
            }
            if(info._ht) {
                info._ht = dynN.cloneNode(true);
                componentClass._helperTemplate.content.append(info._ht)
                dynN.innerHTML = "";
            }
                //  When a registerYield is present inside another registerYield, in fastRender, we will not be able to get the template using the positions and parentComponent alone, since the insertYield is present inside the insertYield of the parent component. 
                // info.actYield = dynN;
              }
        break;
        case "e" : 
        case "s" : {
            let caseStr;
            setHT(dynN,info,dynNewCompile,constr);
            let depthTemp;
            let actualTemplateNewCompile;
            if(info.actualTemplate) {
                dynN = _LC.getContentForIE(info.actualTemplate, constr, undefined);
            }
            if(dynNewCompile){
                actualTemplateNewCompile = fastRenderClass.caseES(dynNewCompile, info, constr);
            }
            var def = "default";
            // if(Lyte._ms) {
            // 	var cases = {};
            //     var defCase;
            //     var dynNchildNodes = dynN.childNodes;
            //     var lyteCaseName = info.hd ? "lc-id" : "case";
            //     for(var i=0;i<dynNchildNodes.length;i++) {
            //       if(dynNchildNodes[i].tagName === "TEMPLATE"){
            //         if(dynNchildNodes[i].getAttribute(lyteCaseName)) {
            //             cases[dynNchildNodes[i].getAttribute(lyteCaseName)] = dynNchildNodes[i];
            //         } else if(dynNchildNodes[i].hasAttribute("default")) {
            //     		  defCase = dynNchildNodes[i];
            //     	  }
            //       }
            //     }
            //     for (let key in info.c) {
            //         if(info.c[key].dcn){
            //             doCompile(dynN, [info.c[key].cdp], componentName, constr ,undefined ,componentClass, fastRenderClass);
            //         }
            //     }
            //     for (let key in info.c) {
            //         let contentNewCompile;
            //         caseStr = info.c[key].dcn ? "[lc-id='" : "[case='";                    
            //         content = _LC.getContentForIE(cases[key], undefined, true);
            //         if(actualTemplateNewCompile) {
            //             contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector(caseStr+_LC.cssEscape(key)+ "']"));
            //         }
            //         setHT(content,info.c[key],contentNewCompile,constr);

            //         doCompile(content, info.c[key].dN, componentName, constr, contentNewCompile ? _LC.getContentForIE(contentNewCompile) : undefined, componentClass, fastRenderClass);

            //         cases[key].remove();
            //         if(actualTemplateNewCompile) {
            //             info.c[key]._sta = _LC.processStatic(contentNewCompile);
            //         }
            //         info.c[key].templateContent = cases[key].outerHTML;
            //     }
            //     if (info.d.dN) {
            //         let contentNewCompile;
            //         content = _LC.getContentForIE(defCase, undefined, true);
            //         if(actualTemplateNewCompile) {
            //             contentNewCompile = actualTemplateNewCompile.querySelector("[default]");
            //         }
            //         setHT(content,info.d,contentNewCompile,constr);
            //         doCompile(content, info.d.dN, componentName, constr, contentNewCompile? _LC.getContentForIE(contentNewCompile) : undefined, componentClass, fastRenderClass);

            //         defCase.remove();
            //         info.d.templateContent = defCase.outerHTML;
            //         if(actualTemplateNewCompile) {
            //             info.d._sta = _LC.processStatic(contentNewCompile);
            //         }
            //     }
            // } else {
                var dynNContent = dynN.content || dynN;
            	for(let key in info.c) {
                    caseStr = info.c[key].dcn ? "[lc-id='" : "[case='";
                    let contentNewCompile;
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector(caseStr+_LC.cssEscape(key)+ "']"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector(caseStr+_LC.cssEscape(key)+ "']"), undefined, true);
                    setHT(content,info.c[key],contentNewCompile,constr);
            		if(info.c[key].dcn){
                        doCompile(dynNContent, [info.c[key].cdp], componentName, constr ,undefined ,componentClass);
                    }
                    doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.c[key].dN,componentName, constr, contentNewCompile, componentClass, fastRenderClass);
                    if(actualTemplateNewCompile) {
                      info.c[key]._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info.c[key]._ht) {
                        info.c[key]._ht = content.cloneNode(true);
                        componentClass._helperTemplate.content.append(info.c[key]._ht)
                        content.innerHTML = "";
                    }
            	}
            	if(info.d.dN) {
                    let contentNewCompile
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[default]"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector("[default]"), undefined, true);
                    setHT(content,info.d,contentNewCompile,constr);
            		doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.d.dN,componentName, constr, contentNewCompile, componentClass, fastRenderClass);
                    if(actualTemplateNewCompile) {
                      info.d._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info.d._ht) {
                        info.d._ht = content.cloneNode(true);
                        componentClass._helperTemplate.content.append(info.d._ht)
                        content.innerHTML = "";
                    }
            	}
            	
            // }

            if(info.actualTemplate) {
                depthTemp = type;
                // if(!Lyte._ie ) {
                    if(info.svg){
                        depthTemp = createSvgDepth(dynN.content,type)
                    }else{
                        depthTemp = createDepth(dynN,type)
                    }
                    appendDepth(depthTemp,constr);
                // }
                if(dynamicNodes[j-1] && (dynamicNodes[j-1].p.toString() === dynamicNodes[j].p.toString())) {
            		dynamicNodes[j-1]._depthTemp = depthTemp;
            	} else {
            		dynamicNodes[j]._depthTemp = depthTemp;
            	}
            }

            if(dynNewCompile) {
                fastRenderClass.replaceWithPf(dynNewCompile,j)
            }
            if(info._ht) {
                info._ht = dynN.cloneNode(true);
                componentClass._helperTemplate.content.append(info._ht)
                dynN.innerHTML = "";
            }
        }
        break;    
        }
    }
}

//This is the function where the actual rendering takes place. 
//It takes the template, finds the actual dynamic nodes uwing dynamicNodes argument and then binds each node with the associated
//property by calling bindNode. 

function getDynamicNode(content, positions){
    let dynamicN = content;
    for(var i=0; i<positions.length; i++){
        dynamicN = (dynamicN.tagName != "TEMPLATE") ? dynamicN.childNodes[positions[i]] : dynamicN.content.childNodes[positions[i]];
    }
    return dynamicN;
}

function getArgString(name, array) {
    let retString;
    for(let i=0;i<array.length;i++) {
        if(array[i] && typeof array[i] === "object") {
            array[i] = getArgString(array[i].value.name, array[i].value.args);
        }
    }
    if(name) {
        retString = name +  "(" + array.toString() + ")";
    } else {
        retString = array.toString();
    }
    return retString;
}

var defHelpers = ComponentRegistry._defaultHelpers;
defHelpers["unbound"] = function(value){
     return value;
}
defHelpers["action"] = function(parentNode,attrName,isCustom,actObj){
    if(isCustom){
        parentNode._actions = parentNode._actions? parentNode._actions : {};
        if(!parentNode._actions[attrName]){
            this.$node.createCustomEvent(attrName, parentNode, actObj); 
            parentNode.removeAttribute(attrName);
        }
    }
    else{
        
        this.$node.createEventListeners(parentNode,attrName,actObj);    
    }
};

defHelpers["lbind"] = function(name){
	return this.getData(name);
};

defHelpers["method"] = function(parentComponent, attributeNode, functionName) {
    var parentComponent = arguments[0];
    var attributeNode = arguments[1];
    var functionName = arguments[2];
    var self = arguments[0].component;
    var childComponent = attributeNode? attributeNode.ownerElement : null;
    var attributeName = arguments[1].nodeName;
    attributeNode = null;
    var args = Array.prototype.slice.call(arguments, 2);
    var newFunc = function() {
        let node = this.$node;
        let contextSwitchArray = [];
        _LC.adCx(node, contextSwitchArray);
        let processedArgs = this.$node.processArgs(this.$node._callee,{"helperInfo" : {"args" : args}}, [], undefined, this.$node);
        let functionName1 = processedArgs.$splice(0,1)[0];
        _LC.rmCx(node, contextSwitchArray);
        let customArgs = Array.from(arguments);
        let mainArgs = processedArgs.$concat(customArgs);
        if(self._methods[functionName1]) {
            return self._methods[functionName1].apply(self, mainArgs);
        }
        //@Slicer.developmentStart
        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC005", functionName, self.$node.tagName);
        //@Slicer.developmentEnd
    }
    if(childComponent) {
        if(!childComponent.set) {
            childComponent.setMethods(_LC.String.toCamelCase(attributeName), newFunc);
        } else {
            childComponent.component._methods[_LC.String.toCamelCase(attributeName)] = newFunc;
        }
    } else {
        return newFunc;
    }
};

defHelpers["unescape"] = function(value,additionalObject,userInstance){
    let lyteIns = this.getAppOrAddon();
    if(_LC.ffr) {
        return value;
    }
    if(lyteIns.Security.ignoreSanitizer){ //af check //take this lyte app instance and proceed
        let divEle = document.createElement("div");
        divEle.innerHTML = value;
        return divEle;
    }
    else{
        if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length >0){
            if(Object(additionalObject.GLOBAL_TAGS).length>0){
                var index = additionalObject.GLOBAL_TAGS.indexOf("link-to");
                if(index != -1){
                    additionalObject.GLOBAL_TAGS.$splice(index,1);
                }
            }
            if(additionalObject && additionalObject.GLOBAL_ATTRIBUTES && Object.keys(additionalObject.GLOBAL_ATTRIBUTES).length>0){
                var arr = ["yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title"];
                for(var i=0;i<arr.length;i++){
                    var index =additionalObject.GLOBAL_ATTRIBUTES.indexOf(arr[i]);
                    if(index != -1){
                        additionalObject.GLOBAL_ATTRIBUTES.$splice(index,1);
                    }
                }
            }
        }
        if(additionalObject && additionalObject.GLOBAL_TAGS){//this if check is inorder to getobserved attributes given in globaltags
            if(additionalObject.GLOBAL_ATTRIBUTES == undefined){
                additionalObject.GLOBAL_ATTRIBUTES = [];
            }
            var globalTagArr = Array.from(additionalObject.GLOBAL_TAGS);
            var attr = [];
            for(var a=0; a<globalTagArr.length; a++){
                
                let regComps = ComponentRegistry._registeredCommonClass;
                if(regComps[globalTagArr[a]]){
                    attr = regComps[globalTagArr[a]].observedAttributes;
                }else if(_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.registeredCustomComponent[globalTagArr[a]]){
                    if(_slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes){
                        attr = _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
                    }else{
                        attr = [];
                    }
                }
                for(var i=0; i<attr.length; i++){
                    if(additionalObject.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
                        additionalObject.GLOBAL_ATTRIBUTES.$push(attr[i]);
                    }
                }
            }
        }
        var divEle = document.createElement("div");
        if(userInstance && Object.keys(userInstance).length){
            if(additionalObject && Object.keys(additionalObject).length){
                lyteIns.Security.addGlobalObject(userInstance,additionalObject);
                var clean = userInstance.sanitize(value);
                lyteIns.Security.removeGlobalObject(userInstance,additionalObject);
            }
            else{
                var clean = userInstance.sanitize(value);
            }
        }
        else{
            if(additionalObject && Object.keys(additionalObject).length){
                lyteIns.Security.addGlobalObject(lyteIns.Security._ourSanitizerInstance_,additionalObject);
                var clean = lyteIns.Security._ourSanitizerInstance_.sanitize(value);
                lyteIns.Security.removeGlobalObject(lyteIns.Security._ourSanitizerInstance_,additionalObject);
            }else{
                var clean = lyteIns.Security._ourSanitizerInstance_.sanitize(value);
            }
        }
        divEle.innerHTML = clean;
        return divEle;
    }
};
defHelpers["unescape"] = function(value,additionalObject,userInstance){
    let lyteIns = this.getAppOrAddon();
    if(_LC.ffr) {
        return value;
    }
    let divEle = document.createElement("div");
    if(lyteIns.Security.ignoreSanitizer){ //af check //take this lyte app instance and proceed
        divEle.innerHTML = value;
        return divEle;
    }
    else{
        if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length > 0){
            _LC.Security.initializeConfig(additionalObject);
            _LC.Security.removeConfig(additionalObject);
            _LC.Security.addLyteComponents(additionalObject);
        }
        let clean;
        let ins = userInstance && Object.keys(userInstance).length ? userInstance : lyteIns.Security._ourSanitizerInstance_;
        if(additionalObject && Object.keys(additionalObject).length){
            clean = _LC.Security.sanitizeWithConfig(value ,additionalObject, ins);
        }else{
            clean = ins.sanitize(value);
        }
        divEle.innerHTML = clean;
        return divEle;
    }
};

defHelpers["escape"] = function(value,type){
    if(type == 'url'){
        return ZSEC.Encoder.encodeForHTMLAttribute(value);	
    }
    else if(type == 'js'){
        return ZSEC.Encoder.encodeForJavaScript(value);
    }
    else if(type == 'css'){
        return ZSEC.Encoder.encodeForCSS(value);	
    }
    else{
        return value;
    }
};

defHelpers["debugger"] = function() {
    debugger;
};

defHelpers["log"] = function() {
    console.log.apply(window, Array.from(arguments));
};

defHelpers["ifEquals"] = function(arg1, arg2) {
    if(arg1 === arg2) {
        return true;
    } else {
        return false;
    }
};

defHelpers["if"] = function(value, trueValue, falseValue) {
    if(value) {
        return trueValue;
    } else {
        return falseValue;
    }
};

defHelpers["negate"] = function(arg1) {
    return !arg1;
};


defHelpers["ifNotEquals"] = function(arg1, arg2) {
    if(arg1 === arg2) {
        return false;
    } else {
        return true;
    }
};

defHelpers['concat'] = function(){
	var resp = '';
	var argLength = arguments.length;
	for(var i=0;i<argLength;i++){
		if(arguments[i] != undefined){
			resp += arguments[i];
		}
	}
	return resp;
};


defProp(HTMLElement.prototype, 'setData', {
    configurable : true, 
    writable : true,
    value : function(arg0, arg1) {
        this._initProperties = this._initProperties || {};
        if(typeof arg0 === "string") {
            this._initProperties[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._initProperties[key] = arg0[key];
            }
        }
    }
});

defProp(HTMLElement.prototype, 'setMethods', {
    configurable : true, 
    writable : true,
    value : function(arg0, arg1) {
        this._initMethods = this._initMethods || {};
        if(typeof arg0 === "string") {
            this._initMethods[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._initMethods[key] = arg0[key];
            }
        }
    }
});

defHelpers['encAttr'] = function(val) {
    return ZSEC.Encoder.encodeForHTMLAttribute(encodeURIComponent(val));
}

defHelpers['expHandlers'] = function(leftOperand,operator,rightOperand,nextOperand){
    var argLen = arguments.length;
    if(operator == '++' ){
    	if(rightOperand == "postfix"){
    	   return (leftOperand++);
    	} else if(rightOperand == "prefix"){
    		return (++leftOperand);
    	}
    } else if(operator == "--"){
    	if(rightOperand == "postfix"){
    	   return (leftOperand--);
    	} else if(rightOperand == "prefix") {
    		return (--leftOperand);
    	}
    } else if((operator == "==")){
    	return leftOperand == rightOperand;
    }
     else if((operator == "===")){
    	return leftOperand === rightOperand;
    }
    
    else if((operator == "!=")) {
        return leftOperand != rightOperand;
    }
    else if((operator =="!==")) {
        return leftOperand !== rightOperand;
    }
    else if( operator == "&&") {
    	return leftOperand && rightOperand;
    } else if(operator == "||") {
    	return leftOperand || rightOperand;
    } else if(operator == "+"){
        if(argLen > 2){
        	return leftOperand+rightOperand;
        }
        return leftOperand;
    } else if(operator == '-'){
         if(argLen > 2){
        	return leftOperand-rightOperand;
        }
        return (-leftOperand);
    } else if(operator == '*'){
    	return leftOperand * rightOperand;
    } else if(operator == "/"){
    	return leftOperand / rightOperand;
    } else if(operator == "%"){
    	return leftOperand % rightOperand;
    } else if(operator == "<"){
    	return leftOperand < rightOperand;
    } else if(operator == ">") {
    	return leftOperand > rightOperand;
    } else if(operator == "<=") {
    	return leftOperand <= rightOperand;
    } else if(operator == ">=") {
    	return leftOperand >= rightOperand;
    } else if(operator == '|') {
        return leftOperand | rightOperand;
    } else if(operator == '&') {
        return leftOperand & rightOperand;
    }
    else if(operator == "!" ){
        return (!leftOperand);
    } else if(operator == '=') {
        leftOperand = rightOperand;
        return leftOperand;
    } else if(operator == "+=") {
        return leftOperand += rightOperand;
    } else if(operator == '-=') {
        return leftOperand -= rightOperand;
    } else if(operator == "*=") {
        return leftOperand *= rightOperand;
    } else if(operator == '/=') {
        return leftOperand /= rightOperand;
    } else if(operator == '?:') {
        return (leftOperand ? rightOperand : nextOperand);
    }
 };

ComponentRegistry.registerCustomPropHandler("ltProp");

_LC.shouldIgnoreDisconnect = function() {
    return _LC.ignoreDisconnect;
}

_LC.addAction = function(element, eventName, func, context) {
    element._lyteEvents = element._lyteEvents || {};
    element._lyteEvents[eventName] = element._lyteEvents[eventName] || []; 
    var ind = element._lyteEvents[eventName].$push({"func" : func, "fromEventListener" : true, "context" : context});
    return eventName + "-" + ind; 
  }

ComponentRegistry.prototype.removeAction = function(element, listenerId) {
    if(!listenerId) {
        //@Slicer.developmentStart
        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC014")
        //@Slicer.developmentEnd
        return;
    }
    var split = listenerId.split('-');
    var eventName = split[0];
    var index = parseInt(split[1]);
    if(!element._lyteEvents || !element._lyteEvents[split[0]] || isNaN(index)) {
        //@Slicer.developmentStart
        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_2__.ComponentError.error("LC015")
        //@Slicer.developmentEnd
        return;
    }
    element._lyteEvents[split[0]][split[1] - 1] = {};
}


_LC.hasLyteEvents = function(element, eventName) {
    if(element._lyteEvents && element._lyteEvents[eventName]) {
        return true;
    } else {
        return false;
    }
}

_LC.handleLyteEvents = function(element, event) {
    var funcs = element._lyteEvents[event.type];
    var ret;
    var eventStopped;
    for(var i=0;i<funcs.length;i++) {
        if(funcs[i].func) {
            ret = funcs[i].func.call(funcs[i].context ? funcs[i].context : window, event);
            if(ret === false || event.cancelBubble) {
                eventStopped = true;
                break;
            } 
        }
    }
    if(eventStopped) {
        event.stopPropagation();
    }
    return eventStopped;
}
_LC.executeObservers = function(compClass){
    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte._preRegister();
    let __observers = compClass.observers();
    _slyte_core__WEBPACK_IMPORTED_MODULE_4__.Lyte._postRegister();
    return __observers;
}
_LC.chromeBugFix();
_LC.booleanAttrList = ["async","autocomplete","autofocus","autoplay","border","challenge","checked1","compact","contenteditable","controls","default","defer","disabled","formNoValidate","frameborder","hidden","indeterminate","ismap","loop","multiple","muted","nohref","noresize","noshade","novalidate","nowrap","open","readonly","required","reversed","scoped","scrolling","seamless","selected","sortable","spellcheck","translate"]

_LC.core = {};
_LC.core._constructor = customElementPrototype;
_LC.core._registerComponent = customElementPrototype._registerComponent;
_LC.core.registerComponent = _LC.registerComponent;
_LC.core.executeBlockHelpers = customElementPrototype.prototype.executeBlockHelpers;
_LC.core.updateForHelper = customElementPrototype.prototype.updateForHelper;
_LC.core.updateForInHelper = customElementPrototype.prototype.updateForInHelper;
_LC.core.updateSwitchHelper = customElementPrototype.prototype.updateSwitchHelper;

ComponentRegistry.prototype.set = _LC.set;
ComponentRegistry.prototype.get = _LC.get;
_LC.aF._name = "arrayUtils";
_LC.oF._name = "objectUtils";
_slyte_core_src_Utils_js__WEBPACK_IMPORTED_MODULE_10__.Utils.addMethods([_LC.set,_LC.get,_LC.arrayUtils,_LC.objectUtils])
let appendChild = _LC.appendChild;
let insertAfter = _LC.insertAfter;
let insertBeforeFn = _LC.insertBefore
let replaceWith = _LC.replaceWith;
let render = _LC.render;
let shouldIgnoreDisconnect = _LC.shouldIgnoreDisconnect;
_LC.globalDOMEvents = globalDOMEvents;
_LC.globalEventHandler = globalEventHandler;
_LC.changeEventhandler = changeEventhandler;
_LC.doCompile = doCompile;
_LC.getDynamicNode = getDynamicNode;



/***/ }),

/***/ 22296759:
/*!****************************************************************!*\
  !*** ./node_modules/@slyte/component/src/utils/lyte-errors.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiError": () => (/* binding */ ApiError),
/* harmony export */   "ComponentError": () => (/* binding */ ComponentError),
/* harmony export */   "RegistryError": () => (/* binding */ RegistryError)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 2800903);
//ignorei18n_start


class ComponentError extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

ComponentError.errorCodes = {
    LC001: "Error while parsing custom prop handler attribute {0} to the component {1}. Check if the value provided is a valid JSON",
    LC002: "{0} Component is not compiled. Please compile using Lyte CLI",
    LC003: "Helper named {0} is not defined",
    LC004: "Action named {0} doesn't exists",
    LC005: "Method named {0} doesn't exists in {1} component",
    LC006: "Error in data passed to component '{0}' for the properties - {1}",
    LC007: "Directive syntax is used but source not loaded",
    LC008: "{0} component not supporting turbo render. please add @turbo-supported in the component's template tag.",
    LC009: "Error in updateForHelper",
    LC010: "Passing lyteFastRender to unbound option in 'for' helper is depricated. So please make use of '@turbo' directive in the node - {0}",
    LC011: "Fast render source not bundled",
    LC012: "Error with templateAttributes.",
    LC013: "Data passed for property '{0}' of '{1}' cannot be serialized. The component '{2}' might not be registered before its use.",
    LC014: "No listenerId provided",
    LC015: "Invalid listenerId / listener is not available",
    LC016: "Deprecation Warning! pass the component class to component-class attribute, instead of passing '{0}' string component name to component-name attribute.",
    LC017: "{0} component not supporting shadow dom rendering. please add @shadow-supported in the component's template tag."

};
ComponentError.register();

class ApiError extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

ApiError.errorCodes = {
    LC001: "Lyte.objectUtils doesn't support {0} function",
    LC002: "Lyte.arrayUtils doesn't support {0} function",
    LC003: "Component not specified in Lyte.Component.render",
    LC004: "Specified outlet {0} doesn't exists - Lyte.Component.render",
    LC005: "Parent Node / reference Node not provided for insertBefore method",
    LC006: "Invalid registry instance passed - Lyte.Component.render",
    LC007: "Uninstantiated registry class passed - Lyte.Component.render",
    LC008: "Unregistered component class passed - Lyte.Component.render",
    LC009: "Sanitizer instance not passed to sanitize api",
    LC010: "Invalid data passed in Lyte.Component.render"

};
ApiError.register();

class RegistryError extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

RegistryError.errorCodes = {
    LC001: "'{0}' registry is not registered with Lyte.",
    LC002: "'{0}' - '{1}' already registered with '{1}' registry.",
    LC003: "'{0}' Component class should extend a ComponentRegistry's Component property directly or extend through base component.",
    LC004: "Registry class extended in the '{0}' '{1}' is not registered with Lyte",
    LC005: "Invalid registry instance '{0}' passed in addRegistries hook of {1}",
    LC006: "Invalid registry instance '{0}'",
    LC007: "'{0}' Registry linked recursively in the app/addon.",
    LC008: "Invalid registry instance '{0}' passed in setDefaultRegisty hook of '{1}'",
    LC009: "Default Registry not found.",
    LC010: "{0} : {1} Not found in any registry."
};
RegistryError.register();


//ignorei18n_end

/***/ }),

/***/ 90815363:
/*!**************************************************!*\
  !*** ./node_modules/@slyte/core/src/DataType.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataType": () => (/* binding */ DataType)
/* harmony export */ });
/* harmony import */ var _lyte_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lyte-error */ 2800903);
/* harmony import */ var _lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte-utils */ 33115194);



class DataType {
    static register(opts){
        this._name = this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');
        var clsExt = this.extends || this.type;
        this.type = clsExt;
        if(clsExt == undefined || DataType.types.indexOf(clsExt) == -1){
            _lyte_error__WEBPACK_IMPORTED_MODULE_0__.Logger.error("Not a valid field type - "+clsExt);
            return;
        }  
        if(this.prototype.serialize){
            this.serialize = this.prototype.serialize;
        }      
        if(this.prototype.deserialize){
            this.deserialize = this.prototype.deserialize;
        }
        var rHash = opts.refHash;
        var currCls = this, 
        appMap = DataType.lyte = DataType.lyte || new Map(),  
        dtMap,
        currClsName = currCls.name;
        if(!appMap.has(rHash)){
            appMap.set(rHash, new Map());
        }
        dtMap = appMap.get(rHash);
        if(!dtMap.has(currClsName)){
            dtMap.set(currCls.name, currCls);
        }
        DataType.triggerEvent(rHash, currCls);
    }
    static registerInApp(parent){
        var name = this._name = this.name || this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');
        var clsExt = this.extends || this.type;
        this.type = clsExt;
        if(clsExt == undefined || DataType.types.indexOf(clsExt) == -1){
            _lyte_error__WEBPACK_IMPORTED_MODULE_0__.Logger.error("Not a valid field type - "+clsExt);
            return;
        }  
        if(this.prototype.serialize){
            this.serialize = this.prototype.serialize;
        }      
        if(this.prototype.deserialize){
            this.deserialize = this.prototype.deserialize;
        }
        var name = this._name = this._name || this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');
        if(!parent.dataType.hasOwnProperty(name)){
            parent.dataType[name] = this;
            if(parent.dataType.triggerEvent){
                parent.dataType.triggerEvent("add", name, this);
            }
        }
        else{
            _lyte_error__WEBPACK_IMPORTED_MODULE_0__.Logger.warn("DataType with the same name - "+ name+ " already present in the app");
        }
    }
}
(0,_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.defProp)(DataType, "types", {
    value: ["string", "object", "number", "boolean", "array"]
});
(0,_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.extendEventListeners)(DataType);


/***/ }),

/***/ 38345401:
/*!**************************************************!*\
  !*** ./node_modules/@slyte/core/src/JsonPath.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Jwalk": () => (/* binding */ pathFinder)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 53501236);


function pathFinder (scope,path){
    if(path){
        var Json = scope;
        if(typeof scope == "object"){
            return parsePath(scope,path)
        }
    }
    else{
        _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Invalid JsonPath - " + path)
    }
}
function parsePath (scope,path){
    if(path.includes(".")){
        path=path.replace(/ /g,"");
        var pathArr =path.split(".")
        if(pathArr[0] == "$"){
            pathArr.splice(0,1)
        }
    }
    return GetData(scope,pathArr)
}
function GetData (scope,path,DeepTraverse){
    if(DeepTraverse){
        var arr =[];
        if(Array.isArray(scope)){
            path.splice(0,1);
            for(var i_deep=0; i_deep<scope.length ; i_deep++){
            var value = deepBranches(scope[i_deep],path,DeepTraverse)
            if(Array.isArray(value) && value.length ==0){
                value = undefined;
            }
            if(value){
                arr.push(value)
            }
            }
            return arr;
        }
    }
    else{
        return deepBranches(scope,path,DeepTraverse)
    }
}
function deepBranches (obj,path,DeepTraverse){
    for(var pathIndex =0 ; pathIndex<path.length; pathIndex ++){
        var key = path[pathIndex];
        var nextKey = path[pathIndex+1],_nextKey;
        if(nextKey){
            _nextKey = keyParser(nextKey);
        }
        if(key.includes("[") && key.includes("]")){
            var utilScope = key.match(/\[([^\]]+)\]/g)[0]
            var utilKey = key.match(/^(.+?)\[/g)
            if(utilKey){
                utilKey=utilKey[0].replace(/\[/g,"");
            }
            if(!Array.isArray(obj) && utilKey){
                obj = obj[utilKey];
            }
            obj = (!Array.isArray(obj) && utilScope) ? undefined : obj;
            if(Array.isArray(obj)){
                if(utilScope && !utilScope.includes("@")){
                    if(utilScope.includes(":")){
                        utilScope = utilScope.replace(/\[/g,"").replace(/\]/g,"");
                        var slice = utilScope.split(":");
                        var start = slice[0]==""?undefined:parseInt(slice[0]);
                        var end = slice[1]==""?undefined:parseInt(slice[1]);
                        obj = obj.slice(start,end)
                    }
                    else if(utilScope.includes("*")){
                        continue
                    }
                    else if(utilScope){
                        var key = utilScope.match(/\[(.*?)\]/)[1]
                        obj = obj[key]
                    }
                }
            }
        }
        else if(key == ""){
            if(_nextKey == undefined){
                _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Invalid JsonPath - " + path + "expected : Path string should not end with the  '..' ")
            }
            obj = GetAllKeys(obj,_nextKey)
            if(path.length-1 != pathIndex){
                if(Array.isArray(obj)){
                    DeepTraverse =1;
                    var utilScope = nextKey.match(/\[([^\]]+)\]/g)
                    path.splice(0,pathIndex+1)
                    if(utilScope!=null){
                        utilScope = utilScope[0];
                        utilScope = utilScope.match(/\[(.*?)\]/)[1]
                        obj = separateArray(obj,utilScope);
                    }
                    if(path.length>1){
                        obj = GetData(obj,path,DeepTraverse)
                        break;
                    }
                }
            }
            if(nextKey && !nextKey.includes("[") && !nextKey.includes("]")){
                pathIndex++;
            }
        }
        else if(key == "*"){
            continue;
        }
        else{
            if(path[pathIndex-1] && (path[pathIndex-1] == "*" || path[pathIndex-1].includes("*"))){
                if(Array.isArray(obj)){
                    var newArray=[];
                    var ind=0;
                    for(var arr_index = 0; arr_index<obj.length; arr_index++){
                        if(obj[arr_index][key]){
                            newArray[ind] = obj[arr_index][key];
                            ind++;
                        }
                    }
                    obj=newArray;
                }
                else if (typeof obj == "object"){
                    obj = obj[key]
                }
            }
            else{
                obj = obj[key]?obj[key]:undefined;
            }
        }

    }
    return obj
}
function keyParser (key){
    if(key.includes("[") && key.includes("]")){
        var utilScope = key.match(/\[([^\]]+)\]/g)[0]
        var utilKey = key.match(/^(.+?)\[/g) 
        if(utilKey){
            utilKey=utilKey[0].replace(/\[/g,"");
            return utilKey;
        }
    }
    return key;
}
function GetAllKeys (scope,key){
    var arr= []; 
    getRecurssive(scope,key,arr);
    return arr
}
function getRecurssive (scope,key,arr){
    if(typeof scope == "object"){
        for(var v in scope){
            if(v == key){
                arr.push(scope[key])
            }
            if(typeof scope[v] == "object"){
                getRecurssive(scope[v],key,arr)
            }
        }
    }
    else if(Array.isArray(scope)){
        for( var index = 0 ; index<scope.length ; index++ ){
            var obj = scope[index];
            getRecurssive(obj,key,arr);
        }
    }
}
function separateArray (scope,index){
    var Arr =[];
    for (var i=0; i< scope.length; i++){
        if(scope[i][index]){
            Arr.push(scope[i][index]);
        }
    }
    return Arr;
}



/***/ }),

/***/ 36329437:
/*!***************************************************!*\
  !*** ./node_modules/@slyte/core/src/LyteAddon.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LyteAddon": () => (/* binding */ LyteAddon)
/* harmony export */ });
/* harmony import */ var _lyte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lyte */ 53501236);
/* harmony import */ var _service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service */ 10723535);
/* harmony import */ var _lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte-utils.js */ 33115194);



// import { resolvePromises } from './rsvp';
// import { Logger } from './lyte-error';
/*convert to custom class*/
class LyteAddon extends _service__WEBPACK_IMPORTED_MODULE_0__.Service {
    constructor(config){
        super();
        this.config = config;
        (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__._lyteInit)(LyteAddon,this);
        (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__._lyteDidConnect)(LyteAddon,this);
    }
    static register(options){
        if(options){
          if(options._migration){
            this._migration = options._migration;
          }
        }
    }
    lookups() {
        return [];
    }

    scopedInstance() {
        return _lyte__WEBPACK_IMPORTED_MODULE_2__.__scopedInstance.apply(this, Array.from(arguments));
    }

    get __isAddon() {
        return true;
    }
    
}
// LyteAddon.prototype.resolvePromises = function(promises) {
//     return new Promise(function(res, rej) {
//       resolvePromises(promises).then(function(data) {
//         res(data);
//       },function(data) {
//         rej(data);
//       })
//     })
// }
LyteAddon._component = {};
// LyteAddon.error = Logger.error.bind(Logger);
// LyteAddon.warn = Logger.warn.bind(Logger);
// LyteAddon.errorCodes = Logger.errorCodes;



/***/ }),

/***/ 49373160:
/*!***********************************************!*\
  !*** ./node_modules/@slyte/core/src/Mixin.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mixin": () => (/* binding */ Mixin)
/* harmony export */ });
/* harmony import */ var _lyte_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lyte-utils.js */ 33115194);
/* harmony import */ var _lyte_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte.js */ 53501236);


let registeredMixin = {};
let Mixin = (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_0__.createCustomClass)(function(arg1,overrides){
    class Mixin extends (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_0__.getClass)([],arg1) {
        static register(options){
            if(this.__lMod) {
                return super.register.apply(this, Array.from(arguments));
            }
            if(options){
                if(options.hash){
                    this._hash = options.hash;
                }
                if(options.refHash){
                    this._refHash = options.refHash;
                    var mobj = Mixin.registeredMixin[options.refHash] = Mixin.registeredMixin[options.refHash] || {};
                    mobj[this.name] = this;
                    Mixin.getAppClass(options, this);
                }
            }
        }
        static getAppClass(options, mixinCls){
            let registryClass;
            _lyte_js__WEBPACK_IMPORTED_MODULE_1__.Lyte._instances.forEach(function(appIns){
                let appClass = appIns.constructor;
                if(appClass._hash == options.refHash){
                    appIns.registeredMixins[mixinCls.name] = mixinCls;
                }
            });
        }
    }
    Mixin.registeredMixin = registeredMixin;
    return overrides(Mixin)
})



/***/ }),

/***/ 90502503:
/*!***********************************************!*\
  !*** ./node_modules/@slyte/core/src/Utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Utils": () => (/* binding */ Utils)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/service */ 10723535);


/*convert to custom class */
class Utils extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__.Service {
    static addMethods(data){
        if(Array.isArray(data)){
            data.forEach(function(fn){
                var name = fn._name ? fn._name : fn.name;
                if(!Utils.prototype[name]){
                    Utils.prototype[name] = fn;
                }
            });
        }
    } 
}
Utils.addMethods([_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject, _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.extendEventListeners]);



/***/ }),

/***/ 68633323:
/*!************************************************!*\
  !*** ./node_modules/@slyte/core/src/errors.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "errorCodes": () => (/* binding */ errorCodes),
/* harmony export */   "getErrorMessage": () => (/* binding */ getErrorMessage)
/* harmony export */ });
var errorCodes =  {
  ERR01 : "Primary key cannot be modified", 
  ERR02 : "Mandatory field cannot be empty", 
  ERR03 : "Type of value does not match the specified data type",
  ERR04 : "Value is greater than the maximum value allowed",
  ERR05 : "Value is less than the minimum value allowed", 
  ERR06 : "Length of string/array is greater than the maximum limit allowed", 
  ERR07 : "Length of string/array is less than the minimum limit allowed",
  ERR08 : "String does not match the specified pattern", 
  ERR09 : "Values in array are not unique", 
  ERR10 : "Value is not equal to the specified constant", 
  ERR11 : "Model of related field is not defined",
  ERR12 : "Model of backward relation is not defined", 
  ERR13 : "Record not found", 
  ERR14 : "Model does not match the related field model", 
  ERR15 : "Error in creating a record as a relation",
  ERR16 : "Record with primary key already exists", 
  ERR17 : "Value cannot be changed because record has been deleted", 
  ERR18 : "Action not defined", 
  ERR19 : "Model not defined",
  ERR20 : "Key not specified", 
  ERR21 : "'belongsTo' relationship expects a single object/id", 
  ERR22 : "Type not specified for polymorphic relation", 
  ERR23: "Primary Key value not present", 
  ERR24: "Error while relating record", 
  ERR25: "Backward relation not present",
  L001: "{0} {1} is already registered",
  ERR27 : "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
//   /* move to component */
//   LC001: "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
//   LC002: "{0} Component is not compiled. Please compile using Lyte CLI",
//   LC003: "Helper named {0} is not defined",
//   LC004: "Action named {0} doesn't exists",
//   LC005: "Lyte.objectUtils doesn't support {0} function",
//   LC006: "Lyte.arrayUtils doesn't support {0} function",
//   LC007: "Component name not specified in Lyte.Component.render",
//   LC008: "Specified outlet {0} doesn't exists - Lyte.Component.render",
//   LC009: "Method named {0} doesn't exists in {1} component",
//   LC010: "Parent Node / reference Node not provided for insertBefore method",
  /* move to data */
  LD01: "Primary key value might be missing in the response data that is received, {0}",
  LD02: "{0} - {1} is not registered",
  LD03: "Cannot set the error {0} for {1}",
  LD04: "No such record to merge, {0}",
  LD05: "Model( {0} ) of related property - {1} not found in model - {2}",
  LD06: "Backward relation not present in model( {0} ), for the property {1} of model( {2} )",
  LD07: "{0} type not handled in handleArrayOperations",
  LD08: "{0} {1} will be deprecated from next version {2}",
  LD09: "deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback",
  LD10: "Response data not in a format lyte data store expects",
  LD11: "Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version",
  LD12: "Response ( {0} ) is not in a format, lyte data store expects",
  LD13: "Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of response data. Data - {3}",
  LD14: "Cannot register {0} - {1}, as it already exists.",
  LD15: "Primary key value might be missing in the response data that is received, {0}",
  LD16: "Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge",
  LD17: "Record with the primary key value already exists",
  LD18: "No { 0 } present",
  LD19: "Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version",
  LD20: "Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.",
  LD21: "No such state ( {0} ) saved for the record.",
  LD22: "For create / createRecord, response with a primary key value should be received",
  LD23: "PrimaryKey field {1} in {0} cannot have default value",
  LD24: "Response couldn't be parsed, {0}",
  LD25: "Cannot create record for the data - {0}",
  LD26: "Only one baseKey is allowed for a model",
  LD27: "Record merge failed, since the data passed is invalid - {0}",
  LD28: "Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}"   
};

function getErrorMessage(code) {
    var args = Array.from(arguments).slice(1);
    if(errorCodes[code]) {
        return errorCodes[code].replace(/{(\d+)}/g, function(t, i) {
            return args[i]
        });
    } else {
        return code;
    }
}



/***/ }),

/***/ 2800903:
/*!****************************************************!*\
  !*** ./node_modules/@slyte/core/src/lyte-error.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Logger": () => (/* binding */ Logger)
/* harmony export */ });
/* harmony import */ var _lyte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte */ 53501236);
/* harmony import */ var _lyte_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lyte-utils */ 33115194);
/* harmony import */ var _LyteAddon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LyteAddon */ 36329437);




// add function which throws error //ex Lyte.attr function need to be added with checking secind arguments as object ans so it will override the original Lyte.attr function in develepment mode
class LyteError extends Error {

}

const level = 0;
class Logger extends Error {
    static get level(){
        return level;
    }
    constructor(){
        super(...arguments);
    }
    static register(){
        var context = this;
        while(context !== Logger){
            if(!context.hasOwnProperty("addEventListener")){
                (0,_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.extendEventListeners)(context);
            }
            context = Object.getPrototypeOf(context);
        }
        if(!Logger.triggerEvent){
            (0,_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.extendEventListeners)(Logger);
        }
    }
    static registerErrorCodes(obj, defineProperty){
        if(obj && typeof obj == "object"){
            for(var key in obj){
                var message = obj[key];
                if(defineProperty){
                    Object.defineProperty(this.errorCodes, key, {
                        value: message
                    });
                }
                else{
                    this.errorCodes[key] = message;
                }
            }
        }
    }
    static getErrorMessage(code, withCode){
      var args = Array.from(arguments).slice(1);
      if(this.errorCodes[code]) {
          var msg = this.errorCodes[code].replace(/{(\d+)}/g, function(t, i) {
              return args[i];
          });
          return code+": "+msg;
      } else {
          return code;
      }
    }
    static setErrorMessage(code, message, defineProperty){
        if(defineProperty){
            Object.defineProperty(this.errorCodes, code, {
                value: message
            });
        }
        else{
            this.errorCodes[code] = message;
        }
    }
    static error(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0 instanceof _lyte__WEBPACK_IMPORTED_MODULE_1__.Lyte || arg0 instanceof _LyteAddon__WEBPACK_IMPORTED_MODULE_2__.LyteAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel < 3){
            errorObj = args[0];
            var parse = errorObj.stack, 
            context = this;
            errorObj = parse ? errorObj : new this(this.getErrorMessage.apply(this, args));
            while(context !== Logger){
                if (context.hasOwnProperty("onerror")) {
                    context.onerror.call(context, errorObj, args[1], this, ins);
                }
                if(context.hasOwnProperty("triggerEvent")){
                    context.triggerEvent.call(context, "error", errorObj, args[1], this, ins);
                }
                context = Object.getPrototypeOf(context);
            }
            if (Logger.hasOwnProperty("onerror")) {
                Logger.onerror.call(Logger, errorObj, args[1], this, ins);
            }
            if(Logger.hasOwnProperty("triggerEvent")){
                Logger.triggerEvent.call(Logger, "error", errorObj, args[1], this, ins);
            }
            if(ins){
                if(ins.onerror) {
                    ins.onerror.call(ins, errorObj, args[1], this, ins);
                }
                if(ins.triggerEvent){
                    ins.triggerEvent.call(ins, "error", errorObj, args[1], this, ins);
                }
            }
            var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1
            if (parse && !safari) {
                errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
            }
            if(args[1]) {
                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message, args[1]);
            } else {
                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message);    
            }
        }
    }
    static warn(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0 instanceof _lyte__WEBPACK_IMPORTED_MODULE_1__.Lyte || arg0 instanceof _LyteAddon__WEBPACK_IMPORTED_MODULE_2__.LyteAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel < 2){
            var errorObj = args[0];
            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));
            console.warn(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "Warn: ") : errorObj) : errorObj.message);
        }
    }
    static log(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0 instanceof _lyte__WEBPACK_IMPORTED_MODULE_1__.Lyte || arg0 instanceof _LyteAddon__WEBPACK_IMPORTED_MODULE_2__.LyteAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel == 0){
            var errorObj = args[0];
            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));
            console.log(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "Log: ") : errorObj) : errorObj.message);        
        }
    }
}
Logger.errorCodes = {
    ERR01 : "Primary key cannot be modified", 
    ERR02 : "Mandatory prop cannot be empty", 
    ERR03 : "Type of value does not match the specified data type",
    ERR04 : "Value is greater than the maximum value allowed",
    ERR05 : "Value is less than the minimum value allowed", 
    ERR06 : "Length of string/array is greater than the maximum limit allowed", 
    ERR07 : "Length of string/array is less than the minimum limit allowed",
    ERR08 : "String does not match the specified pattern", 
    ERR09 : "Values in array are not unique", 
    ERR10 : "Value is not equal to the specified constant", 
    ERR11 : "Schema of related field is not defined",
    ERR12 : "Schema of backward relation is not defined", 
    ERR13 : "Entity not found", 
    ERR14 : "Schema does not match the schema defined in the related field", 
    ERR15 : "Error in creating a entity as a relation",
    ERR16 : "Entity with primary key already exists", 
    ERR17 : "Value cannot be changed because entity has been deleted", 
    ERR18 : "Action not defined", 
    ERR19 : "Schema not defined",
    ERR20 : "Key not specified", 
    ERR21 : "'one' relationship expects a single object/id", 
    ERR22 : "Type not specified for polymorphic relation", 
    ERR23: "Primary Key value not present", 
    ERR24: "Error while relating entities", 
    ERR25: "Backward relation not present",
    ERR26: "Primary key value cannot be undefined or null",
    ERR27: "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
    ERR29: "Property not defined in the object",
    ERR30: "Property's value is not an instanceof the mentioned class",      
    L001: "{0} {1} is already registered",
    // /* move to component */
    // LC001: "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
    // LC002: "{0} Component is not compiled. Please compile using Lyte CLI",
    // LC003: "Helper named {0} is not defined",
    // LC004: "Action named {0} doesn't exists",
    // LC005: "Lyte.objectUtils doesn't support {0} function",
    // LC006: "Lyte.arrayUtils doesn't support {0} function",
    // LC007: "Component name not specified in Lyte.Component.render",
    // LC008: "Specified outlet {0} doesn't exists - Lyte.Component.render",
    // LC009: "Method named {0} doesn't exists in {1} component",
    // LC010: "Parent Node / reference Node not provided for insertBefore method",
};
(0,_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.extendEventListeners)(Logger);

window.Logger = Logger;



/***/ }),

/***/ 33115194:
/*!****************************************************!*\
  !*** ./node_modules/@slyte/core/src/lyte-utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_defineProperty": () => (/* binding */ _defineProperty),
/* harmony export */   "_get": () => (/* binding */ _get),
/* harmony export */   "_lyteDidConnect": () => (/* binding */ _lyteDidConnect),
/* harmony export */   "_lyteInit": () => (/* binding */ _lyteInit),
/* harmony export */   "addEventListener": () => (/* binding */ addEventListener),
/* harmony export */   "addStateToMap": () => (/* binding */ addStateToMap),
/* harmony export */   "arrayUtils": () => (/* binding */ arrayUtils),
/* harmony export */   "bindObj": () => (/* binding */ bindObj),
/* harmony export */   "checkEstablishingSCP": () => (/* binding */ checkEstablishingSCP),
/* harmony export */   "checkNestedProp": () => (/* binding */ checkNestedProp),
/* harmony export */   "checkProperty": () => (/* binding */ checkProperty),
/* harmony export */   "checkWatchPath": () => (/* binding */ checkWatchPath),
/* harmony export */   "cmpData": () => (/* binding */ cmpData),
/* harmony export */   "cmpObjs": () => (/* binding */ cmpObjs),
/* harmony export */   "copyObject": () => (/* binding */ copyObject),
/* harmony export */   "createCustomClass": () => (/* binding */ createCustomClass),
/* harmony export */   "deepCopyObject": () => (/* binding */ deepCopyObject),
/* harmony export */   "defProp": () => (/* binding */ defProp),
/* harmony export */   "defProps": () => (/* binding */ defProps),
/* harmony export */   "defineRelation": () => (/* binding */ defineRelation),
/* harmony export */   "estObjScp": () => (/* binding */ estObjScp),
/* harmony export */   "establishObjectBinding": () => (/* binding */ establishObjectBinding),
/* harmony export */   "establishObserverBindings": () => (/* binding */ establishObserverBindings),
/* harmony export */   "establishWatchScope": () => (/* binding */ establishWatchScope),
/* harmony export */   "extendEventListeners": () => (/* binding */ extendEventListeners),
/* harmony export */   "extendMixin": () => (/* binding */ extendMixin),
/* harmony export */   "extendService": () => (/* binding */ extendService),
/* harmony export */   "getClass": () => (/* binding */ getClass),
/* harmony export */   "getConfig": () => (/* binding */ getConfig),
/* harmony export */   "getCurrentRouterInstance": () => (/* binding */ getCurrentRouterInstance),
/* harmony export */   "getNearestApp": () => (/* binding */ getNearestApp),
/* harmony export */   "getProperty": () => (/* binding */ getProperty),
/* harmony export */   "getSuperClass": () => (/* binding */ getSuperClass),
/* harmony export */   "globalsGet": () => (/* binding */ globalsGet),
/* harmony export */   "globalsSet": () => (/* binding */ globalsSet),
/* harmony export */   "includeMixins": () => (/* binding */ includeMixins),
/* harmony export */   "injectServiceToModules": () => (/* binding */ injectServiceToModules),
/* harmony export */   "isEntity": () => (/* binding */ isEntity),
/* harmony export */   "isInheritedClass": () => (/* binding */ isInheritedClass),
/* harmony export */   "isKeyword": () => (/* binding */ isKeyword),
/* harmony export */   "many": () => (/* binding */ many),
/* harmony export */   "nestScp": () => (/* binding */ nestScp),
/* harmony export */   "nestScpId": () => (/* binding */ nestScpId),
/* harmony export */   "nestScpRemove": () => (/* binding */ nestScpRemove),
/* harmony export */   "newGetSuperClass": () => (/* binding */ newGetSuperClass),
/* harmony export */   "objectUtils": () => (/* binding */ objectUtils),
/* harmony export */   "observes": () => (/* binding */ observes),
/* harmony export */   "one": () => (/* binding */ one),
/* harmony export */   "prop": () => (/* binding */ prop),
/* harmony export */   "registerErrorCodes": () => (/* binding */ registerErrorCodes),
/* harmony export */   "removeEventListener": () => (/* binding */ removeEventListener),
/* harmony export */   "removeNestScp": () => (/* binding */ removeNestScp),
/* harmony export */   "removeStateFromMap": () => (/* binding */ removeStateFromMap),
/* harmony export */   "toAddSuper": () => (/* binding */ toAddSuper),
/* harmony export */   "toBeUsedServices": () => (/* binding */ toBeUsedServices),
/* harmony export */   "triggerEvent": () => (/* binding */ triggerEvent),
/* harmony export */   "types": () => (/* binding */ types),
/* harmony export */   "validateData": () => (/* binding */ validateData)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 53501236);
/* harmony import */ var _slyte_core_src_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/errors.js */ 68633323);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core */ 10723535);
/* harmony import */ var _lyte_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lyte-error */ 2800903);
/* harmony import */ var _rsvp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rsvp */ 73236209);





const _keywords = {
  "component" : ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
  "adapter" : ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
  "serializer" : ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
  "route" : ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith","actions"]
};  
// var arrayUtils =  function() {
//     let lc = window.CrmComponentRegistry._instanceList[0]._getLyteComponent();
//     return lc.aF.apply(lc, arguments);
// };
// var objectUtils =  function() {
//     let lc = window.CrmComponentRegistry._instanceList[0]._getLyteComponent();
//     return lc.oF.apply(lc, arguments);
// }
// var set = function(){
//   return LyteComponent.set.apply(LyteComponent,arguments);
// }
// var get = function(){
//   return LyteComponent.get.apply(LyteComponent,arguments);
// }
// var render = function() {
//   return LyteComponent.render.apply(LyteComponent, arguments);
// }
// var modifyTemplate = function(){
//   return LyteComponent.modifyTemplate.apply(LyteComponent,arguments);
// }
// var compileDynamicTemplate = function(){
//   return LyteComponent.compileDynamicTemplate.apply(LyteComponent,arguments);
// }
// var doDomProcessing = function(){
//   return LyteComponent.doDomProcessing.apply(LyteComponent,arguments);
// }
// var getComponentTemplate = function(){
//   return LyteComponent.getComponentTemplate.apply(LyteComponent,arguments);
// }
// var addLyteEventListener = function(){
//   return Lyte.Component.addLyteEventListener.apply(Lyte.Component,arguments);
// }
// var removeLyteEventListener = function(){
//   return Lyte.Component.removeLyteEventListener.apply(Lyte.Component,arguments);
// }
function getNearestApp(node){
    while(node){
      if(node.component){
        return node.component.getApp();
      }
      node = node.parentElement;
    }
    return _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte._getDefaultAppIns();
}
function defProp() {
	Object.defineProperty.apply(Object, arguments);
}

function defProps() {
	Object.defineProperties.apply(Object, arguments);
}

function observes(){
  var args = Array.from(arguments), 
  func = args.pop(), 
  properties = [];
  args.forEach(function(observerValue) {
      let valueDetails = observerValue.split("::"), 
      observerType = valueDetails[0], 
      observerTo = valueDetails[1];
      switch(observerType){
          // case "event":{
          //     customCrmComponent._callbacks[observerType].push(observerFunction);
          // }
          // break;
          // case "action":
          // case "method":
          // {
          //     customCrmComponent._callbacks[observerType].push({[observerTo] : observerFunction});
          // }
          // break;
          default :{
              properties.push(observerType);
          }
      }
  })
  if(properties.length){
    var observerObj = {
        properties:properties,
        type:"observer",
        value:func
    }
    return observerObj;
  }
}

function isKeyword(key, scope){
  var arr = ["component", "adapter", "serializer", "route"];
  if(scope){
    arr = [scope];
  }
  var len = arr.length;
  for(var i=0;i<len;i++){
    var keyArr = _keywords[arr[i]];
    if(keyArr){
      var res = keyArr.indexOf(key);
      if(res != -1){
        return true;
      }
    }
  }
  return false;
}

function injectServiceToModules(scp, services){
  var mdlObj = scp.$.injectServices;
  for(var mKey in mdlObj){
    var mdl = mdlObj[mKey];
    for(var name in services){
      mdl(name, serv[name], mKey);
    }
  }
}

// function addToInstance(ins) {
//   if(ins.is != "app"){
//     if(!__instances[ins.is].hasOwnProperty(ins.name))
//     {
//       __instances[ins.is][ins.name] = ins;
//     }
//     else{
//       Lyte.warn("L001", ins.is, ins.name);
//     } 
//   }
//   else{
//     if(!__instances[ins.is]){
//       __instances[ins.is] = ins;
//     }
//     else{
//       Lyte.warn("L001", ins.is, "");
//     }
//   }
// }

// function createEngineInstance(engineName,config){
//   var ins = new Lyte('engine',engineName,config);
//   ins = Object.assign(ins,__instances.engine[engineName]);
//   return ins;
// }

function registerErrorCodes(obj, lyte) {
    Object.assign(_slyte_core_src_errors_js__WEBPACK_IMPORTED_MODULE_1__.errorCodes, obj);
}


function isEntity(object){
  if(object && object.$ && object.$.hasOwnProperty("isModified")) {
    return true;
  }
  return false;
}

function isRecord(object){
  if(object && object.$ && object.$.hasOwnProperty("isModified")) {
    return true;
  }
  return false;
}
function getVal(key,target){
  return target && target.__config && (target.__config[key]?"true":(target.__config[key] == false?"false":undefined));
}
function getConfig(key,target){
  if(!target){
    target = LyteCls._instances[0].$router.getRouteInstance();
    return getVal(key,target.$component)||
          ((!target._callee)?getVal(key,target.$app): getConfig(key,target._callee));
  }
  else{
    return getVal(key,target.component)||
          getVal(key,target.$component)||
          ((!target._callee)?getVal(key,target.$app): getConfig(key,target._callee));
  }
}
function getCurrentRouterInstance(){
  return LyteCls._instances[0].$router.getRouteInstance();
}
// function getConfig(key,regIns){
//   var configObj = window.__config;
//   if(configObj){
//       return {value:configObj[key],...((regIns)?{regIns:window.__config.getIns}:{})};
//   }
// }

function triggerEvent() {
  var args = Array.prototype.slice.call(arguments, 1)
  var eventName = arguments[0];
  var stopEvent = false;
  var s = this.__lyteRegisteredEvents[eventName];
    if(!s) {
      s = this.__lyteRegisteredEvents[eventName] = {"listeners" : new Map()};
    } else {
      var mp = s.listeners, keys = Array.from(mp.keys()), kLen = keys.length;    
      for(var i=0;i<kLen;i++) { 
        var func = mp.get(keys[i]);
        if(func) {
           var ret = func.apply(this, args);
           if(ret === false) {
             stopEvent = true;
             break;
           }
        }
      }
    }
    var customEvent = new CustomEvent(eventName, {"detail" : args});
    if(!stopEvent) {
     document.dispatchEvent(customEvent); 
    } 
 }

function addEventListener(eventName, func) {
  if(typeof func !== "function") {
      _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
      return;
  }
  var s = this.__lyteRegisteredEvents[eventName];
  if(!s) {
    s = this.__lyteRegisteredEvents[eventName] = {"listeners" : new Map()};
  }
  var id = genMapId(s.listeners);
  var d = s.listeners.set(id, func);
  return eventName + "-" + id;
}

function removeEventListener(id) {
  if(!id) {
    _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("listener unique id not specified");
    return;
  }
   var arr = id.split("-"), evid = arr.pop(), name = arr.join("-");
   var s = this.__lyteRegisteredEvents[name];
   if(!s || !s.listeners.get(evid)) {
     _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("No such listener registered");
     return;
   }
   s.listeners.delete(evid);
}

function genMapId(map){
  var id = Math.floor(Math.random()*10000000000 + 1);
  while(map.get(id)){
      id = Math.floor(Math.random()*10000000000 + 1)
  }
  return id.toString();
}

// function checkNestedProp (id, path, dtype, wobj, object, property, value, check, fromStore) {
//   if (dtype && path.length != 0){
//       var extend;
//       if(Lyte.Transform[dtype.type]){
//           extend = true;
//       }
//       if (dtype.type == 'array' || (extend && Lyte.Transform[dtype.type].extends == "array")) {
//           if (dtype.items && !isNaN(path[0]) && _typeof(dtype.items) == 'object') {
//               path = path.slice(1);
//               checkNestedProp(id, path, dtype.items, wobj, object, property, value, check);
//           }
//       } else if (dtype.type == "object" || (extend && Lyte.Transform[dtype.type].extends == "object")) {
//           if (dtype.properties){
//               var k = path[0];
//               path = path.slice(1);
//               checkNestedProp(id, path, k == "" ? dtype :dtype.properties[k], wobj, object, property, value, check);
//           }
//       }
//   // } else if (dtype.properties && Lyte.isRecord(value) && !check.hasOwnProperty("warn")) {
//   //     check.warn = { warn: true, message: "Nested property will not support for the record" };
//   } 
//   else {
//       var err;
//       if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
//           var component = {};component.__data = {};
//           if (dtype.properties) {
//               component.__data[property] = dtype.properties[property];
//           } else {
//               component.__data[property] = dtype;
//           }
//           var cp = validateData(object, property, value, component);
//           var errKey = wobj.attr ? wobj.attr : wobj.key,_path = wobj.path.split(".");
//           if (cp && (typeof cp === 'undefined' ? 'undefined' : _typeof(cp)) == "object" && cp.code) {
//               cp.value = value;
//               cp.path = wobj.path !=""?wobj.path:property;
//               if(wobj.isRec && fromStore && wobj.key ==  undefined && wobj.path!=""){
//                   errKey = wobj.path.split(".")[0]
//                   _path.shift();
//                   _path = (_path.length == 1 && _path[0] == property) ? [] : _path;
//               }
//               wobj.Error = {};
//               wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
//               wobj.Error[errKey].code = "ERR34"
//               wobj.Error[errKey].message = Logger.errorCodes.ERR34;
//               err = wobj.Error[errKey].nested;
//               wobj._cmpErr[errKey].code = "ERR34";
//               wobj._cmpErr[errKey].message = Logger.errorCodes.ERR34 ;
//               var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [] ;
//               if(wobj.path !=""){
//                   _path.forEach(function (k) {
//                       if (err && !err[k]) {
//                           err = err[k] = {};
//                       } else {
//                           err = err[k];
//                       }
//                   });
//               }
//               wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
//               cmpErrPath.push(wobj.index == undefined && property? wobj.path+"."+property : wobj.index !=undefined ? wobj.path+"."+wobj.index : wobj.path)
//               wobj._cmpErr[errKey].path = cmpErrPath;
//           } else{
//               if(wobj.isRec && fromStore && wobj.key ==  undefined){
//                   errKey = wobj.path.split(".")[0]
//                   _path.shift();
//                   _path = (_path.length == 1 && _path[0] == property) ? [property] : _path;
//               }
//               err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
//               //var p = object.$.error[property];
//               if(err){
//                   var key = wobj.index || property; 
//                   var flag = true,
//                   p = wobj.path !=""?_path:[property];
//                   wobj.index ? p.push(wobj.index) : p;
//                   var prev;
//                   p.forEach(function (r) {
//                       if (err[r] && err[r].code) {
//                           delete err[r];
//                           if(err && Object.keys(err).length == 0){
//                               flag = true;
//                           }
//                           else{
//                               flag = false;
//                           }
//                       }
//                       err = err[r];
//                   });
//                   if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
//                       delete wobj.Error[errKey];
//                       delete wobj._cmpErr[errKey]
//                   }
//               }

//           }
//           if((check.value && check.value.hasOwnProperty("code") && cp.code) || !check.value){
//               check.value = cp;
//           }
//       }
//   }
//   wobj.path && delete wobj.path;
//   wobj.index && delete wobj.index;
//   wobj.attr && delete wobj.attr;
// };

function checkNestedProp(id,path,dtype,wobj,object,property,value,check){
  if(path.length!=0){
      if(dtype.type == 'array'){
          if(dtype.items && !isNaN(path[0]) && typeof(dtype.items)=='object'){
              path= path.slice(1);
              checkNestedProp(id,path,dtype.items,wobj,object,property,value,check)
          }
      }
      else if( dtype.type == "object"){
          if(dtype.properties && dtype.properties.hasOwnProperty(path[0])){
              var k = path[0];
              path = path.slice(1);
              checkNestedProp(id,path,dtype.properties[k],wobj,object,property,value,check);
          }
      }
  }
  else{
      var err;
      if(dtype.properties || dtype.items){
          var component={};component.__data={};
          if(dtype.properties){
                  component.__data[property]=dtype.properties[property];
              }
              else{
                  component.__data[property]=dtype;
              }
          var cp = validateData(object, property, value, component);
          if(cp && typeof(cp)=="object" && cp.code){
              cp.value=value;
              cp.path=wobj.path;
              (wobj.Error && wobj.Error[wobj.key])?(wobj.Error[wobj.key].code && wobj.Error[wobj.key].nested)?wobj.Error[wobj.key].nested:wobj.Error[wobj.key].nested={}:wobj.Error[wobj.key]={code:cp.code,message:cp.message,nested:{}};
              err = wobj.Error[wobj.key].nested;
              wobj.path.split('.').forEach(function(k){
                  if(err && !err[k]){
                      err=err[k]={};
                  }
                  else{
                      err=err[k];
                  }
              })
              wobj.index?err[wobj.index]=cp:err[property]=cp;
              (object.$ && object.$.error)?object.$.error=err:object.$={error:err};
              Object.defineProperty(object,'$',{
                  enumerable:false,
                  writable:false
              });
          }
          else if(!cp && object.$ && (object.$.error[property] ||(wobj.index && object.$.error[wobj.index]))){
              err = wobj.Error[wobj.key].nested||undefined;
              var key = wobj.index||property;
              delete object.$.error[key];
              var f = true,p=wobj.path.split(".");
              (wobj.index)?p.push(wobj.index):p;
              p.forEach(function(r){
                  if(err[r] && err[r].code){
                      f=false;
                  }
                  err=err[r];
              });
              if(f == true && wobj.Error[wobj.key]){
                  delete wobj.Error[wobj.key];
              }
          }
          check.value=cp;
      }
  } 
}

var types = ["string", "object", "number", "boolean", "array", "component"];
function prop(type, opts){
  var obj = {};
  obj.type = type;
  obj._type = "prop";
  if(opts == undefined){
    opts = {};
  }
  Object.assign(obj,opts);
  return obj;
}

function one(name,opts){
  return defineRelation(name,"belongsTo",opts);
}

function many(name,opts){
  return defineRelation(name,"hasMany",opts);
}

function extendEventListeners(scp){
  if(scp && !scp.hasOwnProperty("__lyteRegisteredEvents")){
      Object.defineProperties(scp, {
          __lyteRegisteredEvents : {
              value : {}
          },
          addEventListener : {
              value : addEventListener
          },
          removeEventListener : {
              value : removeEventListener
          },
          triggerEvent : {
              value : triggerEvent
          }
      });
  }
}

function getSuperClass(obj, getName){
	var cons = obj, isInstance = (typeof obj === "object");
	if(isInstance){
		cons = obj.constructor;
	}
	var bClass = Object.getPrototypeOf(cons);
	if((!(bClass instanceof Function)) || bClass === _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Service){
		if(getName){
			return obj.name;
		}
		return obj;
	} 
	return getSuperClass(bClass, getName);
}

function isInheritedClass(baseObj, inheritedClass){
  var cons = baseObj, isInstance = (typeof obj === "object");
  if(isInstance){
    cons = baseObj.constructor;
  }
  var bClass = Object.getPrototypeOf(cons);
  if((bClass.hasOwnProperty("__lyteOrigClass") && bClass.__lyteOrigClass == inheritedClass) || (bClass == inheritedClass)){
    return true;
  }
  else if((!(bClass instanceof Function)) || bClass === _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Service){
    return false;
  }  
  return isInheritedClass(bClass, inheritedClass); 
}

function newGetSuperClass(obj, getName, toBeCompared, getClass) {
  var cons = obj, isInstance = (typeof obj === "object");
  if(isInstance){
    cons = obj.constructor;
  }
  var bClass = Object.getPrototypeOf(cons);
  if(bClass.__lyteOrigClass == toBeCompared){
    return true;
  }
  else if((!(bClass instanceof Function)) || bClass === _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Service){
    // return false;
    if(getName){
      return obj.name;
    } else if(getClass){
      return obj;
    }
    return obj;
  }  
  return newGetSuperClass(bClass, getName, toBeCompared);    
}

function includeMixins(arr,mainClass){
  if(arr.length == 0) {
    return mainClass;
  } 
  var currentClass = mainClass;
  for(var i=0;i<arr.length;i++) {
    var classVar = arr[i];
    var classFunction = classVar._classFunc;
    currentClass = classFunction(currentClass, classFunction.overrides,classFunction._proxy);
  }
  return currentClass;
}
function getClass(arr, mainClass,clsObj) {
  if(arr.length == 0) {
      return mainClass;
  }
  var currentClass = mainClass;
  for(var i=0;i<arr.length;i++) {
    var classVar = arr[i];
    var classFunction = classVar._classFunc;
    currentClass = classFunction(currentClass, classFunction.overrides,classFunction._proxy);
  }

  return currentClass;
}


Function.prototype.tempApply=Function.prototype.apply;
Function.prototype.tempCall=Function.prototype.call;
Function.prototype.tempBind=Function.prototype.bind;
var classObj = {};
function createCustomClass(classDefFunc, fromInside) {

  class LyteModule {
      constructor() {
          if(window.ssss1) {
              this.constructor = window.ssss1;
              window.ssss1 = undefined;
          }
      }
    static actions(arg1) {
      return arg1 ? arg1 : {};
    }
    static methods(arg1) {
      return arg1 ? arg1 : {};
    }
    static observers(arg1) {
      return arg1 ? arg1 : {};
    }
    data(arg1) {
      return arg1 ? arg1 : {};
    }
   
  }
    var dummyObj={};

    var proxy = new Proxy(class {
        static [Symbol.hasInstance](instance) {  // checks if the object's prototype chain contains the [Symbol.hasInstance] method
          console.log("inside  custom instanceof check")
          return instance instanceof dummyObj.arg1._initialCopyClass;
        }
      },{
      "construct" : function(a,b,c) {
        if(c==proxy) {
          window.ssss1 = dummyObj.retClass;
          let constr=Reflect.construct(dummyObj.retClass._initialCopyClass, b);
          if(constr._afterConstructor){
            constr._afterConstructor();
          }
          return constr;
        } else {
          return Reflect.construct(dummyObj.arg1, b,c);
        }
          
      }, 
      "get" : function(target, prop,value) {
        if(prop == "prototype") {
          return Reflect.get(...arguments);
        } else if(prop == "hasOwnProperty" ) {
          return function(prop1) {
              return dummyObj.arg1.hasOwnProperty(prop1);
          }  
        }
        else if(dummyObj.arg1.hasOwnProperty(prop)) {
          return dummyObj.arg1[prop];
        }
        else if(prop.toString()==='Symbol(Symbol.hasInstance)'){
          return Reflect.get(target, prop,value);
        } 
        else {
          return Reflect.get(dummyObj.arg1, prop,value);
        }
      }, 
      "set" : function(target, prop, value, receiver) {
        dummyObj.arg1._updateStaticVal(prop, value, receiver);
          return true;
      }, 
      "getPrototypeOf": function(target){
        return Reflect.getPrototypeOf(dummyObj.arg1); 
      },
      "defineProperty": function(target, key, descriptor) {
        dummyObj.arg1._defineProperty(target,key,descriptor);
          return true;
        },
        
      "getOwnPropertyDescriptor":function(target,prop){
          if( Object.hasOwn(dummyObj.arg1,prop)){
            return {
              value:dummyObj.arg1[prop],
              enumerable : true,
              configurable : true,
              writable : true
          };
          }
          else {
            return Reflect.getOwnPropertyDescriptor(...arguments)  ;
          }
        } ,
        "deleteProperty":function(target,prop,value){
          return dummyObj.arg1._deleteProperty(target,prop);
        }
      });
  var retClass = classDefFunc(LyteModule, function(arg1,cacheObj) {
      if(arg1.name[0]=='_'){
          Object.defineProperty(arg1,"name",{value:arg1.name.slice(1)});
      }
      dummyObj.arg1 = arg1;
      arg1._lyteClasses = [];
    arg1._lyteClasses = [];  //keep track of classes that have been extended from retClass.
  
    arg1._updatePrototypeVal = function(prop, value) {
       arg1.prototype[prop]=value;
       this._lyteClasses.forEach(function(item){
        item.prototype[prop]=value;
       });  
  }
  arg1._deleteProperty=function(target,prop){
    if(arg1[prop]){
      delete arg1[prop];
      this._lyteClasses.forEach(function(item){
        delete item[prop];
      })
    }
    delete arg1.prototype[prop];
    this._lyteClasses.forEach(function(item){
      delete item.prototype[prop];
    });
  }

  arg1._defineProperty = function(target, prop, descriptor) {
  Object.defineProperty(arg1,prop,descriptor);
    this._lyteClasses.forEach(function(item) {
      if(descriptor==undefined){
        item.prototype[prop]=undefined;
      }else{
        Object.defineProperty(item, prop, descriptor);
      }
    });

  }

  arg1._updateStaticVal = function(prop, value, receiver) {
    //updates the static values of arg1 and all the classes in _lyteClasses with the provided prop and value.
    // arg1[prop]=value;
    this[prop] = value;
    if(cacheObj && cacheObj.hasOwnProperty(prop)){
      cacheObj[prop]=value;
    }
    this._lyteClasses.forEach(function(item) {
      item[prop] = value;
    });
  }
  arg1._hasOwnProperty=function(target,prop,receiver){
    return arg1.prototype.hasOwnProperty(prop)
  }

     let tempProxy=new Proxy({} /*proxy.prototype*/, {

      "get" : function(target, prop) {
        //  if(Object.hasOwn(arg1._initialCopyClass.prototype,prop))
        //    return arg1.prototype[prop];
        if(prop === "deleteProp") {
            return function(prop1) {
                 return arg1._deleteProperty(target, prop1, undefined);
                 };
          }
          else if(prop=="hasOwnProperty"){
            return function(prop1){
                return arg1._hasOwnProperty(target,prop1);
            }
        }
        else {
          if(arg1.prototype[prop] && typeof arg1.prototype[prop]=="function" ) {
              arg1.prototype[prop].apply = function() {
                  let tempArgument=arguments[0];
                  while(tempArgument){
                      if(arg1._proxy==tempArgument.constructor){
                          return arg1._initialCopyClass.prototype[prop].tempApply(tempArgument, arguments[1]);
                      }
                      tempArgument=Object.getPrototypeOf(tempArgument);
                  }
                return  arg1.prototype[prop].tempApply(arguments[0],arguments[1]);
              }
              arg1.prototype[prop].call = function() {
                  let tempArgument=arguments[0];
                  while(tempArgument){
                      if(arg1._proxy==tempArgument.constructor){
                          return arg1._initialCopyClass.prototype[prop].tempCall(tempArgument, arguments[1]);
                      }
                      tempArgument=Object.getPrototypeOf(tempArgument);
                  }
                return  arg1.prototype[prop].tempCall(arguments[0],arguments[1]);
              }
              arg1.prototype[prop].bind = function() {
                  let tempArgument=arguments[0];
                  while(tempArgument){
                      if(arg1._proxy==tempArgument.constructor){
                          return arg1._initialCopyClass.prototype[prop].tempBind(tempArgument, arguments[1]);  
                      }
                      tempArgument=Object.getPrototypeOf(tempArgument);
                  }
                return  arg1.prototype[prop].tempBind(arguments[0],arguments[1]);
              }
          }
            return arg1.prototype[prop];
      }
          
      }, 
      "set" : function(target, prop, value) {    
          arg1._updatePrototypeVal(prop, value);
          return true;
      }, 
      "defineProperty" : function(target, prop, value) {
        arg1._defineProperty(target, prop, value);
      },
      "getPrototypeOf": function(target){
        return Reflect.getPrototypeOf(arg1); 
      }, 
  })  ;
   Object.setPrototypeOf(proxy.prototype,tempProxy);                                        
  return proxy;
  },proxy);
  retClass._proxy = proxy;
  dummyObj.retClass = retClass;
  classDefFunc._proxy = proxy;
  
  // var initialCopyClass = classDefFunc(LyteModule, overrides,proxy);
  var initialCopyClass=overrides(dummyObj.arg1);
  function overrides(cls) {
      if(cls.name[0]=='_'){
          Object.defineProperty(cls,"name",{value:cls.name.slice(1)});
      }
      retClass._lyteClasses.push(cls);
      cls.prototype.__origConstructor = cls;
      cls.__lyteOrigClass = retClass;
      if(retClass._lyteClasses.length>1){
          let baseCls=retClass._lyteClasses[0];
          let arr=Object.getOwnPropertyNames(retClass._lyteClasses[0]);
          for(let i=0;i<arr.length;i++){
              if(!cls.hasOwnProperty(arr[i])){
                  cls[arr[i]]=baseCls[arr[i]];
              }
          }
      let arr1=Object.getOwnPropertyNames(retClass._lyteClasses[0].prototype);
          for(let i=0;i<arr1.length;i++){
              if(!cls.prototype.hasOwnProperty(arr1[i])){
                  cls.prototype[arr1[i]]=baseCls.prototype[arr1[i]];
              }
          }
      }
    return cls;
  }


  classDefFunc.overrides = overrides;
  retClass._classFunc = classDefFunc;
  initialCopyClass._classFunc=classDefFunc;   //new changes
  // retClass._initialCopyClass = initialCopyClass; //new changees
  dummyObj.arg1._initialCopyClass = initialCopyClass;
  classDefFunc._mainClass = retClass;
  if(initialCopyClass.name[0]=='_'){
      Object.defineProperty(initialCopyClass,"name",{value:initialCopyClass.name.slice(1)});

  }   
  return retClass;
}

function getCustomData(scp, fieldVal, fromDb){
  if(fromDb){
    if(scp && scp.dataType && scp.dataType.hasOwnProperty(fieldVal)){
      return scp.dataType[fieldVal];
    }
    scp = scp.lyte;
  }
  if(scp && scp.dataType && scp.dataType.hasOwnProperty(fieldVal)){
    return scp.dataType[fieldVal];
  }
}
function checkProperty(property, dataVal, key, fieldVal, record, name, scp, errorCodes ,init, field, fromDb){
  // var errorCodes = scp.errorCodes;
  var exts = "extends";
  switch(property){
    case "type" : 
      if(typeof fieldVal !== "string"){
        var _fld = getCustomData(scp, fieldVal._name, fromDb);
        if (_fld && dataVal !== undefined && dataVal !== null) {
          var _ret = true;
          if (Array.isArray(dataVal)) {
              if (_fld.type != "array") {
                  return { code: "ERR03", message: errorCodes.ERR03, expected: fieldVal };
              }
              if(_fld.hasOwnProperty("items")){
                  _ret = checkProperty("items", dataVal, key, _fld.items);
              }
          }else if(typeof dataVal === "object" && _fld.type == "object" && _fld.hasOwnProperty("properties")){
              _ret = checkProperty("properties", dataVal, key, _fld.properties);
          } 
          else if (fieldVal && _fld.type != typeof(dataVal)) {
            return { code: "ERR03", message: errorCodes.ERR03, expected: fieldVal };
          }
          if(_ret !== true){
              return _ret;
          }
        }
      }
      else if(dataVal !== undefined && dataVal !== null){
        if(Array.isArray(dataVal)){
          if(fieldVal != "array"){
              return {code : "ERR03", message : errorCodes.ERR03, expected : fieldVal};
          }
        }
        else if(dataVal && dataVal._compName){
          if(fieldVal != "component"){
            return {code : "ERR03", message : errorCodes.ERR03, expected : fieldVal};
          }
        }
        else if(fieldVal != (typeof dataVal)){
          return {code : "ERR03", message : errorCodes.ERR03, expected : fieldVal};
        }
      }
      break;
    case "mandatory":
        let validateFlag = fieldVal;
        if(typeof fieldVal == "object"){
          if(init && fieldVal.skipValidationOnInit == true){
            validateFlag = false;
          }
        }
        if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
          return { code: "ERR02", message: errorCodes.ERR02 };
        }
      break;
    case "maximum" :
      if((typeof dataVal == "number") && dataVal > fieldVal){
        return {code : "ERR04", message : errorCodes.ERR04, expected : fieldVal};
      }
      break;
    case "minimum" :
      if((typeof dataVal == "number") && dataVal < fieldVal){
        return {code : "ERR05", message : errorCodes.ERR05, expected : fieldVal};
      }
      break;
    case "maxLength" :
    case "maxItems" :
      if(dataVal && dataVal.length > fieldVal){
        return {code : "ERR06", message : errorCodes.ERR06, expected : fieldVal};
      }
      break;
    case "minLength" :
    case "minItems" :
      if(dataVal && dataVal.length < fieldVal){
        return {code : "ERR07", message : errorCodes.ERR07, expected : fieldVal};
      }
      break;
      case "pattern" :
        if(typeof fieldVal == "string"){
            var _scp = scp;
            if(fromDb){
              _scp = scp.lyte;
            }
            if(_scp){ 
              if(_scp.patterns && _scp.patterns.hasOwnProperty(fieldVal)){
                fieldVal = _scp.patterns[fieldVal];
              }
              else{
                _lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger.warn("Pattern with name - "+ fieldVal+" is not registered");
                break;
              }
            }
          }
          if( typeof dataVal == "string" && !(new RegExp(fieldVal).test(dataVal))){
            return {code : "ERR08", message : errorCodes.ERR08, expected : fieldVal};
          }
          break;
      case "uniqueItems" :{
      if(Array.isArray(dataVal) && fieldVal){
        var newArr = [];
        for(var i=0; i<dataVal.length; i++){
          var val = dataVal[i];
          if(newArr.indexOf(val) != -1){
            return {code : "ERR09", message : errorCodes.ERR09};
          }
          newArr.push(val);
        }         
      }
      break;        
    }
    case "constant" :
      if(Array.isArray(dataVal)){
        var resp = dataVal.length==fieldVal.length && dataVal.every(function(v,i) { return v === fieldVal[i]});
        if(!resp){
          return {code : "ERR10", message : errorCodes.ERR10, expected : fieldVal};
        }
      }
      else if(typeof dataVal == "object"){
        var resp = db.connector.$.compareObjects(dataVal, fieldVal);
        if(!resp){
          return {code : "ERR10", message : errorCodes.ERR10, expected : fieldVal};
        }
      }
      else if(dataVal && dataVal != fieldVal){
        return {code : "ERR10", message : errorCodes.ERR10, expected : fieldVal};
      }
      break;
    case "items" :{
      if(Array.isArray(dataVal)){
        for(var i=0; i<dataVal.length; i++){
          for(var property in fieldVal){
            var resp = checkProperty(property, dataVal[i], i, fieldVal[property], undefined, undefined, scp, errorCodes, undefined, fieldVal);
            if(resp != true){
              resp.path = resp.path ? i + "." + resp.path : resp.path;
              return resp;
            }
          }
        }         
      }
      break;        
    }
    case "properties" :
      if(typeof dataVal == "object" && !Array.isArray(dataVal)){
        for (var key in dataVal) {
          if(fieldVal.hasOwnProperty(key)){
              var fld = fieldVal[key]
              for (var property in fld) {
                  var resp = checkProperty(property, dataVal[key], key, fld[property], undefined, undefined, scp, errorCodes, undefined, fld);
                  if (resp != true) {
                      resp.path = resp.path ? property + "." + resp.path : property.toString();
                      return resp;
                  }
              }
          }
          else if(field.exact){
              return { code : "ERR29", message: _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.errorCodes.ERR29, property: key };
          }
        }
      }
      break;
    case "validation" :{
      var validator = fieldVal;
      if(validator){
        var resp =  validator.validate.apply(record, [key, dataVal, name]);
        if(resp != true){
          return resp;
        }
      }       
    }
    break;
    case "instanceof": 
    {
        if(typeof dataVal === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)){
            return { code: "ERR30", message: _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal};
        }
    }
  }
  return true;
}

function validateData(object, key, value, component,scp ,init) {
  var definition = component.__data[key];
  var isError = false;
  var type = definition ? definition.type : undefined;
  for(var defKey in definition) {
    let app = component.getApp ? component.getApp() : undefined;
    isError =  checkProperty(defKey, value, key, definition[defKey], object, undefined, app, _lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger.errorCodes, init, definition);
    if(isError !== true) {
      return isError;
    }
  }
  return false;
}

function deepCopyObject(obj){
  return copyObject(obj, true);
}

function copyObject( obj, internal )  {
  var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  var current, copies = [{source : obj, target : targetVal}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
  var cloneObject = copies[0].target, targetReferences = [cloneObject];
  while(current = copies.shift()){
      keys = Object.keys(current.source);
      for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
          descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
          if(!descriptor){
              continue;
          }
          if(!descriptor.value || typeof descriptor.value != "object"){
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              continue;
          }
          nextSource = descriptor.value;
          if(!(descriptor.value instanceof Promise)){
            descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
          }
          indexOf = sourceReferences.indexOf(nextSource);
          if(indexOf != -1){
              descriptor.value = targetReferences[indexOf];
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              continue;
          }
          sourceReferences.push(nextSource);
          targetReferences.push(descriptor.value);
          Object.defineProperty(current.target, keys[propertyIndex], descriptor);
          copies.push({source : nextSource, target : descriptor.value});
      }
      if(internal){
        if(isEntity(current.source)){
          Object.defineProperty(current.target, "$", {
            value: {}
          });
          current.target.$.isNew = current.source.$.isNew;
          current.target.$.isModified = current.source.$.isModified;
          current.target.$.isDeleted = current.source.$.isDeleted;
          current.target.$.pK = current.source.$.pK;
          current.target.$._attributes = current.source.$._attributes;
          current.target.$.isCloned = true;
          if(current.source.$.hasOwnProperty("deepNest")){
            current.target.$.deepNest = current.source.$.deepNest;
          }
          if(current.source.$.hasOwnProperty("partialType")){
            current.target.$.partialType = current.source.$.partialType;
          }
        }
        if(Array.isArray(current.source)){
          if(current.source.partial){
            Object.defineProperty(current.target, "partial", {
              value: current.source.partial
            });
          }
        }
      }
  }
  return cloneObject;
}

function defineRelation(name,type,opts){
  var relation = {type : "relation", relType : type, relatedTo : name};
  if(opts){
    relation.opts = opts;
  }
  return relation;
}

function establishObserverBindings(observers,fromStore,properties,model,lyteScp) {
  var scope = this;
  var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
  if(fromStore){
    scope = fromStore;      
  }
  for(var i=0;i<observers.length;i++) {
    var props = observers[i].properties;
    var obsAttr = {},obsDuplicate=false;
    var Jpath={}
    for(var j=0;j<props.length;j++) {
      var actProp;
      var isArrayObserver = false;
      var isObjectObserver = false;
      if(typeof props[j] == "string"){
        if(props[j].search(/^\$\./g)!=-1){
         
          var JsonPath = props[j];

          var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0]
          if(CmpPropertyPath.search(/\[[0-9*]\]/g)!=-1){
            CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
          }
          if(watchProps[CmpPropertyPath]==undefined){
            watchProps[CmpPropertyPath]=[];
          }

          if(Jpath[CmpPropertyPath] == undefined){
            Jpath[CmpPropertyPath]=[];
          }
          
          var JSONPATH ;
          var reg = "^\\$\\."+CmpPropertyPath+"\\.?"
          reg = new RegExp(reg);
          JSONPATH = props[j].replace(reg,"$.")
          if(!watchProps[CmpPropertyPath].includes(JSONPATH)){
            watchProps[CmpPropertyPath].push(JSONPATH)
          }
          
          if(!Jpath[CmpPropertyPath].includes(JSONPATH)){
            Jpath[CmpPropertyPath].push(JSONPATH)
          }


          CmpPropertyPath =CmpPropertyPath+".*";
          if(!obsAttr.hasOwnProperty(CmpPropertyPath)){
            actProp= getProperty.call(this,CmpPropertyPath,fromStore,properties)
            obsAttr[CmpPropertyPath]=true;
            obsDuplicate = false;
          }
          else{
            obsDuplicate = true;
          }
        }
        else if(props[j].indexOf('.[]') !== -1) {
          isArrayObserver = true;
          actProp = getProperty.call(this,props[j].substring(0, props[j].indexOf('.[]')),fromStore,properties);
        }
        else if(props[j].indexOf('.{}') !== -1) {
          isObjectObserver = true;
          let objObbName = props[j].substring(0, props[j].indexOf('.{}'))
          actProp = this.getProperty(objObbName);
          Object.defineProperty(actProp, '_objectObservers', {
            value: true,
            enumerable: false,
            writable: true,
            configurable: true
          });
			  }
        else {
          if(props[j].indexOf('.*') !== -1) {
            var prop = props[j].split(".")[0];
            var isDeepObs = (!fromStore && this.component.__data[prop] && this.component.__data[prop].watch) || (fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch) ? true : false;
            if(!isDeepObs){
              continue;
            }
          } 
          actProp = getProperty.call(this,props[j],fromStore,properties);
        }
      if(!obsDuplicate){
        if(!actProp._observers) {
          Object.defineProperty(actProp, '_observers', {
            value : new Set(),
            enumerable: false, 
            writable: true,
            configurable: true
          });
        }
       actProp._observers.add({callee : scope, observer: observers[i], isArrayObserver : isArrayObserver,isObjectObserver:isObjectObserver });
      }
    }else{
      _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.warn.call(lyteScp,"ERR27",JSON.stringify(props[j]),observers[i].fnName,this.tagName);
    }
  }
  observers[i].Jpath  = Jpath;
  obsAttr={};
}
}
// getProperty(key) {
//   var arr = key.match(/([^[\].]+|\[\])/g);
// let property = this;
// if(!property._properties[arr[0]]) {
//       property._properties[arr[0]] = {};
//   } 
//   property = property._properties[arr[0]];

// defProp(property, '_path', {enumerable: false, value : arr[0]});
// for(let i=1;i<arr.length;i++) {
//       if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
//           arr[i] = arr[i].substring(1, arr[i].length -1);
//       }
//       if(!property[arr[i]]) {
//           property[arr[i]] = {};
//           defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
//       }
//     property = property[arr[i]];
//   }
//  return property;
// }
function getProperty(key,fromStore,properties) {
  var arr = key.match(/([^[\].]+|\[\])/g);
  let property = this;
  if(fromStore){
    property = properties;
    if(!properties[arr[0]]){
        properties[arr[0]] = {};
    }
    property = properties[arr[0]];
  }
  else {                      
    if(!property._properties[arr[0]]) {
        property._properties[arr[0]] = {};
    } 
    property = property._properties[arr[0]];
  }

  Object.defineProperty(property, '_path', {enumerable: false, value : arr[0]});
  for(let i=1;i<arr.length;i++) {
    if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
      arr[i] = arr[i].substring(1, arr[i].length -1);
    }
    if(!property[arr[i]]) {
        property[arr[i]] = {};
        Object.defineProperty(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
    }
    property = property[arr[i]];
  }
  return property;
}

let nestScpId = 1;
const nestScp = {};
const __nestRef__ = {};
const __nestScp__ = new Map();
function establishObjectBinding(data, attr, fromStore, update, storeRecord, watch) {
  var model, fld, nestObj;
  var checkAttrs=data.__component__ && data.__component__.component.__data?data.__component__.component.__data[attr]:undefined, db;
  if (fromStore || storeRecord) {
      model = (data.$)? (data.$.schema ? data.$.schema : data.$.model) :(storeRecord && storeRecord.$.model)?storeRecord.$.model:undefined;
      db = model.db;
      fld = model ? model.fieldList[attr] : undefined;
      if (!fld) {
          return;
      }
      checkAttrs=fld;
      watch = fld.watch;
  }
  if (update && data._scp && data._scp.size) {
      var keys = Array.from(data._scp.keys());
      keys.forEach(function (id) {
        var _mpObj = data._scp.get(id), 
        mpObj = _mpObj.paths;
          for (var key in mpObj) {
              var path = key ? key.split(".") : [];
              path.push(attr);
              bindObj(data, attr, id, path, new Map(),checkAttrs,watch);
          }
      });
  }
  if ((!fromStore || fld.watch || fld.properties || fld.items || watch) && data[attr]) {
      var _scpObj, kmpKey;
      if (data && data.__component__) {
          data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
              value: {}
          });
          kmpKey = data.__component__;
          _scpObj = data.__component__.__scpObj;
      } else if (isEntity(data)) {
          data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
              value: {}
          });
          kmpKey = data;
          _scpObj = data.$.__scpObj;
      }
      var obj = _scpObj,
      id;
      if (_scpObj) {
          var __nestScp1Set__ = false, __nestScp2Set__ = false;
          if (fromStore) {
              if(data[attr] && !__nestScp__.has(data[attr])){
                  nestObj = { db: db, model: model._name, attr: attr, pK: data.$.pK };
                  __nestScp1Set__ = true;
              }
              else{
                // var kmp = __nestScp__[kid] = __nestScp__[kid] || new Map();
                // data ? kmp.set(data, true) : undefined;
                var __nId = __nestScp__.get(data[attr])
                var refMp = __nestRef__[__nId] = __nestRef__[__nId] || new Map();
                var refMpId = genMapId(refMp);
                refMp.set(refMpId, true);
                setRecBindMap(nestScp[__nId], {db:db, model:model._name, attr: attr, pK: data.$.pK});
                obj[attr] = __nId+"_"+refMpId;
              }
          } else {
            if(data[attr] && !__nestScp__.has(data[attr])){
              // nestObj = { data: data[attr] };
              nestObj = {
                data : data[attr],
                dtype : data.__component__.component.__data[attr],
                Error:data.__component__.component.data.errors,
                key:attr
              };
                __nestScp2Set__ = true;
            }
            else{
                var __nId = __nestScp__.get(data[attr])
                var refMp = __nestRef__[__nId] = __nestRef__[__nId] || new Map();
                var refMpId = genMapId(refMp);
                refMp.set(refMpId, true);
                obj[attr] = __nId+"_"+refMpId;
            }
        }
        if(nestObj){
          nestScpId++;
          var refMp = __nestRef__[nestScpId] = __nestRef__[nestScpId] || new Map();
          var refMpId = genMapId(refMp);
          refMp.set(refMpId, true);
          __nestScp__.set(data[attr], nestScpId);
          if(__nestScp1Set__){
              nestScp[nestScpId] = {};
              if(db){
                nestScp[nestScpId].db = db;
              }
              setRecBindMap(nestScp[nestScpId], nestObj);
              //     setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
          }
          if(__nestScp2Set__){   
            nestScp[nestScpId] = nestObj;                 
          }
          nestScp[nestScpId]._data = data[attr];
          obj[attr] = obj[attr] || nestScpId+"_"+refMpId;
          var path = [];
          // fromStore ? path.push(attr) : undefined;
          bindObj(data, attr, nestScpId, path, new Map(), checkAttrs, watch);
        }
    }
}
};

function establishWatchScope(watchProps,model){
  var scope = this,object;
  for (var v in watchProps){
    var property = v;
    var watch = watchProps[v]
    if(scope.component && scope.component.__data && scope.component.__data[property]){
      object = scope.getData(property);
      watch = scope.component.__data[property].watch ? true : watch;
      if(typeof object == "object"){
        establishObjectBinding(scope.component.data,v,false,undefined,undefined,watch)
      }
      if( nestScp[__nestScp__.get(object)]){
        nestScp[__nestScp__.get(object)].dtype.watch = watch;
      }
    }
    else{
      if(model){
        var fieldList = model.fieldList;
        if(fieldList[v] && fieldList[v].watch == undefined){
          fieldList[v].watch = watch ;
          model._fldGrps.watch[v] = fieldList[v];
        }
      }
    }
  }
}

function removeNestScp2Bind(mp, mdlObj){
  var mp = mp.model;
  if (mp.has(mdlObj.model)) {
    var mp1 = mp.get(mdlObj.model);
    if (mp1.has(mdlObj.pK)) {
        var mp2 = mp1.get(mdlObj.pK);
        if (mp2.has(mdlObj.attr)) {
            mp2.delete(mdlObj.attr);
        }
        !mp2.size ? mp1.delete(mdlObj.pK) : undefined; 
    }
    !mp1.size ? mp.delete(mdlObj.model) : undefined;
  }
}

function setRecBindMap(obj, nestObj){
  var mp = obj.model = obj.model || new Map(), modelName = nestObj.model, pK = nestObj.pK, attr = nestObj.attr;
  if(modelName && !mp.has(modelName)){
    mp.set(modelName, new Map());
  }
  mp = mp.get(modelName);
  if(pK && !mp.has(pK)){
    mp.set(pK, new Map());
  }
  mp = mp.get(pK);
  if(attr && !mp.has(attr)){
    mp.set(attr, true);
  }
}


function bindObj(data, key, id, path, mp, checkAttrs, watch) {
  mp = mp || new Map();
  var value = key != undefined ? data[key] : data;
  var cyclic = false;
  if(!path.length && __nestScp__.get(data) === id){
    delete nestScp[id].cyclic;
  }
  if (path.length > 1 && value && nestScp[id] && nestScp[id].hasOwnProperty("data") && nestScp[id].data === value) {
    if(mp.get(value)){
      cyclic = true;
    }
    if (checkAndAddBind(value, id, path, cyclic)) {
      estObjScp(value, id, path, cyclic);
    }
    return;
  }
  var attrs;
  if(checkAttrs && (checkAttrs.hasOwnProperty("items")||checkAttrs.hasOwnProperty("properties"))){
      attrs=checkAttrs.items || checkAttrs.properties;
  }
  attrs=watch?undefined:attrs;
  if (Array.isArray(value)) {
    if (!mp.get(value)) {
      mp.set(value, true);
      value.forEach(function (val, idx) {
        path.push(idx);
        if(watch || (checkAttrs && checkAttrs.hasOwnProperty("items") && typeof(checkAttrs.items) == "object" )){
          bindObj(value, idx, id, path, mp,attrs,watch);
        }  
        // bindObj(value, idx, id, path, mp);
        path.pop();
      });
    } else {
      cyclic = true;
    }
    if (checkAndAddBind(value, id, path, cyclic)) {
      var _establish;
      if(Array.isArray(watch)){
        _establish = checkEstablishingSCP(value,path,watch)
      }
      if(_establish || (typeof watch =="boolean" && watch )){
          estObjScp(value, id, path, cyclic);
      }
    }
  } else if (value && typeof(value) == "object") {
    var cyclic = false;
    if (!mp.get(value)) {
      mp.set(value, true);
      for (var str in value) {
        path.push(str);
        if(watch || (attrs && attrs.hasOwnProperty(str))){
          bindObj(value, str, id, path, mp,attrs?attrs[str]:undefined,watch);
        }  
        // bindObj(value, str, id, path, mp);
        path.pop();
      }
    } else {
      cyclic = true;
    }
    if (checkAndAddBind(value, id, path, cyclic)) {
      var _establish;
      if(Array.isArray(watch)){
        _establish = checkEstablishingSCP(value,path,watch)
      }
      if(_establish || (typeof watch =="boolean" && watch ) ){
          estObjScp(value, id, path, cyclic);
      }
    }
  }
};

function checkAndAddBind(value, id, path, cyclic){
    if(!value._scp || !value._scp.size){
        return true;
    }
    if(value._scp.size){
      if(value._scp.has(id)){
          var _obj = value._scp.get(id);
          var obj = _obj.paths;
          if(obj.hasOwnProperty(path.join("."))){
            if(cyclic){
              nestScp[id].cyclic = true;
            }                      
            return false;
          }
      }
    }
    return true;
}   

function estObjScp(value, id, path, cyclic){
  if(!value._scp){
    Object.defineProperty(value, "_scp", {
      value : new Map(),
      enumerable : false,
      configurable : true
    });
  }
  var mp = value._scp;
  if(!mp.has(id)){
    mp.set(id, {});
  }
  var obj = mp.get(id),
  path = path ? path.join(".") : path;
  var pathObj = obj.paths = obj.paths || {};
  pathObj[path] = true;
  var nestObj = nestScp[id];
  nestObj.cyclic = true;
}

function cmpObjs(obj1, obj2){
    if(Object.keys(obj1).length !== Object.keys(obj2).length){
        return false;
    }
    for(var key in obj1){
        if(!obj2.hasOwnProperty(key)){
            return false;
        }
        var ret = cmpData(obj1[key], obj2[key]);
        if(ret == false){
            return false;
        }
    }
    return true;
}	


function cmpData(data1, data2){
  if(Array.isArray(data1)){
    if((!Array.isArray(data2)) || data1.length !== data2.length){
      return false;
    }
    var len = data1.length, ret;
    for(var i=0;i <len; i++){
      ret = cmpData(data1[i], data2[i]);
      if(ret == false){
        return false;
      }
    }
  }
  else if(data1 && data2 && typeof data1 == "object" && typeof data2 == "object"){
    return cmpObjs(data1,data2);
  }
  else if(isEntity(data1) && isEntity(data2)){
    if(data1.$.schema){
      if( (data1.$.schema._name !== data1.$.schema._name) || (str$.getpKVal(data1) !== str$.getpKVal(data2)) ){
        return false;
      }
    }
    else{
      if( (data1.$.model._name !== data1.$.model._name) || (str$.getpKVal(data1) !== str$.getpKVal(data2)) ){
        return false;
      }
    }
  }
  else if(data1 !== data2){
    return false;
  }
  return true;
}

function nestScpRmPath(obj, path){
  if(obj && obj.paths){
      obj = obj.paths;
      for(var key in obj){
          if(key.startsWith(path+".")){
              delete obj[key];
          }
      }
  }
}

function nestScpRemove(data, id, path){
  var mp = data._scp;
  if(mp && mp.size){
      if(path){
        nestScpRmPath(mp.get(id), path);
        var _obj = mp.get(id); 
        var obj = _obj ? _obj.paths : undefined;
        if(obj && !Object.keys(obj).length){
            mp.delete(id);
        }  
      }
      else{
          mp.delete(id);
      }
      if(!mp.size){
        delete data._scp;
      }
  }
}

function rmNestScp(value, id, mp, data, path){
  if (Array.isArray(value)) {
      if (!mp.get(value)) {
          mp.set(value, true);
          value.forEach(function (val, idx) {
              rmNestScp(val, id, mp, undefined, path);
          });
      }
      nestScpRemove(value, id, path);
  } else if (value && typeof(value) == "object") {
      if (!mp.get(value)) {
          mp.set(value, true);
          for (var str in value) {
              rmNestScp(value[str], id, mp, undefined, path);
          }
      }
      nestScpRemove(value, id, path);
  }
}

function removeNestScp(value, id, mpId, path, context, mp, data, recObj) {
  mp = mp || new Map();
  id = Number.parseInt(id);
  var obj = nestScp[id], kmp = __nestRef__[id];
  if(recObj && obj.model){
    removeNestScp2Bind(obj, recObj);
  }
  if(context){
      if(kmp && kmp.has(mpId)){
          kmp.delete(mpId);
      }
      if(!kmp || (kmp && !kmp.size)){
          delete __nestRef__[id];
          if(__nestScp__.has(value)){
              __nestScp__.delete(value);
          }
          rmNestScp(value, id, mp, true, path);
          if(!data){
              delete nestScp[id];
          }
      }
  }
  else{
    rmNestScp(value, id, mp, true, path);
  }
};

//@3055
// function addStateToMap(event, target, XHR, stateName){
//   var mp = window.__nodeXHRMap = window.__nodeXHRMap || new Map();
//   var nodeMap = mp.get(target);
//   if(!nodeMap){
//       mp.set(target, new Map());
//   }
//   nodeMap = mp.get(target);
//   var sr = target.lyteState = target.lyteState || [], type = stateName || XHR;
//   if(sr.indexOf(type) == -1){
//       sr.push(type);
//   }
//   target.setAttribute("lyte-state", "");
//   var evMap = nodeMap.get(event);
//   if(!evMap){
//       nodeMap.set(event, []);
//       evMap = nodeMap.get(event);
//   }
//   if(stateName){
//       evMap.push({state:stateName});
//       return {target: target, event: event};        
//   }
//   else{
//       evMap.push({isXHR:true, xhr:XHR});
//       var callback = function(arg){
//         if(XHR.readyState == 4){
//             removeStateFromMap(XHR, event, target);
//             XHR.removeEventListener("readystatechange", callback);
//         }
//     }
//     XHR.addEventListener("readystatechange", callback);
//   }
// }

// function removeStateFromMap(type, event, target){
//   var mp = window.__nodeXHRMap; 
//   var nodeMap = mp.get(target);
//   if(!nodeMap){
//       return;
//   }
//   var evMap = nodeMap.get(event);
//   if(!evMap){
//       return;
//   }
//   if(evMap){
//       var arr = evMap;
//       var ind = -1;
//       arr.every(function(itm, idx){
//           if((itm && itm.isXHR && itm.xhr == type)|| (typeof type == "string" && itm.state == type)){
//               ind = idx;
//               return false;
//           }
//           return true;
//       });
//       if(ind != -1){
//           arr.splice(ind,1);
//           var sind = target.lyteState.indexOf(type);
//           target.lyteState.splice(sind, 1);
//           if(!arr.length){
//               nodeMap.delete(event);
//               var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1; 
//               tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
//               if(target && target.lyteState && target.lyteState.length == 0){
//                   target.lyteState = null;
//                   target.removeAttribute("lyte-state");
//               } 
//           }
//           if(!nodeMap.size){
//               mp.delete(target);
//           }
//       }
//   }
// }

function toBeUsedServices(obj){
  var serviceToBeUsed = Object.assign({},obj.Lyte.toBeInjectedServices);
  var arr = obj.services;
  if(arr){
    arr.forEach(function(service){
        if(typeof service == "string"){
            serviceToBeUsed[service] = service;
        }
        else if(service && typeof service == "object"){
            for(var key in service){
                serviceToBeUsed[key] = service[key];
            }
        }
    })
  }
  return serviceToBeUsed;
}

function extendService(obj){
  var servObj = obj.serviceToBeUsed || toBeUsedServices(obj), name;
  for(var serv in servObj){
    name = servObj[serv];
    if(obj.Lyte.registeredServices.hasOwnProperty(name)){
      obj.scope[serv] = obj.Lyte.registeredServices[name];
    }else{
      obj.Lyte.$.requiredServices(serv, name, obj.callback);
    }
  }  
}

function extendMixin(obj){
  var scp = obj.Lyte, self = obj.scope;
  obj.mixins.forEach(function(item){
    if(scp.Mixin.exists(item)){
      var mixin = scp.registeredMixins[item];
      for(var key in mixin){
        self[key] = mixin[key];
      }
    }
    else{
      scp.$.requiredMixins(item, obj.callback);
    }
  });
}

function toAddSuper(scp, key, name, self){
  if(scp.__toAddSuper && scp.__toAddSuper.hasOwnProperty(name)){
    var addSuper = scp.__toAddSuper[name];
    for(var i=0; i<addSuper.length; i++){
      var child = scp[addSuper[i]];
      if(child && child.is == key){
        child.$super = self;
        self.__extendedBy.push(addSuper[i]);
        var index;
        if(name != "application")
        {	
          if(scp.__toAddSuper.application)
          {
            index = scp.__toAddSuper.application.indexOf(child.__name);
            if(index > -1)
            {
              scp.__toAddSuper.application.splice(index,1);
            }
          }
          if(scp.application)
          {
            index = scp.application.__extendedBy.indexOf(child.__name);
            if(index > -1)
            {
              scp.application.__extendedBy.splice(index,1);
            }
          }
        }
      }
    }
    delete scp.__toAddSuper[name];
  }
}

function _get(cacheObj, key) {
  return cacheObj[key];
}
function globalsSet(scope,value){
  let set = this.$utils.set;
  if(set){
      return set(this.__gl,scope,value);
  }
  else{
      this.error("Globals set will be supported only if component registry is imported in the app");
  }
};
function globalsGet(scope){
  let get = this.$utils.get;
  if(get){
      return get(this.__gl,scope);
  }
  else{
      elf.error("Globals get will be supported only if component registry is imported in the app");
  }
};
function arrayUtils(){
  let arrayUtils = this.$utils.arrayUtils;
  if(arrayUtils){
      return arrayUtils.apply(arrayUtils, arguments);
  }else{
      this.error("arrayUtils will be supported only if component registry is imported in the app");
  }
}
function objectUtils(){
  let objectUtils = this.$utils.objectUtils;
  if(objectUtils){
      return objectUtils.apply(objectUtils, arguments);
  }else{
      this.error("objectUtils will be supported only if component registry is imported in the app");
  }
}
function _lyteDidConnect(LClass,ins){
  if(LClass._component.didConnect){
    LClass._component.didConnect(ins);
  }
}
function _lyteInit(LClass,ins){
  ins.__gl = {};
  ins.Globals = {};
  // ins.triggerEvent = triggerEvent;
  // ins.addEventListener = addEventListener;
  // ins.removeEventListener = removeEventListener; 
  ins.extendEventListeners = extendEventListeners;
  extendEventListeners(ins);
  extendEventListeners(LClass);
  if(LClass._component.init){
    LClass._component.init(ins);
  }
  // ins.arrayUtils = arrayUtils;
  // ins.objectUtils = objectUtils;
  ins.arrayUtils = function() {
    return arrayUtils.apply(ins ,arguments);
  }
  ins.objectUtils = function(){
      return objectUtils.apply(ins ,arguments);
  }
  ins.Globals.set = function(){
      return globalsSet.apply(ins ,arguments);
  }
  ins.Globals.get = function(){
      return globalsGet.apply(ins ,arguments);
  }
  ins.lyteError = _lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger;
  ins.error = _lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger.error.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger);
  ins.warn = _lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger.warn.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger);
  ins.errorCodes = _lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger.errorCodes;
  defProp(ins, "patterns", {
    value: {
      email : new RegExp(/^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/),
      url : new RegExp(/(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/),
      ampm : new RegExp(/^(AM|PM|am|pm)$/),
      hour : new RegExp(/^(0?[0-9]|1[0-9]|2[0-4])$/),
      minute : new RegExp(/^(0?[0-9]|[1-5][0-9]|60)$/),
      boolean : new RegExp(/^(true|false|TRUE|FALSE)$/),
      alphaNumeric : new RegExp(/([a-zA-Z0-9])+/),
      alphabetsOnly : new RegExp(/([a-zA-Z])+/),
      numeric : new RegExp(/([0-9])+/),
      phoneNo : new RegExp(/^[0-9a-zA-Z+.()\-;\s]+$/)
    }
  });
  ins.deepCopyObject = function(obj){
    return copyObject(obj);
  }
  ins.prop = function(type, opts){
    var obj = {};
    obj.type = type;
    if(opts == undefined){
      opts = {};
    }
    // if(this.types.indexOf(type) == -1 && !this.Transform.hasOwnProperty(type)){
    //   throw new Error("Not a valid field type - "+type);
    // }
    Object.assign(obj, opts);
    return obj;
  }
  _lyte_error__WEBPACK_IMPORTED_MODULE_3__.Logger.addEventListener("error", function(){  
    var arr = Array.from(arguments);
    if (LClass.onerror) {
      LClass.onerror.apply(LClass, arr);
    }
    if(LClass.triggerEvent){
      arr.unshift("error");
      LClass.triggerEvent.apply(LClass, arr);
    }
  });
  ins.types = types;
  ins.log = function (text, src, color) {
    if (this.config && this.config.debug) {
        if(color) {
            console.log("%c" + text,'color:' + color);
        } else {
          console.log(text);      
        }
    }
  };
  ins.isComponent = function(object) {
      if(object && object.$node && object.__data) {
        return true;
      }
      return false;
  }
  ins.Transform = {};
  ins.one = one;
  ins.many = many;

  ins.registerDataType = function(fieldTypeName, properties){
      var exts = "extends";
      if(ins.Transform.hasOwnProperty(fieldTypeName)){
        LClass.error("Custom Field Type - "+fieldTypeName+" -  already exists.");
        return;
      }
      if(properties[exts] == undefined || ins.types.indexOf(properties[exts]) == -1){
        LClass.error("Not a valid field type - "+properties[exts]);
        return;
      }
      ins.Transform[fieldTypeName] = properties;
  }
  ins.registerPattern = function(patternName, pattern){
    ins.patterns[patternName] = pattern;
  }
  ins.injectResources = function (files, every, completed, options) {
    var successFiles = [],
    errorFiles = [],
    scope = ins;
    every = every || function () {};
    completed = completed || function () {};
    return new Promise(function (resolve,reject) {
      processRequirements(files, function () {
        if (options && options.defer) {
          options.defer({
            injectJS: injectJS,
            files: files,
            errorFiles: errorFiles
          });
          resolve();
        } else {
          injectJS(files, function () {
            completed(successFiles, errorFiles);
            if(errorFiles.length) {
                reject(successFiles, errorFiles);
              } else {
                resolve(successFiles, errorFiles);
              }
          });
        }
      }.bind(ins));
    });
  
    function injectJS(files, resolve, execFiles) {
      execFiles = execFiles || []
      if (!files) {
        resolve(successFiles, errorFiles);
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve(successFiles, errorFiles);
        }
        var len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
             var fileSplit = file.split('.'),
            type = fileSplit[fileSplit.length - 1];
            if (type && type == "js" && execFiles.indexOf(file) == -1) {
              execFiles.push(file);
              createScript(file, function () {
                loaded();
              });
            } else {
              loaded();
            }
          } else if (Array.isArray(file)) {
            new Promise(function (r) {
              injectJS(file, r);
            }).then(function () {
              loaded();
            });
          } else {
            len--;
            new Promise(function (r) {
              injectJS(file.parent, r);
            }).then(function () {
              new Promise(function (r) {
                injectJS(file.child, r);
              }).then(function () {
                loaded();
              });
              loaded();
            });
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve(successFiles, errorFiles);
        }
      }
    }
    
    function createScript(file, resolve) {
      var ev = scope.injectResources.respObj[file];
      if (!scope.injectResources.availableTags[file] || scope.injectResources.availableTags[file].tag.tagName == "LINK") {
        var tag = document.createElement('script');
        tag.setAttribute('type', "text/javascript");
        ev.getAttributeNames().forEach(function (attr) {
          if (["href", "as", "rel"].indexOf(attr) == -1) {
            tag.setAttribute(attr, ev.getAttribute(attr));
          }
        });
        tag.setAttribute('src', file);
        tag.onerror = tag.onload = function(event) {
          if (event.type == "error") {
            errorFiles.push(event)
          } else {
            successFiles.push(event)
          }
          scope.injectResources.availableTags[file].tag.remove();
          scope.injectResources.availableTags[file] = { tag: tag, event: { type: event.type == "error" ? "error" : "load"} };
          resolve();
        }
        _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.$.assetsDiv.appendChild(tag);
      } else {
        resolve();
      }
    }
  
    function processRequirements(files, resolve) {
      if (!files) {
        resolve();
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve();
        }
        var len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
            requestFile.call(scope, file, scope.injectResources.availableTags[file], function () {
              loaded();
            });
          } else if (Array.isArray(file)) {
            new Promise(function (r) {
              processRequirements(file, r);
            }).then(function () {
              loaded();
            });
          } else {
            len--;
            new Promise(function (r) {
              processRequirements(file.parent, r);
            }).then(function () {
              loaded();
            });
            new Promise(function (r) {
              processRequirements(file.child, r);
            }).then(function () {
              loaded();
            });
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve();
        }
      }
  
      function requestFile(file, cached, resolve) {
        if(ins.$.reqFiles[file]) {
          ins.$.reqFiles[file].push(resolve);
        } else {
          var scope = ins;
          ins.$.reqFiles[file] = [resolve];
          if (cached && cached.event.type != "error") {
            if (ins.removeFromCache.arr.indexOf(file) != -1) {
              ins.removeFromCache.arr.splice(scope.removeFromCache.arr.indexOf(file), 1);
            }
            fileLoaded.call(cached.tag, file, cached.event, true);
            resolve();
          } else {
            makeRequest(file, function (event) {
              scope.injectResources.respObj[file] = ins;
              scope.$.reqFiles[file].forEach(function (resolve) {
                resolve();
              });
              // filesObj[file] = ins;
              fileLoaded.call(ins, file, event);
              every.call(ins, event);
            });
          }
        }
      }
  
      function fileLoaded(file, event, cached) {
        delete scope.$.reqFiles[file];
        if (!cached) {
          if (scope.injectResources.availableTags[file]) {
            scope.injectResources.availableTags[file].tag.remove();
            delete scope.injectResources.respObj[file];
          }
          ins.onerror = ins.onload = undefined;
          scope.injectResources.availableTags[file] = { tag: ins, event: { type: event.type } };
        }
      }
    }
  
    function makeRequest(file, callBack) {
      var tag,
          ev = every.internal || {},
          fileSplit = file.split('.'),
          type = fileSplit[fileSplit.length - 1];
      ev.file = file;
      if (fileSplit.length == 1) {
        _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error('Type of file is not specified in injectResources.');
        return;
      }
      tag = document.createElement('link');
      tag.setAttribute('href', file);
      ev.tag = tag;
      if (type == 'css') {
        tag.setAttribute('type', "text/css");
        tag.setAttribute('rel', "stylesheet");
        tag.onerror = tag.onload = function (event) {
          // if (event.type == "error") {
          //   errorFiles.push(event);
          // } else {
          //   successFiles.push(event);
          // }
          callBack.call(ins, event);
        };
      } else {
        tag.setAttribute('as', "script");
        tag.setAttribute('rel', "preload");
        tag.onerror = tag.onload = function (event) {
          // if (event.type != "error") {
          //   tag.status = 200;
          // }
          callBack.call(ins, event);
        };
      }
      _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.triggerEvent("onBeforeInject", ev);
      _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.$.assetsDiv.appendChild(tag);
    };
  };
  ins.injectResources.availableTags = [];
  ins.injectResources.respObj = [];

  ins.removeFromCache = function(arr) {
    var scope = ins;
    ins.removeFromCache.assign.call(ins,arr);
    if(ins.removeFromCache.arr.length) {
      ins.removeFromCache.arr.forEach(function(file) {
        if(scope.injectResources.availableTags[file]) {
          scope.injectResources.availableTags[file].tag.remove();
          delete scope.injectResources.availableTags[file];  
        }
      });
      ins.removeFromCache.arr = [];
    }
  }
  ins.removeFromCache.arr = [];
  ins.removeFromCache.assign = function(arr) {
    arr = arr == "*" ? Object.keys(ins.injectResources.availableTags) : (Array.isArray(arr) ? arr : [arr]); 
    ins.removeFromCache.arr = ins.removeFromCache.arr.concat(arr);
    return;
  }
  ins.resolvePromises = function(promises) {
    return new Promise(function(res, rej) {
      ;(0,_rsvp__WEBPACK_IMPORTED_MODULE_4__.resolvePromises)(promises).then(function(data) {
        res(data);
      },function(data) {
        rej(data);
      })
    })
  }
  // ins.setState = function(str){
  //   if(!str){
  //     console.error("Please provide a state name");
  //   }
  //   var evnt = window.event;
  //   if(/^(click|dblclick)$/.test(evnt.type)){
  //       var target = evnt.target;
  //       if(getConfig("stateHandling") == true && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false"){
  //           var state = target.getAttribute("lyte-state");
  //           if(!state){
  //               var mp = window.__stateMap = window.__stateMap || new Map();
  //               var mpobj = mp.get(str);
  //               if(!mpobj){
  //                   var obj = addStateToMap(evnt.type, target, undefined, str);
  //                   mp.set(str, obj);
  //               }
  //               else{
  //                   console.error("There is already a open state by the name",str);
  //               }
  //           }
  //       }        
  //   }
  // }
  // ins.removeState = function(str){
  //   if(!str){
  //       console.error("Please provide a state name");
  //   }
  //   var mp = window.__stateMap;
  //   if(mp){
  //       var obj = mp.get(str);
  //       if(obj){
  //           mp.delete(str);
  //           removeStateFromMap(str, obj.event, obj.target);
  //       }
  //   }
  // }

  // ins.setConfig = function(key, value){
  //   var configObj = window.__config = window.__config || {};
  //   configObj[key] = value;
  // }
  // ins.getConfig = getConfig;
}


function _defineProperty(exportsObj,specsObj){
  let actualObj = {};
  let defineProperty = function(obj,property){
    Object.defineProperty(exportsObj,property,{
      set : function(newValue){
        actualObj[property] = newValue;
      },
      get : function(){
        if(!actualObj[property]){
          actualObj[property] = obj();
        }
        return actualObj[property];
      }

    })
  }
  for(let key in specsObj){
    defineProperty(specsObj[key],key)
  }
}

function checkEstablishingSCP(value,path,watch){
  if(Array.isArray(watch)){
      var _path ='';
      _path = path.join(".")
      if(checkWatchPath(_path,watch,true) && typeof value != "object"){
          return true
      }
      var _key = Object.keys(value);
      for(var i_scp =0 ; i_scp<_key.length ; i_scp++){
          var spiePath = _key[i_scp];
         var finalaUth =  _path == ""?spiePath : _path+"."+spiePath;
          if(checkWatchPath(finalaUth,watch,true)){
              return true
          }
      }
  }
}
function checkWatchPath(actualPath,watchArr,establishBind){
  if(typeof watchArr == "boolean" && watchArr === true){
      return true
  }
  else if(Array.isArray(watchArr)){
      for(var i_watch=0; i_watch < watchArr.length ; i_watch++){
          var path = watchArr[i_watch];
          path =path.replace(/ /g,"");
          path = path.replace(/\$\.\./g,"..");
          path = path.replace(/\$\./g,"")
          var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g)!=-1 ? true :  false || path.includes("*");
          if(actualPath == path){
              return true;
          }
          else if (weirdPath){
              if(establishBind){
                if(path.search(/\.\./) != -1 ){
                  path = path.replace(/\.\.\S+/g,"..*")
                  if(path == "..*"){
                    return true;
                  }
                } 
              }
              path = path.search(/\[/) == 0? path.replace("[",""):path;
              path = path.search(/\.\.\[/)==0 ? path.replace("..[",".."):path
              path = path.replace(/\.*\[/g,".");
              path = path.replace(/\]/g,"");
              var _watchPath = checkWeirdPath(path,actualPath);
              if(_watchPath){
                  return true
              }
          }
      }
  }
}
function checkWeirdPath(watchPath,actualPath){
  if(actualPath == watchPath){
      return true;
  }
  else if(watchPath.includes("..") || watchPath.includes("*")) {
      var cmpPath = watchPath;
      cmpPath = cmpPath.replace(/\*/g, "$$")
      cmpPath = cmpPath.replace(/\.\./g,"::")
      // cmpPath = cmpPath.replace("[","\\[")
      cmpPath = cmpPath.replace(/\./g, "\\.")
      cmpPath=cmpPath.replace(/\:\:/g,"\\.?.*\\.?");
      cmpPath=cmpPath.replace(/\$/g,".*");
      var _wildCard = watchPath.split(".")
      var _wClenght = _wildCard.length;
      if(_wildCard[_wClenght-2] == "" && _wildCard[_wClenght-1]!="*"){
        cmpPath = cmpPath+"$";
      }
      var regularExp = new RegExp(cmpPath);
      if(regularExp.test(actualPath)){
          return true;
      }
      return false;
  }
}
function removeStateFromMap(type, event, target) {
  var mp = window.__nodeXHRMap;
  var nodeMap = mp.get(target);
  if (!nodeMap) {
      return;
  }
  var evMap = nodeMap.get(event);
  if (!evMap) {
      return;
  }
  if (evMap) {
      var arr = evMap;
      var ind = -1;
      arr.every(function (itm, idx) {
          if ((itm && itm.isXHR && itm.xhr == type) || (typeof type == "string" && itm.state == type)) {
              ind = idx;
              return false;
          }
          return true;
      });
      if (ind != -1) {
          arr.splice(ind, 1);
          var sind = target.lyteState.indexOf(type);
          target.lyteState.splice(sind, 1);
          if (!arr.length) {
              nodeMap.delete(event);
              var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1;
              tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
              if (target && target.lyteState && target.lyteState.length == 0) {
                  target.lyteState = null;
                  target.removeAttribute("lyte-state");
              }
          }
          if (!nodeMap.size) {
              mp.delete(target);
          }
      }
  }
}

function addStateToMap(event, target, XHR, stateName) {
  var mp = window.__nodeXHRMap = window.__nodeXHRMap || new Map();
  var nodeMap = mp.get(target);
  if (!nodeMap) {
      mp.set(target, new Map());
  }
  nodeMap = mp.get(target);
  var sr = target.lyteState = target.lyteState || [],
      type = stateName || XHR;
  if (sr.indexOf(type) == -1) {
      sr.push(type);
  }
  target.setAttribute("lyte-state", "");
  var evMap = nodeMap.get(event);
  if (!evMap) {
      nodeMap.set(event, []);
      evMap = nodeMap.get(event);
  }
  if (stateName) {
      evMap.push({
          state: stateName
      });
      return {
          target: target,
          event: event
      };
  } else {
      evMap.push({
          isXHR: true,
          xhr: XHR
      });
      var callback = function () {
          if (XHR.readyState == 4) {
              removeStateFromMap(XHR, event, target);
              XHR.removeEventListener("readystatechange", callback);
          }
      }
      XHR.addEventListener("readystatechange", callback);
  }
}




/***/ }),

/***/ 53501236:
/*!**********************************************!*\
  !*** ./node_modules/@slyte/core/src/lyte.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lyte": () => (/* binding */ Lyte),
/* harmony export */   "__componentsMap": () => (/* binding */ __componentsMap),
/* harmony export */   "__getCurrentContext": () => (/* binding */ __getCurrentContext),
/* harmony export */   "__getCurrentFunc": () => (/* binding */ __getCurrentFunc),
/* harmony export */   "__instances": () => (/* binding */ __instances),
/* harmony export */   "__scopedInstance": () => (/* binding */ __scopedInstance),
/* harmony export */   "__setCurrentContext": () => (/* binding */ __setCurrentContext),
/* harmony export */   "toLowerCase": () => (/* binding */ toLowerCase)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 33115194);
/* harmony import */ var _service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service */ 10723535);
/* harmony import */ var _lyte_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lyte-error */ 2800903);
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils.js */ 90502503);
/* harmony import */ var _DataType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataType.js */ 90815363);
/* harmony import */ var _Mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Mixin.js */ 49373160);
window.addEventListener('__onBeforeInject__',function(event){
    let detail = event.detail;
    let link = detail.link;
    let path = link.getAttribute('href');
    let fingerPrintedVal = window.LyteFingerPrint && window.LyteFingerPrint.get(path);
    if(fingerPrintedVal){
        path = fingerPrintedVal.file;
    }
    link.setAttribute('href',""+path);
});








var __instances = { engine : {}, addon: {}};
var __componentsMap = {};
var __servicesMap = {}; // Map for containing the services needed for every engine
var __enginesMap = new Map(); //Map for containing the engines associated with every service
var d = document;
// //change to defProp later
// Function.prototype.observes = function(){//af
//   return {
//     type: "observer",
//     value: this,
//     properties: arguments,
//     on: Function.prototype.on
//   }
// }
// Function.prototype.on = function(){
//   return {
//     type: "callBack",
//     value: "observer" === this.type ? this.value : this,
//     properties: arguments,
//     observes: "observer" === this.type ? this : void 0
// }
// }
var currentContext;
var currFunc;

function __setCurrentFunc(func) {
    currFunc = func;
}

function __getCurrentFunc() {
    return currFunc;
}
function __setCurrentContext(self) {
    currentContext = self;
}

function __getCurrentContext() {
    return  currentContext;
}

function toLowerCase(string) {
    return string.charAt(0).toLowerCase() + string.slice(1)
}

function __scopedInstance(cls, args, func, extendArgs) {
  var oldcontext = __getCurrentContext();
  __setCurrentContext(this);
  var self = this;
  __setCurrentFunc(function(ins) {
      __setCurrentFunc();
      if(extendArgs && extendArgs.length){
        extendArgs.forEach(function(itm){
          // let itm__lyte = __getLyte(itm);
          // itm.__lookups
          if(itm.__lookups && itm.__lookups.length){
            (0,_service__WEBPACK_IMPORTED_MODULE_0__.__handleLookups)(itm.__lookups, self, ins);
          }
        });
      }
      func(ins);
  });
  var ins = Reflect.construct(cls, args);
  __setCurrentContext(oldcontext);
  return ins;
}

class Lyte {
  static dataType(type){
    var self = this;
    class dataType extends self.DataType {}
    dataType.type = type;
    return dataType;
  }

  lookups() {
    return [];
  }

  scopedInstance() {
    return __scopedInstance.apply(this, Array.from(arguments));
  }
  static componentMap(map){
    Lyte._componentMap = map;
  }
  static register(options){
    if(options){
      if(options.app == true){
        Lyte._setDefaultApp(this);
      }
      if(options._migration){
        this._migration = options._migration;
      }
      if(options.hash){
        this._hash = options.hash;
      }
      if(options.refHash){
          this._refHash = options.refHash;
      }
    }
    var DT = this.DataType = (function() {
      class DataType extends _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType {
        static register(){
          _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(this, [DT]);
        }
      }
      return DataType;
    })();
    DT.dataType = {};
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(DT.dataType);
    // DT.register = function(){
    //     DataTypeClass.register.apply(this, [DT]);
    // }    
    var hash = options ? options.hash : undefined;
    if(hash && _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType && _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app && _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app.has(options.hash)){
      var dMap = _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app.get(hash);
      if(dMap.size){
        dMap.forEach(function(cls, name){
          _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(cls, [DT]);
          dMap.delete(name);
        });
        if(!dMap.size){
          _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app["delete"](hash);
        }
        if(!_DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app.size){
          delete _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app;
        }
      }
    }
    if(hash){
      _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.addEventListener(hash, function(dCls){
        _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(dCls, [DT]);
        if(_DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte.has(hash)){
            var dMap = _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte.get(hash); 
            if(dMap.has(dCls.name)){
              dMap.delete(dCls.name);
            }
            if(!dMap.size){
              _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte["delete"](hash);
            }
            if(!_DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte.size){
              delete _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte;
            }
        }
      });
    }
  }
  constructor(config) {
    var self = this;
    let defApp = Lyte._getDefaultApp();
    if(!Lyte._getDefaultAppIns() &&  defApp && defApp == this.constructor){
      Lyte._setDefaultAppIns(this);
    }
    Lyte._instances.push(this);
    // extendEventListeners(this);
    // this.lyteError = Logger;
    // this.error = Logger.error.bind(Logger);
    // this.warn = Logger.warn.bind(Logger);
    // this.errorCodes = Logger.errorCodes;
    // this.addEventListener = addEventListener;
    // this.removeEventListener = removeEventListener;
    // this.triggerEvent = triggerEvent;
    var consoleTime = [],
    wLyte = Lyte;
    var type = this.is = config.__lp && config.__lp.type ? config.__lp.type :  "app";
    this.config = config;
    this.version = "4.0.0";
    this.$ = {
      isApp : type == "app",
      isSubApp : type == "subApp",
      isAddon : type == "Addon",
      reqFiles : {},
      injectServices : {},
      modules : {}
    };
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.$.modules);
    this.$.modules.addEventListener("add", function(name, ins){
      if(!self.$.modules.hasOwnProperty(name)){
        self.$.modules[name] = [];
      }
      self.$.modules[name].push(ins);
    });
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.defProps)(this, {
      "__mixins__":{
        value: new Map()
      },
      "registeredServices":{
        value:{}
      },
      "registeredMixins":{
        value:{}
      },
      "_registeredComponents":{
        value: {}
      },
      "Service":{
        value:{}
      },
      "toBeInjectedServices": {
        value:{}
      },
      "toBeRegistered": {
        value:{}
      },
      "dataType":{
        value:{}
      }
    });
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.defProps)(this, { "customValidator":{
      value: new Map()
    } });
    this.constructor.DataType.dataType.addEventListener("add",function(name, def){
      self.dataType[name] = def;
    });
    var dTypeDef = this.constructor.DataType.dataType;
    for(var dKey in dTypeDef){
      this.dataType[dKey] = dTypeDef[dKey];
    }
    this.registeredCustomComponent = {};
    this.updateMixinsInApp();
    // this.Globals = {}
    // this.__lyteRegisteredEvents = {};
    // this.patterns = {
    //   email : /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
    //   url : /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
    //   ampm : /^(AM|PM|am|pm)$/,
    //   hour : /^(0?[0-9]|1[0-9]|2[0-4])$/,
    //   minute : /^(0?[0-9]|[1-5][0-9]|60)$/,
    //   boolean : /^(true|false|TRUE|FALSE)$/,
    //   alphaNumeric : /([a-zA-Z0-9])+/,
    //   alphabetsOnly : /([a-zA-Z])+/,
    //   numeric : /([0-9])+/,
    //   phoneNo : /^[0-9a-zA-Z+.()\-;\s]+$/
    // };
    // this.$.requiredMixins  = {};
    // this.$.requiredServices = {};
    var self = this;
    this.time = function(fn) {
      if(this.config.performance) {
        var index;
        if((index = consoleTime.indexOf(fn)) != -1) {
          consoleTime.splice(index,1);
          console.timeEnd(fn);
        } else {
          consoleTime.push(fn)
          console.time(fn);
        }
      }
    }

    // this.arrayUtils = arrayUtils;
    // this.objectUtils = objectUtils;
    // this.Globals.set = function(){
    //   return globalsSet.apply(self ,arguments);
    // }
    // this.Globals.get = function(){
    //   return globalsGet.apply(self ,arguments);
    // }
    // if(Lyte._component.init){
    //   Lyte._component.init(this);
    // }
    // if(config.compiler){
    //   config.compiler.compiler(this);
    // }
    ;(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__._lyteInit)(Lyte, this);
    this.Globals._name = "Globals";
    _Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.addMethods([this.Globals])

    if(config && config.engines){
      for(var engine in config.engines){
        var dependencies = config.engines[engine];
        if(dependencies.dependencies.services){
          __servicesMap[engine] = dependencies.dependencies.services;
        }
      }
    }

    if(type == 'engine' && name){
      if(__servicesMap[name]){
        __servicesMap[name].forEach(function(itm){
          if(config.dependencies && (engServ = config.dependencies.services)){
            if(itm && typeof itm == 'object'){
              for(var key in itm){
                if(engServ.includes(key)){
                  if(__instances.app.registeredServices.hasOwnProperty(itm[key])){
                    self.registeredServices[itm[key]] = __instances.app.registeredServices[itm[key]]
                  }
                  // else{
                  //   self.$.requiredServices(key,itm[key],callback.bind(self));
                  // }
                self.toBeInjectedServices[key] = itm[key];
                  if(!__enginesMap.has(itm[key])){
                    __enginesMap.set(itm[key],[]);
                  }
                  __enginesMap.get(itm[key]).push(self.name);
                }
              }
            }else if(itm){
              if(engServ.includes(itm)){
                if(__instances.app.registeredServices.hasOwnProperty(itm)){
                  self.registeredServices[itm] = __instances.app.registeredServices[itm]
                }
                // else{
                //   self.$.requiredServices(itm,itm,callback.bind(self));
                // }
                self.toBeInjectedServices[itm] = itm;
                if(!__enginesMap.has(itm)){
                  __enginesMap.set(itm,[]);
                }
                __enginesMap.get(itm).push(self.name);
                }
              }
            }
        })
      }
    }

    // this.__lyteRegisteredEvents = {};

    this.addEventListener("navigationStart", function(obj){
      var trans = obj.nextTrans;
      if(trans && obj.prevTrans){
          if(window.event && /^(click|dblclick|mouseover|mouseout|mousemove|mousedown|mouseup|contextmenu|keydown|keyup|keypress|submit|reset|focus|blur|input|change|select|load|resize|scroll|unload|beforeunload|DOMContentLoaded|readystatechange|touchstart|touchmove|touchend|touchcancel|play|pause|ended|volumechange|durationchange|ratechange|dragstart|drag|dragenter|dragleave|dragover|drop|dragend)$/g.test(window.event.type)){
              trans.ev = window.event;
              if(obj.prevTrans.ev){
                delete obj.prevTrans.ev;
              }
          }
          else if((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev){
            trans.ev = obj.prevTrans.ev;
            delete obj.prevTrans.ev;
        }
      }
    });

    this.addEventListener("afterRouteNavigation", function(obj){
        if(obj && obj.trans){
            var mp = window.__transXHRMap;
            if(obj.trans.state == 409 || obj.trans.state == 308){
                if(mp){
                    var mpObj = mp.get(obj.trans);
                    if(mpObj){
                        removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
                        mp.delete(obj.trans);
                    }
                }
            }
            else if(obj.trans.state == 200){
                mp ? mp.delete(obj.trans) : undefined;
                obj.trans.ev ? delete obj.trans.ev : undefined;
            }
        }
    });

    this.addEventListener("afterRouteTransition",function(obj){
      if(false) {}
    })

    this.addEventListener("beforeRouteNavigation", function(obj){
        if(obj && obj.prevTrans && obj.prevTrans.nested){
            obj.trans.ev = obj.prevTrans.ev;
            obj.trans.fromPrevTrans = true; // temp check
        }
    });

    this.includes = function(modules) {
      for(var module in modules) {
        var mod = this[module] = modules[module];
        mod.lyteInit ? mod.lyteInit(this) : undefined;
      }
    }
    // this.Security = {};
    // this.Security.$scp = this;
    // this.Security.createSanitizer = Lyte.Security.createSanitizer;
    // addToInstance(this);
    // window.Lte = Lyte.$scp[type][this.name] = this;
    //window.Lte = Lyte.$scp[type][this.name] = this;
    if(__instances.app && false) { var compName; }

    // if(false) { /* check code to move to compoennt module*/
    //   this.Component._registeredComponents = Object.assign(this.Component._registeredComponents , __globalElements.Component._registeredComponents);
    //   this.Component.registeredComponents = Object.assign(this.Component.registeredComponents , __globalElements.Component.registeredComponents);
    //   this.Component.registeredHelpers = Object.assign(this.Component.registeredHelpers , __globalElements.Component.registeredHelpers);
    //   this.Component.customPropRegex =  __globalElements.Component.customPropRegex;
    //   this.Component.customPropHandlers = Array.from(__globalElements.Component.customPropHandlers);
    // }
    // this.$.requiredMixins.component = Lyte.Component.requiredMixins.component;
    // this.Security = {};
    // this.Security.$scp = this;
    // this.Security.createSanitizer = Lyte.Security.createSanitizer;

    if(config && config.init){
      config.init.apply(this);
    }
    Object.defineProperty(this, "__lyte", {
      enumerable : false, 
      writable : true, 
      value : {"lookupMap" : new Map()}
    });
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.__lyte.lookupMap);
    __setCurrentContext(this);
    (0,_service__WEBPACK_IMPORTED_MODULE_0__.__handleLookups)([_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils], this, this);
    var lookups = this.lookups();
    // if(Array.isArray(lookups)){
    //   lookups.unshift(Utils);
    // }
    // else{
    //   lookups = [Utils];
    // }
    (0,_service__WEBPACK_IMPORTED_MODULE_0__.__handleLookups)(lookups, this, this);
    __setCurrentContext(undefined)   
    // if(Lyte.instantiateComponent){
    //   Lyte.instantiateSecurity(this);
    // }
    // if(Lyte._component.didConnect){
    //   Lyte._component.didConnect(this);
    // }
    ;(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__._lyteDidConnect)(Lyte, this);
  }
  updateMixinsInApp(){
    var hash = this.constructor._hash;
    if(hash){
      var mObj = _Mixin_js__WEBPACK_IMPORTED_MODULE_4__.Mixin.registeredMixin[hash];
      if(mObj){
        for(var key in mObj){
          let mixinCls = mObj[key];
          if(this.constructor._hash == mixinCls._refHash){
            this.registeredMixins[mixinCls.name] = mixinCls;
          }
        }
      }
    }
  }
  static isEntity(obj){
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(obj);
  }
  get __isApp() {
    return true;
  }
}

Lyte._instances = [];

var fnProto = Function.prototype;
if(!fnProto.on){
    fnProto.on = function(){
        Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
        return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
    };
}
if(!fnProto.observes){
    fnProto.observes = function(){
        Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
        return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
    };
}
if(!fnProto.computed){
    fnProto.computed = function(){
        Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
        return { "type": "computed", "value": this, "properties": arguments };
    };
}
Lyte._onObj = function(){
  return {"type": "callBack", "value":(this.type === "observer") ? this.value:this , "properties":arguments, "observes":(this.type === "observer" ? this: undefined)}
}
Lyte._observesObj = function() {
    return {"type" : "observer", "value" : this, "properties" : arguments, "on": Lyte._onObj, "lyteOn" : Lyte._onObj}
}
Lyte._computedObj = function() {
    return {"type" : "computed", "value" : this, "properties" : arguments}
}
Lyte._preRegister = function(){
  Lyte._actualFnProtoOn = Function.prototype.on;
  Lyte._actualFnProtoObserves = Function.prototype.observes;
  Lyte._actualFnProtoComputed = Function.prototype.computed;
  let fnProto = Function.prototype;
  fnProto.on = fnProto.lyteOn = Lyte._onObj;
  fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
  fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
}
Lyte._postRegister = function(){
  let fnProto = Function.prototype;
  fnProto.on = Lyte._actualFnProtoOn;
  fnProto.observes = Lyte._actualFnProtoObserves;
  fnProto.computed = Lyte._actualFnProtoComputed;
}

Object.defineProperty(Lyte, "_singleTonLookupMap", {
  enumerable : false, 
  writable : true, 
  value : new Map()
});
(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(Lyte._singleTonLookupMap);
// Lyte.prototype.arrayUtils = function(){
//   if(this.$.modules.component && this.$.modules.component.length){
//     let lc = this.$.modules.component[0]._getLyteComponent();
//     return lc.aF.apply(lc, arguments);
//   }else{
//     this.error("arrayUtils will be supported only if component registry is imported in the app");
//   }
// }
// Lyte.prototype.objectUtils = function(){
//   if(this.$.modules.component && this.$.modules.component.length){
//     let lc = this.$.modules.component[0]._getLyteComponent();
//     return lc.oF.apply(lc, arguments);
//   }else{
//     this.error("objectUtils will be supported only if component registry is imported in the app");
//   }
// }
// extendEventListeners(Lyte);
// Logger.addEventListener("error", function(){  
//   var arr = Array.from(arguments);
//   if (Lyte.onerror) {
//     Lyte.onerror.apply(Lyte, arr);
//   }
//   if(Lyte.triggerEvent){
//     arr.unshift("error");
//     Lyte.triggerEvent.apply(Lyte, arr);
//   }
// });

window.addEventListener("getLyteIns", function(ev){
  if(ev && ev.detail && ev.detail.init){
    ev.detail.init(Array.from(Lyte._instances));
  }
});
// Lyte.prototype.Compile = {};
window.LyteCls = Lyte;/* global lyte class */
Lyte.error = _lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger.error.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger);
Lyte.warn = _lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger.warn.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger);
Lyte.errorCodes = _lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger.errorCodes;
Lyte.browser = {};
Lyte._component = {};
Lyte.appList = [];
Lyte._setDefaultApp = function(appClass){
  Lyte._defaultApp = appClass;
}
Lyte._setDefaultAppIns = function(appIns){
  Lyte._defaultAppIns = appIns;
}
Lyte._getDefaultApp = function(){
  return Lyte._defaultAppIns;
}
Lyte._getDefaultAppIns = function(){
  return Lyte._defaultAppIns;
}
var userAgent = navigator.userAgent;
//temporary fix for IE 11
if (userAgent.match(/rv:11/)) {
  Lyte.browser.ie = true;
  window.action = function () {
    return;
  };
}
if (userAgent.match('Edge')) {
  var s = createElement("div");
  s.innerHTML = "<template><div>c</div></template>";
  if (s.querySelector("template").childNodes.length) {
    Lyte.browser.ie = true;
  } else {
    Lyte.browser.edge = true;
  }
  s.remove();
}

Lyte.reg = function(fn,options) {
  let type = options.type;
  let name = options.name;
  if(Lyte.$scp[type][name] && Lyte.$sscp[type][name]){
    fn(Lyte.$scp[type][name],Lyte.$sscp[type][name]);
  }
  else{
    Lyte.$scp[type][name] = new Lyte(type,name);
    Lyte.$sscp[type][name] = new Lyte.Store();
    fn(Lyte.$scp[type][name],Lyte.$sscp[type][name]);
  }
}
Lyte.$scp = {app : {}, addon : {}, subApp : {}};
Lyte.$sscp = {app : {},subApp : {}}
// Lyte.__lyteRegisteredEvents = {};
// Lyte.addEventListener = addEventListener;
// Lyte.removeEventListener = removeEventListener;
// Lyte.triggerEvent = triggerEvent;
Lyte.toBeRegistered = [];
Lyte.nestScp = {};
Lyte.nestScpId = 1;
Lyte.addons = {};
Lyte.registeredCustomComponent = {};
Lyte.$ = {
  assetsDiv : document.createElement("div"),
  shadowDiv : document.createElement("div")
}
Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
Lyte.$.shadowDiv.setAttribute("id", "lyteShadowDiv");

Lyte.domContentLoaded = function(callback) {
  if(d.readyState === "complete" || d.readyState === "interactive") { 
    callback();
  } else {
    window.addEventListener('DOMContentLoaded', function() {
      callback();
    });
  }
}

Lyte.createApplication = function(name, config){
  var ins = new Lyte("app", name, config);
  setTimeout(function() {
    config.includes.forEach(function(module) {
      module.init && module.init(ins);
    });
  },0)
  if(Lyte.Store) {
    var sins = new Lyte.Store();
    Lyte.$sscp.app[name] = sins;
  }
  // window.Lte = Lyte.$scp.app[name] = ins;
  return ins;
}

Lyte.createEngine = function(name, config){
  var ins = new Lyte("engine", name, config);
  // var sins = new Lyte.Store();
  // Lyte.$sscp.engine[name] = sins;
  Lyte.$scp.engine[name] = ins;
  return ins;
}

Lyte.createAddon = function(name, config){
  var ins = new Lyte("addon", name, config);
  Lyte.$scp.addon[name] = ins;
  return ins;
}

// Lyte.prototype.types = ["string", "object", "number", "boolean", "array"];

// Lyte.prototype.deepCopyObject = function(obj){
//   return copyObject(obj);
// }

// Object.defineProperty(Lyte, 'debug', {
//   set : function(data) {
//     Lyte._debug = Lyte.prototype.debug = data;
//     return data;
//   },
//   get : function() {
//     return Lyte._debug;
//   }
// });

// Lyte.prototype.log = function (text, src, color) {
//   if (this.config.debug) {
//       if(color) {
//           console.log("%c" + text,'color:' + color);
//       } else {
//         console.log(text);      
//       }
//   }
// };

// Lyte.prototype.isComponent = function(object) {
//   if(object && object.$node && object.__data) {
//     return true;
//   }
//   return false;
// }
// Lyte.prototype.Transform = {};
// Lyte.prototype.prop = function(type, opts){
//   var obj = {};
//   obj.type = type;
//   if(opts == undefined){
//     opts = {};
//   }
//   // if(this.types.indexOf(type) == -1 && !this.Transform.hasOwnProperty(type)){
//   //   throw new Error("Not a valid field type - "+type);
//   // }
//   Object.assign(obj,opts);
//   return obj;
// }

// Lyte.prototype.one = function(name,opts){
//   return defineRelation(name,"belongsTo",opts);
// }

// Lyte.prototype.many = function(name,opts){
//   return defineRelation(name,"hasMany",opts);
// }

// Lyte.prototype.registerDataType = function(fieldTypeName, properties){
//   var exts = "extends";
//   if(this.Transform.hasOwnProperty(fieldTypeName)){
//     this.error("Custom Field Type - "+fieldTypeName+" -  already exists.");
//     return;
//   }
//   if(properties[exts] == undefined || this.types.indexOf(properties[exts]) == -1){
//     this.error("Not a valid field type - "+properties[exts]);
//     return;
//   }
//   this.Transform[fieldTypeName] = properties;
// }

// Lyte.prototype.registerPattern = function(patternName, pattern){
//   this.patterns[patternName] = pattern;
// }

// Lyte.prototype.injectResources = function (files, every, completed, options) {
//   var successFiles = [],
//   errorFiles = [],
//   scope = this;
//   every = every || function () {};
//   completed = completed || function () {};
//   return new Promise(function (resolve,reject) {
//     processRequirements(files, function () {
//       if (options && options.defer) {
//         options.defer({
//           injectJS: injectJS,
//           files: files,
//           errorFiles: errorFiles
//         });
//         resolve();
//       } else {
//         injectJS(files, function () {
//           completed(successFiles, errorFiles);
//           if(errorFiles.length) {
//               reject(successFiles, errorFiles);
//             } else {
//               resolve(successFiles, errorFiles);
//             }
//         });
//       }
//     }.bind(this));
//   });

//   function injectJS(files, resolve, execFiles) {
//     execFiles = execFiles || []
//     if (!files) {
//       resolve(successFiles, errorFiles);
//     } else {
//       if (!Array.isArray(files)) {
//         files = [files];
//       }
//       if (!files.length) {
//         resolve(successFiles, errorFiles);
//       }
//       var len = -files.length;
//       files.forEach(function (file) {
//         if (typeof file == "string") {
//            var fileSplit = file.split('.'),
//           type = fileSplit[fileSplit.length - 1];
//           if (type && type == "js" && execFiles.indexOf(file) == -1) {
//             execFiles.push(file);
//             createScript(file, function () {
//               loaded();
//             });
//           } else {
//             loaded();
//           }
//         } else if (Array.isArray(file)) {
//           new Promise(function (r) {
//             injectJS(file, r);
//           }).then(function () {
//             loaded();
//           });
//         } else {
//           len--;
//           new Promise(function (r) {
//             injectJS(file.parent, r);
//           }).then(function () {
//             new Promise(function (r) {
//               injectJS(file.child, r);
//             }).then(function () {
//               loaded();
//             });
//             loaded();
//           });
//         }
//       });
//     }

//     function loaded() {
//       len++;
//       if (len == 0) {
//         resolve(successFiles, errorFiles);
//       }
//     }
//   }

//   function createScript(file, resolve) {
//     var ev = scope.injectResources.respObj[file];
//     if (!scope.injectResources.availableTags[file] || scope.injectResources.availableTags[file].tag.tagName == "LINK") {
//       var tag = document.createElement('script');
//       tag.setAttribute('type', "text/javascript");
//       ev.getAttributeNames().forEach(function (attr) {
//         if (["href", "as", "rel"].indexOf(attr) == -1) {
//           tag.setAttribute(attr, ev.getAttribute(attr));
//         }
//       });
//       tag.setAttribute('src', file);
//       tag.onerror = tag.onload = function(event) {
//         if (event.type == "error") {
//           errorFiles.push(event)
//         } else {
//           successFiles.push(event)
//         }
//         scope.injectResources.availableTags[file].tag.remove();
//         scope.injectResources.availableTags[file] = { tag: tag, event: { type: event.type == "error" ? "error" : "load"} };
//         resolve();
//       }
//       Lyte.$.assetsDiv.appendChild(tag);
//     } else {
//       resolve();
//     }
//   }

//   function processRequirements(files, resolve) {
//     if (!files) {
//       resolve();
//     } else {
//       if (!Array.isArray(files)) {
//         files = [files];
//       }
//       if (!files.length) {
//         resolve();
//       }
//       var len = -files.length;
//       files.forEach(function (file) {
//         if (typeof file == "string") {
//           requestFile.call(scope, file, scope.injectResources.availableTags[file], function () {
//             loaded();
//           });
//         } else if (Array.isArray(file)) {
//           new Promise(function (r) {
//             processRequirements(file, r);
//           }).then(function () {
//             loaded();
//           });
//         } else {
//           len--;
//           new Promise(function (r) {
//             processRequirements(file.parent, r);
//           }).then(function () {
//             loaded();
//           });
//           new Promise(function (r) {
//             processRequirements(file.child, r);
//           }).then(function () {
//             loaded();
//           });
//         }
//       });
//     }

//     function loaded() {
//       len++;
//       if (len == 0) {
//         resolve();
//       }
//     }

//     function requestFile(file, cached, resolve) {
//       if(this.$.reqFiles[file]) {
//         this.$.reqFiles[file].push(resolve);
//       } else {
//         var scope = this;
//         this.$.reqFiles[file] = [resolve];
//         if (cached && cached.event.type != "error") {
//           if (this.removeFromCache.arr.indexOf(file) != -1) {
//             this.removeFromCache.arr.splice(scope.removeFromCache.arr.indexOf(file), 1);
//           }
//           fileLoaded.call(cached.tag, file, cached.event, true);
//           resolve();
//         } else {
//           makeRequest(file, function (event) {
//             scope.injectResources.respObj[file] = this;
//             scope.$.reqFiles[file].forEach(function (resolve) {
//               resolve();
//             });
//             // filesObj[file] = this;
//             fileLoaded.call(this, file, event);
//             every.call(this, event);
//           });
//         }
//       }
//     }

//     function fileLoaded(file, event, cached) {
//       delete scope.$.reqFiles[file];
//       if (!cached) {
//         if (scope.injectResources.availableTags[file]) {
//           scope.injectResources.availableTags[file].tag.remove();
//           delete scope.injectResources.respObj[file];
//         }
//         this.onerror = this.onload = undefined;
//         scope.injectResources.availableTags[file] = { tag: this, event: { type: event.type } };
//       }
//     }
//   }

//   function makeRequest(file, callBack) {
//     var tag,
//         ev = every.internal || {},
//         fileSplit = file.split('.'),
//         type = fileSplit[fileSplit.length - 1];
//     ev.file = file;
//     if (fileSplit.length == 1) {
//       Lyte.error('Type of file is not specified in injectResources.');
//       return;
//     }
//     tag = document.createElement('link');
//     tag.setAttribute('href', file);
//     ev.tag = tag;
//     if (type == 'css') {
//       tag.setAttribute('type', "text/css");
//       tag.setAttribute('rel', "stylesheet");
//       tag.onerror = tag.onload = function (event) {
//         // if (event.type == "error") {
//         //   errorFiles.push(event);
//         // } else {
//         //   successFiles.push(event);
//         // }
//         callBack.call(this, event);
//       };
//     } else {
//       tag.setAttribute('as', "script");
//       tag.setAttribute('rel', "preload");
//       tag.onerror = tag.onload = function (event) {
//         // if (event.type != "error") {
//         //   tag.status = 200;
//         // }
//         callBack.call(this, event);
//       };
//     }
//     Lyte.triggerEvent("onBeforeInject", ev);
//     Lyte.$.assetsDiv.appendChild(tag);
//   };
// };

// if(Lyte.browser.ie) { //remove no ie support // af
//   Lyte.prototype.injectResources = function (files, every, completed) {
//     var successFiles = [],
//     errorFiles = []; 
//     every = every || function() {};
//     completed = completed || function() {};
//     return new Promise(function(resolve) {
//       processRequirements(files, resolve);   
//     }).then(function() {
//       completed(successFiles,errorFiles);  
//     });

//     function processRequirements(files, resolve) {
//       if(!files) {
//         resolve();
//       } else {
//         if(!Array.isArray(files)) {
//           files = [files];
//         }
//         if(!files.length) {
//           resolve();
//         }
//         var len = -(files.length);
//         files.forEach(function(file) {
//           if(typeof file == "string"){
//             requestFile.call(scope,file, scope.injectResources.availableTags[file], function() {
//               loaded();
//             });  
//           } else if(Array.isArray(file)) {
//             new Promise(function(r){
//               processRequirements(file, r);
//             }).then(function(){
//               loaded();
//             })
//           } else {
//             new Promise(function(r){
//               processRequirements(file.parent, r);
//             }).then(function(){
//               new Promise(function(r1){
//                 processRequirements(file.child, r1)
//               }).then(function(){
//                 loaded();
//               })
//             })
//           }
//         })
//       }

//       function loaded() {
//         len++;
//         if(len == 0) {
//           resolve();
//         }
//       }

//       function requestFile(file,cached,resolve) {
//         if(this.$.reqFiles[file]) {
//           this.$.reqFiles[file].push(resolve)
//         } else {
//           this.$.reqFiles[file] = [resolve];
//           if(cached && cached.event.type != "error") {
//             if(this.removeFromCache.arr.indexOf(file) != -1) {
//               this.removeFromCache.arr.splice(this.removeFromCache.arr.indexOf(file),1);
//             }
//             fileLoaded.call(cached.tag,cached.event,true);
//             resolve();
//           } else {
//             makeRequest(file,
//               function(event) {
//                 this.$.reqFiles[file].forEach(function(resolve) {
//                   resolve();
//                 });
//                 fileLoaded.call(this,event);
//                 every.call(this,event);
//               }
//             );
//           }
//         }
//       }

//       function fileLoaded(event,cached) {
//         var file = this.getAttribute('src') || this.getAttribute('href');
//         delete scope.$.reqFiles[file];
//         if(!cached) {
//           if(scope.injectResources.availableTags[file]) {
//             scope.injectResources.availableTags[file].tag.remove();
//           }
//           this.onerror = this.onload = undefined;
//           scope.injectResources.availableTags[file] = {tag : this, event : {type : event.type}};
//         }
//       }
//     }

//     function makeRequest(file,callBack) {
//       var tags = { ".js": 'script', ".css" : 'link' },
//       type = file.match(/\.[a-zA-Z]+(?=\?|$)/),
//       tag = document.createElement(tags[type]);
//       if (!type) {
//         Lyte.error('Type of file is not specified in injectResources.');
//         return;
//       } else if (type == '.css') {
//         tag.setAttribute('href', file);
//         tag.setAttribute('type', "text/css");
//         tag.setAttribute('rel', "stylesheet");
//       } else {
//         tag.setAttribute('src', file);
//       }
//       tag.onerror = tag.onload = function (event) {
//         if(event.type == "error") {
//           errorFiles.push(event);  
//         } else {
//           successFiles.push(event);
//         }
//         if(callBack) {
//           callBack.call(this,event);
//         }
//       };
//       var ev = every.internal || {};
//       ev.file = file;
//       ev.tag = tag;
//       Lyte.triggerEvent("onBeforeInject", ev);
//       Lyte.$.assetsDiv.appendChild(tag);
//     };
//   };
// }

// Lyte.prototype.injectResources.availableTags = [];
// Lyte.prototype.injectResources.respObj = [];

// Lyte.prototype.removeFromCache = function(arr) {
//   var scope = this;
//   this.removeFromCache.assign.call(this,arr);
//   if(this.removeFromCache.arr.length) {
//     this.removeFromCache.arr.forEach(function(file) {
//       if(scope.injectResources.availableTags[file]) {
//         scope.injectResources.availableTags[file].tag.remove();
//         delete scope.injectResources.availableTags[file];  
//       }
//     });
//     this.removeFromCache.arr = [];
//   }
// }

// Lyte.prototype.removeFromCache.arr = [];

// Lyte.prototype.removeFromCache.assign = function(arr) {
//     arr = arr == "*" ? Object.keys(this.injectResources.availableTags) : (Array.isArray(arr) ? arr : [arr]); 
//     this.removeFromCache.arr = this.removeFromCache.arr.concat(arr);
//     return;
// }

// Lyte.prototype.triggerEvent = triggerEvent;

// Lyte.prototype.addEventListener = addEventListener;

// Lyte.prototype.removeEventListener = removeEventListener; 

// Lyte.prototype.extendEventListeners = extendEventListeners;

// Lyte.prototype.resolvePromises = function(promises) {
//   return new Promise(function(res, rej) {
//     resolvePromises(promises).then(function(data) {
//       res(data);
//     },function(data) {
//       rej(data);
//     })
//   })
// }

Lyte.createCustomElement = function(customElementName, definition) {
  var constructor = definition.constructor;
  delete definition.constructor;
  var connectedCallback = definition.connectedCallback;
  delete definition.connectedCallback;
  var attributeChangedCallback = definition.attributeChangedCallback;
  delete definition.attributeChangedCallback;
  var disconnectedCallback = definition.disconnectedCallback;
  delete definition.disconnectedCallback;

  this.defProperty = function(obj, key, val) {
    var obj1 = {};
    if(val.get) {
      obj1.get = val.get
    }
    if(val.set) {
      obj1.set = val.set
    }
    Object.defineProperty(obj, key, obj1);
  }
  class classDef extends HTMLElement {
    constructor() {
      super();
      if(this.isNewComp(customElementName)){
        this.executeCallbacks(constructor,arguments);
      }else{
        this.__lyteIgnore = true;
      }
    }

    connectedCallback(){
      let _LC = Lyte._instances[0].$.modules.component[0]._getLyteComponent();//temp fix
      if(!_LC.ignoreDisconnect && !this.__lyteIgnore) {
        this.executeCallbacks(connectedCallback,arguments);
        this.setAttribute("lyte-rendered-ce", "");
      }
    }
    attributeChangedCallback(){
      if(!this.__lyteIgnore) {
        this.executeCallbacks(attributeChangedCallback,arguments);
      }
    }
    disconnectedCallback(){
      let _LC = Lyte._instances[0].$.modules.component[0]._getLyteComponent();//temp fix
      if(!_LC.ignoreDisconnect && !this.__lyteIgnore) {
        this.executeCallbacks(disconnectedCallback,arguments);
      }
    }
    executeCallbacks(callBack,argArr){
      if(callBack) {
        callBack.apply(this, Array.from(argArr));
      }
    }
    isNewComp(customElementName){
      if(this.hasAttribute("lyte-rendered-ce")) {
        return false;
      }
      return true;
    }
  }
  var staticDef = definition.static;
  if(staticDef) {
    for(var key in staticDef) {
      if(typeof staticDef[key] === "object") {
        this.defProperty(classDef, key, staticDef[key]);
      } else {
        Object.defineProperty(classDef, key, {
          value : staticDef[key]
        });
      }
    }
    delete definition.static;
  }
  for(var key in definition) {
    if(typeof definition[key] === "object") {
      this.defProperty(classDef.prototype, key, definition[key]);
    } else {
      Object.defineProperty(classDef.prototype, key, { writable: true, value : definition[key]});
    }
  }
  definition.static = staticDef;
  definition.constructor = constructor;
  definition.connectedCallback = connectedCallback;
  definition.attributeChangedCallback = attributeChangedCallback;
  definition.disconnectedCallback = disconnectedCallback;
  if (document.readyState === "complete" || document.readyState === "interactive") {     
    // document is already ready to go
    customElements.define(customElementName, classDef);
  }
  else{
    // ***
    //Change the Lyte to instance
    Lyte.toBeRegistered.push({name:customElementName, def: classDef});
  }
  Lyte.registeredCustomComponent[customElementName] = classDef;
}

function domContentLoaded1() {
  document.head.appendChild(Lyte.$.assetsDiv);
  document.head.appendChild(Lyte.$.shadowDiv);
  let comp = Lyte.toBeRegistered;    
  if(comp && comp.length){    
      for(let j=0; j<comp.length;j++){
          customElements.define(comp[j].name, comp[j].def);    
      }    
      Lyte.toBeRegistered = [];    
  }
}

if(document.readyState === "complete" || document.readyState === "interactive") {
    domContentLoaded1();
} else {
    document.addEventListener("DOMContentLoaded", function(e){
        domContentLoaded1();
    },true);
}

//@3055
// var XHRSend = XMLHttpRequest.prototype.send;
// XMLHttpRequest.prototype.send = function(){
//     var event = window.event;  
//     var type, target = event ? event.target : undefined; 
//     let regIns = getConfig("stateHandling",true)
//     if(getConfig("stateHandling")){
//         if(event){
//             type = event.type;
//             /^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type,target,this) : undefined;
//         }
//         else{
//             var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
//             if(router){
//                 var currentAction = router.transition ? router.transition.ev : undefined;
//                 if(currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false"){
//                     var mp = window.__transXHRMap = window.__transXHRMap || new Map();
//                     mp.set(router.transition, {currentAction : currentAction, XHR:this});
//                     addStateToMap(currentAction.type, currentAction.target, this);
//                 }
//             }
//         }
//     }
//     XHRSend.apply(this, arguments);
// }

// Lyte.prototype.setState =   function(str){
//   if(!str){
//     console.error("Please provide a state name");
//   }
//   var evnt = window.event;
//   if(/^(click|dblclick)$/.test(evnt.type)){
//       var target = evnt.target;
//       if(getConfig("stateHandling") == true && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false"){
//           var state = target.getAttribute("lyte-state");
//           if(!state){
//               var mp = window.__stateMap = window.__stateMap || new Map();
//               var mpobj = mp.get(str);
//               if(!mpobj){
//                   var obj = addStateToMap(evnt.type, target, undefined, str);
//                   mp.set(str, obj);
//               }
//               else{
//                   console.error("There is already a open state by the name",str);
//               }
//           }
//       }        
//   }
// }

// Lyte.prototype.removeState = function(str){
//     if(!str){
//         console.error("Please provide a state name");
//     }
//     var mp = window.__stateMap;
//     if(mp){
//         var obj = mp.get(str);
//         if(obj){
//             mp.delete(str);
//             removeStateFromMap(str, obj.event, obj.target);
//         }
//     }
// }

// Lyte.prototype.setConfig = function(key, value){
//     var configObj = window.__config = window.__config || {};
//     configObj[key] = value;
// }

// Lyte.prototype.getConfig = getConfig;  @3055


// Lyte.errorCodes = errorCodes;
// Lyte.registerErrorCodes = registerErrorCodes;
// Lyte.getErrorMessage = getErrorMessage;






/***/ }),

/***/ 73236209:
/*!**********************************************!*\
  !*** ./node_modules/@slyte/core/src/rsvp.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolvePromises": () => (/* binding */ resolvePromises)
/* harmony export */ });
function resolvePromises(promises) {
    if(typeof promises == "string" || promises instanceof Promise) {
        return promises;
    } else {
        if(Array.isArray(promises)) {
        return promiseArray(promises);
        } else if(typeof promises == "object") {
        return promiseHash(promises);
        }    
    }

    function promiseHash(promiseObj) {
        var actPromKeys = [],
        promises = [],
        promiseKeys = Object.keys(promiseObj);
        promiseKeys.forEach(function(key) {
            var value = promiseObj[key];
        if(value instanceof Promise) {
            actPromKeys.push(key)
            promises.push(value);
        }
        });
        if(!promises.length) {
            return Promise.resolve(promiseObj);
        } else {
            var obj = {},promise = new Promise(function(resolve,reject) {
            Promise.all(promises).then(function(data) {
                promiseKeys.forEach(function(promiseKey) {
                if(actPromKeys.indexOf(promiseKey) != -1) {
                    obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)]
                } else {
                    obj[promiseKey] = promiseObj[promiseKey];
                }
                });
            resolve(obj);
            },function(err) {
            reject(err);
            });
        });   
        return promise;
        }
    }
    
    function promiseArray(promiseArray) {
        var array = [],
        hasPromise = false;
        promiseArray.every(function(item,i) {
            if(item instanceof Promise) { 
                hasPromise = true;
                return false;
            }
            return true
        });
        if(!hasPromise) {
            return Promise.resolve(promiseArray);
        }
        var promise = new Promise(function(resolve,reject) {
            Promise.all(promiseArray).then(function(data) {
                promiseArray.forEach(function(key,index){
                    array[index] = data[index];
                });
                resolve(array);
            },function(err) {
                reject(err);
                
            });
        });   
        return promise;
    }
};



/***/ }),

/***/ 10723535:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/core/src/service.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Service": () => (/* binding */ Service),
/* harmony export */   "__checkIfService": () => (/* binding */ __checkIfService),
/* harmony export */   "__getLyte": () => (/* binding */ __getLyte),
/* harmony export */   "__handleLookups": () => (/* binding */ __handleLookups)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/lyte.js */ 53501236);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);


/*convert to custom class*/
class Service { 
    static actions(arg1) {
      if(super.actions){
        return super.actions(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    static methods(arg1) {
      if(super.methods){
        return super.methods(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    static observers(arg1) {
      if(super.observers){
        return super.observers(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    data(arg1) {
      if(super.data){
        return super.data(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    constructor() {
        var context = (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__getCurrentContext)();
        // if(context){
        if(context.__isAddon) {
            if(this.__isAddon){
                this.$parent = context;
                this.$app = context.$app;
            }else{
                this.$addon = context;
            }
            if((0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.toLowerCase)(this.constructor.name) !== "utils"){
                this.$utils = context.$utils;
            }
        } else {
            this.$app = context;
            if(this.__isAddon){
                this.$parent = context;
            }
            if((0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.toLowerCase)(this.constructor.name) !== "utils"){
                this.$utils = context.$utils;
            }
        }
        var func = (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__getCurrentFunc)();
        var lookupMap;
        if(this.__isAddon){
            Object.defineProperty(this, "__lyte", {
                enumerable : false, 
                writable : true, 
                value : {"lookupMap" : new Map()}
            });
            lookupMap = this.__lyte.lookupMap;
            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.extendEventListeners)(this.__lyte.lookupMap);
        }
        else{
            if(this.$addon){
                lookupMap = this.$addon.__lyte.lookupMap;
            }else if(this.$app){
                lookupMap = this.$app.__lyte.lookupMap;
            }
        }
        if(func) {
            func(this);
        }
        var oldContext = (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__getCurrentContext)();
        if(this.__isAddon) {
            (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__setCurrentContext)(this);
        }
        
        if(lookupMap.get(this.constructor)){
            lookupMap.set(this.constructor,this);
        }
        else if(this.constructor.SINGLETON){
            _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte._singleTonLookupMap.set(this.constructor,this);
        }

        var lookups = this.lookups();
        // if(this.$addon){ //commented since lookups returned array - we are not using or holding it for anny purpose
        //     this.$addon.__lyte.lookupMap.lookups = lookups;
        // }else{
        //     this.$app.__lyte.lookupMap.lookups = lookups;
        // }
        __handleLookups(lookups, this.__isAddon ? this : context, this);
        this.__lookups = lookups;
        if(this.__isAddon) {
            (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__setCurrentContext)(oldContext);
        }
        // }else{
            // debugger
        // }
    }
    
    lookups() {
        return [];
    }

    onLookup() {
        
    }
}
function __getLyte(service){
    return service.$addon ? service.$addon.__lyte : service.__lyte ? service.__lyte : service.$app.__lyte;
}
function __handleLookups(lookups, app, curr) {
    if(lookups && lookups.length){
        var appLookupMap = app.__lyte.lookupMap;
        var currLookupMap = __getLyte(curr).lookupMap;
        lookups.forEach(function(item) {
            if(!item){
                _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Invalid class/instance passed in "+ curr.constructor.name + "'s lookup hook.")
                return
            }
            if(typeof item == "string") {
                if(curr) {
                    if(item.length){
                        if(appLookupMap.get(item)){
                            curr["$" + item] = appLookupMap.get(item);
                            __callOnLookup(curr["$" + item], curr);
                        }
                        else{
                            var id = app.__lyte.lookupMap.addEventListener(item, function(ins){
                                curr["$" + item] = ins;
                                __callOnLookup(ins, curr);
                                app.__lyte.lookupMap.removeEventListener(id);
                            });
                        }
                    }
                    else{
                        _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Lookup cannot be added for empty(undefined) key");
                    }
                }
            } else {
                if(__checkIfService(item)) {
                    instantiateService(item, app, curr);
                } else if(Object.keys(item).length == 1) {
                    for(var onlyKey in item){
                        var val = item[onlyKey];
                        if(onlyKey.length){
                            if(/^(utils|node|lg|app|addon)$/.test(onlyKey)){
                                _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Lookup cannot be added for the predefined key - "+ onlyKey);
                                return;
                            }
                            let name = "$" + onlyKey;
                            if(__checkIfService(val)) {
                                instantiateService(val, app, curr, name);
                            } else {
                                if(val && typeof val == "object"){
                                    curr[name] = val;
                                    __callOnLookup(val, curr);
                                    if(!appLookupMap.get(onlyKey)){
                                        appLookupMap.set(onlyKey, val); //how singleton af ?
                                        appLookupMap.triggerEvent(onlyKey, val);
                                    }
                                }
                                else if(typeof val == "string"){
                                    if(appLookupMap.get(val)){
                                        curr[name] = appLookupMap.get(val);
                                        __callOnLookup(curr[name], curr);
                                    }
                                    else{
                                        var id = appLookupMap.addEventListener(val, function(ins){
                                            curr[name] = ins;
                                            __callOnLookup(ins, curr);
                                            appLookupMap.removeEventListener(id);
                                        });
                                    }
                                }
                                currLookupMap.set(onlyKey, val);
                            }
                        }
                        else{
                            _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Lookup cannot be added for empty(undefined) key");
                        }
                    }
                }
            }
            
        });
    }
}

function instantiateService(cls, app, curr, name) {
    name = name || ("$" + (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.toLowerCase)(cls.name));
    let appLookupMap = app.__lyte.lookupMap;
    // let currLookupMap = curr.__lyte.lookupMap;
    let lookupValue = appLookupMap.get(cls);
    if(lookupValue) {
        if(lookupValue instanceof Promise) {
            lookupValue.then(function(val) {
                curr[name] = val;
                __callOnLookup(val, curr);
            });
        } else {
            curr[name] = lookupValue;
            __callOnLookup(lookupValue, curr);
        }
    } else {
        if(cls.SINGLETON){
            let singleTonclass = _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte._singleTonLookupMap.get(cls)
            if(singleTonclass){
                curr[name] = singleTonclass;
                return;
            }else{
                _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte._singleTonLookupMap.set(cls,cls);
            }
        }else{
            appLookupMap.set(cls, cls);
        }
        let obj = curr[name] = new cls();
        __callOnLookup(obj, curr);
        appLookupMap.triggerEvent(name, obj);
    }
}
function __checkIfService(item) {
    var isService = false;
    while(item != null) {
        if(item == Service || item.__lyteOrigClass) {
            isService = true;
            break;
        } else {
            item = Object.getPrototypeOf(item);
        }
    }
    return isService;
}

function __callOnLookup(service, module) {
    if(service && service.onLookup) {
        service.onLookup(module);
    }
}



/***/ }),

/***/ 71791193:
/*!***************************************************!*\
  !*** ./node_modules/@slyte/data/src/Connector.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Connector": () => (/* binding */ Connector)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 10723535);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 33115194);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 67921756);
/* harmony import */ var _dberror_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dberror.js */ 67992299);




/*convert to custom class*/
class Connector extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Service {
    constructor(){
        super();
        this.constructor._name = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.dbModName)(this.constructor.name, "Connector");
    }
    static processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts){
        return new Promise(function(resolve, reject){
            if(xhr){
                var contentType = xhr.getResponseHeader('content-type'),
                resp,
                isSuccess = xhr && (xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3") ? true : false,
                def = db.getSchemaObj(name),
                cresp;
                if(Connector.JSON.test(contentType)){
                    resp = xhr.responseText.length ? JSON.parse(xhr.responseText) : JSON.parse("{}");
                }
                else if(Connector.TEXT.test(contentType)){
                    try {
                        resp = JSON.parse(xhr.responseText);
                    }
                    catch(exp){ 
                        resp = new _dberror_js__WEBPACK_IMPORTED_MODULE_2__.ConnectorError("Cannot parse the data", xhr);
                        isSuccess = false;
                    }
                }
                else if(type !== "triggerAction"){
                    resp = xhr.responseText;
                }
                else{
                    resp = new _dberror_js__WEBPACK_IMPORTED_MODULE_2__.ConnectorError("Not an acceptable content-type: "+contentType, xhr);
                }
                argsObj.payLoad = resp;
                // def = getSchemaObj(db, def);
                var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(
                    db,
                    "connector",
                    def ? def.connector : undefined,
                    Connector.PARSERESPONSE,
                    { argsObj: argsObj, args:[type, name, xhr, resp, urlObj ? urlObj.qP : undefined, key, customData, opts]}
                );
                if(res){
                    cresp = res.data;
                    resp = argsObj.payLoad = cresp;
                }
                if(cresp && cresp instanceof Promise)
                {
                    return cresp.then(function(res){
                        argsObj.payLoad = res;
                        return resolve(res)
                    }, function(res){
                        return reject(res);
                    })
                    // return RESTConnector.handleParseResponsePromise(db,cresp,def,type,key,urlObj,xhr,undefined,undefined,undefined,resolve,reject,opts,argsObj);
                }
                else{
                    if(isSuccess){
                        return resolve(resp)
                    }
                    else{
                        return reject(resp);
                    }
                }

            }
        });
    }

    static sendXHR(db,name,type,key,urlObj,customData,argsObj,opts){
        var xhr = new XMLHttpRequest();
        var prm = new Promise(function(res, rej){
            argsObj.xhr = xhr;
            xhr.open(urlObj.method, urlObj.url, true);
            for(var header in urlObj.headers){
                xhr.setRequestHeader(header, urlObj.headers[header]);
            }
            if(urlObj.data !== undefined && !(urlObj.data instanceof FormData) && ( urlObj.headers && !urlObj.headers.hasOwnProperty("Content-Type") && urlObj.method !== "GET")){
                xhr.setRequestHeader("Content-Type", "application/json");
            }
            xhr.withCredentials = (urlObj.withCredentials)?true:false;
            var sch = db.getSchemaObj(name);
            if(sch && sch.connector){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db, "connector", sch.connector, /*RESTConnector.PARSEREQUEST*/ "parseRequest", { argsObj: argsObj, args:[type, name, xhr ,urlObj ? urlObj.qP : undefined, key, customData]});
            }
            db.emit("beforeRequest", [xhr, name, type, key, urlObj.qP]);
            xhr.send(urlObj.data);
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    db.emit("afterRequest",[xhr, name, type, key, urlObj.qP]);
                    argsObj.status = xhr.status;
                    /*RESTConnector.processResponse*/ Connector.processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts).then(function(data){
                        return res({data:data, xhr:xhr});
                    }, function(err){
                        return rej({data:err, xhr:xhr});
                    });
                }
            }
        });
        prm.xhr = xhr;
        return prm;
    }
    static getConnector(db, def, argsObj, defless){
        var defObj = def;
        def = def.def ? def.def : def
        if(defless){
            if(db.Connector.hasOwnProperty(def)){

            }
        }
        else if(def && def.Connector && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__.isInheritedClass)(def.Connector, db.constructor.ConnectorCls) && typeof def.Connector == "function" ){
            var parent = Object.getPrototypeOf(def.Connector), parentName = parent ? parent.name :undefined, context;
            var connec = def.Connector.apply(def, [argsObj]);
            if(connec){
                db.lyte.scopedInstance(connec, [db], function(ins){
                    defObj.connector = ins;
                }, [db]);
                context = defObj.connector.__type;
                db.connector[context] = db.connector[context] || {};
                db.connector[context][defObj.connector.constructor._name] = defObj.connector;
            }
        }
    }
    static getSerializer(db, def, argsObj){
        var defObj = def;
        def = def.def ? def.def : def
        if(def && def.Serializer && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__.isInheritedClass)(def.Serializer, db.constructor.SerializerCls) && typeof def.Serializer == "function"){
            var parent = Object.getPrototypeOf(def.Serializer), parentName = parent ? parent.name :undefined, context;
            var serz = def.Serializer.apply(def, [argsObj]);
            if(serz){
                db.lyte.scopedInstance(serz, [db], function(ins){
                    defObj.serializer = ins;
                }, [db]);
                context = defObj.serializer.__type;
                db.serializer[context] = db.serializer[context] || {};
                db.serializer[context][defObj.serializer.constructor._name] = defObj.serializer;
            }
        }
    }
    static getSuccess(db,def,type,key,urlObj,respObj,resolve,reject,response,resObj,from,opts,argsObj){
        var resp = respObj ? respObj.data : response, 
        // req = respObj ? respObj.xhr : undefined, 
        req,
        xhr = respObj ? respObj.xhr : undefined,
        batchIndex, 
        batch, 
        customD = opts.customD, 
        name = def && def._name ? def._name : def,
        status = xhr ? xhr.status : undefined;
        if(from != "idb"){
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            if(resObj){
                batchIndex = resObj.index;
                batch = resObj.batch;
                argsObj.xhr = req = resObj.resp;
                argsObj.payLoad = resObj.content;
                var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def.connector, baseCons.PARSERESPONSE , { argsObj: argsObj, args:[type, name, req, resp, urlObj ? urlObj.qP : undefined, key, customD, opts]});
                if(res){
                    resp = res.data;
                }
                if(resp instanceof Promise)
                {
                    return baseCons.handleParseResponsePromise(db,resp,def,type,key,urlObj,xhr,undefined,batchIndex,batch,resolve,reject,opts,argsObj);
                }
                else{
                    argsObj.payLoad = resp;
                }
            }
            // if(req){
                argsObj.payLoad = resp;
            // }
            return baseCons.findParseRequestPromise(db, resp,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj);
        }
        var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,"batch",{index:batchIndex,batch:batch}] : from ? [resp, "idb"] : [resp];
        resolve(resArr);
    }
    static getFailure(db,def,type,key,urlObj,respObj,resolve,reject,opts,content,code,argsObj,bObj){
        var customD = opts.customD, 
        name = def && def._name ? def._name : def;
        var xhr = respObj? respObj.xhr : undefined,
        response = respObj ? respObj.data : undefined;
        if(xhr){
            var resp;         
            argsObj.payLoad = response;
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def ? def.connector : undefined, baseCons.PARSERESPONSE, { argsObj: argsObj, args:[type, name, xhr, response ,urlObj ? urlObj.qP : undefined, key, customD, opts]});
            if(res){
                resp = res.data;
                argsObj.payLoad = resp;
            }
            if(resp instanceof Promise)
            {
                return baseCons.handleParseResponsePromise(db,resp,def,type,key,urlObj,xhr,undefined,undefined,undefined,resolve,reject,opts,argsObj);
            }
            return reject(xhr);
        }
        else if(content){
            var batch, batchIndex;
            if(bObj){
                batchIndex = bObj.index;
                batch = bObj.batch;
            }
            db.$.batchResponse[batch][batchIndex] = {code:code, status:"requestFailure", data:content};
            return reject({code:code,status:"requestFailure", data:content});
        }
        return reject(respObj.data);
    }
    static handleParseResponsePromise(db,response,def,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts,argsObj)
    {
        response.then(function(payload){
            argsObj.payLoad = payload;
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            if(type == "get")
            {
                baseCons.findParseRequestPromise(db, payload,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj);
            }
            else
            {
                baseCons.otherParseRequestPromise(db, payload,def,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts ? opts.customD : undefined,undefined,argsObj,key);
            }
        },function(payload){	
            reject(xhr);
        });
    }
    static findParseRequestPromise(db, payload,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj){
        var options = Object.assign({},opts);
        delete options.customD;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer; 
        var resp = baseSerz.getResponse(db,payload,def,type,key,urlObj,xhr, opts ? opts.customD : undefined, options,argsObj);
        var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,"batch",{index:batchIndex,batch:batch}] : [resp];
        resolve(resArr);
    }
    static create(db, name, data, isSingleRecord, customData, qP, mutationName){
        var type= isSingleRecord ? "createEntity": "create", 
        def = db.schema[name], 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData};
        Connector.getConnector(db, def, argsObj);
        Connector.getSerializer(db, def, argsObj);
        return def.connector.constructor.create.apply(def.connector.constructor, arguments);
    }
    static put(db, name, data, record, isSingleRecord,customData, qP, mutationName){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = (isSingleRecord) ? "updateEntity" : "update", 
        key = isSingleRecord ? (isComp && bK ? record[bK] : record.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        Connector.getConnector(db, def, argsObj);
        Connector.getSerializer(db, def, argsObj);
        return def.connector.constructor.put.apply(def.connector.constructor, arguments);
    }
    static del(db, name, data, isSingleRecord, destroy, customData, qP, mutationName){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = destroy || "deleteEntity", 
        key = isSingleRecord ? (isComp && bK ? data[bK] : data.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        Connector.getConnector(db, def, argsObj);
        Connector.getSerializer(db, def, argsObj);
        return def.connector.constructor.del.apply(def.connector.constructor, arguments);
    }
    static otherParseRequestPromise(db,resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,argsObj,key){
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer; 
        var response = baseSerz.genericResponse(db,resp,def,type,data,urlObj,xhr,partialObj,customData,partialRef,argsObj);
        if(batchIndex != undefined){
            db.$.batchResponse[batch][batchIndex] = response;
        }
        if(type != "action" && db.idbIns && def){
            db.idbIns.updateIDB(db,def._name,type,data,customData,urlObj);
        }
        var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
        if(baseCons.constructor.returnData == "new"){
            var obj = {};
            if(xhr && xhr.status){
                obj.status = xhr.status;
            }
            if(obj.status === 204){
                obj.data = null;
            }
            else{
                obj.data = response;
            }
        }
        resolve(response);
    }
    static handleRequest(db,urlObj,name,data,type,changedData,customData,partialObj,key,actionName, partialRef, argsObj){
        if(urlObj.data && (typeof urlObj.data == "object" || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__.isEntity)(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){
            // urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
            urlObj.data = JSON.stringify(urlObj.data);
        }
        var self = this, xhr, key, def = db.schema[name], prmXhr;;
        var prm = new Promise(function(resolve, reject){
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;             
            var processRequest = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def ? def.connector : undefined, baseCons.PROCESSREQUEST),sendXHR = true;
            var makeBatch = db.$.makeBatch;
            var batchPro = false;
            if(processRequest){
                sendXHR = false;
                var returnPromise = self.callGeneric(db,type,def,urlObj.data,data,customData,urlObj?urlObj.qP:undefined,key,urlObj.url,actionName,urlObj.method,urlObj.headers,argsObj),response;
                if(returnPromise instanceof Promise){
                    batchPro = true;						
                    returnPromise.then(function(resp){
                        resp = (resp == "" ? JSON.parse("{}") : JSON.parse(resp));
                        response = baseSerz.genericResponse(db,resp,def,type,data,urlObj,undefined,partialObj,customData,undefined,argsObj);
                        resolve(response);
                    },function(message){
                        reject(message);
                    });
                }
                else{
                    sendXHR = true;
                }
            }
            if(makeBatch && !batchPro){
                baseCons.constructBatch(db,name,type,key,urlObj,customData).then(function(respObj){
                    var resp = respObj.content; 
                    baseCons.handleSuccess(db, name, type, xhr, data, urlObj, resolve, resp, respObj,undefined,reject,key,customData,actionName,partialRef, argsObj);
                    // resolve(resp);
                },function(resObj){
                    baseCons.handleFailure(db, name, type, xhr, data, urlObj, resolve,resObj.content,undefined,reject,key,customData,resObj.code,actionName, argsObj, resObj);
                });
            }
            else if(sendXHR){
                var argsXHR = [db,name,type,key,urlObj,customData,argsObj];
                var xhrPrm = baseCons.sendXHR.apply(baseCons, argsXHR);
                xhrPrm.then(function(xhrResp){
                    baseCons.handleSuccess(db, name, type, xhrResp, data, urlObj, resolve, undefined, undefined, partialObj,reject,key,customData,actionName,partialRef,argsObj);					
                },function(xhrResp){
                    baseCons.handleFailure(db, name, type, xhrResp, data, urlObj, resolve, undefined,partialObj,reject,key,customData,undefined,actionName,argsObj);
                });
                prmXhr = xhrPrm.xhr;
            }
        });	
        if(prmXhr){
            prm.xhr = prmXhr;
        }
        return prm;
    }
    static handleSuccess(db, name, type, xhrResp, data, urlObj, resolve, resp, respObj, partialObj, reject, key, customData, actionName, partialRef, argsObj){
        var resp = resp ? resp : xhrResp ? xhrResp.data : undefined, 
        req, 
        batchIndex, 
        batch, 
        xhr = xhrResp ? xhrResp.xhr : undefined,
        req = xhr ? xhr : undefined,
        def = db.schema[name], 
        opts = { customD : customData };
        var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
        if(respObj){
            batchIndex = respObj.index;
            batch = respObj.batch;
            req = respObj.resp;
            argsObj.xhr = req;
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def && def.connector ? def.connector : undefined, baseCons.PARSERESPONSE, { argsObj:argsObj, args:[type, name, req, resp, urlObj ? urlObj.qP : undefined, key,customData,undefined,actionName]});
            if(res){
                resp = res.data;
                if(resp instanceof Promise)
                {
                    return baseCons.handleParseResponsePromise(db,resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts,argsObj);
                }
                else{
                    argsObj.payLoad = resp;
                }
            }
        }
        return this.otherParseRequestPromise(db, resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,argsObj,key);
    }
    static handleFailure(db, name, type, xhrResp, data, urlObj, resolve, respObj, partialObj,reject,key,customData,code,actionName,argsObj,bObj){
        var def = db.schema[name],
        xhr = xhrResp ? xhrResp.xhr : undefined;
        if(xhr){
            var resp, 
            response = xhrResp ? xhrResp.data : undefined;
            argsObj.payLoad = response;
        }
        else if(respObj){
            var batch, batchIndex;
            if(bObj){
                batchIndex = bObj.index;
                batch = bObj.batch;
            }
            db.$.batchResponse[batch][batchIndex] = {code:code, status:"requestFailure", data:respObj};
            reject({code:code, status:"requestFailure", data:respObj});
        }
        reject(response);
    }
}
Connector.__lMod = "Connector";
Connector.returnData = "old";
Connector.PARSEREQUEST = "parseRequest";
Connector.REQUESTURL = "requestURL";
Connector.REQUESTHEADERS = "requestHeaders";
Connector.REQUESTMETHOD = "requestMethod";
Connector.REFETCHALL = "refetchAll";
Connector.REFETCH = "refetchEntity";
Connector.PROCESSREQUEST = "processRequest";
Connector.PARSERESPONSE = "parseResponse";
Connector.JSON = /application\/json/;
Connector.TEXT = /text\/plain/;



/***/ }),

/***/ 54661849:
/*!********************************************!*\
  !*** ./node_modules/@slyte/data/src/Db.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Db": () => (/* binding */ Db),
/* harmony export */   "Dberror": () => (/* reexport safe */ _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror),
/* harmony export */   "ValidationError": () => (/* reexport safe */ _dberror__WEBPACK_IMPORTED_MODULE_4__.ValidationError)
/* harmony export */ });
/* harmony import */ var _dberror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dberror */ 67992299);
/* harmony import */ var _Schema_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Schema.js */ 79928624);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ 67921756);
/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Entity.js */ 20810078);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core */ 90815363);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/service */ 10723535);
/* harmony import */ var _Connector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Connector */ 71791193);
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Serializer */ 85831899);









/*convert to custom class*/
class Db extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__.Service {
    // getConnector(name, type){
    //     if(type == "graphql"){
    //         return this.GraphqlConnector.connector[name];
    //     }    
    //     return this.RESTConnector.connector[name];
    // }
    // getSerializer(name, type){
    //     if(type == "graphql"){
    //         return this.GraphqlSerializer.serializer[name];
    //     }  
    //     return this.RESTSerializer.serializer[name];
    // }
    registerPattern(key, pattern) {
        this.patterns[key] = pattern;
    }
    static getSchema(name){
        return this.Schema.schema[name];
    }
    static dataType(type){
        var self = this;
        class dataType extends self.DataType {}
        dataType.extends = type;
        return dataType;
    }
    static register(opts){
        var hash = opts ? opts.hash : this.name;
        var DT = this.DataType = (function() {
            class DataType extends _slyte_core__WEBPACK_IMPORTED_MODULE_1__.DataType {}
            return DataType;
        })();
        DT.register = function(){
            _slyte_core__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(this, [DT]);
        }
        this.DataType.dataType = {};
        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.DataType.dataType);    
        Object.defineProperty(this, "Schema", {
            value: (function() {
                class Schema extends _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema {
                }
                return Schema;
            })()
        });
        var SM = this.Schema; 
        this.Schema.schema = {};
        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.Schema.schema);
        if(_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db && _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.size && _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.has(hash)){
            var schMap = _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.get(hash);
            if(schMap.size){
                schMap.forEach(function(cls, name){
                    _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.registerInDb.apply(cls, [undefined, SM]);
                    schMap.delete(name);
                });
                if(!schMap.size){
                    _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db["delete"](hash);
                }
                if(!_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.size){
                    delete _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db;
                }
            }
        }
        SM.register = function(opts){
            _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.registerInDb.apply(this, [opts, SM]);
        }
        _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.addEventListener(hash, function(schCls){
            _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.registerInDb.apply(schCls, [undefined, SM]);
            if(_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.has(hash)){
                var schMap = _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.get(hash); 
                if(schMap.has(schCls.name)){
                    schMap.delete(schCls.name);
                }
                if(!schMap.size){
                    _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db["delete"](hash);
                }
                if(!_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.size){
                    delete _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db;
                }
            }
        });
    }
    constructor(opts){
        super();
        var self = this, 
        appIns = this.$app || this.$addon;
        if(!this.constructor.Connector || !this.constructor.Serializer){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns, "Base Connector / Serializer not defined in Db class");
            return;
        }
        if(this.includeDbs){
            var subDbs = this.subDbs = [];
            var dbs = this.includeDbs();
            dbs.forEach(function(itm){
                if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.newGetSuperClass)(itm, false, self.constructor)){
                    subDbs.push(itm);
                }
            });
        }
        if(appIns.$ && appIns.$.modules.triggerEvent){
            appIns.$.modules.triggerEvent("add", "db", this);
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"Connector",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"Serializer",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"connector",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"serializer",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"schema",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"_schema",new Map());
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"schemaless",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"dataType", {});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"_entity",_Entity_js__WEBPACK_IMPORTED_MODULE_6__.Entity);
        var lIns = this.lyte = appIns;
        var parent = this.constructor;
        if(this.constructor.Connector && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.newGetSuperClass)(this.constructor.Connector, false, _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector)){
            var cparentName = Object.getPrototypeOf(this.constructor.Connector).__lMod, context, defaultConnec;
            switch(cparentName){
                case "RESTConnector":
                    context = "REST";
                    break;
                case "GraphqlConnector":
                    context = "gql";
                    break;
                case "Connector":
                    defaultConnec = this.constructor.Connector;
            }
            if(context){
                this.Connector[context] = this.Connector[context] || {};
                this.Connector[context].application = this.constructor.Connector;
                this.lyte.scopedInstance(this.constructor.Connector, [this], function(ins){
                    self.connector[context] = self.connector[context] || {}; 
                    self.connector[context].application = ins;
                    self.applicationConnector = ins;
                }, [this]);
            }
            else if(defaultConnec){
                var dcparentName = defaultConnec.name, context;
                switch(dcparentName){
                    case "RESTConnector":
                        context = "REST";
                        break;
                    case "GraphqlConnector":
                        context = "gql";
                        break;
                }
                if(context){
                    class applicationConnector extends defaultConnec {
            
                    }
                    applicationConnector.register();
                    this.Connector[context] = this.Connector[context] || {};
                    this.Connector[context].application = applicationConnector;
                    this.lyte.scopedInstance(applicationConnector, [this], function(ins){
                        self.connector[context] = self.connector[context] || {}; 
                        self.connector[context].application = ins;
                        self.applicationConnector = ins;
                    }, [this]);
                }
            }
        }
        if(this.constructor.Serializer && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.newGetSuperClass)(this.constructor.Serializer, false, _Serializer__WEBPACK_IMPORTED_MODULE_8__.Serializer)){
            var sparentName = Object.getPrototypeOf(this.constructor.Serializer).__lMod, context, defaultSerz;
            switch(sparentName){
                case "RESTSerializer":
                    context = "REST";
                    break;
                case "GraphqlSerializer":
                    context = "gql";
                    break;
                case "Serializer": 
                    defaultSerz = this.constructor.Serializer;
                    break;
            }
            if(context){
                this.Serializer[context] = this.Serializer[context] || {};
                this.Serializer[context].application = this.constructor.Serializer;
                this.lyte.scopedInstance(this.constructor.Serializer, [this], function(ins){
                    self.serializer[context] = self.serializer[context] || {}; 
                    self.serializer[context].application = ins;
                    self.applicationSerializer = ins;
                }, [this]);
            }
            else if(defaultSerz){
                var dsparentName = defaultSerz.name, context;
                switch(dsparentName){
                    case "RESTSerializer":
                        context = "REST";
                        break;
                    case "GraphqlSerializer":
                        context = "gql";
                        break;
                }
                if(context){
                    class applicationSerializer extends defaultSerz {
        
                    }
                    applicationSerializer.register();
                    this.Serializer[context] = this.Serializer[context] || {};
                    this.Serializer[context].application = applicationSerializer;    
                    this.lyte.scopedInstance(applicationSerializer, [this], function(ins){
                        self.serializer[context] = self.serializer[context] || {}; 
                        self.serializer[context].application = ins;
                        self.applicationSerializer = ins;
                    }, [this]);
                }
            }
        }
        var schemaDef = parent.Schema.schema;
        for(var key in schemaDef){
            this.schema[key] = schemaDef[key].create(this, lIns);
            this._schema.set(schemaDef[key], this.schema[key]);
        }
        var dTypeDef = parent.DataType.dataType;
        for(var dKey in dTypeDef){
            this.dataType[dKey] = dTypeDef[dKey];
        }
        this.entityStrictLock = true; //default for external release
        if(opts && opts.hasOwnProperty("entityStrictLock")){
            this.entityStrictLock = opts.entityStrictLock;
        }
        parent.Schema.Lyte = parent.DataType.Lyte = lIns;
        parent.Schema.db = parent.DataType.db = this;
        // var _Logger = lIns.lyteError || Logger; 
		this.$ = {
            toRelate:{},
            idbQ2:{}
        };
        this.cache = {
            getEntity:function getEntity(def,pKey,isDeleted){
                var args = arguments, 
                args0 = args[0], 
                isObj = typeof def == "object" && def != null,
                db = self,
                defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
                _defless;
                if(isObj){
                    def = args0.schema, 
                    pKey = args0.pK, 
                    isDeleted = args0.isDeleted;
                }
                var isSchema = defless == true && typeof def == "string" ? false : (def ? ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(def, true) === "Schema") : def);
                def = isSchema ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(db, def) : def;
                var name = def && def._name ? def._name : def; 
                if( !def  ){
                    _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema ",name);
                    return;
                }
                else if(defless == true && !isSchema && name){
                    def = db.schemaless[name];
                    if(!def){
                        _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema");
                        return;	
                    }
                    _defless = true;
                }    
                if(isDeleted === true){
                    var deleted = def._deleted;
                    var obj = deleted.get(pKey);
                    if(obj && obj.data){
                        return obj.data;
                    }
                }
                else{
                    var isComp = def.isComp; 
                    pKey = (pKey == undefined) ? "" : pKey;
                    if(!isComp && def.data._recMap){
                        return def.data._recMap.get(pKey.toString());
                    }
                    else{
                        var data = def.data, entity;
                        if(_defless != true){
                            entity = data.filter(function(ins){
                                if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.comparePk)(ins, pKey)){
                                    return ins;
                                }
                            });
                        }
                        else{
                            entity = data.filter(function(ins){
                                if(ins[def._pK] === pKey){
                                    return ins;
                                }
                            });
                        }    
                        if(entity[0]){
                            return entity[0];
                        }
                    }
                }
                return undefined;
            },
            getAll: function getAll(def){
                var args = arguments, 
                args0 = args[0], 
                isObj = typeof def == "object" && def != null, 
                db = self,
                defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
                if(isObj){
                    def = args0.schema;
                }
                var isSchema = defless == true && typeof def == "string" ? false : (def ? ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(def, true) === "Schema") : def);
                def = isSchema ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(db, def) : def;
                var name = def && def._name ? def._name : def;
                if( !def  ){
                    _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema");
                    return;
                }
                else if(defless == true && !isSchema && name){
                    def = db.schemaless[name];
                    if(!def){
                        _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema ",name);
                        return;	
                    }
                }    
                return def.data;
            }
        }
        this.lyte = lIns;
        this.constructor.Schema.schema.addEventListener("add", function(name, def){
            self.schema[name] = def.create(self, lIns);
            self._schema.set(def, self.schema[name]);
        });
        this.constructor.DataType.dataType.addEventListener("add", function(name, def){
            self.dataType[name] = def;
        });
    }
    isEntity(obj){
        if(obj && obj.$ && obj.$ instanceof _Entity_js__WEBPACK_IMPORTED_MODULE_6__.$Entity && obj.$.db == this){
            return true;
        }
        return false;
    }
    triggerUpdate(def, pkVal, keys, qP, customData){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, pkVal = args0.pK, keys = args0.keys, qP = args0.qP, customData = args0.customData;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var name = def._name;
        var ArrayOfKeys,sendData=[],recordsArray=[];
        ArrayOfKeys = Array.isArray(pkVal)?pkVal:[pkVal]
        for(var update_Rec = 0; update_Rec<ArrayOfKeys.length ; update_Rec++){
            var ins = this.cache.getEntity(def.def, ArrayOfKeys[update_Rec])
            if(ins){
                var obj = {};
                var def = ins.$.schema,
                pK = def._arrPk,
                fields = keys || Object.keys(def.fieldList);	
                fields.forEach(function(item){
                    obj[item] = ins[item];
                });
                pK.forEach(function(item){
                    obj[item] = ins[item];
                });
                sendData.push(obj)
                recordsArray.push(ins);
            }
            else{
                return Promise.reject("No such record found");
            }
        }
        var isSingleRecord = false;
        if(!Array.isArray(pkVal)){
            sendData=sendData[0];
            recordsArray=recordsArray[0];
            isSingleRecord=true;
        }	
        return def.connector.constructor.put(this, name, sendData, recordsArray, isSingleRecord, customData, qP);
    }
    batch(arg){
		var db = this;
        return new Promise(function(resolve, reject){
            db.$.makeBatch = true;
            db.$.batch = db.$.batch || {};
            db.$.batchPromise = db.$.batchPromise || {};
            var method, 
            customData,
            bLen = (db.$.currentBatch === undefined) ? Object.keys(db.$.batch).length : (db.$.currentBatch + 1), 
            batch = db.$.currentBatch = bLen;
            if(arg && typeof arg == "function"){
                method = arg;
            }
            else if(arg && typeof arg == "object"){
                method = arg.method;
                customData = arg.customData;
            }
            try{
                method();
            }
            catch(e){
                db.$.makeBatch = false;
                throw e;
            }
            db.$.makeBatch = false;
            var payLoad = { batch:db.$.batch[batch] }, 
            argsObj = { type: "batch" }; 
            argsObj.customData = customData;
            argsObj.payLoad = payLoad;
            var urlObj = db.applicationConnector.constructor.buildURL(db, "batch", "POST", undefined, undefined, payLoad, undefined, undefined, customData, undefined, argsObj), 
            batchPl = payLoad.batch;
            if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty)(batchPl)){
                if(db.$.cachedBatch && db.$.cachedBatch[batch] && db.$.cachedBatch[batch].length){
                    var finalRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleCachedResponse)(db, batch, []);
                    return resolve(finalRes);
                }
                return resolve();					
            }
            argsObj.data = payLoad;
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.initCB)(db,"serializer", undefined, db.applicationSerializer.constructor.SERIALIZE, {args:["batch",payLoad,undefined,customData], argsObj:argsObj});
            if(res){
                argsObj.data = payLoad = res.data;
            }
            var xhr = new XMLHttpRequest();
            argsObj.xhr = xhr;
            xhr.open("POST", urlObj.url, true);
            for(var header in urlObj.headers){
                xhr.setRequestHeader(header, urlObj.headers[header]);
            }
            xhr.withCredentials = (urlObj.withCredentials)?true:false;
            xhr.send(JSON.stringify(payLoad));
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    argsObj.xhr = xhr;
                    if(xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3"){
                        var resp = JSON.parse(xhr.responseText);
                        db.$.batchResponse = db.$.batchResponse || {};
                        db.$.batchResponse[batch] = [];
                        db.applicationConnector.constructor.handleBatchPromise({db:db,response:resp,batch:batch,resolve:resolve, argsObj:argsObj});
                        setTimeout(function(){
                            var finalRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleCachedResponse)(db, batch, db.$.batchResponse[batch]);
                            resolve(finalRes);
                            db.$.batchResponse[batch] = [];
                        },0);
                    }
                    else{
                        db.$.batchResponse[batch] = [];
                        db.applicationConnector.constructor.handleBatchPromise({db:db,batch:batch,resolve:resolve,fail:true, argsObj:argsObj});
                        setTimeout(function(){
                            var finalRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleCachedResponse)(db, batch, db.$.batchResponse[batch]);
                            reject(finalRes);
                        },0);
                    }
                }
            }					
        });
    }
    push(def,data,deserialize,index){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined; 
        if(isObj){
            def = args0.schema, 
            data = args0.data, 
            deserialize = args0.deserialize;
            index = args0.index;
        }
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        def = defless && typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var name = def && def._name ? def._name : def, 
        result = data, 
        len;
        if(deserialize){
            data = def.serializer.constructor.buildJSON(db,def,"pushPayload",data);
            var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cbScp)(db, def.serializer, def.serializer.constructor.DESERIALIZEKEY, "serializer");
            len = data ? Object.keys(data).length : undefined;
            if(scope){
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(this.lyte, "LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
                if(len > 2){
                    _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte, "LD09");
                }
                var keys = Object.keys(data), ind = 0;
                if(keys.length == 2 && keys[0] == "meta"){
                    ind = 1;
                }
                var argsObj = { type: "pushPayload", schemaName: name};
                var deserializeKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cB)(scope, [argsObj]), rec = data[keys[ind]];
                delete data[keys[ind]];
                data[deserializeKey] = rec;
                
            }
            result = data[name];
        }
        // if(db.idbIns){
        //     db.idbIns.idbQ2Push(this,name,data,undefined,"pushPayload");
        // }
        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.insertIntoStore)(
            this,
            def.def ? def.def : def,
            result,
            true,
            undefined,
            undefined,
            index,
            true
        );
        var nData = data || [];
        if(!Array.isArray(nData)){
            nData = [nData];
        }
        var idb = def && def.hasOwnProperty("idb");
        nData.forEach(function(itm){
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(itm)){
                if(idb){
                    db.idbIns.idbQ2Push(db,name,itm,undefined,"pushPayload");
                }
                if(!itm.$.isError){
                    if(itm.$.inIDB && Object.keys(itm.$.inIDB).length){
                        db.dbIns.updateRelationsIDB(itm, itm.$.model.relations);
                    }
                }
            }
        });

        def ? delete def.rel : undefined;
        return data;
    }
    unregisterSchema(data){		
		var self = this;
		if(Array.isArray(data)){
			data.forEach(function(item){
				(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unregisterDef)(self, item);
			});
		}
		else{
			(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unregisterDef)(self, data);
		}
    }
    unregisterConnector(data){
        if(Array.isArray(data)){
            data.forEach(function(item){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this, "connector", item);
            });
        }	
        else{
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this, "connector", data);
        }		
    }
    unregisterSerializer(data){
        if(Array.isArray(data)){
            data.forEach(function(item){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this, "serializer",item);
            });
        }
        else{
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this,"serializer",data);
        }
    }
    addField(def, key, type, options, skipValidation, deserialize){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, key = args0.key, type = args0.prop ? args0.prop : args0.type, options = args0.options, skipValidation = args0.skipValidation, deserialize = args0.deserialize;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        if(key === "$"){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte, "$ is a reserved key, which cannot be used as the field name");
            return;
        }
        var fieldType, obs = [];
        if(type && typeof type == "object"){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.registerField)(this,def,key,type,obs);
            if(type.type == "relation"){
                fieldType = "relation"
            }
            else{
                fieldType = "attr"; 
            }
            var deserialize = arguments[4],
            skipValidation = arguments[3];
        }
        else{
            var field = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.prop)(type,options);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.registerField)(this,def,key,field,obs);
        }
        if(fieldType != "relation"){
            if(!skipValidation || deserialize){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.updateFieldValidation)(this, def, key, deserialize, skipValidation);
            }
        }
    }
    getSchemaObj(name){
        var schema = this.schema[name];
        if(!schema && this.subDbs){
            var len = this.subDbs.length;
            for(var i=0; i<len; i++){
                var subDb = this.subDbs[i];
                if(subDb.schema[name]){
                    schema = subDb.schema[name];
                    break;
                }
            }
        }
        return schema;
    }
    getSchema(name){
        var schema = this.schema[name];
        if(!schema && this.subDbs){
            var len = this.subDbs.length;
            for(var i=0; i<len; i++){
                var subDb = this.subDbs[i];
                if(subDb.schema[name]){
                    schema = subDb.schema[name];
                    break;
                }
            }
        }
        return schema && schema.def? schema.def : schema;
    }
    hasSchema(name){
        // return this.schema.hasOwnProperty(name);
        var hasSchema = this.schema.hasOwnProperty(name);
        if(!hasSchema && this.subDbs){
            var len = this.subDbs.length;
            for(var i=0; i<len; i++){
                var subDb = this.subDbs[i];
                if(subDb.schema[name]){
                    hasSchema = subDb.schema.hasOwnProperty(name);
                    break;
                }
            }
        }
        return hasSchema;
    }
    getSerializerObj(name, type){
        // return this.serializer[name];
        type = type == "graphql" ? "gql" : type;
        var sObj = type ? this.serializer[type] : this.serializer.REST;
        if(sObj){
            var serializer = sObj[name];
            if(!serializer && this.subDbs){
                var len = this.subDbs.length;
                for(var i=0; i<len; i++){
                    var subDb = this.subDbs[i];
                    if(subDb.serializer[name]){
                        var ssObj = type ? subDb.serializer[type] : subDb.serializer.REST;
                        serializer = ssObj[name];
                        break;
                    }
                }
            }
            return serializer;
        }
    }
    getConnectorObj(name, type){
        // return this.connector[name];
        type = type == "graphql" ? "gql" : type;
        var cObj = type ? this.connector[type] : this.connector.REST;
        if(cObj){
            var connector = cObj[name];
            if(!connector && this.subDbs){
                var len = this.subDbs.length;
                for(var i=0; i<len; i++){
                    var subDb = this.subDbs[i];
                    if(subDb.connector[name]){
                        var scObj = type ? subDb.connector[type] : subDb.connector.REST;
                        connector = scObj[name];
                        break;
                    }
                }
            }
            return connector;
        }
    }
    newEntity(def, opts, skipValidation){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, opts = args0.data, skipValidation = args0.skipValidation;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte, "LD02","Schema");
            return;
        }
        // skipValidation = skipValidation == undefined ? true : skipValidation;
        var name = def._name;
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.newRecord)(this, def, opts, skipValidation);
    }
    deleteEntity(def, key){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, key = args0.pK;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(def, key, undefined);
    }
    getEntity(def, key, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, methodType, oprName, variables){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        appIns = this.$app || this.$addon;
        if(isObj){
            def = args0.schema, 
            key = args0.pK, 
            queryParams = args0.qP, 
            cQuery = args0.cacheQuery, 
            cacheData = args0.cacheData, 
            customData = args0.customData;
            drop = args0.drop,
            forceFetch = args0.forceFetch, 
            index = args0.index;
            oprName = args0.gqlQuery;
            variables = args0.gqlVariables;
        }
        var name = def ? def._name : undefined;
        def = typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var connec = def && def.connector ? def.connector.constructor : db.applicationConnector.constructor; 
        var prm = connec.get(this,methodType ? methodType : "getEntity",def,key,queryParams,cQuery,customData,cacheData,drop,forceFetch,oprName,variables);
        var gPrm = prm.then(function(){
            var data = arguments[0][0], 
            fromCache = arguments[0][1] == "cache" ? true : false,
            xhr = arguments[0][2],
            status = xhr ? xhr.status : arguments[0][3],
            batchObj = (arguments[0][1] == "batch") ? arguments[0][2] : undefined,
            fromIDB = (arguments[0][1] == "idb") ? true : false,
            schema = def, 
            defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
            isDefinedSchema = (typeof schema !== "string" ? ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(schema ? schema.def : undefined, true) === "Schema") : false),
            name = isDefinedSchema ? schema._name : defless ? schema : undefined,
            toCacheParams = (cQuery && cQuery !== true) ? cQuery : (cQuery === true && queryParams && typeof queryParams == "object" && Object.keys(queryParams).length ) ? queryParams : undefined,
            _defless;
            
            if(!isDefinedSchema  && cacheData == undefined){
                cacheData = false;
            }
            else if(defless && !isDefinedSchema && cacheData == true){
                _defless = true;
            }  
            if(cacheData !== undefined && typeof cacheData == "object" && cacheData !== null){
                cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
            }
            if(cacheData === false){
                if(!fromCache && toCacheParams){
                    if(key != undefined){
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheRecordQuery)(db, name, key, toCacheParams, data, status);
                    }
                    else{
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheQuery)(db, name, toCacheParams, data, status);
                    }
                }
                if(batchObj != undefined){
                    db.$.batchResponse[batchObj.batch][batchObj.index] = data;
                }
                return data;
            }
            if(data){
                if(!fromCache){
                    var isEmp;
                    if(!data || !data.hasOwnProperty(name)){
                        _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte, "LD13", "get",name, (",key-"+(typeof key == "object"? JSON.stringify(key):key)+(queryParams && typeof queryParams == "object" ? ", queryParams-"+JSON.stringify(queryParams)+"":"")), (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? data: JSON.stringify(data));
                        return;
                    }						
                    // if(!fromIDB && db.idbIns){
                    //     db.idbIns.idbQ2Push(db,name,data,queryParams,methodType ? methodType : "getEntity", key); 
                    // }
                    if(!(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
                        var payLoad = data[name], pload;
                        if(key !== undefined){
                            if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty)(payLoad) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmptyObj)(payLoad)){
                                pload = data[name] = {};
                                isEmp = true;
                            }
                            if(typeof payLoad != "object" || Array.isArray(payLoad)){
                                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(db.lyte,"LD11");
                            }
                        }
                        else{
                            if(payLoad === undefined || payLoad === null || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmptyArray)(payLoad)){
                                pload = data[name] = [];
                                isEmp = true;
                            }
                            else if(!Array.isArray(payLoad)){
                                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(db.lyte,"LD19");
                            } 
                        }
                        if(!isEmp){
                            var defnd = _defless ? "id" : undefined,
                            ind = _defless && index != undefined ? index : defnd;
                            if(key !== undefined){
                                pload = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.insertIntoStore)(db, schema.def ? schema.def : schema, payLoad, true, true, undefined, ind);
                                data[name] = pload;
                            }
                            else{
                                pload = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.toInsertData)(db, schema.def ? schema.def : schema, data,true,ind);
                                data[name] = pload;
                            }
                            var nRec = pload;
                            if(pload && !Array.isArray(pload)){
								nRec =[pload];
							}
                            if(!fromIDB && db.idbIns && ((nRec && !nRec.$) || (pload && pload.$ && !pload.$.isError))){
								if(def && def.hasOwnProperty('idb')){
									db.idbIns.idbQ2Push(db, name, nRec, queryParams, methodType ? methodType : "getEntity", undefined, undefined, customData);
								}
								nRec.forEach(function(itm){
									if(itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length){
										db.idbIns.updateRelationsIDB(itm, itm.$.model.relations);
									}
								});
							}
                            if(fromIDB && Array.isArray(nRec) && nRec.length){
                                nRec.forEach(function(itm){
                                    db.idbIns.constructor.changeIDBState(db, itm);
                                });
                            }
                        }
                        if(data.hasOwnProperty("meta")){
                            if(!(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(pload) && !data[name].$){
                                data[name].$ || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(data[name], "$", {});
                            }
                            var p$ = pload.$ ? pload.$ : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(pload, "$", {});
                            p$.meta = data.meta;
                        }
                    }
                    if(!fromCache && toCacheParams){
                        if(key !== undefined){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheRecordQuery)(db, name, key, toCacheParams, data);
                        }
                        else{
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheQuery)(db, name, toCacheParams, data);								
                        }
                    }						
                }
                if(batchObj != undefined){
                    db.$.batchResponse[batchObj.batch][batchObj.index] = data[name];
                }
                if(connec.returnData == "new"){
                    var obj = {};
                    obj.data = data[name];
                    if(data.meta){
                        obj.meta = data.meta;
                    }
                    if(status !== undefined){
                        obj.status = status;
                    }
                    return obj;
                }
                return data[name];	
            }
            return arguments;
        }, function(e){
            return Promise.reject(e);
        });
        if(prm.xhr){
            gPrm.xhr = prm.xhr;
        }
        return gPrm;
    }
    getAll(def, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, oprName,variables ){
        return this.getEntity(def, undefined, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, "getAll", oprName,variables)
    }
    ajax(obj){
        var defless = this.Connector.REST.application ? this.Connector.REST.application.prototype.schemaless : undefined;
        if(defless != true){
            return Promise.reject("Schemaless behaviour is not enabled. Please enable it to make db.ajax call for not defined schemas");
        }
        if(!obj.schema){
            return Promise.reject("Schema name is mandatory for db.ajax");
        }
        if(!obj.type){
            return Promise.reject(obj.type+" is not a valid HTTP method");
        }
        var def = typeof obj.schema === "string" ? this.schema[obj.schema] : undefined;
        if(def || ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(obj.schema) === Object.getPrototypeOf(this.constructor.Schema))){
            return Promise.reject(obj.schema+" is a defined schema. db.ajax is supported only for a schema which is not defined");
        }
        var nObj = Object.assign({}, obj);
        nObj.db = this;
        return this.applicationConnector.constructor.handleAjax(nObj);
    }
    deleteMany(def, pK){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, pK = args0.pK;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(def, pK, undefined);
    }
    dropEntity(def, key){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
        _defless; 
        if(isObj){
            def = args0.schema, key = args0.pK;
        }
        def = defless && typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var parentRel = args[2];
        var schema = def;
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema");
            return;
        }
        else if(defless == true && typeof def == "string"){
            var name = def;
            schema = db.schemaless[def];
            if(!schema){
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema ",name);
                return;	
            }
            _defless = true;
        }

        if(key == undefined){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(db.lyte,"LD18","key");
        }
        var cls = def && def.def ? def.def : def; 
        var data = this.cache.getEntity(cls, key),
        pkVal;
        if(_defless == true){
            var ind = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getInd)(schema.data, schema._pK, key);
            if(ind != -1){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleArrOp)(this.lyte, schema.data, "removeAt", undefined, ind, 1);
            }
        }
        else if(data){
            pkVal = data.$.pK;
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(schema, pkVal, true, true, undefined, undefined, true, parentRel);
            def._deleted.delete(key);
            var crq = this.schema.cachedRecordQueries;
            if(crq && crq[name] && crq[name][key]){
                crq[name][key] = [];
            }
            var cqueries = db.schema.cachedQueries;	
            if(cqueries){
                var n=def._name, Nm = cqueries[n];
                if(Nm && Nm.length){
                    for(var i=Nm.length-1; i>=0; i--){
                        var obj = Nm[i];
                        if(obj && obj.data){
                            var ind = obj.data[n].indexOf(data);
                            if(ind != -1){
                                Nm.splice(i, 1);
                            }							
                        }
                    }					
                }
            }
        }
    }
    dropAll(def, arr){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
        _defless;
        if(isObj){
            def = args0.schema, arr = args0.data;
        }
        def = defless && typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var name = def ? def._name: undefined, schema = def;
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema");
            return;
        }
        else if(defless == true && typeof def == "string"){
            var name = def;
            schema = db.schemaless[def];
            if(!schema){
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema ",name);
                return;	
            }
            _defless = true;
        }
        var keys = [], 
        cls = def && def.def ? def.def : def,
        data = arr || this.cache.getAll(cls);
        if(_defless == true){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleArrOp)(this.lyte, schema.data, "removeAt", undefined, 0, schema.data.length);
        }
        else{
            if(data){
                for(var i=0; i<data.length; i++){
                    keys.push(data[i].$.pK);
                }				
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(schema, keys, true, true, undefined, undefined, true);
            this.schema[name].dirty = [];
            this.schema[name]._deleted = new Map();
            var cq = this.schema.cachedQueries;
            if(cq && cq[name]){
                cq[name] = [];
            }
			var crq = this.schema.cachedRecordQueries; 
			if(crq && crq[name]){
				crq[name] = [];
			}
        }
    }
    triggerAction(def,actionName,customData,qP,method,data){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, actionName = args0.action, qP = args0.qP, customData = args0.customData, method = args0.method, data = args0.data;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if(!def){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var actions = def.actions, action = (actions)?def.actions[actionName]:undefined;
        if(action){
            return def.connector.constructor.handleAction(this,actionName,def,this.cache.getAll(def.def),customData,qP,method,data).then(function(data){
                return data;
            },function(err){
                return Promise.reject(err);
            });
        }
        else{
            return Promise.reject({code : "ERR18", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR18});
        }
    }
    revert(def){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def=args0.schema;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        var name = def._name;
        var pK = def._pK, self = this, 
        dirty = Array.from(def.dirty),
        len = dirty.length;
        for(var i=0; i<len; i++){
            var rec = self.cache.getEntity(def.def, dirty[i]);
            if(rec && rec.$.isDeleted){
                continue;
            }
            else if(rec && rec.$.isNew){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.rollBackNew)(def, rec, pK);
            }                                
            else if(rec && rec.$.isModified){
                rec.$.revertProps(rec.$.getDirtyProps());
            }
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.rollBackDelete)(def, undefined, true);
    }
    create(def, data, customData, qP, toFilterRecords, mutationName){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, data = args0.data, customData = args0.customData, qP = args0.qP, toFilterRecords = args0.toSendData, 
            mutationName = args0.mutationName;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema ");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var name = def._name;
        if(Array.isArray(data)){
            var self = this;
            data.forEach(function(item){
                var resp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.newRecord)(self, def, item);
                if(resp.$.isError){
                    return Promise.reject(resp);
                }
            });
        }
        else if(data && typeof data == "object"){
            var self = this;
            var resp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.newRecord)(self, def, data);
            if(resp.$.isError){
                return Promise.reject(resp);
            }				
        }
        var dirty = def.dirty, len = dirty.length, created = [], err;
        for(var i=0; i<len; i++){
            var rec = this.cache.getEntity(def.def, dirty[i]);
            if(rec && rec.$.isNew){
                if(toFilterRecords && toFilterRecords.indexOf(rec) == -1){
                    continue;
                }	
                err = new _dberror__WEBPACK_IMPORTED_MODULE_4__.ValidationError(def.lyte);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.validateRecord)(this, rec, def.fieldList);
                if(rec.$.isError && Object.keys(rec.$.error).length > 0){
                    return Promise.reject(err);
                }
                created.push(rec);
            }
        }
        if(created.length){
            return _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector.create(this, name, created, false, customData, qP, mutationName);
        }
        return Promise.resolve();
    }
    update(def, customData, qP, toFilterRecords, mutationName){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, qP = args0.qP, customData = args0.customData, toFilterRecords = args0.toSendData, 
            mutationName = args0.mutationName;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var changed = [], 
        name = def._name,
        db = def.db,
        recordsChanged = [],
        records = toFilterRecords || db.cache.getAll(def.def),
        rels = def.relations,
		self = this;
        records.forEach(function(item){
            if(item.$.schema === def ){
                var rec = item,
                dirty = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isDirty)(self, rec, rels);
                if((rec && rec.$.isModified && !rec.$.isNew) || (dirty && dirty.length)){
                    var obj = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.updateJSON)(self, rec, def, dirty);
                    changed.push(obj);
                    recordsChanged.push(rec);
                }
            }
        });
        if(changed.length){
            return _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector.put(this, name, changed, recordsChanged,false, customData, qP, mutationName);
        }
        return Promise.resolve();
    }
    delete(def, key, customData, qP, toFilterRecords, mutationName){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, key = args0.pK, qP = args0.qP, customData = args0.customData, toFilterRecords = args0.toSendData, 
            mutationName = args0.mutationName;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var name = def._name;
        if(key){
            this.deleteEntity(name, key);				
        }
        var deleted = [];
        def._deleted.forEach(function(itm, idx){
            deleted.push(itm.data);
        });
        if(toFilterRecords){
            var newDel = [];
            toFilterRecords.forEach(function(itm){
                var ind = deleted.indexOf(itm);
                if(ind != -1){
                    newDel.push(itm);
                }
            });
            deleted = newDel;
        }
        if(deleted.length){
            var prm = _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector.del(this, name, deleted,undefined,"delete",customData,qP,mutationName);
            return prm.then(function(resp){
                return resp;
            }, function(e){
                return Promise.reject(e);
            });
        }
        return Promise.resolve();
    }
    clearCachedQuery(def, key, cacheQuery){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null, qP; 
        if(isObj){
            def = args0.schema, key = args0.pK, qP = cacheQuery = args0.cacheQuery;
            // key = (key == undefined && queryParams && typeof queryParams == "object") ? queryParams : key;
        }
        else{
            if( key && typeof key == "object"){
                qP = key;
                key = undefined;
            }
            else if(cacheQuery && typeof cacheQuery == "object"){
                qP = cacheQuery;
            }
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        // var qP = key && typeof key == "object" ? key : queryParams && typeof queryParams == "object" ? queryParams : undefined,
        var cachedQueries = [];
        if(!qP){
            if(def && def._name){
                var cq = this.schema.cachedQueries;
                var crq = this.schema.cachedRecordQueries;
                cq && cq.hasOwnProperty(def._name) ? delete cq[def._name] : undefined;
                crq && crq.hasOwnProperty(def._name) ? ( key ? delete crq[def._name][key] : delete crq[def._name] )  : undefined;
            }
            else{
                this.schema.cachedQueries = [];
                this.schema.cachedRecordQueries = {};
            }
            return;
        }
        if(qP){
            if(key == undefined){
                var cq = this.schema.cachedQueries;
                if(cq && cq[def._name]){
                    cachedQueries = cq[def._name];
                }
            }
            else{
                var crq = this.schema.cachedRecordQueries;
                if(crq && crq[def._name] && crq[def._name][key]){
                    cachedQueries = crq[def._name][key];
                }
            }
            for(var i=0; i<cachedQueries.length; i++){
                if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.compareData)(cachedQueries[i].cacheQuery, qP, true)){
                    cachedQueries.splice(i, 1);
                    break;
                }
            }
        }
    }
    getErrorMessage(code){
        var args = arguments, args0 = args[0], isObj = typeof code == "object" && code != null; 
        if(isObj){
            code = args0.code;
        }
        return _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes[code];
    }
    setErrorMessages(obj){
        Object.assign(_dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes, obj);
    }
    addEventListener(type,func){
        var args = arguments, args0 = args[0], isObj = typeof type == "object" && type != null; 
        if(isObj){
            type = args0.type, func = args0.func;
        }
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.evAdd)(this,type,func);
    }
    removeEventListener(id){
        var args = arguments, args0 = args[0], isObj = typeof id == "object" && id != null; 
        if(isObj){
            id = args0.id;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.evRemove)(this,id);
    }
    emit(type,args){
        var _args = arguments, args0 = _args[0], isObj = typeof type == "object" && type != null; 
        if(isObj){
            type = args0.type, args = args0.args;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.evEmit)(this,type,args);
    }
    getPrimaryKey(def){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null;
        if(isObj){
            def = args0.schema;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if(!def){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        return def._pK;
    }
    getDirtyEntities(def , filters , deepNest){
        var isObj = typeof def == "object" ? true : false; 
        if(isObj){
            var args = arguments[0];
            def = args.schema;
            filters = args.filters;
            deepNest = args.deepNest;
        }
        var model = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if(!model){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn("LD02","schema ",def._name);
            return;
        }
        var DirtyKeys = model.dirty,dirtyRecords=[],dirty={isNew :[],isModified :[],isDeleted :[]};
        for(var i_dirty = 0 ; i_dirty<DirtyKeys.length; i_dirty++){
            var record = this.cache.getEntity(def,DirtyKeys[i_dirty]);
            if(record){
                record.$.isNew?dirty.isNew.push(record):dirty.isModified.push(record);
            }
        }
        if(model._deleted.size){
            var deletedRecord = model._deleted
            deletedRecord.forEach(function(value){
                dirty.isDeleted.push(value.data);
            })
        }
        if(model.dirty || model._deleted.size){
            if(filters == undefined || filters == true){
                dirtyRecords=dirtyRecords.concat(dirty.isNew,dirty.isModified,dirty.isDeleted);
            }
            if(Array.isArray(filters)){
                filters.forEach(function(value){
                    dirtyRecords=dirtyRecords.concat(dirty[value]);
                })
            }
            if(typeof filters == "string"){
                dirtyRecords = dirty[filters];
            }
        }
        if(deepNest){
            var records =this.cache.getAll(def);
            records.forEach(function(rec){
                if(rec.$.isDirty() && !dirtyRecords.includes(rec)){
                    dirtyRecords.push(rec);
                }
            });
        }
        return dirtyRecords;
    }
}

Db.__lMod = "Db";

Db.ConnectorCls = _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector;

Db.SerializerCls = _Serializer__WEBPACK_IMPORTED_MODULE_8__.Serializer;




/***/ }),

/***/ 20810078:
/*!************************************************!*\
  !*** ./node_modules/@slyte/data/src/Entity.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$Entity": () => (/* binding */ $Entity),
/* harmony export */   "Entity": () => (/* binding */ Entity)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ 67921756);
/* harmony import */ var _dberror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dberror */ 67992299);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 33115194);
/* harmony import */ var _Connector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connector.js */ 71791193);






class Entity {
    constructor(name,data,opts){
        var def = db.getSchema(name), delayPers = opts ? opts.delayPersistence : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db, "connector", def.connector, "delayPersistence");
        Object.assign(this, data);
        Object.defineProperties(this, {
            $ : {
                writable : true,
                value : new $Entity(this, def, delayPers)
            }
        });
        var parent = db.$.saveParent;
        if(parent && this !== parent){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this.$, "parent", parent);
        }
        var defF = def._fldGrps.default;
        var watchF = def._fldGrps.watch;
        var hasManyF = def._fldGrps.hasMany;
        for(var dKey in defF){
            var dFld = defF[dKey];
            var fldVal = data[dKey];
            if(fldVal === undefined || fldVal === ""){
                this[dKey] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultVal)(this, dFld.default);
            }
        }

        for( var k in model.fieldList){
            var field= model.fieldList[k];
            if(/^(array|object)$/.test(field.type) && (field.properties || field.items)){
                (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.establishObjectBinding)(this,k,true,undefined,undefined,(field && field.watch)?field.watch:undefined);
            }
        }
    
        // for(var wKey in watchF){
        //     establishObjectBinding(this, wKey, true);
        // }
        for(var hKey in hasManyF){
            var hFld = hasManyF[hKey];
            if(this.hasOwnProperty(hKey)){
                this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];
            }
            else if(hFld.relatedTo){
                var toInit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db,"serializer", (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaObj)(db,hFld.relatedTo).serializer, "initHasManyRelation");
                if(toInit){
                    this[hKey] = [];
                }
            }
        }
        var props = def._properties;
        if(Object.keys(props).length){
            if(!this._bindings){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this, '_bindings', new Set(), false, true, true);
            }
            this._bindings.add(props);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.establishObsBindings)(this,props);
        }
    }
}

Entity.__lMod = "Entity";
class $Entity {
    constructor(ins, def, delayPers, db){
        // def = getSchemaObj(db, def);
        this.isModified = false;
        this.isNew = false;
        this.isDeleted = false;
        this.isError = false;
        this.error = {};
        this.db = db;
        this.isUnloaded = false;
        var pkVal = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getpKVal)(ins, def);
        Object.defineProperties(this, {
            events:{ 
                value : [],
                writable : true
            }, 
            validatedOnCreate:{ 
                value : true,
                writable: true
            },
            pK:{
                value: pkVal,
                writable: true
            },
            schema : {
                value : def
            },
            _attributes : {
                value : {} ,
                writable : true
            },
            _relationships : {
                value : {},
                writable : true
            },
            isDirty: {
                value: function value(){
                    var result = [];
                    var ins = this.entity;
                    if(ins.$.isModified){
                        return true;
                    }
                    result = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isDirty)(db, ins, this.schema.relations);
                    if(result.length){
                        return result;
                    }
                    return false;
                }
            },
            undoStack : {
                value : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)(),
                writable : true
            },
            redoStack : {
                value : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)(),
                writable : true
            },
            delayPersistence : {
                value : delayPers
            },
            entity: {
                value: ins
            }
        });
        this.inIDB = false;
        this.isPersisted = true;
        this.strictLock = def.db && def.db.entityStrictLock ? def.db.entityStrictLock : false; 
    }
    get(attr){
        if(this.db.lyte && this.db.lyte.$utils && this.db.lyte.get){
            return this.db.lyte.$utils._get(this.entity,attr)
        }
        else{
            if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
                return this.entity[attr];
            }
        }
    }
    set(attr, value, opts){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            if(this.isUnloaded){
                _dberror__WEBPACK_IMPORTED_MODULE_2__.ValidationError.setRecErr(this, this.schema._pK, "ERR17");
            }
            else{
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setData)(this, attr, value, opts);
            }
            return this.entity;
        }
    }
    getDirtyProps(){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var ret = [];
            var attributes = this._attributes;
            if(Object.keys(attributes).length){
                for(var key in attributes){
                    ret.push(key);
                }
            }
            return ret;
        }
    }
    revertProps(attr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            if(!Array.isArray(attr)){
                attr = [attr];
            }
            var ins = this.entity, changed = [], def = this.schema, _attrs = this._attributes;
            for(var i=0; i<attr.length; i++){
                var key = attr[i];
                if(_attrs.hasOwnProperty(key)){
                    var field = def.fieldList[key], oldVal = _attrs[key];
                    if(field.type == "relation"){
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rllBckRecArr)(def.db, oldVal && oldVal._changes ? oldVal._changes : oldVal, ins, def, field);
                        var obj = ins.$.dN && ins.$.dN.hasOwnProperty(key) ? ins.$.dN[key] : new Map();
                        for(var dnArr of obj){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deleteDeepNest)(ins, key, dnArr[0]);
                        }
                    }
                    else{
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cmpSet)( def.db.lyte, ins, key, oldVal, undefined, true );
                    }
                    changed.push(key);
                    delete _attrs[key];
                }
                _dberror__WEBPACK_IMPORTED_MODULE_2__.ValidationError.clrRecErr(this, key);
            }
            if(!Object.keys(this._attributes).length){
                if((!this.hasOwnProperty("dN") || ( this.dN && !Object.keys(this.dN).length )) && !ins.$.isNew){
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeParentNesting)(ins, undefined, "modified");
                }
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(def.db.lyte, this, "isModified", false);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.changePersist)(this.entity, true);
                if(!this.isNew){
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deleteFromArray)(def.dirty, this.get(def._pK));
                }
            }
            if(changed.length > 0){
                var arr = [ins,changed];
                this.emit("change", arr);
                def.emit("change", arr);
                this.undoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)();
                this.redoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)();
            }
        }
    }
    revert(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, pK = def._pK;
            if(state){
                this.revertToState(state);
            }
            else {
                if(this.isModified){
                    this.revertProps(this.getDirtyProps());
                    delete this._savedState;
                }
                if(this.isDeleted){
                    // var index = getInd(model._deleted, pK, this.get(pK));
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rollBackDelete)(def, this.get(pK));
                }
                else if(this.isNew){
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rollBackNew)(def, this.entity, pK);
                }			
                else if(this.isError){
                    _dberror__WEBPACK_IMPORTED_MODULE_2__.ValidationError.clrRecErr(this);
                }
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeOnSave)(def.db, this.schema._name, this.entity.$.pK);
        }
    }
    delete(delayPers){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, ins = this.entity, 
            delayPers = ( delayPers !== undefined ) ? delayPers : (ins.$.delayPersistence ? ins.$.delayPersistence.delete : false); 
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromStore)(def, ins.$.pK, undefined, undefined, delayPers);
        }
    }
    destroy(customData,qP,delayPers){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            this.delete(delayPers);
            return this.save(customData,qP,"destroyRecord");
        }
    }
    addEventListener(type, func){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evAdd)(this, type, func);
        }
    }
    removeEventListener(id){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evRemove)(this,id);
        }
    }
    emit(type, args){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evEmit)(this,type,args);
        }
    }
    triggerAction(actionName,customData,qP,method,data){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, 
			db = def.db,
			actions = def.actions, 
			action = (actions) ? actions[actionName] : undefined;
            if(action){
                return def.connector.constructor.handleAction(db,actionName,def,this.entity,customData,qP,method,data);
            }
            return Promise.reject({code : "ERR18", message : _dberror__WEBPACK_IMPORTED_MODULE_2__.Dberror.errorCodes.ERR18, data : actionName});
        }
    }
    save(customData,qP,options,destroy,mutationName){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, 
			db = def.db,
			ins = this.entity, 
			dirty = this.isDirty(), 
			validateOnSave = options && options.validateOnSave, 
			skipValidation = options && options.skipValidation, 
			fields = def.fieldList, 
			ret;
            if(this.isUnloaded !== true){
                if(this.isDeleted){
                    if(!this.isNew){
                        return _Connector_js__WEBPACK_IMPORTED_MODULE_3__.Connector.del(db, def._name, ins, true, destroy, customData, qP, mutationName);
                    }
                }
                else if(this.isNew){
                    var err = this;
                    if(!skipValidation && (!ins.$.validatedOnCreate || validateOnSave)){
                        ret = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateRecord)(db, this.entity, fields);
                    }
                    if(!skipValidation && (ret == false || (err && err.error && Object.keys(err.error).length > 0))){
                        return Promise.reject(err.error);
                    }
                    return _Connector_js__WEBPACK_IMPORTED_MODULE_3__.Connector.create(db, def._name, ins, true , customData, qP, mutationName);
                }
                else if(this.isModified || (dirty && dirty.length) ){
                    var data = {};
                    if(!skipValidation && (options && validateOnSave)){
                        ret = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateRecord)(db, this.entity, fields);
                    }
                    if(!skipValidation){
                        if(ret == false || (ins && ins.$ && ins.$.isError)){
                            return Promise.reject(ins.$.error);
                        }
                    }
                    var data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateJSON)(db, this.entity, def, dirty);
                    return _Connector_js__WEBPACK_IMPORTED_MODULE_3__.Connector.put(db, def._name, data, ins, true, customData, qP, mutationName);
                }
            }
            else{
                _dberror__WEBPACK_IMPORTED_MODULE_2__.Dberror.warn(db.lyte,"LD29", typeof ins.$.pK == "object" ? JSON.stringify(ins.$.pK) : ins.$.pK, def._name)
				var rejectUnloadRecordSave = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db, "connector", def.connector, "rejectUnloadRecordSave");
				if(rejectUnloadRecordSave){
					return Promise.reject({code: "ERR28", message: _dberror__WEBPACK_IMPORTED_MODULE_2__.Dberror.errorCodes.ERR28, data: ins});
				}
			}
            return Promise.resolve();
        }
    }
    getInitialValues(attr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var isAttrPassed = false;
            if(attr){
                if(!Array.isArray(attr)){
                    attr = [attr];
                }
                isAttrPassed = true;
            }
            else{
                attr = this.getDirtyProps();
            }
            var ret = {}, rec = this.entity, _attrs = this._attributes;
            for(var i=0; i<attr.length; i++){
                if(rec[attr] == undefined || !rec[attr[i]].add){
                    ret[attr[i]] = _attrs[attr[i]];					
                }
                else{
                    ret[attr[i]] = rec[attr[i]].slice(0);
                    var arr = _attrs[attr[i]] && _attrs[attr[i]]._changes ? _attrs[attr[i]]._changes : [], 
                    isPoly = rec[attr[i]].polymorphic,
                    pK = !isPoly ? rec[attr[i]].schema._pK : undefined;
                    for(var j=arr.length-1; j>=0; j--){
                        if(arr[j]._type == "added"){
                            for(var k=0; k<arr[j].records.length; k++){
                                var index = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getInd)(ret[attr[i]], !isPoly ? pK : arr[j].records[k].$.schema._pK, arr[j].records[k].$.pK);
                                if(index == -1){
                                    continue;
                                }
                                ret[attr[i]].splice(index, 1);
                            }
                        }
                        else if(arr[j]._type == "removed"){
                            for(var k=arr[j].records.length-1; k>=0; k--){
                                ret[attr[i]].splice(arr[j]._indices[k], 0, arr[j].records[k]);
                            }
                        }
                        else if(arr[j]._type == "changed"){
                            ret[attr[i]] = Array.isArray(arr[j].records) ? Array.from(arr[j].records) : arr[j].records;
                        }
                    }
                }
            }
            if(isAttrPassed){
                return ret[attr[0]];
            }
            return ret;
        }
    }
    toJSON(type){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var db = this.schema.db,addNotDefinedFields,
            parentRel = arguments[1];
            if(typeof type == "object" && type.hasOwnProperty("addNotDefinedFields")){
                addNotDefinedFields = type.addNotDefinedFields?true:false
                type = undefined;
            }
            return Object.assign({}, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toJSON)(db, this.schema._name, this.entity, !type ? true : type, undefined, undefined, parentRel,addNotDefinedFields));
        }
    }
    undo(attr, state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var currentState = this.undoStack._order_.length;
            state = state || (currentState ? currentState - 1 : currentState);
            // state = state || 0;
            while(currentState-- > state){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.unredoOp)(1, this, attr);
            }
        }
    }
    getCurrentState(){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            return this.undoStack._order_.length;
        }
    }
    redo(attr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.unredoOp)(2,this,attr);
        }
    }
    validate(arr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var fields = {};
            var def = this.schema;
            var fieldList = def.fieldList;
            if(Array.isArray(arr)){
                arr.forEach(function(item, index){
                    if(fieldList[item]){
                        fields[item] = fieldList[item];
                    }
                });
            }
            if(Object.keys(fields).length == 0){
                fields = fieldList;
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateRecord)(def.db, this.entity, fields);				
        }
    }
    saveState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var fromRel = arguments[1];
            var parentRel = arguments[2];
            if(!fromRel){
                if(!this.isNew && !this.isModified){
                    _dberror__WEBPACK_IMPORTED_MODULE_2__.Dberror.warn(this.db.lyte,"LD20");
                    return;
                }
                var savedState = this._savedState = this._savedState || {};
                var currentState = state, randomState;
                while(!currentState){
                    randomState = Math.floor(Math.random()*100000 + 1);
                    currentState = !savedState.hasOwnProperty(randomState) ? randomState : currentState;
                }
            }
            var obj = this.toJSON("state", parentRel);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(obj, "$", {}, false, true);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(obj.$, "isSavedState", true, false, true);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(obj.$, "pK", this.entity.$.pK, false, true);
            var pK = this.schema._arrPk;
            pK.forEach(function(val){
                delete obj[val];
            });
            var undoStack = this.undoStack;
            var redoStack = this.redoStack;
            var _attributes = this._attributes;
            // var dN = this.entity.$.dN;
            if(undoStack && Object.keys(undoStack).length){
                var _order = undoStack._order_;
                undoStack = obj.$.undoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepCopyStack)(undoStack);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(undoStack, "_order_", (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(_order), false, true);
            }
            if(redoStack && Object.keys(redoStack).length){
                var _order = redoStack._order_;
                redoStack = obj.$.redoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepCopyStack)(redoStack);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(redoStack, "_order_", (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(_order), false, true);
            }			
            if(_attributes && Object.keys(_attributes).length){
                obj.$._attributes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepCopyAttrs)(this.schema, _attributes);
            }
            if(!fromRel){
                this._savedState[currentState] = obj; 
                return currentState;
            }else{
                return obj;	
            }
        }
    }
    clearState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            if(!state){
                this._savedState = {};
                return;
            }
            delete this._savedState[state];
        }
    }
    revertToState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var savedSt = this._savedState
            var obj = savedSt ? savedSt[state] : undefined;
            if(!obj){
                _dberror__WEBPACK_IMPORTED_MODULE_2__.Dberror.warn(this.db.lyte, "LD21", state);
                return;
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setState)(this, obj);
            delete this._savedState[state];
        }
    }
    hasSavedState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            return this._savedState && this._savedState.hasOwnProperty(state) ? true : false;
        }
    }
    clone(){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var parentRel = arguments[0];
            var obj = this.toJSON("clone", parentRel);
            return this.schema.db.newEntity(this.schema.def, obj);
        }
    }
    persist(obj){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var schema = this.schema, 
			name = schema._name,
			db = schema.db, 
			ins = this.entity, 
			partialObj = {obj:new Map()}, 
            type, 
            dirty;
            if(this.isNew){
                type = "create";
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toJSON)(db, name, ins, undefined, "create", partialObj);
            }
            else if(dirty = this.isDirty()){
                var data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateJSON)(db, ins, this.schema, dirty);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toJSON)(db, name, data, undefined, undefined, partialObj);
            }
            var pObj = partialObj.obj.get(this.pK);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeResponse)(db, ins, this.schema, undefined, this.pK, pObj, true);
            if(db.idbIns){
                db.idbIns.updateIDB(db, name, type ? type : ins.$.isDeleted ? "deleteEntity" : ins.$.isModified || dirty ? "updateEntity" : undefined, ins);
            }
        }
    }
}
$Entity.__lMod = "$Entity";
(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(Entity, "strictValueSet", true);
(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(Entity, "strictRelSet", true);


/***/ }),

/***/ 62765273:
/*!*******************************************************!*\
  !*** ./node_modules/@slyte/data/src/RESTConnector.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RESTConnector": () => (/* binding */ RESTConnector)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 67921756);
/* harmony import */ var _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RESTSerializer.js */ 35623115);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);
/* harmony import */ var _Connector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Connector.js */ 71791193);




/*convert to custom class*/
class RESTConnector extends _Connector_js__WEBPACK_IMPORTED_MODULE_0__.Connector {
    static register(parent){
    }
    constructor(db){
        super();
        this.host = window.location.origin ? window.location.origin : window.location.protocol+"//"+window.location.host;
        this.namespace = "";
        this.actionNamespace = "action";
        this.batchNamespace = "batch";
        this.__type = "REST";
        var lIns = db.lyte, 
        name = this.constructor._name;
        Object.defineProperty(this,'$lg', {
            value : lIns.__gl
        });   
        if(!db.getConnectorObj(name)){
            db.connector.REST = db.connector.REST || {}; 
            db.connector.REST[this.constructor._name] = this; 
        }
    }

    // static sendXHR(db,name,type,key,urlObj,customData,argsObj,opts){
    //     var xhr = new XMLHttpRequest();
    //     var prm = new Promise(function(res, rej){
    //         argsObj.xhr = xhr;
    //         xhr.open(urlObj.method, urlObj.url, true);
    //         for(var header in urlObj.headers){
    //             xhr.setRequestHeader(header, urlObj.headers[header]);
    //         }
    //         if(urlObj.data !== undefined && ( urlObj.headers && !urlObj.headers.hasOwnProperty("Content-Type") && urlObj.method !== "GET")){
    //             xhr.setRequestHeader("Content-Type", "application/json");
    //         }
    //         xhr.withCredentials = (urlObj.withCredentials)?true:false;
    //         initCB(db,"connector", name, RESTConnector.PARSEREQUEST, { argsObj: argsObj, args:[type, name, xhr ,urlObj ? urlObj.qP : undefined, key, customData]});
    //         db.emit("beforeRequest", [xhr, name, type, key, urlObj.qP]);
    //         xhr.send(urlObj.data);
    //         xhr.onreadystatechange = function(){
    //             if(xhr.readyState == 4){
    //                 db.emit("afterRequest",[xhr, name, type, key, urlObj.qP]);
    //                 argsObj.status = xhr.status;
    //                 RESTConnector.processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts).then(function(data){
    //                     return res({data:data, xhr:xhr});
    //                 }, function(err){
    //                     return rej({data:err, xhr:xhr});
    //                 });
    //             }
    //         }
    //     });
    //     prm.xhr = xhr;
    //     return prm;
    // }
    static getHost(db, connector){
        
    }
    static buildURL(db,type,method,def,key,snapshot,queryParams,actionName,customData,url,argsObj){
        var adapter, name;
        if(def !== undefined){
            adapter = def.connector, name = def._name;
        }
        var schemaless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
        if(typeof def == "string" && schemaless){
            name = def;
        }
        var host = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",adapter,"host"), 
        url = url || "", 
        makeBatch = db.$.makeBatch;
        argsObj.host = host;
        if(!url){
            if(!makeBatch){
                if(host !== undefined){
                    url += host;
                    if(host[host.length-1] != "/"){
                        url+="/";					
                    }
                }
            }
            var namespace = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",adapter,"namespace");
            if(namespace !== "" && namespace[namespace.length-1] != "/"){
                url+=namespace+"/";
                argsObj.namespace = namespace;
            }
            else{
                url+=namespace;
            }
            if(type != "batch"){
                if(def.endPoint){
                    url +=def.endPoint
                }
                else{
                    url+=name;
                }
                if(key && typeof key != "object"){
                    url+="/"+key;
                }	
            }
            if(type == "action" && def){
                var actionNamespace = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",adapter,"actionNamespace");
                if(actionNamespace !== "" && actionNamespace[actionNamespace.length-1] != "/"){
                    url+="/"+actionNamespace;
                }
                else{
                    url+=actionNamespace;
                }
                // url+="/"+getFromCB(db,"connector",adapter,"actionNamespace");
                var actions = def.actions, action = actions[actionName].endPoint ? actions[actionName].endPoint : actionName;
                url+="/"+action;
                argsObj.actionName = action;
            } else if(type == "batch"){
                url+=(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",undefined,"batchNamespace");
            }
        }
        if(!queryParams){
            queryParams = {};
        }
        var ret = {method : (method)? method : ""}, res;
        argsObj.url = url;
        argsObj.method = ret.method;
        argsObj.queryParams = queryParams;
        res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", adapter, RESTConnector.REQUESTHEADERS, { argsObj: argsObj, args:[type, queryParams, customData, actionName, key]});
        if(res){
            ret.headers = res.data;
        }
        argsObj.headers = ret.headers;
        argsObj.cachedData = snapshot;
        res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", adapter, RESTConnector.REQUESTURL, { argsObj: argsObj, args:[name, type, queryParams, snapshot, url,actionName,customData, key]});
        if(res){
            url = res.data;
        }
        argsObj.url = url;
        res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", adapter, RESTConnector.REQUESTMETHOD, { argsObj: argsObj, args:[method, type, queryParams, customData, actionName, key]});
        if(res){
            ret.method = res.data;
        }
        argsObj.method = method;
        if(!makeBatch && Object.keys(queryParams).length){
            url+="?";
            var index = 0;
            for(var qKey in queryParams){
                if(index !== 0){
                    url+="&";
                }
                var res = queryParams[qKey];
                if(res && typeof res == "object"){
                    res = JSON.stringify(res);
                }
                url+=qKey+"="+encodeURIComponent(res);
                index++;
            }
        }
        if(adapter && adapter.withCredentials == true){
            ret.withCredentials = true;
        }
        ret.url = url;
        ret.qP = queryParams;
        return ret;
    }
    static get(db, type, def, key, queryParams, cacheQuery, customData, cacheData, unload, forceFetch){
        var name = def && def._name ? def._name : def, 
        argsObj = { type: type, schemaName : name, queryParams: queryParams, opts:{cacheData:cacheData !== undefined ? cacheData : true, cacheQuery:cacheQuery!== undefined ? cacheQuery : false, unload: unload!==undefined?unload:false, forceFetch: forceFetch!==undefined?forceFetch:false }, customData: customData, key: key}, 
        mdl = def,
        makeBatch = db.$.makeBatch, 
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
        if(defless && typeof def == "string"){
            var defobj = db.schemaless, _name = def; 
			def = defobj[_name] = defobj[_name] || {};
            def._name = _name;
        }
        if(mdl || ( typeof mdl == "string"  && defless === true)){
            RESTConnector.getConnector(db, def, argsObj, defless);
            RESTConnector.getSerializer(db, def, argsObj, defless);
            if(unload){
                if(key !== undefined){
                    db.dropEntity(def.def, key);
                }
                else{
                    db.dropAll(def.def);
                }
            }
            customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", mdl.connector, "customData") : customData;
            var urlObj = this.buildURL(db, type, "GET", def, key, undefined, queryParams,undefined,customData,undefined,argsObj), 
            self = this,
            queryParams = urlObj.qP, 
            toCheckParams = (cacheQuery && typeof cacheQuery !== "boolean") ? cacheQuery : (queryParams && typeof queryParams == "object") ? queryParams : undefined;
            if(key == undefined && toCheckParams && db.schema.cachedQueries && db.schema.cachedQueries[name] && !forceFetch){
                var cachedQueries = db.schema.cachedQueries[name], 
                sendData;
                for(var i=0; i<cachedQueries.length; i++){
                    var qry = cachedQueries[i];
                    if(!qry.hasDeletedRecords){
                        var params = qry.cacheQuery;
                        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.compareData)(params, toCheckParams, true)){
                            sendData = [qry.data, "cache", undefined, qry.status];
                            break;
                        }
                    }
                }
                if(sendData){
                    return new Promise(function(resolve){
                        if(makeBatch){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addToCachedBatch)(db,Array.isArray(sendData) ? sendData[0][name] : sendData);
                        }
                        resolve(sendData);
                    });
                }
            }
            else if(key !== undefined && toCheckParams && db.schema.cachedRecordQueries && db.schema.cachedRecordQueries[name] && db.schema.cachedRecordQueries[name][key] && !forceFetch){
                var cachedQueries = db.schema.cachedRecordQueries[name][key], 
                sendData;
                for(var i=0; i<cachedQueries.length; i++){
                    var params = cachedQueries[i].cacheQuery;
                    if((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.compareData)(params, toCheckParams, true)){
                        sendData = [cachedQueries[i].data, "cache", undefined, cachedQueries[i].status];
                        break;
                    }
                }
                if(sendData){
                    return new Promise(function(resolve){
                        if(makeBatch){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addToCachedBatch)(db,Array.isArray(sendData) ? sendData[0][name] : sendData);
                        }
                        resolve(sendData);
                    });
                }
            }
            else if(!forceFetch){
                var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db, def.connector, type == "getAll" ? RESTConnector.REFETCHALL : RESTConnector.REFETCH, "connector");
                if(scope){
                    var data, callRefetch = false;
                    if(key !== undefined){
                        data = db.cache.getEntity(mdl.def,key);		
                        callRefetch = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? true : false; 					
                    }
                    else{
                        data = db.cache.getAll(mdl.def);
                        callRefetch = data && data.length ? true : false;
                    }
                    argsObj.cachedData = data;
                    if(callRefetch && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj])){
                        var toRet = {};
                        toRet[name] = data;
                        return new Promise(function(resolve){
                            if(makeBatch){
                                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addToCachedBatch)(db,toRet[name]);
                            }
                            resolve([toRet, "cache"], "success", undefined, true);
                        });
                    }
                }
            }
            if(urlObj.method == "POST"){
                var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", mdl.serializer, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.SERIALIZE, { argsObj: argsObj, args:[type,undefined,undefined,customData,name,queryParams]});
                if(res){
                    urlObj.data = res.data;
                    if(urlObj.data && (typeof urlObj.data == "object" || (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){
                        // urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
                        urlObj.data = JSON.stringify(urlObj.data);
                    }
                    argsObj.data = urlObj.data;
                }
            }
            var prmXhr;
            var prm = new Promise(function(resolve, reject){
                var idbObj = def ? def.idb : undefined, 
                processRequest = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def ? def.connector : undefined, RESTConnector.PROCESSREQUEST),payLoad, sendXHR = true, 
                batchPro = false, 
                opts = { cacheQuery : cacheQuery, cacheData : cacheData, customD : customData},
                argsXHR = [db,name,type,key,urlObj,customData,argsObj,opts];
                if(processRequest){
                    sendXHR = false;
                    var returnPromise = self.callGeneric(db,type,def,undefined,undefined,customData, queryParams,key,urlObj.url,undefined,urlObj.method,urlObj.headers,argsObj);
                    if(returnPromise instanceof Promise){
                        batchPro = true;
                        returnPromise.then(function(resp){
                            resp = (resp == "" ? JSON.parse("{}") : JSON.parse(resp));
                            payLoad = _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.getResponse(db,resp,def,type,key,urlObj,undefined,customData,opts,argsObj);
                            resolve([payLoad]);
                        },function(message){
                            reject(message);
                        });
                    }
                    else{
                        sendXHR = true;
                    }
                }
                if(makeBatch && !batchPro){
                    RESTConnector.constructBatch.apply(RESTConnector, argsXHR).then(function(resObj){
                        var payLoad = resObj.content;
                        RESTConnector.getSuccess(db,def,type,key,urlObj,undefined,resolve,reject,payLoad,resObj,undefined,opts,argsObj);
                    },function(resObj){
                        RESTConnector.getFailure(db,def,type,key,urlObj,undefined,resolve,reject,opts,resObj.content,resObj.code,argsObj,resObj);
                    });
                }
                else if(idbObj && db.idbIns){
                    db.idbIns.getFromIDB(idbObj, name, type, queryParams, key, urlObj).then(function(payLoad){
                        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.IDBRESPONSE, { argsObj: argsObj, args:[name, type, queryParams, key, payLoad]});
                        if(res){
                            payLoad = res.data;
                        }
                        if(payLoad == false){
                            var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);
                            xhrPrm.then(function(resp){
                                RESTConnector.getSuccess(db,def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);
                            }, function(resp){
                                RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);
                            });	
                            prmXhr = xhrPrm.xhr;						
                        }
                        else{
                            RESTConnector.getSuccess(db, def,type,key,urlObj,undefined,resolve,reject,payLoad,undefined,"idb",opts,argsObj);
                        }
                    },function(message){
                        var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);
                        xhrPrm.then(function(resp){
                            RESTConnector.getSuccess(db, def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);
                        }, function(resp){
                            RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);
                        });		
                        prmXhr = xhrPrm.xhr;					
                    });
                }
                else if(sendXHR){
                    var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);
                    xhrPrm.then(function(resp){
                        RESTConnector.getSuccess(db, def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);
                    },function(resp){
                        RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);
                    });
                    prmXhr = xhrPrm.xhr;
                }
            });
            if(prmXhr){
                prm.xhr = prmXhr;
            }
            return prm;
        }
        else {
            Dberror.error(db.lyte,"LD02","Schema",name);
            return Promise.reject({code : "ERR19", message : Dberror.errorCodes.ERR19, data:name});
        }
    }
    static create(db, name, data, isSingleRecord, customData, qP){
        var type= isSingleRecord ? "createEntity": "create", 
        def = db.schema[name], 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData};
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def.connector, "customData") : customData;
        var urlObj = this.buildURL(db, type, "POST", def, undefined, data,qP,undefined,customData,undefined,argsObj);
        qP = urlObj.qP;
        var partial = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initPartialObj)(db, name, type, qP, undefined, urlObj.url, customData, argsObj);
        var changedData = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(db, name, data, undefined, "create", partial);
        _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.sendingData(db, name, changedData, urlObj, type, customData, data, argsObj);
        return this.handleRequest(db, urlObj, name, data, type, changedData, customData, partial.obj, undefined, undefined, partial.ref, argsObj);
    }
    static put(db, name, data, record, isSingleRecord,customData, qP){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = (isSingleRecord) ? "updateEntity" : "update", 
        partialObj = new Map(), 
        key = isSingleRecord ? (isComp && bK ? record[bK] : record.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def.connector, "customData") : customData;
        var urlObj = this.buildURL(db, type, "PATCH", def, key, data, qP, undefined, customData, undefined, argsObj);
        qP = urlObj.qP;
        var partial = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initPartialObj)(db, name, type, qP, key, urlObj.url, customData, argsObj);
        var updatedData = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(db, name, data, undefined, undefined, partial);
        _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.sendingData(db, name, updatedData, urlObj, type, customData, record, argsObj);
        return this.handleRequest(db, urlObj, name, record, type, updatedData, customData, partial.obj,key, undefined, partial.ref, argsObj);
    }
    static del(db, name, data, isSingleRecord, destroy, customData, qP){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = destroy || "deleteEntity", 
        key = isSingleRecord ? (isComp && bK ? data[bK] : data.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def.connector, "customData") : customData;
        var urlObj = this.buildURL(db, type, "DELETE", def, key, data,qP,undefined,customData,undefined,argsObj);
        qP = urlObj.qP;
        var partial = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initPartialObj)(db, name, type, qP, key, urlObj.url, customData, argsObj);
        var ids = [];
        if(!isSingleRecord){
            ids = data.map(function(val){
                return val.$.pK;
            });				
        }
        var pkVal = (isSingleRecord) ?  (data ? data.$.pK : undefined) : ids;
        _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.sendingData(db, name, pkVal, urlObj, type, customData, data, argsObj);
        return this.handleRequest(db, urlObj, name, data, type, pkVal, customData, undefined, key, undefined, undefined, argsObj);
    }
    static handleAjax(obj){
        if(obj.url){
            if(!obj.schema){
                Dberror.error(obj.db.lyte,"Please pass schema param to db.ajax call");
                return Promise.reject("Please pass schema param to db.ajax call");
            }
        }
        var argsObj = { type: "ajax", schemaName : obj.schema, queryParams: obj.queryParams, customData: obj.customData}
        var urlObj = RESTConnector.buildURL(obj.db, "ajax", obj.type, obj.schema, obj.index, undefined, obj.queryParams, undefined, obj.customData, obj.url, argsObj);
        urlObj.data = obj.data;
        var qP = urlObj.qP, res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(obj.db,"serializer", obj.schema, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.SERIALIZE, { argsObj: argsObj, args:["ajax",urlObj.data,undefined,obj.customData,obj.schema,qP,undefined]});
        if(res){
            argsObj.data = urlObj.data = res.data;
        }
        return RESTConnector.handleRequest(obj.db, urlObj, obj.schema, undefined, "ajax",undefined,obj.schema,undefined,undefined,undefined,undefined,argsObj);
    }
    static handleAction(db,actionName,def,record,customData,qP,method,data){
        var pkVal;
        if(record && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record)){
            pkVal = record.$.get(def._pK);				
        }
        var name = def._name, 
        type = "action", 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, actionName:actionName}
        RESTConnector.getConnector(db, def, argsObj);
        RESTConnector.getSerializer(db, def, argsObj);
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def ? def.connector : undefined, "customData") : customData;
        var urlObj = this.buildURL(db,type, method ? method : "POST", def, pkVal, record, qP, actionName, customData, undefined, argsObj);
        argsObj.data = urlObj.data = data, qP = urlObj.qP;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.SERIALIZE, { argsObj: argsObj, args:["action",data,record,customData,name,qP,actionName]});
        if(res){
            argsObj.data = urlObj.data = res.data;
        }
        return this.handleRequest(db, urlObj, def._name, undefined, type,undefined,customData,undefined,undefined,actionName,undefined,argsObj);
    }
    static callGeneric(db, type, def, data, record, customData, queryParams, key, url, actionName, method, headers, argsObj){
        var name = def && def._name ? def._name : def;
        argsObj.cachedData = record;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def.connector, RESTConnector.PROCESSREQUEST, {argsObj:argsObj, args:[type,name,data,record,customData,queryParams,key,url,actionName,method,headers]});
        return res ? res.data : undefined;
    }
    static handleBatchPromise(obj){
        var response = obj.response,
        db = obj.db, 
        batch = obj.batch, 
        fail = obj.fail;
        //callback
        obj.argsObj.payLoad = response;
        if(!fail){
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", undefined, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.NORMALIZE, {argsObj:obj.argsObj, args:[undefined,"batch",obj.response]});
            if(res){
                response = res.data;
            }
    
            var resp = response.batch_requests;
            resp.forEach(function(item, index){
                var pro = db.$.batchPromise[batch][index];
                var status = item.status.toString();
                var code = status[0];
                if(code == "2"){
                    pro.resolve({content:item.content,index:index,batch:batch,resp:item});
                }
                else if(code == "4" || code == "5"){
                    db.$.batchResponse[batch][index] = undefined;
                    pro.reject({content:item.content,index:index,batch:batch,resp:item,code:status});
                }
            });
        }
        else{
            var prmArr = db.$.batchPromise[batch];
            prmArr.forEach(function(itm, idx){
                itm.reject({content:{}, index: idx, batch:batch, code:"400",resp:{}})
            });
        }
        // obj.resolve(response);
        delete db.$.batch[batch];
        delete db.$.batchPromise[batch];
    }
    static constructBatch(db,name,type,key,urlObj,customData){
        return new Promise(function(resolve, reject){
            var batch = db.$.currentBatch;
            var q = db.$.batch[batch] = db.$.batch[batch] || [];
            var pro = db.$.batchPromise[batch] = db.$.batchPromise[batch] || []; 
            var batchObj = {};
            batchObj.method = urlObj.method;
            batchObj.uri = "/" + urlObj.url;
            batchObj.parameters = urlObj.qP;
            batchObj.content = typeof urlObj.data == "string" ? JSON.parse(urlObj.data) : undefined;
            q.push(batchObj);
            pro.push({resolve:resolve,reject:reject});	
        });
    }
}
RESTConnector.__lMod = "RESTConnector";
RESTConnector.returnData = "old";
RESTConnector.PARSEREQUEST = "parseRequest";
RESTConnector.REQUESTURL = "requestURL";
RESTConnector.REQUESTHEADERS = "requestHeaders";
RESTConnector.REQUESTMETHOD = "requestMethod";
RESTConnector.REFETCHALL = "refetchAll";
RESTConnector.REFETCH = "refetchEntity"
RESTConnector.PROCESSREQUEST = "processRequest";
RESTConnector.PARSERESPONSE = "parseResponse";

RESTConnector.JSON = /application\/json/;
RESTConnector.TEXT = /text\/plain/;
RESTConnector.__extendedBy = [];


/***/ }),

/***/ 35623115:
/*!********************************************************!*\
  !*** ./node_modules/@slyte/data/src/RESTSerializer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RESTSerializer": () => (/* binding */ RESTSerializer)
/* harmony export */ });
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Serializer */ 85831899);


/*convert to custom class*/
class RESTSerializer extends _Serializer__WEBPACK_IMPORTED_MODULE_0__.Serializer {
    static register(parent){
        // this.__class = RESTSerializer;
        // var name = this._name = dbModName(this.name, "Serializer");
    }
    constructor(db){
        super();
        this.__type = "REST";
        var lIns = db.lyte,
        name = this.constructor._name;
        Object.defineProperty(this,'$lg', {
            value : lIns.__gl
        });
        this.deserializeEmptyData = true;
        if(!db.getSerializerObj(name)){
            db.serializer.REST = db.serializer.REST || {}; 
            db.serializer.REST[name] = this; 
        }
    }
}

RESTSerializer.__lMod = "RESTSerializer";

RESTSerializer.PROCESSENTITY = "processEntity";

RESTSerializer.NORMALIZE = "normalizePayload";

RESTSerializer.SERIALIZE = "serializePayload";

RESTSerializer.SERIALIZEKEY = "serializeKey";

RESTSerializer.NORMALIZEKEY = "normalizeKey";

RESTSerializer.SERIALIZEENTITY = "serializeEntity";

RESTSerializer.NORMALIZEENTITY = "normalizeEntity";

RESTSerializer.DESERIALIZEKEY = "deserializeKey";

RESTSerializer.GETMETA = "getMeta";

RESTSerializer.IDBRESPONSE = "idbResponse";

RESTSerializer.REFERENCEKEY = "referenceKey";

RESTSerializer.__extendedBy = [];



/***/ }),

/***/ 79928624:
/*!************************************************!*\
  !*** ./node_modules/@slyte/data/src/Schema.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Schema": () => (/* binding */ Schema)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ 67921756);
/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Entity.js */ 20810078);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 33115194);
/* harmony import */ var _dberror_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dberror.js */ 67992299);






class Schema {
    static observers(arg){
        return arg;
    }
    static actions(arg){
        return arg;
    }
    static prop(type, opts){
        if(opts && typeof opts !== "object"){
            console.error("second param should be a object");
        }
        opts = opts || {};
        var obj = Object.assign({},opts);
        obj.type = type;
        return obj;
    }
    static register(opts){
        var rHash = opts.refHash;
        var schCls = this, 
        dbMap = Schema.db = Schema.db || new Map(),  
        schMap,
        schClsName = schCls.name;
        if(!dbMap.has(rHash)){
            dbMap.set(rHash, new Map());
        }
        schMap = dbMap.get(rHash);
        if(!schMap.has(schClsName)){
            schMap.set(schCls.name, schCls);
        }
        Schema.triggerEvent(rHash, schCls);
    }
    static registerInDb(opts, parent){
        this.__class = Schema;
        var name;
        if(this.schemaName){
            name = this._name = this.schemaName;
        }   
        else{
            name = opts && opts.name? opts.name : this.name;
            name = this._name = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dbModName)(name, "Schema", opts && opts.name ? false : true);
        }
        parent = parent || Object.getPrototypeOf(this);
        if(!parent.schema.hasOwnProperty(name)){
            parent.schema[name] = this;
            this.opts = opts;
            if(parent.schema.triggerEvent){
                parent.schema.triggerEvent("add", name, this);
            }
        }
        else{
            _dberror_js__WEBPACK_IMPORTED_MODULE_1__.Dberror.warn("Schema with the same name - "+ name+ " already present in the db");
        }        
    }
    static create(db, lIns){
        var _this = {}, 
        parent = Object.getPrototypeOf(this);
        parent = parent !== db.constructor.Schema && parent !== Schema ? parent : undefined;
        (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(_this);
        Object.defineProperty(_this, "emit", {
            value: function(name, args){
                var arr = Array.isArray(args) ?  Array.from(args) : [];
                arr.splice(0, 0, name);
                _this.triggerEvent.apply(this, arr);
            }
        });
        var name = _this._name = this._name;
        var delay = this.opts && this.opts.delay ? this.opts.delay : undefined;
        _this.db = db;
        _this.Lyte = lIns;
        _this.__class = Schema;
        _this.fieldList = {id : {type : "string", primaryKey : true, defined : false}};
        _this.relations = new Map();
        _this._properties = {};
        _this._fldGrps = { default : {}, hasMany: {}, watch: {}, inherit:{} ,nested_prop: {}, reverseKey: new Map() , JsonPathWatch : {} };
        _this.data = [];
        _this.dirty = [];
        _this._deleted = new Map();
        _this.events = {};
        _this.def = this;
        _this.endPoint = this.endPoint;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(_this.data, "_recMap", new Map());
		// _defProp(_this, "db", db);
        
        var obs = [], self = _this, _self = this;
        function _props(){
            delete self._pK;
            delete self._arrPk;
            var parentProps = {};
            if(parent && parent.props){
                parentProps = parent.props(lIns);
                for(var key in parentProps){
                    if(parentProps[key].type == "relation"){
                        delete parentProps[key];
                    }
                }
            }
            var fields = Object.assign(parentProps, _self.prototype.props(lIns));            
            for(var key in fields){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.registerField)(db,self,key,fields[key],obs);
            }
            if(!self._pK){
                self._pK = 'id';
            }    
            self.isComp = false;
            var splt = self._pK.split(',');
            if(splt.length > 1){
                self.isComp = true;
            }
            self._arrPk = splt;    
            // delete _self.prototype.props;    
        }
        var self = _this;
        db.schema[_this._name] = _this;
        if(this.prototype.props){
            if(delay){
                setTimeout(_props,1)
            }
            else{
                _props();
            }
        }
        if(this.prototype.actions){
            var parentAct = {};
            if(parent && parent.actions){
                parentAct = parent.actions() || {};
            }
            Object.defineProperty(_this, "actions", {
                value: Object.assign(parentAct, this.prototype.actions() || {})
            });
            // _this.actions = Object.assign(parentAct, this.prototype.actions());
        }
        if(this.observers){
            var parentObs = {};
            if(parent && parent.observers){
                parentObs = parent.observers() || {};
            }
            var obj = Object.assign(parentObs, this.observers() || {});
            for(var key in obj){
                obs.push(obj[key]);
            }
        }
        _this.didLoad = _this.didLoad || [];
        if(this.prototype.didLoad){
            _this.didLoad.push(this.prototype.didLoad);
        }
        if(this.prototype.idb){
            this.prototype.idb;
            _this.idb = this.prototype.idb(db);
        }
        if(!_this._pK){
            _this._pK = 'id';
        }
        _this.isComp = false;
        var splt = _this._pK.split(',');
        if(splt.length > 1){
            _this.isComp = true;
        }
        _this._arrPk = splt;
        (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishObserverBindings)(obs,true,_this._properties, _this);
        (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishWatchScope)(_this._fldGrps.JsonPathWatch,_this)
        ;(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.defArrUtls)(_this.data);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.defUtls)(_this.data, _this);
        if(parent){
            _utils_js__WEBPACK_IMPORTED_MODULE_0__.extendDef.apply(self, [db.getSchemaObj(parent._name), undefined, db]);
        }
        else if(this.prototype.polymorphic){
            var pArr = this.prototype.polymorphic();
            pArr.forEach(function(itm, idx){
                _utils_js__WEBPACK_IMPORTED_MODULE_0__.extendDef.apply(db.getSchemaObj(itm._name), [self, undefined, db]);
            });
        }
        delete _this.connector;
        delete _this.serializer;
        var self = _this;
        if(this.Connector){
            if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isInheritedClass)(this.Connector, db.constructor.ConnectorCls)){
                _this.Connector = this.Connector;
                var cname = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dbModName)(this.Connector.name, "Connector");
                if(cname === "application"){
                    var aIns;
                    lIns.scopedInstance(this.Connector, [db], function(ins){
                        self.connector = ins;
                        aIns = ins;
                    }, [db]);
                    var context = aIns.__type
                    db.Connector[context] = db.Connector[context] || {};
                    db.Connector[context][cname] = _self.Connector;
        
                    db.connector[context] = db.connector[context] || {}; 
                    db.connector[context].application = aIns;
                }
                else{
                    lIns.scopedInstance(this.Connector, [db], function(ins){
                        self.connector = ins;
                    }, [db]);
                    var context = self.connector.__type;
                    db.Connector[context] = db.Connector[context] || {};
                    db.Connector[context][cname] = _self.Connector;
                }
    
                // _this.connector = new this.Connector(lIns); 
            }
        }
        else if(db.applicationConnector){
            self.connector = db.applicationConnector;
        }
        if(this.Serializer){
            if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isInheritedClass)(this.Serializer, db.constructor.SerializerCls)){
                _this.Serializer = this.Serializer;
                var sname = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dbModName)(this.Serializer.name, "Serializer");
                if(sname === "application"){
                    var asIns;
                    lIns.scopedInstance(this.Serializer, [db], function(ins){
                        self.serializer = ins;
                        asIns = ins;
                    }, [db]);
                    var context = asIns.__type
    
                    db.Serializer[context] = db.Serializer[context] || {};
                    db.Serializer[context][sname] = _self.Serializer;
        
                    db.serializer[context] = db.serializer[context] || {}; 
                    db.serializer[context].application = asIns;
                }
                else{
                    lIns.scopedInstance(this.Serializer, [db], function(ins){
                        self.serializer = ins;
                    }, [db]);
                    var context = self.serializer.__type
                    db.Serializer[context] = db.Serializer[context] || {};
                    db.Serializer[context][sname] = _self.Serializer;
                }
            }
        }
        else if(db.applicationSerializer){
            self.serializer = db.applicationSerializer;
        }
        _this.cache = {
            get : function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.cache.get.apply(self.db.cache, args);
            },
            getAll: function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.cache.getAll.apply(self.db.cache, args);
            },
            drop : function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.drop.apply(self.db.cache, args);
            },
            dropAll : function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.dropAll.apply(self.db.cache, args);
            }
        }
        delete this.prototype.actions;
        delete this.prototype.didLoad;
        delete this.prototype.includes;
        delete this.prototype.idb;
        return _this;
    }
    constructor(data, opts, db){
        // super();
        var def = this.constructor;
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaObj)(db, def);
        var delayPers = opts && opts.hasOwnProperty("delayPersistence") ? opts.delayPersistence : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db,"connector", def.connector, "delayPersistence");
        Object.assign(this, data);
        Object.defineProperties(this, {
            $ :{
                writable : true,
                value : new _Entity_js__WEBPACK_IMPORTED_MODULE_3__.$Entity(this, def, delayPers, db)
            }
        });
        var parent = db.$.saveParent;
        if(parent && this !== parent){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this.$, "parent", parent);
        }
        var defF = def._fldGrps.default;
        var watchF = def._fldGrps.watch;
        var hasManyF = def._fldGrps.hasMany;
        for(var dKey in defF){
            var dFld = defF[dKey];
            var fldVal = data[dKey];
            if(fldVal === undefined || fldVal === ""){
                this[dKey] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultVal)(this, dFld.default);
            }
        }
        for(var wKey in watchF){
            (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishObjectBinding)(this, wKey, true, undefined, undefined, true);
        }
        for(var hKey in hasManyF){
            var hFld = hasManyF[hKey];
            if(this.hasOwnProperty(hKey)){
                this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];
            }
            else if(hFld.relatedTo){
                var toInit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db,"serializer", (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaObj)(db, hFld.relatedTo).serializer, "initHasManyRelation");
                if(toInit){
                    this[hKey] = [];
                }
            }
        }
        var props = def._properties;
        if(Object.keys(props).length){
            if(!this._bindings){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this, '_bindings', new Set(), false, true, true);
            }
            this._bindings.add(props);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.establishObsBindings)(this,props);
        }
    }
    static addEventListener(type, func){
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evAdd)(this,type,func);
    }
    static removeEventListener(id){
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evRemove)(this,id);
    }
    static emit(type, args){
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evEmit)(this,type,args);
    }
    static on(type,func){
        return this.addEventListener(type,func);
    }
    /**
     * To get a data from the server.
     * @param {Object} obj - arguments object.
     * @param {string} obj.schema - schema.
     * @param {string} obj.pK - pK.
     * @return A promise which will be resolved on success and rejected on failure
    */
}

Schema.__lMod = "Schema";

(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(Schema);




/***/ }),

/***/ 85831899:
/*!****************************************************!*\
  !*** ./node_modules/@slyte/data/src/Serializer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Serializer": () => (/* binding */ Serializer)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/service */ 10723535);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 67921756);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);




/*convert to custom class*/
class Serializer extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__.Service {
    constructor(){
        super();
        this.constructor._name = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.dbModName)(this.constructor.name, "Serializer");
    }
    static genericResponse(db,resp,def,type,data,urlObj,xhr,partialObj,customData,partialRef,argsObj){
        var response = resp, 
        name = def && def._name ? def._name : def,
        status = xhr ? xhr.status : undefined, 
        scope, 
        args, 
        qP = urlObj ? urlObj.qP : undefined, extractMetaCall;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db, def ? def.serializer : undefined, baseSerz.GETMETA, "serializer");
        if(scope){
            if(response){
                var metaRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    argsObj.meta = response.meta = metaRes;    
                }
                extractMetaCall = true;
            }
            else{
                extractMetaCall = false;
            }
        }
        if(response && type != "action" && type != "ajax"){
            response = baseSerz.buildJSON(db, def, type, response, (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? data[db.getSchemaObj(name)._pK] :undefined ,xhr ? xhr.status : undefined, urlObj, customData, qP, argsObj);
            if( extractMetaCall == false && scope && response ){
                var metaRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    response.meta = metaRes;
                }
            }
            var keys = Object.keys(response);
            var len = keys.length;
            /* Internal release
            scope = cbScp(db, def ? def.serializer : undefined, RESTSerializer.DESERIALIZEKEY, "serializer");
            if(scope){
                db.lyte.warn("LD08", "deserializeKey", "callback", "Please use normalizeKey callback instead");
                if(len > 2){
                    db.lyte.error("LD09");
                }
                    var index = 0;
                    if(keys[0] == "meta"){
                        index = 1;
                    }
                    var deserializeKey = cB(scope, [argsObj]), rec = response[keys[index]];
                    delete response[keys[index]];
                    response[deserializeKey] = rec;	
            } 
            */	
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.handleResponse)(db, data, response, def, type, partialObj, undefined, partialRef);
        }
        return response;
    }
    static getResponse(db,resp,def,type,key,urlObj,xhr,customData,opts,argsObj){
        var name = def && def._name ? def._name : def,
        scope, 
        payLoad, 
        args, 
        qP = urlObj ? urlObj.qP : undefined;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var doNormalize = opts.cacheData !== undefined && opts.cacheData !== null && typeof opts.cacheData == "object" && opts.cacheData.hasOwnProperty("normalize")  ? opts.cacheData.normalize : true;
        if(doNormalize){
            resp = baseSerz.normalizeResponse(db, def, type, resp, key, xhr ? xhr.status : xhr, urlObj,customData,opts,argsObj)
            payLoad = resp;
            if(payLoad && typeof payLoad != "object"){
                payLoad = JSON.parse(payLoad);
                argsObj.payLoad = payLoad;
            }
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.GETMETA, { argsObj: argsObj, args:[payLoad,name,type,qP,customData,opts]}), metaRes;
            if(res){
                metaRes = res.data;
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    payLoad.meta = metaRes;
                    argsObj.meta = payLoad.meta;
                }	
            }
            var keys = Object.keys(payLoad);
            var len = keys.length; 
            if(len){			
                res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.NORMALIZEKEY, { argsObj: argsObj, args:[name,type,key,qP,customData,opts]});
                var plKey;
                if(res){
                    plKey = res.data;
                    if(plKey && plKey != name){
                        var temp = payLoad[plKey];
                        payLoad[name] = temp;
                        delete payLoad[plKey];
                    }
                }
                /* Internal release
                scope = cbScp(db,def.serializer, RESTSerializer.DESERIALIZEKEY, "serializer");
                if(scope){
                    db.lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
                    if(len > 2){
                        db.lyte.error("LD09");
                    }
                    var index = 0;
                    if(len == 2 && keys[0] == "meta"){
                        index = 1;
                    }
                    args = [name,type];
                    var deserializeKey = cB(scope, [argsObj]), rec = payLoad[keys[index]];
                    delete payLoad[keys[index]];
                    payLoad[deserializeKey] = rec;
                }
                */
                baseSerz.normalize(
                    db,
                    def,
                    type,
                    payLoad,
                    key,
                    xhr ? xhr.status : xhr,
                    urlObj.headers,
                    customData,
                    opts,
                    urlObj,
                    argsObj
                );
            }
            return payLoad;
        }
        else{
            payLoad = resp
            if(payLoad && typeof payLoad != "object"){
                payLoad = JSON.parse(payLoad);
                argsObj.payLoad = payLoad;
            }
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.GETMETA, { argsObj: argsObj, args:[payLoad,name,type,qP,customData,opts]}), metaRes;
            if(res){
                metaRes = res.data;
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    payLoad.meta = metaRes;
                    argsObj.meta = payLoad.meta;
                }	
            }
            return payLoad;
        }
    }
    static sendingData(db,name,data,urlObj,type,customData,snapshot,argsObj,partial){
        var serializeKey = name, 
        payload = {}, 
        qP = urlObj ? urlObj.qP : undefined, 
        tempObj = {},
        def = db.schema[name];
        for (var key in urlObj){
            tempObj[key] = urlObj[key];
        }
        tempObj.type = type;
        tempObj.schema = name;
        argsObj.data = data;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.SERIALIZEKEY, { argsObj: argsObj, args:[name,type,customData,qP]});
        if(res){
            serializeKey = res.data;
        }
        data = baseSerz.serializeRecords(db,def,data,snapshot,tempObj,"serializeEntity",customData,argsObj,partial);
        if(!serializeKey){
            payload = data;
        }
        else if(Array.isArray(data) || typeof data == "object" || (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
            payload[serializeKey] = data;
        }
        argsObj.data = payload;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.SERIALIZE, { argsObj: argsObj, args:[type,payload,snapshot,customData,name,qP]});
        if(res){
            argsObj.data = payload = res.data;
        }   
        urlObj.data = payload;
    }
    static serializeRecords(db,schema,data,records,urlObj,type,customData,argsObj,partial){
        var defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
        if(!schema && defless){
            return data;
        }
        var rels = schema.relations;
        if(!records && type != "normalizeEntity"){
            records = db.cache.getEntity(schema.def, data.$.pK);
        }
        var result, 
        baseSerz = schema && schema.serializer ? schema.serializer.constructor : db.constructor.Serializer;
        if(Array.isArray(data)){
            result = [];
            for(var index1=0;index1<data.length;index1++){
                var record = data[index1];
                if(record && typeof record === "object")
                {
                    result.push(baseSerz.serializeSingleRecord(db,schema,record,records ? records[index1]:undefined,urlObj,rels,type,customData,argsObj,partial));
                }
                else{
                    result.push(record);
                }
            }
        }
        else if(data){
            result = data;
            if(data && typeof data === "object"){
                result = baseSerz.serializeSingleRecord(db,schema,data,records,urlObj,rels,type,customData,argsObj,partial)
            }
        }
        return result;
    }
    static serializeSingleRecord(db,def,data,record,urlObj,rels,type,customData,argsObj,partial){
        var partObj;
        type == "serializeRecord" && typeof data == "object" && data.$ == undefined ? store.$.defProp(data, "$", {}): data;
        if(typeof partial == "object" && record && record.$ && record.$.pK){
            partObj = partial.get ? partial.get(record.$.pK):partial;
            if(data.$ && data.$._partialObj){
                var data$; 
                data$ = Object.assign({}, data.$);
                data = Object.assign({}, data);
                store.$.defProp(data, "$", data$);
            }
            var relDirty =  store.$.isDirty(record,record.$.schema.relations);
            if(record.$.isModified || (Array.isArray(relDirty) && relDirty.length != 0)){
                var dirtAttr = record.$.getDirtyAttributes();
                Array.isArray(relDirty) && dirtAttr.concat(relDirty);
                var keys = Object.keys(data);
                !partObj.hasOwnProperty("_removedAttr")?Object.defineProperties(partObj,{_removedAttr : {value : {} }}):undefined; 
                dirtAttr.forEach(function(val){
                    if(!keys.includes(val) && !record.$.schema._arrPk.includes(val)){
                        partObj._removedAttr[val] = true;
                    }
                })
            }
            Object.defineProperties(data.$,{
                _partialObj:{
                    value:partObj
                },
                _pkVal:{
                    value:record.$.pK
                },
                _model:{
                    value:model_name
                },
                _payloadObj:{
                    value:data
                }
            })
        }
        type == "serializeRecord" ? store.$.defpayObjUtls(data.$) : undefined;
        var name = def && def._name ? def._name : def,
        baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer, 
        scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db,def.serializer,type == "serializeEntity" ? baseSerz.SERIALIZEENTITY : baseSerz.NORMALIZEENTITY,"serializer");
        if(scope){
            var args;
            var oPLoad = argsObj.payLoad
            if(type == "serializeEntity"){
                argsObj.entityData = data;
                argsObj.cachedData = record;
                args = [argsObj];
            }
            else{
                argsObj.entityData = data;
                argsObj.entityPayload = data;
                args = [argsObj];
            }
            data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope,args);
            argsObj.payLoad = oPLoad;
        }
        if(rels){
            rels.forEach(function(rel, key){
                var relLen = rel.length;
                for(var i=0; i<relLen; i++){
                    var field = rel[i];
                    var val = data[field.relKey], recs, res, relTo, srz, isPoly;
                    if(field.type == "relation" && val && ( type == "normalizeEntity" || ( type == "serializeEntity" && field.opts && field.opts.serialize && field.opts.serialize != "id"))){
                        recs = record ? record[field.relKey] : undefined, relTo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getSchemaObj)(db, field.relatedTo), srz = field.opts ? field.opts.serialize : undefined;
                        isPoly = field.opts ? field.opts.polymorphic : undefined
                        if(field.relType === "hasMany"){
                            if(!Array.isArray(val)){
                                val = [val];
                            }
                            var valLen = val.length, res = [];
                            for(var index1=0;index1<valLen;index1++){
                                var _relTo = relTo;
                                if(isPoly){
                                    if(type == "normalizeEntity"){
                                        _relTo = val[index1] && val[index1]._type ? val[index1]._type : relTo; 
                                    }
                                    else if(type == "serializeEntity"){
                                        if(srz == "record"){
                                            _relTo = recs && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(recs[index1]) ? recs[index1].$.schema._name : relTo;
                                        }
                                        else if(srz == "partial"){
                                            _relTo =  val[index1] && val[index1].$ ?  val[index1].$.polymorphicType : relTo;
                                        }
                                    }
                                }	
                                res.push(baseSerz.serializeRecords(db,relTo,val[index1],undefined,urlObj,type,customData,argsObj));
                            }
                            data[field.relKey] = res;
                        }
                        else {
                            var _relTo = relTo;
                            if(isPoly){
                                if(type == "normalizeEntity"){
                                    _relTo = data[field.relKey] && data[field.relKey]._type ? data[field.relKey]._type : relTo; 
                                }
                                else if(type == "serializeEntity"){
                                    _relTo = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record[field.relKey]) ? record[field.relKey].$.schema._name : relTo;									
                                }
                            }	
                            data[field.relKey] = baseSerz.serializeRecords(db,_relTo,data[field.relKey],record ? record[field.relKey] : undefined,urlObj,type,customData,argsObj);
                        }
                    }	
                }
            });
        }
        return data;
    }
    static buildJSON(db, def, type, payLoad, id, status, urlObj, customData, qP, argsObj){
        var headers = urlObj ?  urlObj.headers : undefined, 
        realData = payLoad,
        name = def && def._name ? def._name : def;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db, "serializer", def.serializer, baseSerz.NORMALIZE, { argsObj: argsObj, args:[name, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined,customData]});
        if(res){
            argsObj.payLoad = realData = res.data;
            
        }
        var changed = false, recs, isGet = type == "get";
        if(!isGet && realData && typeof realData == "object"){
            res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.NORMALIZEKEY, { argsObj: argsObj, args:[name,type,undefined,qP,customData]});
            if(res){
                var plKey = res.data;
                if(plKey && plKey != name){
                    var temp = realData[plKey];
                    realData[name] = temp;		
                    delete realData[plKey];
                }	
            }
        }    
        if(isGet || (realData && realData[name])){
            recs = realData[name], changed = true;
            // Internal release
            var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db, def.serializer, baseSerz.PROCESSENTITY, "serializer");
            if(scope){
                if(Array.isArray(recs)){
                    for(var i=0; i<recs.length; i++){
                        argsObj.entityData = recs[i];
                        recs[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                    }
                }					
                else{
                    argsObj.entityData = recs;
                    recs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                }
            }
            var flUrlObj = type != "pushPayload" ? {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, schema :name} : undefined;
            recs = baseSerz.serializeRecords(db, def, recs, undefined, flUrlObj, baseSerz.NORMALIZEENTITY, customData, argsObj);
            realData[name] = recs;
            argsObj.payLoad = realData;
        }
        return realData;
    }
    static normalizeResponse(db, def, type, payLoad, id, status, urlObj, customData, opts, argsObj){
        var headers = urlObj ? urlObj.headers : undefined,
        name = def && def._name ? def._name : def, realData;
        argsObj.payLoad = realData = payLoad;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.NORMALIZE, { argsObj: argsObj, args:[name, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, opts]});
        if(res){
            argsObj.payLoad = realData = res.data;
        }
        return realData;
    }
    static normalize(db,def,type,payLoad,id,status,headers,customData,opts,urlObj,argsObj){
        var realData = payLoad, 
        changed = false,
        name = def && def._name ? def._name : def;
        if(type == "get" || realData[name]){
            realData = realData[name];
            changed = true;
        }
        // Internal release
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db,def.serializer, baseSerz.PROCESSENTITY, "serializer");
        if(scope){
            if(Array.isArray(realData)){
                for(var i=0; i<realData.length; i++){
                    argsObj.entityData = realData[i];
                    realData[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                }
            }					
            else{
                argsObj.entityData = realData;
                realData = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
            }
        }
        
        argsObj.payLoad = realData;
        if(changed){
            payLoad = {};
            realData = baseSerz.serializeRecords(db, def, realData, undefined, {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, schema :name}, "normalizeEntity", customData, argsObj)
            payLoad[name] = realData;
        }
        argsObj.payLoad = payLoad;
    }
}

Serializer.__lMod = "Serializer";



/***/ }),

/***/ 67992299:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/data/src/dberror.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectorError": () => (/* binding */ ConnectorError),
/* harmony export */   "Dberror": () => (/* binding */ Dberror),
/* harmony export */   "SerializerError": () => (/* binding */ SerializerError),
/* harmony export */   "ValidationError": () => (/* binding */ ValidationError)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ 67921756);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 2800903);



class Dberror extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

Dberror.errorCodes = {
    LD01: "Primary key value might be missing in the response data that is received, {0}",
    LD02: "Not a valid {0}",
    LD03: "Cannot set the error {0} for {1}",
    LD04: "No such record to merge, {0}",
    LD05: "Model( {0} ) of related property - {1} not found in model - {2}",
    LD06: "Backward relation not present in model( {0} ), for the property {1} of model( {2} )",
    LD07: "{0} type not handled in handleArrayOperations",
    LD08: "{0} {1} will be deprecated from next version {2}",
    LD09: "deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback",
    LD10: "Response data not in a format lyte data store expects",
    LD11: "Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version",
    LD12: "Response ( {0} ) is not in a format, lyte data store expects",
    LD13: "Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of response data. Data - {3}",
    LD14: "Cannot register {0} - {1}, as it already exists.",
    LD15: "Primary key value might be missing in the response data that is received, {0}",
    LD16: "Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge",
    LD17: "Record with the primary key value already exists",
    LD18: "No { 0 } present",
    LD19: "Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version",
    LD20: "Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.",
    LD21: "No such state ( {0} ) saved for the record.",
    LD22: "For create / createRecord, response with a primary key value should be received",
    LD23: "PrimaryKey field {1} in {0} cannot have default value",
    LD24: "Response couldn't be parsed, {0}",
    LD25: "Cannot create record for the data - {0}",
    LD26: "Only one baseKey is allowed for a model",
    LD27: "Record merge failed, since the data passed is invalid - {0}",
    LD28: "Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}"   
};
Dberror.register();

class ValidationError {
    constructor(lyte, attr, obj, message){
        Object.defineProperties(this, {
            $ : {
                value : {isError : true , error:message?message:{}}
            }
        });
        if(attr){
            ValidationError.setError(lyte,this,attr,obj);
        }    
    }

    static setError(lyte,err,attr,codeObj){
        if(err.$.hasOwnProperty("error")){
            if(Array.isArray(attr)){
                attr.forEach(function(itm){
                    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cmpSet)(lyte, err.$.error, itm, codeObj);
                });
            }
            else{
                (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cmpSet)(lyte, err.$.error,attr,codeObj);
            }
        }
        else{
            ValidationError.error(lyte,"LD03",err,attr);
        }
    }

    static setRecErr(ent$, field, code, value){
        var lyte = ent$.schema.Lyte;
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cmpSet)(lyte, ent$, "isError", true);
        var errObj = code;
        if(typeof errObj == "object"){
            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cmpSet)(lyte, ent$.error,field,errObj);
        }
        else{
            if(typeof code == "string"){
                var errMes = ValidationError.errorCodes[code];
                if(errMes){
                    errObj = {code : code, message : ValidationError.errorCodes[code]};
                }
                else{
                    errObj = code;
                }
            }
            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cmpSet)(lyte, ent$.error, field, errObj);
            if(value){
                (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cmpSet)(lyte, ent$.error[field],"value",value);
            }				
        }
		var db = ent$.schema.db;
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.emit)(db,"error",ent$.entity,field,errObj);
    }

    static clrRecErr(ent$, field, code){
        var lyte = ent$.schema.Lyte;
        var objUtl = lyte.objectUtils;
        var $err = ent$.error;
        if(code){
            if(ent$.error.code == code){
                if(typeof objUtl != "undefined"){
                    objUtl($err,"delete",field);
                }
                else{
                    delete $err[field];                        
                }
            }
        }
        else if(field){
            if(typeof objUtl != "undefined"){
                objUtl($err,"delete",field);
            }
            else{
                delete $err[field];                       
            }
        }
        else{
            if(typeof objUtl != "undefined"){
                for(var err in $err){
                    objUtl($err,"delete",err);
                }
            }	
            else{
                ent$.error = {};
            }   
        }
        if(Object.keys(ent$.error).length == 0){
            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.cmpSet)(lyte, ent$, "isError", false);
        }
    }
}

ValidationError.errorCodes = {
    ERR01 : "Primary key cannot be modified", 
    ERR02 : "Mandatory prop cannot be empty", 
    ERR03 : "Type of value does not match the specified data type",
    ERR04 : "Value is greater than the maximum value allowed",
    ERR05 : "Value is less than the minimum value allowed", 
    ERR06 : "Length of string/array is greater than the maximum limit allowed", 
    ERR07 : "Length of string/array is less than the minimum limit allowed",
    ERR08 : "String does not match the specified pattern", 
    ERR09 : "Values in array are not unique", 
    ERR10 : "Value is not equal to the specified constant", 
    ERR11 : "Schema of related field is not defined",
    ERR12 : "Schema of backward relation is not defined", 
    ERR13 : "Entity not found", 
    ERR14 : "Schema does not match the schema defined in the related field", 
    ERR15 : "Error in creating a entity as a relation",
    ERR16 : "Entity with primary key already exists", 
    ERR17 : "Value cannot be changed because entity has been deleted", 
    ERR18 : "Action not defined", 
    ERR19 : "Schema not defined",
    ERR20 : "Key not specified", 
    ERR21 : "'one' relationship expects a single object/id", 
    ERR22 : "Type not specified for polymorphic relation", 
    ERR23: "Primary Key value not present", 
    ERR24: "Error while relating entities", 
    ERR25: "Backward relation not present",
    ERR26: "Primary key value cannot be undefined or null",
    ERR27: "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
    ERR29: "Property not defined in the object",
    ERR30: "Property's value is not an instanceof the mentioned class"      
};
// ValidationError.register();


class ConnectorError extends Dberror {
    constructor(msg, xhr){
        super();
        this.message = msg;
        this.xhr = xhr;
    }
}
ConnectorError.register();

class SerializerError extends Dberror {
    constructor(msg, xhr){
        super();
        this.message = msg;
        this.xhr = xhr;
    }
}
SerializerError.register();



/***/ }),

/***/ 67921756:
/*!***********************************************!*\
  !*** ./node_modules/@slyte/data/src/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_attrsForRel": () => (/* binding */ _attrsForRel),
/* harmony export */   "_defProp": () => (/* binding */ _defProp),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "addDeepNest": () => (/* binding */ addDeepNest),
/* harmony export */   "addOnSave": () => (/* binding */ addOnSave),
/* harmony export */   "addToCachedBatch": () => (/* binding */ addToCachedBatch),
/* harmony export */   "addToRelate": () => (/* binding */ addToRelate),
/* harmony export */   "addTo_Del": () => (/* binding */ addTo_Del),
/* harmony export */   "cB": () => (/* binding */ cB),
/* harmony export */   "cacheQuery": () => (/* binding */ cacheQuery),
/* harmony export */   "cacheRecordQuery": () => (/* binding */ cacheRecordQuery),
/* harmony export */   "cbScp": () => (/* binding */ cbScp),
/* harmony export */   "changeCallbck": () => (/* binding */ changeCallbck),
/* harmony export */   "changePersist": () => (/* binding */ changePersist),
/* harmony export */   "changeRelPkMaps": () => (/* binding */ changeRelPkMaps),
/* harmony export */   "checkAndAddToArray": () => (/* binding */ checkAndAddToArray),
/* harmony export */   "checkAttrs": () => (/* binding */ checkAttrs),
/* harmony export */   "checkForCorrectRelation": () => (/* binding */ checkForCorrectRelation),
/* harmony export */   "checkObjAndAddToArr": () => (/* binding */ checkObjAndAddToArr),
/* harmony export */   "checkPresenceInArray": () => (/* binding */ checkPresenceInArray),
/* harmony export */   "cmpRelInitVal": () => (/* binding */ cmpRelInitVal),
/* harmony export */   "cmpSet": () => (/* binding */ cmpSet),
/* harmony export */   "compareData": () => (/* binding */ compareData),
/* harmony export */   "compareObjects": () => (/* binding */ compareObjects),
/* harmony export */   "comparePk": () => (/* binding */ comparePk),
/* harmony export */   "compareRecordWithObj": () => (/* binding */ compareRecordWithObj),
/* harmony export */   "compareRecords": () => (/* binding */ compareRecords),
/* harmony export */   "compareRelations": () => (/* binding */ compareRelations),
/* harmony export */   "createAndRelate": () => (/* binding */ createAndRelate),
/* harmony export */   "createCopy": () => (/* binding */ createCopy),
/* harmony export */   "dbModName": () => (/* binding */ dbModName),
/* harmony export */   "deepCopyAttrs": () => (/* binding */ deepCopyAttrs),
/* harmony export */   "deepCopyStack": () => (/* binding */ deepCopyStack),
/* harmony export */   "deepRelIter": () => (/* binding */ deepRelIter),
/* harmony export */   "deepRelOptions": () => (/* binding */ deepRelOptions),
/* harmony export */   "deepValueChange": () => (/* binding */ deepValueChange),
/* harmony export */   "defArrUtls": () => (/* binding */ defArrUtls),
/* harmony export */   "defPar": () => (/* binding */ defPar),
/* harmony export */   "defPolyUtls": () => (/* binding */ defPolyUtls),
/* harmony export */   "defUtls": () => (/* binding */ defUtls),
/* harmony export */   "deleteDeepNest": () => (/* binding */ deleteDeepNest),
/* harmony export */   "deleteFromArray": () => (/* binding */ deleteFromArray),
/* harmony export */   "demoLishObserverBindings": () => (/* binding */ demoLishObserverBindings),
/* harmony export */   "demolishLink": () => (/* binding */ demolishLink),
/* harmony export */   "demolishSingleRelation": () => (/* binding */ demolishSingleRelation),
/* harmony export */   "emit": () => (/* binding */ emit),
/* harmony export */   "estAttrs": () => (/* binding */ estAttrs),
/* harmony export */   "establishLink": () => (/* binding */ establishLink),
/* harmony export */   "establishObsBindings": () => (/* binding */ establishObsBindings),
/* harmony export */   "establishToRelated": () => (/* binding */ establishToRelated),
/* harmony export */   "evAdd": () => (/* binding */ evAdd),
/* harmony export */   "evEmit": () => (/* binding */ evEmit),
/* harmony export */   "evRemove": () => (/* binding */ evRemove),
/* harmony export */   "extendDef": () => (/* binding */ extendDef),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "filterBy": () => (/* binding */ filterBy),
/* harmony export */   "genPk": () => (/* binding */ genPk),
/* harmony export */   "genUnRedoStack": () => (/* binding */ genUnRedoStack),
/* harmony export */   "generateRandomPk": () => (/* binding */ generateRandomPk),
/* harmony export */   "getBackwardRel": () => (/* binding */ getBackwardRel),
/* harmony export */   "getCompInd": () => (/* binding */ getCompInd),
/* harmony export */   "getDefaultVal": () => (/* binding */ getDefaultVal),
/* harmony export */   "getFromCB": () => (/* binding */ getFromCB),
/* harmony export */   "getInd": () => (/* binding */ getInd),
/* harmony export */   "getIndex": () => (/* binding */ getIndex),
/* harmony export */   "getRelatedRecord": () => (/* binding */ getRelatedRecord),
/* harmony export */   "getRelations": () => (/* binding */ getRelations),
/* harmony export */   "getSchemaObj": () => (/* binding */ getSchemaObj),
/* harmony export */   "getpKVal": () => (/* binding */ getpKVal),
/* harmony export */   "handleArrOp": () => (/* binding */ handleArrOp),
/* harmony export */   "handleCachedResponse": () => (/* binding */ handleCachedResponse),
/* harmony export */   "handleRelation": () => (/* binding */ handleRelation),
/* harmony export */   "handleResponse": () => (/* binding */ handleResponse),
/* harmony export */   "handleResults": () => (/* binding */ handleResults),
/* harmony export */   "hasDuplicateRelation": () => (/* binding */ hasDuplicateRelation),
/* harmony export */   "hasRecordInArray": () => (/* binding */ hasRecordInArray),
/* harmony export */   "hasRecordsArrayChanged": () => (/* binding */ hasRecordsArrayChanged),
/* harmony export */   "idSerialize": () => (/* binding */ idSerialize),
/* harmony export */   "idbSerialize": () => (/* binding */ idbSerialize),
/* harmony export */   "initCB": () => (/* binding */ initCB),
/* harmony export */   "initPartialObj": () => (/* binding */ initPartialObj),
/* harmony export */   "insertIntoStore": () => (/* binding */ insertIntoStore),
/* harmony export */   "isDefData": () => (/* binding */ isDefData),
/* harmony export */   "isDirty": () => (/* binding */ isDirty),
/* harmony export */   "isDuplicateEntity": () => (/* binding */ isDuplicateEntity),
/* harmony export */   "isDuplicateRecord": () => (/* binding */ isDuplicateRecord),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isEmptyArray": () => (/* binding */ isEmptyArray),
/* harmony export */   "isEmptyObj": () => (/* binding */ isEmptyObj),
/* harmony export */   "isRelDirty": () => (/* binding */ isRelDirty),
/* harmony export */   "makeDirty": () => (/* binding */ makeDirty),
/* harmony export */   "mapBy": () => (/* binding */ mapBy),
/* harmony export */   "mergeData": () => (/* binding */ mergeData),
/* harmony export */   "mergeDeletedRec": () => (/* binding */ mergeDeletedRec),
/* harmony export */   "mergeError": () => (/* binding */ mergeError),
/* harmony export */   "mergeModifiedRec": () => (/* binding */ mergeModifiedRec),
/* harmony export */   "mergeNewDataKeys": () => (/* binding */ mergeNewDataKeys),
/* harmony export */   "mergeNewRecord": () => (/* binding */ mergeNewRecord),
/* harmony export */   "mergePartialObj": () => (/* binding */ mergePartialObj),
/* harmony export */   "mergeRecords": () => (/* binding */ mergeRecords),
/* harmony export */   "mergeResponse": () => (/* binding */ mergeResponse),
/* harmony export */   "newRecord": () => (/* binding */ newRecord),
/* harmony export */   "partialData": () => (/* binding */ partialData),
/* harmony export */   "partialSerialize": () => (/* binding */ partialSerialize),
/* harmony export */   "pkPresence": () => (/* binding */ pkPresence),
/* harmony export */   "polyToJSON": () => (/* binding */ polyToJSON),
/* harmony export */   "polymorphicToJSON": () => (/* binding */ polymorphicToJSON),
/* harmony export */   "rSerialize": () => (/* binding */ rSerialize),
/* harmony export */   "recChk": () => (/* binding */ recChk),
/* harmony export */   "recordSerialize": () => (/* binding */ recordSerialize),
/* harmony export */   "registerField": () => (/* binding */ registerField),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "removeBackwardRel": () => (/* binding */ removeBackwardRel),
/* harmony export */   "removeDeepNest": () => (/* binding */ removeDeepNest),
/* harmony export */   "removeDirtyStack": () => (/* binding */ removeDirtyStack),
/* harmony export */   "removeFromStore": () => (/* binding */ removeFromStore),
/* harmony export */   "removeOnSave": () => (/* binding */ removeOnSave),
/* harmony export */   "removeParentNesting": () => (/* binding */ removeParentNesting),
/* harmony export */   "removePartial": () => (/* binding */ removePartial),
/* harmony export */   "removePartialKeys": () => (/* binding */ removePartialKeys),
/* harmony export */   "removeSelfCircularReference": () => (/* binding */ removeSelfCircularReference),
/* harmony export */   "revertToOldVal": () => (/* binding */ revertToOldVal),
/* harmony export */   "rllBckRecArr": () => (/* binding */ rllBckRecArr),
/* harmony export */   "rollBackDelete": () => (/* binding */ rollBackDelete),
/* harmony export */   "rollBackNew": () => (/* binding */ rollBackNew),
/* harmony export */   "schArgs": () => (/* binding */ schArgs),
/* harmony export */   "setData": () => (/* binding */ setData),
/* harmony export */   "setDeepNest": () => (/* binding */ setDeepNest),
/* harmony export */   "setState": () => (/* binding */ setState),
/* harmony export */   "setValue": () => (/* binding */ setValue),
/* harmony export */   "singleEstablishLink": () => (/* binding */ singleEstablishLink),
/* harmony export */   "solveRelation": () => (/* binding */ solveRelation),
/* harmony export */   "sortBy": () => (/* binding */ sortBy),
/* harmony export */   "toDemolishLink": () => (/* binding */ toDemolishLink),
/* harmony export */   "toDemolishRelation": () => (/* binding */ toDemolishRelation),
/* harmony export */   "toInsertData": () => (/* binding */ toInsertData),
/* harmony export */   "toJSON": () => (/* binding */ toJSON),
/* harmony export */   "toJSONObj": () => (/* binding */ toJSONObj),
/* harmony export */   "unRegCb": () => (/* binding */ unRegCb),
/* harmony export */   "unredoOp": () => (/* binding */ unredoOp),
/* harmony export */   "unregisterDef": () => (/* binding */ unregisterDef),
/* harmony export */   "updateDn": () => (/* binding */ updateDn),
/* harmony export */   "updateFieldValidation": () => (/* binding */ updateFieldValidation),
/* harmony export */   "updateJSON": () => (/* binding */ updateJSON),
/* harmony export */   "updateNestScp": () => (/* binding */ updateNestScp),
/* harmony export */   "validateAndMerge": () => (/* binding */ validateAndMerge),
/* harmony export */   "validateAndPush": () => (/* binding */ validateAndPush),
/* harmony export */   "validateField": () => (/* binding */ validateField),
/* harmony export */   "validateJSON": () => (/* binding */ validateJSON),
/* harmony export */   "validateRecord": () => (/* binding */ validateRecord),
/* harmony export */   "validateRelatedRecord": () => (/* binding */ validateRelatedRecord)
/* harmony export */ });
/* harmony import */ var _dberror__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dberror */ 67992299);
/* harmony import */ var _Schema_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Schema.js */ 79928624);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 33115194);
/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Entity.js */ 20810078);




// import { isMixin } from "../../core/src/lyte-utils";

// function getOrigParent(cls){
// 	var prt = Object.getPrototypeOf(cls);
// 	while(isMixin(prt)){
// 		prt = Object.getPrototypeOf(prt);
// 	}
// 	return prt;
// }

function changePersist(record, value){
	if(!record.$.isUnloaded || record.$.isPeristed !== value){
		switch(value){
			case true: {
				if(!record.$.isNew && !record.$.isModified && !record.$.isDeleted){
					cmpSet(undefined, record.$, "isPersisted", true);
				}
				break;
			}
			case false: {
				if(record.$.isNew || record.$.isModified || record.$.isDeleted || (record.$.dN && Object.keys(record.$.dN) && Object.keys(record.$.dN).length)){
					cmpSet(undefined, record.$, "isPersisted", false);
				}
				break;
			}
		}
	}
}

function getSchemaObj(db, schema){
	var schemaObj = db._schema.get(schema);
	if(!schemaObj && db.subDbs){
		var len = db.subDbs.length;
		for(var i=0;i<len;i++){
			var subDb = db.subDbs[i];
			if(subDb._schema.get(schema)){
				schemaObj = subDb._schema.get(schema);
				break;
			}
		}
	}
	return schemaObj;
}

function dbModName(name, type, pascalToCamel){
	var mp = { Schema : /([a-zA-Z0-9])(Schema)$/g, Connector: /([a-zA-Z0-9])(Connector)$/g, Serializer : /([a-zA-Z0-9])(Serializer)$/g };
	name = name.replace(mp[type], '$1');
	return pascalToCamel !== false ? name.slice(0, 1).toLowerCase() + name.slice(1) : name;
}

function schArgs(){
	var arg1 = arguments[0], args;
	if(typeof arg1 == "object"){
		arg1.schema = this;
		args = [arg1]
	}
	else{
		args = Array.from(arguments);
		args.splice(0,0,this);
	}
	return args;
}

function evAdd(scope,type,func){
	scope.events = scope.events || {};
	scope.events[type] = scope.events[type] || [];
	scope.events[type].push({f : func});
	return type+"-"+(scope.events[type].length-1);              
}

function evRemove(scope,id){
	var type;
	if(id){
		if(/^(add|remove|change)$/.test(id)){
			type = id;
			(scope.events && scope.events[type]) ? delete scope.events[type] : undefined;   
		}
		else{
			var arr = id ? id.split("-") : undefined;
			if(arr){
				var listeners = scope.events[arr[0]];
				if(listeners && arr[1]){
					listeners[arr[1]] = null;
				}   
			}            
		}
	}else{
		var ev = scope.events;
		for(var evType in ev){
			(ev && ev[evType]) ? delete ev[evType] : undefined;
		}
	}
}

function evEmit(scope,type,args){
	var listeners = (scope.events && scope.events[type]) ? scope.events[type] : [];
	for(var i=0; i<listeners.length; i++){
		(listeners[i]) ? listeners[i].f.apply(null, args) : undefined;
	}            
}

function addTo_Del(def, data, ind){
	var deleted = def._deleted = def._deleted || new Map(), 
	obj = { index : ind , data : data };
	deleted.set(data.$.pK, obj);
}

function genUnRedoStack(){
	var obj = {};
	_defProp(obj, "_order_", [], false);
	return obj;
}

function deepCopyStack(stack){
	if(stack && typeof(stack) == "object"){
		stack = Object.assign({},stack);
		for(var attr in stack){
			if(Array.isArray(stack[attr])){
				var arr = stack[attr] = Array.from(stack[attr]);
				arr.forEach(function(itm,idx){
					arr[idx] = Object.assign(itm);
				});
			}
		}
	}
	return stack;
}

function deepCopyAttrs(def,obj){
	var fields = def.fieldList, 
	obj = Object.assign({},obj);
	for(var attr in obj){
		var _attr = obj[attr];
		if(fields[attr] && fields[attr].type == "relation" && Array.isArray(_attr)){
			_attr = obj[attr] = Array.from(_attr);
			_attr.forEach(function(itm, idx){
				_attr[idx] = Object.assign({}, itm);
				itm.hasOwnProperty("records") && itm.records ? (itm.records = Array.from(itm.records)) : undefined;
				itm.hasOwnProperty("_indices") && itm._indices ? (itm._indices = Array.from(itm._indices)) : undefined;
			});
		}
	}
	return obj;
}

function unredoOp(type,rec,attr){
	var stack, revStack;
	var lyte = rec.schema.db.lyte;
	if(type == 1){
		stack = rec.undoStack;
		revStack = rec.redoStack;
	}
	else{
		stack = rec.redoStack;
		revStack = rec.undoStack;
	}
	var attrs=[], obj, revObj = {};
	if(attr){
		if(!Array.isArray(attr)){
			attrs=[attr];
		}
		else{
			attrs = attr;
		}
		attrs.forEach(function(item){
			if(stack[item].length){
			var len = stack._order_.length;
			for (var index=len-1;index>=0;index--){
				var order = stack._order_[index];
				var attrIndex = order.indexOf(item);
				if(attrIndex > -1){
					order.splice(attrIndex,1);
						if(!order.length){
							stack._order_.splice(index,1);
						}
						break;
					}
				}
			}
		});
	}
	else{
		attrs = stack._order_ && stack._order_.length ? stack._order_.pop() : attrs;
	}
	if(attrs.length){
		for(var index=0;index<attrs.length;index++){
			var key=attrs[index], obj = stack[key].pop();
			if(obj._type == "update"){
				if(obj.hasOwnProperty("val")){
					setData(rec,key,obj.val,undefined, revObj);
					// redoObj[key] = undo;
				}
				else if(obj.hasOwnProperty("records")){
					setData(rec,key,obj.records,undefined, revObj)	
				}
			}
			else if(type == 1 && obj._type == "propAdd"){
				if(typeof lyte != "undefined"){
					revObj[key] = {_type:"propDelete", val:rec.entity[key]};
					if(obj.hasOwnProperty("val")){
						setData(rec,key,obj.val,undefined, {});
						// redoObj[key] = undo;
					}
					if(lyte.objectUtils){
						lyte.objectUtils(rec.entity, "delete", key);
					}
					else{
						delete rec.entity[key];
					}
				}
				else{
					delete rec.entity[key];
				}
			}
			else if(type == 2 && obj._type == "propDelete"){
				revObj[key] = {_type:"propAdd"}
				setData(rec,key,obj.val,undefined, revObj);
			}
			else if(obj._type == "added"){
				rec.entity.$.get(key).remove(obj.records,undefined,revObj);
			}
			else if(obj._type == "removed"){
				rllBckRecArr(rec.schema.db, [obj], rec.entity, rec.schema, rec.schema.fieldList[key])
				obj._type = "added";
				revObj[key] = obj;
			}
		}
		var keys = Object.keys(revObj);
		for(var index=0;index<keys.length;index++){
			var key = keys[index];
			revStack[key] = revStack[key] || [];
			revStack[key].push(revObj[key]);
		}
		if(keys.length){
			// rec.redoStack._order_ = rec.redoStack._order_ || [];
			revStack._order_.push(keys);
		}
	}
}

function unregisterDef(db, schema){
	schema = getSchemaObj(db, schema);
	if(schema){
		var name = schema._name;
		if(schema.data.length){
			db.dropAll(schema.def);
		}
		var extendedBy = schema.extendedBy;
		if(extendedBy && Object.keys(extendedBy).length){
			for(var ext in extendedBy){
				unregisterDef(db, db.schema[ext].def);
			}
		}
		if(schema.extend){
			var extend = db.getSchemaObj(schema.extend);
			if(extend){
				delete extend.extendedBy[name];
			}
		}
		delete db.schema[name];  
		delete db.constructor.Schema.schema[name];
		db._schema.delete(schema.def);
	}
}

function updateFieldValidation(db, schema, key, deserialize, ignoreValidation){
	var records = schema.data, 
	fields = schema.fieldList;
	records.forEach(function(item){
		var field = fields[key], 
		isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty("value") ? true : false, 
		oldVal = isOldVal ? item.$.error[key].value : undefined;
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(item.$, key);
		if(deserialize){
			var fldTypeName = field.type._name, 
			empD = getDsrzEmpData(schema, field, schema._name), 
			boolChk = !empD && item[key];
			if((item.hasOwnProperty(key) && (boolChk || empD) && db.dataType[fldTypeName].hasOwnProperty("deserialize"))){
				item[key] = db.dataType[fldTypeName].deserialize(item[key],key,schema._name,getpKVal(item,schema));
			}
		}
		isOldVal ? validateField(db, item, key, fields[key], undefined, {old:true, value:oldVal}) : validateField(db, item, key, fields[key], undefined)
		if(!ignoreValidation){
			var isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty("value") ? true : false;
			var oldVal = isOldVal ? item.$.error[key].value : undefined;
			_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(item.$, key);
			isOldVal ? validateField(db, item, key, field, undefined, {old:true, value:oldVal}) : validateField(db, item, key, fields[key], undefined)
		}
		if(isOldVal && item.$.error && Object.keys(item.$.error) === 0){
			item.$.set(key, oldVal);
		}
	});
}

function handleCachedResponse(db,batch,resp){
	var cached = db.$.cachedBatch = db.$.cachedBatch || {}, 
	arr = cached[batch] || [], 
	count = 0;
	arr.forEach(function(item,index){
		resp.splice((item.ind+count++),0,item.data);
	});
	delete cached[batch];
	return resp;
}

function addToCachedBatch(db, data){
	var curr = db.$.currentBatch, 
	cached = db.$.cachedBatch = db.$.cachedBatch || {}, 
	cachedB = cached[curr] = cached[curr] || [], 
	arr = db.$.batch[curr] || [], 
	ind = arr.length;
	cachedB.push({ind:ind, data:data});
}

function checkObjAndAddToArr(arr, obj, keys){
	var len = Object.keys(keys).length, res = -1, arrLen = arr.length;
	for(var k=0; k<arrLen; k++){
		var item = arr[k];
		var i=0;
		for(var key in keys){
			if(item[key] == obj[key]){
				i++;
			}	
		}
		if(i == len){
			res = k;
			arr.splice(k,1,obj);
			return;
		}
	}
	if(res == -1){
		arr.push(obj);
	}
	return res;
}

function addToRelate(db, name, data, rel, key){
	var relMod = getSchemaObj(db, rel.forward.relatedTo), 
	toRelMod = db.$.toRelate[relMod._name] = db.$.toRelate[relMod._name] || new Map();
	if(!toRelMod.has(key)){
		toRelMod.set(key, []);
	}
	var toRel = toRelMod.get(key), 
	pkVal = data.$.pK, 
	obj = {schema : name, pkVal : pkVal, key : rel.forward.relKey};
	toRel.push(obj);
	// checkObjAndAddToArr(toRel, obj, ["record","key"]);
}

function getDefaultVal(rec, defVal){
	if(typeof defVal != "function"){
		return defVal;
	}
	else{
		return defVal.call(rec);
	}
}

function deepValueChange(rec, attr, value, changeObj){
	var toEmit = {emit : false, attr : [], oldRec : {}};
	estAttrs(rec, attr, value, toEmit, changeObj);
	checkAttrs(rec);
	changeCallbck(rec, toEmit);
}

function updateDn(record){
	var schema = record.$.schema, 
	relations = schema.relations;
	relations.forEach(function(rels, key){
		rels.forEach(function(itm){
			var options = itm.opts, 
			attr = itm.relKey, 
			relType = itm.relType ;
			if(options && options.deepNest == true){
				deepRelIter("updateDN", schema, record);
				if(record.hasOwnProperty(attr)){
					var relRec = record[attr];
					if(relType == "belongsTo" && (relRec.$.isModified || (relRec.$.dN && Object.keys(relRec.$.dN).length ))){
						setDeepNest(record, attr, relRec.$.pK, "updated", undefined, relRec)
					}
					else if(relType == "hasMany" && Array.isArray(relRec)){
						relRec.forEach(function(rec){
							if(rec.$.isModified || (rec.$.dN && Object.keys(rec.$.dN).length)){
								setDeepNest(record, attr, rec.$.pK, "updated", undefined, rec)
							}
						});
					}
				}
			}
		});
	});
}

function deepRelIter(type, def, record, parentRel){
	var relations = def.relations, db = def.db;
	relations.forEach(function(arr, key){
		arr.forEach(function(rel){
			var relKey = rel.relKey, isParent;
			var relType = rel.relType;
			var dN = rel.opts && rel.opts[type];
			if(parentRel){
				var relDef = getSchemaObj(db, rel.relatedTo);
				var child = getBackwardRel(def,rel, relDef);
				if(parentRel == child && def != relDef){
					isParent = true;
				}
			}
			if(!isParent && record.hasOwnProperty(relKey) && record[relKey] && dN){
				var relData = record[relKey];
				if(relType == "hasMany" && Array.isArray(relData)){
					relData.forEach(function(relRec){
						deepRelOptions(db, relRec, type, rel);
					});
				}
				else if(relType == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(relData)){
					deepRelOptions(db, relData, type, rel);
				}
			}
		});		
	});
}

function deepRelOptions(db, relRec, type, rel){
	switch(type){
		case "rollback":
		{
			relRec.$.rollBack(undefined,rel);
			break;
		}	
		case "unload":
		{
			db.dropEntity(rel.relatedTo, relRec.$.pK, rel);
		}								
	}
}

function handleResults(db, results, partialRef){
	if(Array.isArray(results)){
		results.forEach(function(itm, idx){
			var refKey = partialRef.refKey;
			var refId = itm[refKey], refObj = partialRef.get(refId);
			if(refObj){
				mergePartialObj(db, refObj, undefined, itm, true);
			} 
		});
	}
	else{
		_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.warn(db.lyte, "results expected be a flat structure of type array, instead it was "+typeof(results));
	}
}

function handleResponse(db, data, response, schema, type, partialObj, status, partialRef){
	var pK = schema._pK, 
	partial, 
	obj, 
	pkVal;
	if(response.results && schema._name != "results"){
		handleResults(db,response.results, partialRef);
	}
	response = response[schema._name];
	if(Array.isArray(data)){
		for(var i=0; i<data.length; i++){
			obj = data[i], pkVal = obj.$.pK;
			partial = partialObj && obj && pkVal ?  partialObj.get(pkVal) : undefined;
			mergeResponse(db, data[i], schema, Array.isArray(response) ? response[i] : response, pK, partial);	
		}
	}
	else{
		pkVal = data.$.pK;
		partial = partialObj && data && pkVal ?  partialObj.get(pkVal) : undefined;
		mergeResponse(db, data, schema, response, pK, partial);	
	}
}

function setState(self, obj){
	self.dN ? self.dN = {} : undefined;
	setData(self, obj, undefined, undefined, {}, true);
	updateDn(self.entity);
	self.undoStack = obj.$.undoStack || genUnRedoStack();
	self.redoStack = obj.$.redoStack || genUnRedoStack();
	self._attributes = obj.$._attributes || {};
	checkAttrs(self.entity);
}

function validateRelatedRecord(db, record, key, field){
	var fields = getSchemaObj(db, field.relatedTo).fieldList;
	if(field && field.opts && record && record.hasOwnProperty(key)){
		if(field.opts && field.opts.serialize == "record"){
			if(field.relType == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record[key])){
				return validateRecord(db, record[key], fields);
			}
			else if(field.relType == "hasMany"){
				if(Array.isArray(record[key])){
					var ret = true, 
					result, 
					self = this;
					record[key].forEach(function(item, index){
						if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(item)){
							result = validateRecord(db, item, fields);
							if(result === false){
								ret = false;
							}
						}
					});
					return ret;
				}
			}
		}
	}
}

function validateRecord(db, record, fields){
	var result, ret = true, returnVal;
	for(var field in fields){
		returnVal = validateField(db, record, field, fields[field], result);
		if(ret === true && returnVal === false){
			ret = false;
		}
	}
	if(ret === false || (record.$.isError === true && record.$.error && Object.keys(record.$.error).length)){
		return false;
	}
	return true;
}

function validateField(db, record, key, field, result, obj){
	var val = obj && obj.old ? obj.value : record[key], 
	ret, 
	err = record.$, 
	clear,
	db = record.$.schema.db,
	lyte = record.$.schema.db.lyte,
	validateOptions = true;
	if(field.type == "relation"){
		ret = validateRelatedRecord(db, record, key, field);
		if(ret === false){
			result = false;
			return result;
		}
		validateOptions = false;
	}
	else if(field.mandatory && !record.$.error.hasOwnProperty(key) && (val === undefined || val === "" || (Array.isArray(val) && val.length === 0) )){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(err, key, {code : "ERR02", message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR02, value : val});
	}
	if(validateOptions){
		clear = true;
		if( obj || (record.hasOwnProperty(key) && !record.$.error.hasOwnProperty(key))){
			for(var property in field){
				var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkProperty)(property, val, key, field[property], record, (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record) ? record.$.schema._name : undefined, db, _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.errorCodes, undefined, field, true);
				if(resp !== true){
					if(typeof resp == "object"){
						resp.value = val; 
					}
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(err,key,resp);
					clear = false;
					//err[field] = resp;
					break;
				}
			}
			if(_Entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity.strictValueSet === false && obj && clear){
				cmpSet( lyte, record, key, val, undefined, true );
			}
			if(clear){
				_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(err, key);
			}		
		}
	}
}

function addOnSave(db,name,record,attr,field,pK,relPk){
	db.$.onSave = db.$.onSave || {};
	var saveMod = db.$.onSave[name] = db.$.onSave[name] || {};
	var saveQ = saveMod[record[pK]] = saveMod[record[pK]] || {} 
	var recs = record[attr] || [];
	if(field.relType == "belongsTo"){
		recs = !Array.isArray(record[attr]) ? [record[attr]] : record[attr]; 
	}
	recs.forEach(function(item){
		var q = saveQ[field.relKey] = saveQ[field.relKey] || [];
		checkAndAddToArray(q, item[relPk]);
	});
}

function removeOnSave(db, name, pkVal){
	var saveMod = db.$.onSave ? db.$.onSave[name] : undefined;
	if(saveMod && saveMod[pkVal]){
		delete saveMod[pkVal];
	}
}

function registerField(db,def,key,field,obs){
	var oldField = def.fieldList[key] ? Object.assign({},def.fieldList[key]) : undefined;
	if(key == "didLoad"){
		if(!def.didLoad){
			def.didLoad = [];
		}
		def.didLoad.push(field);
	}
	else if(typeof field.type == "string"){
		if(field.primaryKey){
			if(def.fieldList.id && def.fieldList.id.defined == false){
				delete def.fieldList.id;
			}
			if(field.hasOwnProperty("default")){
				_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.warn(db.lyte, "LD23",def._name,key);
				delete field.default;
			}
			if(def._pK != undefined){
				def._pK = def._pK + "," + key;
				def.isComposite = true; 
			}
			else{
				def._pK = key;
			}
			if(field.baseKey){
				if(def.bK){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.warn(db.lyte, "LD02",type,def._name);
					return;
				}
				def.bK = key
			}	
		}
		def.fieldList[key] = field;
		if(oldField && def._fldGrps){
			if(oldField.hasOwnProperty("default")){
				delete def._fldGrps.default[key];
			}
			if(oldField.hasOwnProperty("watch")){
				delete def._fldGrps.watch[key];
			}
		}
		if(field.hasOwnProperty("default")){
			def._fldGrps.default[key] = field;
		}
		if(field.hasOwnProperty("watch") && (field.watch == true || Array.isArray(field.watch)) && /^(array|object)$/.test(field.type)){
			def._fldGrps.watch[key] = field;
		}		
	}
	else if(field._type == "prop"){
		if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.newGetSuperClass)(field.type,  undefined, def.db.constructor.DataType)){
			field.is = "transform";
			def.fieldList[key] = field;
		}
		else{
			_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.warn(db.lyte, key+" in Schema-"+def._name+" is not a valid prop");
		}
	}
	if(field.type === "relation"){
		field.relKey = key;
		var relTo;
		if(typeof field.relatedTo == "string"){
			var fRelToName = dbModName(field.relatedTo, "Schema"); 
			_relTo = db.constructor.getSchema(field.relatedTo);
			if(_relTo){
				relTo = _relTo;
			}
			else{
				var _id = db.constructor.Schema.schema.addEventListener("add", function(name, newRelTo){
					if(name == fRelToName){
						relDef(def, key, newRelTo, field);
						db.constructor.Schema.schema.removeEventListener(_id);
					}
				});
			}
		}
		else{
			relTo = field.relatedTo;
		}
		if(relTo){
			relDef(def, key, relTo, field);
		}
	}	
}

function relDef(def, key, relTo, field){
	if(typeof field.relatedTo == "string" && relTo && typeof relTo !== "string"){
		field.relatedTo = relTo;
	}
	var relObj = def.fieldList[key];
	if(!def.relations.get(relTo)){
		def.relations.set(relTo, []);
	}
	var rArr = def.relations.get(relTo);
	var chkObj = {};
	chkObj.relKey = relObj.relKey; 
	checkObjAndAddToArr(rArr, relObj, chkObj);
	if(field.relType == "hasMany"){
		def._fldGrps.hasMany[key] = field;
	}
	if(field.hasOwnProperty("opts") && field.opts.hasOwnProperty("reverseKey")){
		def._fldGrps.reverseKey.set(relTo, field);
	}
}
function unRegCb(db,type,name){
	var callback = db[type][name];
	if(!callback){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.error(db.lyte,"LD02",type,name);
		return;
	}
	var extendedBy = callback.__extendedBy;
	if(extendedBy.length)
	{
		db[type].__toAddSuper = db[type].__toAddSuper || {};
		if(!db[type].__toAddSuper[name])
		{
			db[type].__toAddSuper[name] = extendedBy.slice();
		}
		else
		{
			extendedBy.forEach(function(item){
				db[type].__toAddSuper[name].push(item);
			});
		}
		extendedBy.forEach(function(item){
			db[type][item].$super = undefined;
		});
		if(db[type].application && name != "application")
		{	
			var application = db[type].application;
			extendedBy.forEach(function(item){
				db[type][item].$super = application;
				db[type].application.__extendedBy.push(item);
			});
		}
		if(!db[type].application)
		{
			if(!db[type].__toAddSuper.application)
			{
				db[type].__toAddSuper.application = extendedBy.slice();
			}
			else
			{
				extendedBy.forEach(function(item){
					db[type].__toAddSuper.application.push(item);
				});
			}
		}
	}
	if(callback.$super){
		callback.$super.__extendedBy.splice(callback.$super.__extendedBy.indexOf(name),1);
	}
	delete db[type][name];
}

function extendDef(extend, mdl, db){
	var scp = mdl || this,
	// scp = getSchemaObj(db, scp),
	db = db || scp.db;
	if(!extend){
		return;
	}
	var parentFields = Object.assign({},extend.fieldList);
	for(var key in parentFields){
		if(parentFields[key].type == "relation"){
			delete parentFields[key];
		}
	}
	var pkObj = {}, 
	extendParentPks = scp._pK == "id" && scp.fieldList.id.defined == false ? true : false;
	for(var key in parentFields){
		var fld = parentFields[key], 
		custPk = extendParentPks && fld.primaryKey && fld.defined != false;
		if(scp.fieldList.hasOwnProperty(key) && scp._fldGrps){
			var oldField = scp.fieldList[key];
			if(oldField.hasOwnProperty("default")){
				delete scp._fldGrps.default[key];
			}
			if(oldField.hasOwnProperty("watch")){
				delete scp._fldGrps.watch[key];
			}
		}
		if(fld.hasOwnProperty("default")){
			scp._fldGrps.default[key] = fld;
		}
		if(fld.hasOwnProperty("watch") && fld.watch == true && /^(array|object)$/.test(fld.type)){
			scp._fldGrps.watch[key] = fld;
		}
		if(!fld.primaryKey){
			scp.fieldList[key] = fld;
		}
		else {
			pkObj[key] = fld;
		}
	}
	var pkObjKeys = Object.keys(pkObj), pkObjLen = pkObjKeys.length;
	if(extendParentPks && pkObjLen){
		delete scp.fieldList.id;
		for(var key in pkObj){
			scp.fieldList[key] = pkObj[key];
		}
		if(pkObjLen == 1){
			scp._pK = pkObjKeys[0];
			scp._arrPk = Array.from(pkObjKeys);
		}
		else{
			scp.isComp = true;
			scp._arrPk = Array.from(pkObjKeys);
			scp._pK = scp._arrPk.toString();
		}
	}
	var name = scp._name;
	db.schema[name].extend = extend._name;
	extend.extendedBy = extend.extendedBy || {};
	extend.extendedBy[name] = true;
	// if(!db.connector[name] && db.connector[extend]){
	// 	db.connector[name] = db.connector[extend];
	// }
	// if(!db.serializer[name] && db.serializer[extend]){
	// 	db.serializer[name] = db.serializer[extend];
	// }
	if(extend.actions){
		var actions = scp.actions = scp.actions || {};
		for(var key in extend.actions){
			if(!actions.hasOwnProperty(key)){
				actions[key] = extend.actions[key]; 							
			}
		}					
	}
}

function demoLishObserverBindings(obj,prop,record){
	if(!record){
		record = obj;
	}
	for(var key in prop){
		if(obj[key] instanceof Object){
			if(record && obj[key]._setterScope){
				var ind = obj[key]._setterScope.indexOf(record);
				ind != -1 ? obj[key]._setterScope.splice(ind, 1) : undefined;
			}
			if(Object.keys(prop[key]).length){
				demoLishObserverBindings(obj[key],prop[key],obj);
			}
		}
		if(obj._setterScope && obj != record){
			var inx = obj._setterScope.indexOf(record);
			inx != -1 ? obj._setterScope.splice(inx, 1) : undefined;
		}
	}
}

function establishObsBindings(obj,prop,record){
	if(!record){
		record = obj;
	}
	for(var key in prop){
		if(obj[key] instanceof Object){
			if(!obj[key]._bindings){
				_defProp(obj[key], '_bindings', new Set(), false, true, true);
			}
			if(record && !obj[key]._setterScope){
				_defProp(obj[key],'_setterScope',[]);
			}
			var ind = obj[key]._setterScope.indexOf(record);
			ind == -1 ? obj[key]._setterScope.push(record) : undefined;
			obj[key]._bindings.add(prop[key]);
			if(Object.keys(prop[key]).length){
				establishObsBindings(obj[key],prop[key],obj);
			}
		}
		if(!obj._setterScope){
			_defProp(obj, '_setterScope', []);
			obj._setterScope.push(obj);
		}
	}
}

function isEmpty(val){
	if(val != undefined && val !== "" && val != null){
		return false;
	}
	return true;
}

function isEmptyObj(obj){
	if(obj !== null && typeof obj == "object" && Object.keys(obj).length == 0){
		return true;
	}
	return false;
} 

function isEmptyArray(arr){
	if(Array.isArray(arr) && arr.length == 0){
		return true;
	}
	return false;
}

function compareData(data1, data2, isQp){
	if(!isEmpty(data1) && !isEmpty(data2)){
		var data1Type = typeof data1, data2Type = typeof data2;
		if(data1Type !== data2Type){
			return false;
		}
		switch(data1Type){
			case "string":
			case "number":
			case "boolean":
			if(data1 === data2){
				return true;
			}
			break;
			case "object":
				return compareObjects(data1, data2, isQp);
		}
	}
	return false;
}

function compareObjects(obj1, obj2, qP){
	if(!(obj1 instanceof Object) || !(obj2 instanceof Object)){
		return false;
	}
	if(Object.keys(obj1).length != Object.keys(obj2).length){
		return false;
	}
	for(var key in obj1){
		var val1 = obj1[key], val2 = obj2[key];
		if(qP && Array.isArray(val1) && Array.isArray(val2)){
			if(val1.length != val2.length){
				return false;
			}
			var len = val1.length;
			for(var i=0; i<len; i++){
				var ret = compareData(val1[i], val2[i], qP);
				if(!ret){
					return false;
				}
			}
		}
		else if(val2 == undefined || !compareData(val1,val2,qP)){
			return false;
		}
	}
	return true;
}

function setData(self, attr, value, opts, redoObj, ignoreChange){
	var toEmit = {emit : false, attr : [], oldRec : {}}, 
	schema = self.schema, 
	db = schema.db,
	_estObsBind = false, 
	record = self.entity, 
	attrData;
	if(record && record.$.isStrict && record.$.isDeleted){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.warn(db.lyte, "LD29");
		return;
	}
	if(attr && typeof attr === "object"){
		attrData = [];
		opts = value;
		for(var key in attr){
			attrData.push(key);
			setValue(self, key, attr[key], opts, toEmit, ignoreChange);
			schema && schema._properties && schema._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
		}
	}
	else{
		attrData = attr;
		setValue(self, attr, value, opts, toEmit, ignoreChange);
		schema && schema._properties && schema._properties.hasOwnProperty(attr) ? _estObsBind = true : undefined;
	}
	self.emit("set", [self.entity, attrData]);
	self.schema.emit("set", [schema._name, self.entity, attrData]);
	db.emit("set", [schema._name, self.entity, attrData]);
	if(_estObsBind){
		establishObsBindings(record, schema._properties);
	}
	if( !ignoreChange && toEmit.emit){
		changeCallbck(record, toEmit, redoObj)
	}
	return record;
} 

function changeCallbck(record, toEmit, redoObj){
	var db = record.$.schema.db;
	var arr = [record, toEmit.attr], 
	self = record.$;
	self.emit("change", arr);
	self.schema.emit("change", arr);
	db.emit("change", [self.schema._name,self.entity, toEmit.attr]);
	if(redoObj){
		for(var key in toEmit.oldRec){
			redoObj[key] = toEmit.oldRec[key];
		}
	}
	else{
		for(var index=0;index<toEmit.attr.length;index++){
			var key = toEmit.attr[index];
			self.undoStack[key] = self.undoStack[key] || [];
			self.undoStack[key].push(toEmit.oldRec[key]);
		}
		// self.undoStack._order_ = self.undoStack._order_ || _defProp(self.undoStack, "_order_", [], false, true);
		self.undoStack._order_.push(toEmit.attr); 
	}
}

function setValue(self,attr,value,opts,toEmit,ignoreChange,deepChange){
	var schema = self.schema, 
	db = schema.db,
	lyte = db.lyte,
	pK = schema._pK, 
	record = self.entity, 
	_attrs = record.$._attributes;
	if(attr === "$"){
		return;
	}
	if(attr != schema._pK){
		var field = schema.fieldList[attr], watch = field && field.opts ? field.opts.watch == true : undefined;
		var serz = field && field.opts ? field.opts.hasOwnProperty("serialize") : undefined;
		if(!field){
			cmpSet( lyte, record, attr, value, undefined, true );
			return;
		}
		else if(field.mandatory && (value == undefined || value == null || value === "")){
			_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(self, attr, {code : "ERR02", message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR02, value : value});
		}
		else if(field.relType){
			var relType = field.relType;
			var rel ={},relRec, oldVal, relMod = getSchemaObj(db, field.relatedTo), bDef = relMod, bPk = bDef._pK, relPk = relMod._pK, isComp = relMod.isComp, bPkType = isComp ? "object" : relMod.fieldList[bPk].type, relRec;
			var isComp = relMod.isComp, bPk = relMod._pK, bPkType = isComp ? "object" : relMod.fieldList[bPk].type, isPoly = field && field.opts ? field.opts.polymorphic : undefined;;
			getRelations(db, schema, field.relKey, relMod, rel);
			// var oldRecVal = record[attr], oldRecId, newRecId;
			// if(oldRecVal && isEntity(oldRecVal)){
			// 	oldRecId = oldRecVal.$.pK;
			// }
			// if(value && isEntity(value)){
			// 	newRecId = value.$.id;
			// }

			if(record[attr] && relType == "hasMany"){
				oldVal = [];
				record[attr].forEach(function(item){
					oldVal.push(item);
				});
				if(record[attr] === value){
					return;
				}
				if(Array.isArray(value) && value.length === record[attr].length){
					var valLen = value.length,j=0, val;
					for(var i=0;i<valLen;i++){
						val = value[i];
						if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(val)){
							relRec = val;
						}
						else {
							if(val && typeof val == bPkType){
								relRec = db.cache.getEntity((val._type) ? val._type : field.relatedTo, val);
							}
						}
						if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(relRec) && relRec === record[attr][i]){
							j++;
						}
						else{
							break;
						}
					}
					if(j && j == valLen){
						return;
					}
				}
				// oldVal = record[attr].slice(0);
				// oldVal1 = record[attr].mapBy(relMod._pK);
				addOnSave(db, schema._name, record, attr, field, pK, relPk);
				// toDemolishLink(schema, record, rel.forward);
				var relData = Array.from(record[attr]);
				relData.forEach(function(rec){
					demolishLink(db, rec, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
					if(rel.backward !== null){
						demolishLink(db, record, schema._pK, rec, rel.backward.relKey, rel.forward);
					}
					_attrsForRel(record, attr, "removed", rec);
				});
				// // record[attr].splice(0, record[attr].length);
				// if(record[attr].length){
				// 	handleArrOp(lyte, record[attr], "removeAt", undefined, 0, record[attr].length);
				// }
				// _attrsForRel(record, attr, "removed", oldVal, 0);
				// if(!_attr.size){
				// 	delete record.$._attributes[attr];
				// }
			}
			else if(record[attr] && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record[attr]) && relType == "belongsTo"){
				oldVal = record[attr];
				if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(value)){
					relRec = value;
				}
				else {
					if(value && typeof value == bPkType){
						relRec = db.cache.getEntity((value._type) ? value._type : field.relatedTo, value);
					}
				}
				if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(relRec) && relRec === record[attr]){
					return;
				}
				// oldVal = this.createCopy(record[attr]);
				addOnSave(db, schema._name, record, attr, field, pK, relPk);
				// oldVal1 = record[attr][relMod._pK];
				// toDemolishLink(schema, record, rel.forward);
				var relRef = record[attr];
				demolishLink(db, relRef, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
				if(rel.backward !== null){
					demolishLink(db, record, schema._pK, relRef, rel.backward.relKey, rel.forward);
				}
				_attrsForRel(record, attr, "removed", relRef);
				// record[attr] = undefined;
				cmpSet(lyte, record, attr, {}, opts, true);
				// _attrsForRel(record, attr, "removed", oldVal);
			}
			if(relType == "hasMany" && isEmpty(value)){
				var partial = record[attr] && record[attr].partial ? record[attr].partial : undefined;  
				cmpSet(lyte, record, attr, [], opts, true);
				partial ? (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.defProp)(record[attr], "partial", { value : partial }) : undefined;
				establishObsBindings(record, record.$.schema._properties);
				defArrUtls(record[attr]);
				defPolyUtls(record[attr]);
				defUtls(record[attr], relMod, record, attr);	
			}

			if(!Array.isArray(value)){
				value = [value];
			}
			else if(relType == "belongsTo"){
				revertToOldVal(record, attr, oldVal, rel);
				_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(self, attr, "ERR21", value);
				return;
			}

			var err = [];
			for(var i=0; i<value.length; i++){
				if(isEmpty(value[i]) || (relType == "belongsTo" && isEmptyObj(value[i])) || (relType == "hasMany" && isEmptyArray(value[i]))){
					continue;
				}
				var relRecord = value[i], relMod1 = (value[i] && value[i]._type) ? value[i]._type : field.relatedTo;
				relMod1 = getSchemaObj(db, relMod1);
				if(!isComp && value[i] && typeof value[i] === bPkType){
					relRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);
					if(relRecord == undefined){
						addToRelate(db, schema._name, record, rel, value[i]);
					}
					else if(!_Entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity.strictRelSet && relRecord && relRecord.$ && relRecord.$.isError){
						err.push({code : "ERR15", message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
						continue;
					}
				}
				else if(value[i] && typeof value[i] == "object"){
					if(!_Entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity.strictRelSet && relRecord.$ && relRecord.$.isError){
						err.push({code : "ERR15", message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
						continue;
					}
					else if(!(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(relRecord)){
						if(isPoly && value[i] && value[i]._type){
							relRecord = db.cache.getEntity(db.getSchema(value[i]._type), getpKVal(value[i], db.getSchema(value[i]._type)));
						}
						else if(isComp){
							relRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);
							if(!relRecord){
								relRecord = newRecord(db, relMod1, value[i], opts ? opts.skipValidation : undefined);
							}
						}
						else if(value[i].$ && value[i].$.isSavedState){
							relRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i].$.pK);
							// if(!relRecord){
							// 	//to check 	
							// }
							setState(relRecord.$, value[i]);
						}
						else{
							relRecord = newRecord(db, relMod1, value[i],opts?opts.skipValidation:undefined);
						}
						if(!_Entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity.strictRelSet && relRecord.$.isError){
							err.push({code : "ERR15", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
							continue;
						}
					}
				}
				var changed = establishLink(db, rel.forward, rel.backward, record, relRecord , undefined, undefined);
				if(changed != true){
					err.push({code : changed, data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes[changed]});
				}
				else{
					_attrsForRel(record, attr, "added", relRecord);
					// if(!_attr.size){
					// 	delete record.$._attributes[attr];
					// }
					addOnSave(db, schema._name, record, attr, field, pK, relPk);
				}
			}
			if(err.length && (err.length == value.length)){
				revertToOldVal(record, attr, oldVal, rel);
				if(field.relType == "belongsTo"){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(self, attr, err[0]);
				}
				else{
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(self, attr, err);
				}
				return;
			}
			else{
				if(err.length > 1){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(self, attr, err);
				}
				else{
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(self, attr);
				}
				if(!ignoreChange || serz){
					toEmit.emit = true;
					toEmit.attr.push(attr);
					var obj = {}; obj.records = oldVal; obj._type = "update";
					toEmit.oldRec[attr] = obj;
					var _attr = _attrs[attr] = _attrs[attr] || new Map();
					var _changes = _attr._changes = _attr._changes || []; 
					_changes.push({_type:"changed", records:oldVal});
					cmpRelInitVal(record, attr, bDef);
				}
			}
		}
		else{
			if(value !== record[attr]){
				// if(field && field.type !== Lyte.getDataType(value) && (value !== undefined  || field.type === "boolean")) {
				// 	value = Lyte.typeCast(value, field.type);
				// }
				var clear = true;
				if(!opts || (opts && opts.skipValidation !== true)){		
					for(var property in field){
						var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkProperty)(property, value, attr, field[property], record, schema._name, db, _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.errorCodes, undefined, field, true);
						if(resp != true){
							if(typeof resp == "object"){
								resp.value = value;
							} 
							_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(self, attr, resp);
							clear = false;
							if(_Entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity.strictValueSet === false){
								break;
							}
							return;
						}
					}
				}
				if(!ignoreChange){
					estAttrs(record, attr, value, toEmit, deepChange, opts, clear);
				}
				else{
					if(watch && /^(array|object)$/.test(field.type)){
						(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.establishObjectBinding)(record, attr, true, undefined, undefined,watch);
					}
					cmpSet(lyte,record,attr,value,opts,true);
				}
			}
			else if(value === record[attr] && record.$.isError && record.$.error[attr]){
				var valid = true;
				for(var property in field){
					var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkProperty)(property, value, attr, field[property], record, schema._name, db, _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.errorCodes, undefined, field, true);
					if(resp != true){
						valid = false;
					}
				}
				if(valid){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(self,attr);
				}
			}
		}
		checkAttrs(record);
	}
	else{
		if(record[attr] !== value){
			_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(self, attr, "ERR01", value);
		}
	}
}

function estAttrs(record, attr, value, toEmit, deepChange, opts, clear){
	var _attrs = record.$._attributes, 
	schema = record.$.schema, 
	attribute = _attrs[attr], 
	isAttrPres = _attrs.hasOwnProperty(attr);
	if( !isAttrPres){
		_attrs[attr] = deepChange ? deepChange.data : createCopy(record[attr]);
	}
	else if((( deepChange && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.cmpData)(isAttrPres ? attribute : deepChange.data, record[attr])) || (value && typeof value == "object" && ( !deepChange && compareObjects(attribute, value))) || (attribute == value))){
		delete _attrs[attr];
	}
	var hasAttr = record.hasOwnProperty(attr), 
	oldAttrVal = deepChange ? deepChange.data : record[attr];
	if(!deepChange){
		var isPropPresent = schema._properties && schema._properties.hasOwnProperty(attr), propObj = {};
		if(isPropPresent){
			propObj[attr] = schema._properties[attr];
			demoLishObserverBindings(record, propObj);
		}
		cmpSet(schema.db.lyte,record,attr,value,opts,true);
	}
	if(clear){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(record.$, attr);
	}
	var obj = {};
	obj._type = "update";
	obj.val = oldAttrVal;
	if(!hasAttr){
		obj._type = "propAdd";
	}
	toEmit.emit = true;
	toEmit.attr.push(attr);
	toEmit.oldRec[attr] = obj;
}

function checkAttrs(record){
	var schema = record.$.schema;
	if( Object.keys(record.$._attributes).length ){
		// changeModified(schema.db.lyte, record, true, record.$.pK, true);
		if(!record.$.isNew){
			cmpSet(schema.db.lyte, record.$, "isModified", true);
			changePersist(record, false);
		}
		addDeepNest(record);
		checkAndAddToArray(schema.dirty, record[schema._pK]);
	}
	else{
		// changeModified(schema.db.lyte, record, false);
		cmpSet(schema.db.lyte, record.$, "isModified", false);
		changePersist(record, true);
		if(!record.$.isNew && (!record.$.hasOwnProperty("dN") || (record.$.dN && !Object.keys(record.$.dN).length))){
			var ignorePartial = record.$.isNew ? true : false;
			removeParentNesting(record, ignorePartial);                  
		}
		if(!record.$.isNew){
			deleteFromArray(schema.dirty, record.$.pK);
		}
	}
}

function checkForCorrectRelation(db,rel,record){
	var relatedTo = rel.relatedTo;
	if(!(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record)){
		return false;
	}
	if(rel.opts && rel.opts.polymorphic){
		return (record.$.schema.extend ? rel.relatedTo === db.getSchema(record.$.schema.extend) : false);
	}
	return (rel && record ? relatedTo === record.$.schema.def : false);
}

function partialData(rec, prop, relRec, type, polymorphicType,partRemoveOnly){
	var arr = rec[prop];
	if(!arr || !Array.isArray(arr)){
		return true;
	}
	if(!arr.partial){
		defPar(arr);
	}
	var partial = arr.partial; 
	// = arr.partial || new Map();
	if(!partial.get(relRec)){
		partial.set(relRec, {});
	}
	var revert = false, 
	obj = partial.get(relRec), 
	objType = obj.type;
	if(type == "delete"){
		partial.delete(relRec);
		revert = true;
	}
	else{
		switch(objType){
			case "added":{
				if(type == "removed"){
					partial.delete(relRec);
					revert = true;
				}
				break;
			}
			case "removed":{
				if(type == "added"){
					if(rec[prop]._recMap){
						var relRec = rec[prop]._recMap.get(relRec.$.pK);
					} 
					if(!relRec || ((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(relRec) && !relRec.$.isDirty())){
						partial.delete(relRec);
						revert = true;
					}
					else{
						var obj = partial.get(relRec);
						obj.type = "modified";
					}
				}
				break;
			}
			case "modified":
			case "updated":{
				if(type == "added"){
					//this case mostly won't come. if at all it comes, break
					break;
				}
			}
			default:{
				if(!partRemoveOnly){
					var pObj = { type : type };
					polymorphicType ? pObj.polymorphicType = polymorphicType : undefined;
					partial.set(relRec, pObj);
				}
			}
		}
	}
	if(revert && !partial.size){
		deleteDeepNest(rec, prop, relRec);
		return true;
	}
}

function removeDeepNest(record){
	if(!(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record)){
		return;
	}
	var bool1 = record.$.dN && Object.keys(record.$.dN).length;
	if(bool1){
		record.$.dN = {};
		var schema = record.$.schema, 
		relations = schema.relations;
		relations.forEach(function(rels, key){
			rels.forEach(function(item){
				var opts = item.opts;
				if(opts && (opts.deepNest == true || opts.serialize == "partial")){
					var data = record[item.relKey];
					if(Array.isArray(data)){
						data.forEach(function(itm){
							if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(itm)){
								removeDeepNest(itm);
								if(!itm.$.isNew && !itm.$.isModified && (!itm.$.dN || ( itm.$.dN && Object.keys(itm.$.dN).length == 0 ))){
									removeParentNesting(itm);
								}
							}
						});
					}
					else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data)){	
						removeDeepNest(data);
						if(!data.$.isNew && !data.$.isModified && (!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0))){
							removeParentNesting(data);
						}																			
					}
				}
			});					
		});
	}
}

function addDeepNest(record, extended,type,parentRel,ignoreRel, mp , processOnlySrzPart){
	var relatedRecord, 
	mp = mp || new Map(),
	db = record.$.schema.db,
	schema = extended ? db.schema[record.$.schema.extend] : record.$.schema, 
	pK = record.$.pK,
	type = type || "updated",
	relations = schema.relations;
	relations.forEach(function(rels, key){
		rels.forEach(function(item){
			var inv , deep, part, serz, bMod = getSchemaObj(db , item.relatedTo);
			inv = getBackwardRel(schema,item,bMod);
			if(bMod){
				if(!item.relKey || (inv === item)){
					relatedRecord = getRelatedRecord(record,getSchemaObj(db, item.relatedTo),item.dummy ? item.dummy: item.relKey);
				}
				else{
					relatedRecord = record[item.relKey];
				}
				if(relatedRecord){
					var mppass = false, nmp , ignoreDn;
					if(inv !== parentRel){		
						if(!mp.get(inv)){
							nmp = mp.set(inv, new Map());
							mppass = true;
						}
						nmp = mp.get(inv);			
						if(mppass || !nmp.get(relatedRecord)){
							nmp.set(relatedRecord, true);
							if(inv && inv.opts){
								deep = inv.opts.deepNest;
								part = inv.opts.serialize == "partial" ? true : false; 
								serz = inv.opts.serialize ? true : false;
							}
							if((type == "updated" && serz == "id")){
								ignoreDn = true;
							}
							if((!processOnlySrzPart || ( processOnlySrzPart && part)) && !ignoreDn){
								if(deep == true){
				//					if(deep || part){
									makeDirty(relatedRecord, type, inv, pK, item, record, mp);
								}
								if(serz && record && relatedRecord && (!ignoreRel || !(ignoreRel && ignoreRel.schema === item.relatedTo && inv.relKey === ignoreRel.relKey))){
									var data = relatedRecord;
									if(inv.relType == "hasMany"){
										if(Array.isArray(data)){
											data.forEach(function(item){
												partialData(item, inv.relKey, record , /^(added|removed)$/.test(type) ? type : "modified");								
											});
										}
										else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data)){
											partialData(data, inv.relKey, record, /^(added|removed)$/.test(type) ? type : "modified");	
										}
									}
									else{
										if(Array.isArray(data)){
											data.forEach(function(item){
												if(type == "added" && item && item.$ && item.$.partial && item.$.partial[inv.relKey] && item.$.partial[inv.relKey].has(pK)){
													delete item.$.partial;
												}
											});
										}
										else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data)){
											if(type == "added" && data && data.$ && data.$.partial && data.$.partial[inv.relKey] && data.$.partial[inv.relKey].has(pK)){
												delete data.$.partial;
											}
										}
									}
									//partialData(record[item.relKey], inv.relKey, pK , "modified");
								}
							} 
						}
					}
				}
			}
		});		
	});
	if(schema.extend){
		addDeepNest(record, true);
	}
}

function makeDirty(records, type, rel, pK, parentRel, relRec, mp){
	if(!(rel.opts.serialize =='id' && type =="updated")){
		var relKey = rel.relKey;
		if(Array.isArray(records)){
			records.forEach(function(item){
				setDeepNest(item, relKey, pK, type, parentRel, relRec, mp);
			});
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(records)){
			setDeepNest(records, relKey, pK, type, parentRel, relRec, mp);
		}
	}
}

function setDeepNest(item, relKey, pK, type, parentRel, relRec, mp){
	var deepN = item.$.dN = item.$.dN || {}, 
	deepRel = deepN[relKey] = deepN[relKey] || new Map();
	if(!deepRel.has(relRec)){
		deepRel.set(relRec, {});
	}
	var obj = deepRel.get(relRec);
	switch(obj.type){
		case "added": {
			if(type == "removed"){
				deleteDeepNest(item, relKey, relRec);
			}
			break;
		}
		case "removed": {
			if(type == "added"){
				deleteDeepNest(item, relKey, relRec);
			}
			break;
		}
		default : {
			obj.type = type;
			changePersist(item, false);
			addDeepNest(item, undefined, undefined, parentRel, undefined, mp);		
		}
	}
}

function deleteDeepNest(rec, key, relRec){
	var deepNest = rec.$.dN;
	if(deepNest){
		if(deepNest[key] && relRec === undefined){
			delete deepNest[key];
		}
		else if(deepNest[key] && deepNest[key].get(relRec)){
			deepNest[key].delete(relRec);
			if(!deepNest[key].size){
				delete deepNest[key];
			}
		}
		if(!Object.keys(deepNest).length){
			delete rec.$.dN;
			if(!rec.$.isModified && !rec.$.isNew){
				removeParentNesting(rec);
			}
			changePersist(rec, true);
		}
	}
}

function getRelatedRecord(ins,def,key){
	if(ins){
		var relationship = ins.$._relationships;
		if(relationship[def._name] && relationship[def._name][key]){
			return relationship[def._name][key];
		}
	}
}

function removeParentNesting(rec, ignorePartial, type){
	var schema = rec.$.schema, 
	db = schema.db,
	pkVal = rec.$.pK, 
	rels = schema.relations;
	rels.forEach(function(relations, key){
		relations.forEach(function(item){
			var inv, deep, part, invRecs;
			//getRelations(schema, item.relKey, db.schema[item.relatedTo], rel);
			var bMod = item.relatedTo, _bDef = getSchemaObj(db, bMod);
			if(bMod){
				inv = getBackwardRel(schema, item, _bDef);
				//inv = rel.backward;
				if(inv && inv.opts){
					deep = inv.opts.deepNest;
					part = inv.opts.hasOwnProperty("serialize");
					if(!item.relKey || (item == inv)){
						invRecs = getRelatedRecord(rec,_bDef,item.dummy?item.dummy:item.relKey);
					}
					else{
						invRecs = rec[item.relKey];
					}
				}
				// if(deep == true){
				// 	if(Array.isArray(invRecs)){
				// 		invRecs.forEach(function(item){
				// 			if(isEntity(item)){
				// 				deleteDeepNest(item, inv.relKey, rec);
				// 			}
				// 		});
				// 	}
				// 	else if(isEntity(invRecs)){
				// 		deleteDeepNest(invRecs, inv.relKey, rec);
				// 	}
				// }
				if(part && !ignorePartial){
					if(invRecs && !Array.isArray(invRecs)){
						invRecs=[invRecs];
					}
					if(Array.isArray(invRecs)){
						invRecs.forEach(function(invItm){
							if(invItm instanceof bMod){
								if(inv.relKey){	
									if(inv.relType == "belongsTo" && invItm && invItm.$){
										if(invItm.$.partial && invItm.$.partial[inv.relKey] && invItm.$.partial[inv.relKey].has(rec)){
											invItm.$.partial[inv.relKey].delete(rec);
											if(!invItm.$.partial[inv.relKey].size){
												delete invItm.$.partial[inv.relKey]; 
											}
										}
										deep ? deleteDeepNest(invItm, inv.relKey, rec ) : undefined;
									}
									else if(inv.relType == "hasMany"){
										var invArr = invItm[inv.relKey];
										if(Array.isArray(invArr)){
											if(invArr.partial && invArr.partial.has(rec)){
												var _ptype = invArr.partial.get(rec).type;
												if(type == "modified"){
													if(/^(modified|updated)$/.test(_ptype)){
														invArr.partial.delete(rec);
													}   
												}
												else{
													invArr.partial.delete(rec);
												}
											}
											deep ? deleteDeepNest(invItm, inv.relKey, rec) : undefined;
										}
									}
								}
							}
						});
					}
				}
			}
		});		
	});
}

function cmpRelInitVal(record, attr, bDef ){
	var arr = record.$.getInitialValues(attr), 
	changed = true, 
	_attrs = record.$._attributes, 
	bPk = bDef._pK, 
	field = record.$.schema.fieldList[attr], 
	srz = field && field.opts ? field.opts.serialize : undefined, 
	cmpInd = (srz == "id" || srz == "record"); 
	if(arr && Array.isArray(record[attr]) && arr.length == record[attr].length && cmpInd){
		changed = false;
		for(var i=0; i<arr.length; i++){
			if(!comparePk(record[attr][i], arr[i])){
				changed = true;
				break;
			}
		}
	}
	var size = _attrs[attr].size;
	if((!changed && size == 0 && cmpInd) || (srz == "partial" && size == 0)){
		delete _attrs[attr];
	}
}

function _attrsForRel(record, attr, type, arr, index){
	var _attrs = record.$._attributes, 
	_attr,
	db = record.$.schema.db; 
	_attr = _attrs[attr] = _attrs[attr] || new Map();
	if(arr && !Array.isArray(arr)){
		arr = [arr];
	}
	arr.forEach(function(itm){
		var _attrObj = _attr.get(itm), currType = _attrObj ? _attrObj._type : undefined;
		switch(currType){
			case "added": {
				if(type == "removed"){
					_attr.delete(itm);
					break;
				}
			}
			case "removed":{
				if(type == "added"){
					_attr.delete(itm);
					break;
				}
			}
			default: {
				var obj = { _type : type };
				if(index){
					obj.index = index;
				}
				_attr.set(itm, obj);
			}
		}
	});
}

function establishToRelated(record, relArr){
	var bSchema = record.$.schema, 
	rel = {},
	db = bSchema.db;
	relArr.forEach(function(item){
		var rec = db.cache.getEntity(db.getSchemaObj(item.schema).def, item.pkVal);
		if(rec){
			var fSchema = rec.$.schema;
			getRelations(db, fSchema, item.key, bSchema, rel);
			establishLink(db, rel.forward, rel.backward, rec, record, undefined, true);
		}
	});
}

function add(value,type,opts,redoObj){
	var record = this.entity, 
	schema = record.$.schema,
	db = schema.db,
	attr = this.key, 
	field = schema.fieldList[attr], 
	rel = {}, 
	oldArr, 
	serz = field.opts ? field.opts.hasOwnProperty("serialize") : undefined;
	getRelations(db, schema, field.relKey, getSchemaObj(db, field.relatedTo), rel);
	if(!Array.isArray(value)){
		value = [value];
	}
	var relMod = getSchemaObj(db, rel.forward.relatedTo);
	var pK = relMod._pK, err = [], arr = [], isComp = relMod.isComp;
	if(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){
		oldArr = record.$.getInitialValues(attr);
	}
	for(var i=0; i<value.length; i++){
		var rec = value[i];
		if(isComp){
			if(typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length){
				if(this.polymorphic && !type){
					err.push({code : "ERR22", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR22});
					continue;
				}
				
				rec = db.cache.getEntity(this.polymorphic && type ? (typeof type == "string" ? db.getSchema(type) : type) : rel.forward.relatedTo, rec);	
			}
		}
		if((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof rec) || (isComp && typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length) ){
			if(this.polymorphic && !type){
				err.push({code : "ERR22", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR22});
				continue;
			}
			rec = db.cache.getEntity(this.polymorphic && type ? (typeof type == "string" ? db.getSchema(type) : type) : rel.forward.relatedTo, rec);
		}
		else if(typeof rec == "object" && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(rec)){
			if(this.polymorphic){
				var pType;
				if(rec._type){
					pType = typeof rec._type == "string" ?  db.getSchemaObj(rec._type) : rec._type
				}
				else if(type){
					pType = typeof type == "string" ?  db.getSchemaObj(type) : type
				}
				if(!pType){
					err.push({code : "ERR22", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR22});
					continue;
				}
				rec = newRecord(db, pType, rec, opts?opts.skipValidation:undefined);
			}
			else{
				rec = newRecord(db,getSchemaObj(db,field.relatedTo), rec, opts?opts.skipValidation:undefined);
			}
		}
		var polyType = this.polymorphic && type ? type : ((rec && rec._type) ?rec._type: undefined);
		if(rec == undefined){
			err.push({code : "ERR13", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR13});
		}
		else if(!_Entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity.strictRelSet && rec.$ && rec.$.isError){
			err.push({code : "ERR15", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR15, error : rec});
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(rec) && !hasDuplicateRelation(rec, record[attr], pK, polyType, relMod)){
			var resp = establishLink(db, rel.forward, rel.backward, record, rec);
			if(resp != true){
				err.push({code : resp, data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes[resp]});
			}
			else{
				arr.push(rec);
			}
		}
	}
	if(arr.length){
		if(serz){
			var obj = {_type:"added", records: arr};
			_attrsForRel(record, attr, "added", arr);
			if(redoObj){
				redoObj[attr] = obj; 
			}
			else{
				var stackObj = {};
				stackObj[attr] = obj;
				record.$.undoStack[attr] = record.$.undoStack[attr] || [];
				record.$.undoStack[attr].push(obj);
				// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
				record.$.undoStack._order_.push([attr]);
			}
			var _attrs = record.$._attributes, _attr = _attrs[attr];
			if(_attr){
				var _changes = _attr._changes = _attr._changes || [];
				_changes.push(obj);
			}
			cmpRelInitVal(record, attr, relMod);
			if(Object.keys(_attrs).length > 0){
				// changeModified(db.lyte, record, true)
				if(!record.$.isNew){
					cmpSet(db.lyte, record.$, "isModified", true);
					changePersist(record, false);
				}
				checkAndAddToArray(schema.dirty, record[schema._pK]);
			}
			else{
				delete record.$._attributes[attr];
				if(!Object.keys(record.$._attributes).length){
					// changeModified(db.lyte, record, false, record.$.pK)
					cmpSet(db.lyte, record.$, "isModified", false);
					changePersist(record, true);
					// record.$.isModified = false;
					// delete _attrs[attr];
					if(!record.$.isNew){
						deleteFromArray(schema.dirty, record.$.pK);
						if(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){
							removeParentNesting(record);
						}			
					}
				}
			}
			emit(db, "change", record, [attr]);
		}
	}
	if(err.length > 0){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(record.$, attr, err);
	}
	else{
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(record.$, attr);
	}
	return record;
}

function remove(key,type,redoObj){
	var record = this.entity, 
	schema = record.$.schema, 
	db = schema.db,
	lyte = db.lyte,
	attr =  this.key, 
	field = schema.fieldList[attr], 
	rel = {},
	oldArr, 
	serz = field.opts ? field.opts.hasOwnProperty("serialize") : undefined;
	getRelations(db, schema, field.relKey, getSchemaObj(db, field.relatedTo), rel);
	if(!Array.isArray(key)){
		key = [key];
	}
	var relMod = getSchemaObj(db, rel.forward.relatedTo), 
	pK = relMod._pK, 
	isComp = relMod.isComp, 
	err = [], 
	relatedRecord, 
	arr = [], 
	indices = [];
	if(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){
		oldArr = record.$.getInitialValues(attr);
	}
	for(var i=0; i<key.length; i++){
		var rec = key[i], polyType;
		if((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof key[i]) || (isComp && typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length)){
			if(this.polymorphic == true && !type){
				err.push({code : "ERR22", data : key[i], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR22});
				continue;
			}
			relatedRecord = db.cache.getEntity((type)?(typeof type == "string" ? db.getSchema(type) : type):rel.forward.relatedTo,key[i]);
			polyType = type;
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(key[i])){
			relatedRecord = key[i];
			polyType = type ? type : ((relatedRecord && relatedRecord._type) ? relatedRecord._type : undefined);
		}
		if(relatedRecord){
			var index = getIndex(record[attr], pK, relatedRecord.$.get(pK),polyType);
			demolishLink(db, relatedRecord, pK, db.cache.getEntity(schema.def, record.$.pK), rel.forward.relKey, undefined, undefined, undefined, true);
			if(rel.backward != null){
				demolishLink(db, record, schema._pK, db.cache.getEntity((polyType)?(typeof polyType == "string" ? db.getSchema(polyType) : polyType):rel.forward.relatedTo, relatedRecord.$.pK), rel.backward.relKey, rel.forward);
			}
			arr.push(relatedRecord);
			indices.push(index);
		}
	}
	if(arr.length){
		if(serz){
			var obj = {_type:"removed", records: arr, _indices : indices};
			_attrsForRel(record, attr, "added", arr);
			if(redoObj){
				redoObj[attr] = obj; 
			}
			else{
				var stackObj = {};
				stackObj[attr] = obj;
				// record.$.undoStack.push(stackObj);
				record.$.undoStack[attr] = record.$.undoStack[attr] || [];
				record.$.undoStack[attr].push(obj);
				// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
				record.$.undoStack._order_.push([attr]); 
			}
			var _attrs = record.$._attributes, _attr = _attrs[attr];
			if(_attr){
				var _changes = _attr._changes = _attr._changes || [];
				_changes.push(obj);
			}
			// if(!_attr.size){
			// 	delete record.$._attributes[attr];
			// }
			cmpRelInitVal(record, attr, relMod);
			if(Object.keys(_attrs).length > 0){
				// changeModified(lyte, record, true);
				if(!record.$.isNew){
					cmpSet(lyte, record.$, "isModified", true);
					changePersist(record, false);
				}
				checkAndAddToArray(schema.dirty, record[schema._pK]);
			}
			else{
				delete record.$._attributes[attr];
				if(!Object.keys(record.$._attributes).length){
					// changeModified(lyte, record, false, record.$.pK)
					cmpSet(lyte, record.$, "isModified", false);
					changePersist(record, true);
					// record.$.isModified = false;
					// delete _attrs[attr];
					if(!record.$.isNew){
						deleteFromArray(schema.dirty, record.$.pK);								
						if(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){
							removeParentNesting(record);
						}			
					}
				}
			}
		}
		emit(db, "change", record, [attr]);
	}
	if(err.length > 0){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(record.$, attr, err);
	}
	else{
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(record.$, attr);
	}
}

function filter(record,filObj,len){
	var j=0;
	for(var key in filObj){
		if(record[key] === filObj[key]){
			j++;
		}
	}
	if(j === len){
		return true;
	}
}

function filterBy(obj){
	var len = Object.keys(obj).length, j = 0, arr = [];
	for(var i=0; i<this.length; i++){
		if(filter(this[i],obj,len)){
			arr.push(this[i]);
		}
	}
	if(!arr.filterBy){
		defArrUtls(arr);
		defUtls(arr,this.schema);
	}
	return arr;
}

function checkAndAddToArray(arr,value){
	if(!checkPresenceInArray(arr,value)){
		arr.push(value);
	}else{
		return -1;
	}
}

function deleteFromArray(arr,value){
	var ind = arr.indexOf(value);
	if(ind != -1){
		arr.splice(ind,1);
	}
}

function genPk(pK, opts, fields){
	var pkType;
	pK.forEach(function(item){
		pkType = fields[item].type;
		var random = opts[item] = Math.floor(Math.random()*100000 + 1);
		if(pkType == "string"){
			opts[item] = random.toString();                    
		}
	});
}

function generateRandomPk(def, opts, pK, fields){
	genPk(pK, opts, fields);
	while(isDuplicateRecord(def, opts, pK.toString())){
		genPk(pK, opts, fields);
	}            
}

function isDuplicateRecord(def,obj){
	var data = def.data, pK = def._pK, isComp = def.isComposite;
	if(data.length){
		if(!isComp && def.data._recMap){
			var pkVal = obj[pK];
			if(pkVal!=undefined){
				return def.data._recMap.get(pkVal ? pkVal.toString() : pkVal) !== undefined;
			}
			else{
				return false
			}
		}
		else{
			return data.some(function(record){
				if(compareObjects( getpKVal(obj, def), getpKVal(record) )){
					return true;
				}
			});
		}
	}
	return false;
}

function pkPresence(opts, pK){
	var result = true;
	pK.forEach(function(item){
		if(!opts.hasOwnProperty(item) || !opts[item] ){
			result = false;
			return;
		}
	});
	return result;
}

function updateJSON(db, record, def, dirty){
	var data = {},
	arrPk = def._arrPk,
	dirtyAttr = record.$._attributes;
	for(var field in dirtyAttr){
		data[field] = record[field];
	}
	var attrs = dirty;
	if(dirty == true){
		attrs = isDirty(db, record, def.relations) || [];
	}
	for(var i=0;i<attrs.length;i++){
		data[attrs[i]] = record[attrs[i]];
	}
	arrPk.forEach(function(item){
		data[item] = record[item];
	});
	return data;
}

function isDirty(db, record, relations, parent, fMod){
	var result = [];
	relations.forEach(function(red_def, rel){
		for(var j=0;j<red_def.length;j++){
			var rel = red_def[j];
			if(rel.opts && rel.opts.serialize){
				var key = rel.relKey, 
				type = rel.relType, 
				records = record[key],
				bMod = rel.relatedTo;
				if(parent && bMod){
					var child = getBackwardRel(fMod,rel,getSchemaObj(db, rel.relatedTo));
					if(parent == child && fMod != rel.relatedTo){
						continue;
					}
				}
				if(rel.opts.serialize == "record"){
					var res = isRelDirty(db, rel, records, rel);
					if(res){
						result.push(key);
						continue;
					}							
				}
				else if(rel.opts.serialize == "partial"){
					if(type == "hasMany"){
						if(records && records.partial && records.partial.size){
							result.push(key);
							continue;
						}
					}
					else{
						if(((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(records) && records.$.isModified) || (record && record.$ && record.$.partial && record.$.partial.hasOwnProperty(key))){
							result.push(key);
							continue;
						}
					}
				}
				if(rel.opts.deepNest == true){	
					if(record.$.dN && record.$.dN[key]){
						result.push(key);
					}
				}
			} 
		}
	});
	return result;
}

function isRelDirty(db, rel, records, parent){
	var type = rel.relType;
	var fMod = rel.relatedTo;
	var fDef = getSchemaObj(db, fMod);
	var relations = fDef.relations; 
	if(!isEmpty(records)){
		if(type == "hasMany" && Array.isArray(records) && records.length){
			var len = records.length;
			for(var i=0; i<len; i++){
				if(records[i].$.isModified == true){
					return true;
				}
			}
			for(var j=0; j<len; j++){
				var rec = records[j];
				var arr = isDirty(db, rec, relations, parent, fDef);
				if(arr.length){
					return true;
				}
			}
		}
		else if(type == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(records)){
			if(records.$.isModified == true){
				return true;
			}
			var arr = isDirty(db, records, relations, parent, fDef);
			if(arr.length){
				return true;
			}
		}
	}
	return false;
}

function polymorphicToJSON(db,rel,data){
	var opts = rel.opts;
	if(opts && opts.polymorphic){
		if(Array.isArray(data)){
			var res = [];
			data.forEach(function(item){
				res.push(polyToJSON(db,item));
			});
			return res;
		}
		else{
			return polyToJSON(db,data);
		}
	}
}

function polyToJSON(db, data){
	// var type = data ? data._type : undefined;
	var polyMod = data.$.schema;
	if(!polyMod.hasOwnProperty("fieldList") && polyMod._name){
		polyMod = db.getSchema(polyMod._name);
	} 
	var pK = polyMod ? polyMod._pK : undefined, 
	poly = {}, 
	pkVal = data.$.pK;

	if(typeof pkVal == "object"){
		poly = Object.assign({}, pkVal);
	}
	else{
		poly[pK] = pkVal;
	}
	// poly._type = data._type;
	poly._type = data._type ? data._type : data.$.model._name;
	return poly;
}

function removeBackwardRel(val,rel,pK,pkVal,wholeRelKey){
	if(wholeRelKey){
		delete val[rel.backward.relKey];
		return; 
	}
	if(rel.backward != null){
		var rec = val[rel.backward.relKey];
		if(Array.isArray(rec)){
			for(var i=0; i<rec.length; i++){
				if(comparePk(rec[i],pkVal)){
					rec.splice(i,1);
					if(rec.length == 0){
						delete val[rel.backward.relKey];
					}
					return;
				}								
			}
		}
		else if(rec && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(rec) && comparePk(rec, pkVal)){
			delete val[rel.backward.relKey];
		}
	}
}

function checkPresenceInArray(arr,value){
	return arr && arr.some(function(val){
		return val === value;
	});
}

function idbSerialize(db, data, rel, def, bDef, pkVal, expose){
	var relTo = rel.forward.relatedTo, 
	pK = def._pK, 
	bPk = bDef._pK;
	if(Array.isArray(data)){
		data.forEach(function(item, index){
			if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(item) && item.$.inIDB){
				data[index] = item[bPk];										
			}
			else if(!checkPresenceInArray(db.$.recStack[relTo._name],item[bPk])){
				removeBackwardRel(item, rel, pK, pkVal, true);
				removeSelfCircularReference(db, bDef._name, item, expose);
			}
			else{
				data[index] = item[bPk];										
			}
		});
	}
	else if(data && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data)){
		if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data) && data.$.inIDB){
			obj[relKey] = data[bPk];
		}
		else if(!checkPresenceInArray(db.$.recStack[relTo._name],data[bPk])){
			removeBackwardRel(data, rel, pK, pkVal, true);
			removeSelfCircularReference(db, bDef._name, data,expose);
		}else{
			obj[relKey] = data[bPk];
		}
	}
}

function idSerialize(db, obj, rel, expose, partialObj, partialRef){
	var opts = rel.forward.opts, 
	polymorphic = opts ? opts.polymorphic : undefined, 
	relKey = rel.forward.relKey,
	relKey = rel.forward.relKey, 
	toJSON,
	clone, 
	saveState;
	if(opts){
		toJSON = opts.toJSON, clone = opts.clone, saveState = opts.saveState;
	}
	var data = obj[relKey], 
	schema = rel.backward.relatedTo, 
	bDef = rel.forward.relatedTo, 
	pkVal = getpKVal(obj,getSchemaObj(db, schema)), 
	modName;
	if(Array.isArray(data)){
		if(polymorphic){
			obj[relKey] = polymorphicToJSON(db,rel.forward,data);
		}
		else{
			var arr = [];
			if(partialObj){
				var partial = partialObj[relKey] = partialObj[relKey] || [], anyNew = false;
			}
			data.forEach(function(item){
				if(item.$.isNew && expose != true && expose != "state"){
					anyNew = true;
					rSerialize(db, item, rel, bDef, schema._pK, pkVal, expose, partial, partialRef);
					arr.push(item);													
				}
				else{
					if(partial){
						var pObj = {}, pType = "related";
						if(item.$.isDeleted){
							pType = "removed";
						}
						_defProp(pObj, "$", {});
						var nPartial = 	pObj.$, nDef = getSchemaObj(db, rel.forward.relatedTo);
						Object.defineProperties(nPartial, {
							pkVal : {
								value : item.$.pK
							},
							type : {
								value : pType
							},
							schema : {
								value : nDef
							},
							record : {
								value : db.cache.getEntity(nDef.def, item.$.pK)
							}
						});		
						if(item.$.isDeleted){
							pObj.$.onlyDetach = true;
						}
						partial.push(pObj);
					}
					if(!item.$.isDeleted){
						if(expose == true && toJSON){
							arr.push(item.$.toJSON(undefined, rel.backward));
						}
						else if(expose == "state" && saveState){
							arr.push(item.$.saveState(undefined, true, rel.backward));
						}
						else if(expose == "clone" && clone){
							arr.push(item.$.clone(rel.backward));
						}
						else{
							arr.push(item.$.pK && typeof item.$.pK == "object" ? Object.assign({}, item.$.pK) : item.$.pK);
						}	
					}
				}
			});
			obj[relKey] = arr;
		}
	}
	else if(data && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data)){
		if(data.$.isNew && expose != true && expose != "state"){
			var partial;
			if(partialObj){
				partial = partialObj[relKey] = partialObj[relKey] || {};
			}
			partial = rSerialize(db, data, rel, bDef, schema._pK, pkVal, expose, partial, partialRef);
			partialObj[relKey] = partial;
		}
		else{
			if(polymorphic){
				obj[relKey] = polymorphicToJSON(db,rel.forward,data);								
			}
			else if(!data.$.isDeleted){
				if(expose == true && toJSON){
					obj[relKey] = data.$.toJSON(undefined, rel.backward);
				}
				else if(expose == "state" && saveState){
					obj[relKey] = data.$.saveState(undefined, true, rel.backward);
				}
				else if(expose == "clone" && clone){
					obj[relKey] = data.$.clone(rel.backward);
				}
				else{
					obj[relKey] = (data.$.pK && typeof data.$.pK == "object" ? Object.assign({}, data.$.pK) : data.$.pK);
				}
			}
		}
	}
}

function recordSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef){
	var pK = def._pK;
	if(Array.isArray(val)){
		if(val.length == 0){
			delete obj[key];
			return 0;
		}
		val = Array.from(val);
		var partial = partialObj[key] = partialObj[key] || [];
		for(var j=0; j<val.length; j++){
			if(val[j] && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(val[j])){
				rSerialize(db, val[j], rel, bDef, pK, pkVal, expose, partial, partialRef);
				if(val[j].$.isDeleted){
					partial[j] && partial[j].$ ? partial[j].$.onlyDetach = true : undefined; 
					val.splice(j,1);
					j--;
				}
			}
		}
	}
	else if(val && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(val)){
		var partial = partialObj[key] = partialObj[key] || {};
		partial = rSerialize(db, val, rel, bDef, pK, pkVal, expose, partial, partialRef);
		// if(val.$.isDeleted){
		// 	debugger
		// }
		partialObj[key] = partial;
	}
}

function rSerialize(db, data, rel, bDef, pK, pkVal, expose, partialObj, partialRef){
	var relTo = rel.forward.relatedTo, 
	partial, 
	def = rel.backward.relatedTo, 
	polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined; 
	removeBackwardRel(data, rel, pK, pkVal);
	if(partialObj){
		var partial = {}, 
		pType = data.$.isNew ? "added" : data.$.isModified ? "modified" : data.$.isDeleted ? "removed" : "related", modName;
		if(polymorphic){
			modName = data.$.schema._name;
			data.$.polymorphicType = modName;
			bDef = db.schema[modName];
		}
		_defProp(partial, "$", {});
		var nPartial = 	partial.$, 
		nDef = polymorphic ? db.schema[modName] : getSchemaObj(db, relTo);
		Object.defineProperties(nPartial, {
			pkVal : {
				value : data.$.pK
			},
			type : {
				value : pType
			},
			schema : {
				value : nDef
			},
			record : {
				value : db.cache.getEntity(nDef.def, data.$.pK)
			}
		});
		if(Array.isArray(partialObj)){
			partialObj.push(partial);
		}
	}
	removeSelfCircularReference(db, bDef._name, data, expose, undefined, partial, partialRef);
	return partial;
}

function partialSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef){
	var field = rel.forward, 
	pK = def._pK, 
	relTo = rel.forward.relatedTo,
	polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
	if(field.relType == "hasMany"){
		if(val && val.partial){
			var part = val.partial,
			bpK = bDef._pK;
			if(partialObj){
				partial = partialObj[key] = partialObj[key] || [];
				_defProp(partial, "partial", true);
			}
			if(part){
				var pObj, 
				pKey, 
				newPartial,
				result = [], 
				self = this, 
				relRec;
				part.forEach(function(value , partKey){
					pObj = value, relRec = partKey, pKey = partKey.$.pK , newPartial;
					if(/^(added|modified)$/.test(pObj.type)){
						var pType = "related",
						ind = getIndex(val, bpK, pKey, undefined, getSchemaObj(db, relTo));
						if(ind != -1){
							var rec = val[ind], updVal, rec$;
							var polyType;
							if(rec && rec.$){
								rec$ = Object.assign({}, rec.$);
								rec = Object.assign({}, rec);
								_defProp(rec, '$', rec$);
							}
							updVal = rec;
							if(polymorphic && rec){
								polyType =  rec._type ? rec._type : rec.$.schema._name;
								bDef = db.schema[polyType];
							}
							var record = db.cache.getEntity(bDef.def, pKey);
							removeBackwardRel(rec, rel, pK, pkVal);
							if(rec.$.isNew){
								pType = "added";
							}
							else if(rec.$.isModified){
								pType = "modified";												
								var valDir = isDirty(db, record, bDef.relations);
								updVal = updateJSON(db, rec, bDef, valDir);				
							}
							else{
								var valDir = isDirty(db, record, bDef.relations);
								updVal = updateJSON(db, rec, bDef, valDir);											
							}
							if(partial){
								var newPart = {};
								_defProp(newPart, "$", {});
								var newPart$ = newPart.$,
								newPartDef = polymorphic ? polyType : relTo;
								Object.defineProperties(newPart$, {
									pkVal : {
										value : pKey
									},
									type : {
										value : pType
									},
									schema : {
										value : polymorphic ? db.schema[polyType] : getSchemaObj(db, relTo)
									},
									record : {
										value :  db.cache.getEntity(newPartDef, pKey)
									}																										
								});
								// if(partialRef){
								// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
								// 	updVal[refKey] = refId;
								// 	partialRef.set(refId, newPart);
								// }
								partial.push(newPart);
							}
							removeSelfCircularReference(db, bDef._name, updVal, expose, undefined, newPart, partialRef);			
							// var resObj = {type: pObj.type, data: updVal};
							if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(updVal)){
								updVal.$.partialType = pObj.type;
							}
							else{
								_defProp(updVal, "$", {});
								_defProp(updVal.$, "partialType", pObj.type);
								if(!updVal.$.hasOwnProperty("pK")){
									_defProp(updVal.$, "pK", pKey);
								}
							}
							if(polymorphic){
								updVal.$.polymorphicType = polyType;
							}
							result.push(updVal);
						}
					}
					else if(pObj.type == "removed"){
						var dObj = {};
						if(pKey && typeof pKey == "object"){
							Object.assign(dObj, Object.assign({},pKey));
						}
						else{
							dObj[bpK] = pKey;
						}
						var record = db.cache.getEntity(bDef.def, pKey) || db.cache.getEntity(bDef.def, pKey, true);
						if(partial){
							var newPart = {}; 
							_defProp(newPart, "$", {});
							var newPart$ = newPart.$;
							Object.defineProperties(newPart$, {
								pkVal : {
									value : pKey
								},
								type : {
									value : "removed"
								},
								schema : {
									value : polymorphic && pObj.polymorphicType ? db.schema[pObj.polymorphicType] : getSchemaObj(db, relTo) 
								},
								record: {
									value : record
								}																										
							});
							if(partialRef){
								var sz = partialRef.size,
								refId = "rec"+(++sz), refKey = partialRef.refKey;
								dObj[refKey] = refId;
								partialRef.set(refId, newPart);
							}
							partial.push(newPart);
						}
						_defProp(dObj, "$", {});
						dObj.$.partialType = "removed";
						if(polymorphic && pObj.polymorphicType){
							dObj.$.polymorphicType = pObj.polymorphicType;
						} 
						if(!dObj.$.hasOwnProperty('pK')){
							dObj.$.pK = pKey;
						}
						// result.push({type:"removed", data: dObj})

						result.push(dObj);
					}
				});
				if(result.length){
					val = obj[key] = result;
				}
				else{
					delete obj[key];
				}
			}
		}
		else{
			delete obj[key];
		}
	}
	else if(field.relType == "belongsTo" && val && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(val)){
		var polyType;
		if(polymorphic && val){
			polyType =  val._type ? val._type : val.$.schema._name;
			bDef = db.schema[polyType];
		}
		removeBackwardRel(val, rel, pK, pkVal);
		var updVal = val, valDir;
		if(val.$.isNew){
			removeBackwardRel(val, rel, pK, pkVal);
		}
		else{
			valDir = isDirty(db, val, bDef.relations);
			updVal = updateJSON(db, val, bDef, valDir);
		}
		if(partialObj){
			var partial = partialObj[key] = partialObj[key] || {};
			var pType = val.$.isNew ? "added" : val.$.isModified ? "modified" : "related";
			_defProp(partial, "$", {});
			var partial$ = partial.$;
			var partMod = polymorphic ? db.schema[polyType] : getSchemaObj(db, relTo);
			Object.defineProperties(partial$, {
				pkVal : {
					value : val.$.pK
				},
				type : {
					value : pType
				},
				schema : {
					value : partMod
				},
				record : {
					value : db.cache.getEntity(partMod.def, val.$.pK)
				}
			});
			// if(partialRef){
			// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
			// 	updVal[refKey] = refId;
			// 	partialRef.set(refId, partial);
			// }
		}
		if(polymorphic){
			updVal.$ || _defProp(updVal, "$", {});
			updVal.$.polymorphicType = polyType;
		}
		removeSelfCircularReference(db, bDef._name, updVal, expose, undefined, partial, partialRef);
		val = obj[key] = updVal;
	}
}

function removeSelfCircularReference(db, name, obj, expose, type, partialObj, partialRef, parentRel,addNotDefinedFields){
	var def = db.schema[name], 
	fieldList = def.fieldList,
	pkVal = getpKVal(obj,def),  
	record = db.cache.getEntity(def.def, pkVal), 
	partObj = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record) ? record.$.partial : undefined, 
	polymorphicType = obj && obj.$ ? obj.$.polymorphicType : undefined, 
	refId;
	db.$.recStack[name] = db.$.recStack[name] || []; 
	var ret = checkAndAddToArray(db.$.recStack[name], pkVal)
	if(partialRef){
		var sz = partialRef.size,
		refObj = {};
		refId = "rec"+(++sz);
		_defProp(refObj, "$", {pkVal: record.$.pK, schema :record.$.schema});
		partialRef.set(refId, refObj);
	}
	var unlinkedKeys = getFromCB(db,"serializer",def.serializer,"serializeEmptyRelation");
	for(var key in obj){
		var field = fieldList[key], 
		extMod, 
		swap = false, 
		relTo, 
		bDef, 
		relType;
		var removePk = ((expose == "clone" || type == "create" || ((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(obj) && obj.$.isNew)) && def._pK == key) ? true: false;
		if(field && (field == parentRel || (removePk && expose != true && expose != "state"))){
			delete obj[key];
			continue;
		}
		if(!field){
			if(polymorphicType){
				extMod = db.getSchemaObj(polymorphicType);
				field = extMod.fieldList[key];
				swap = true;
			}
			if(!addNotDefinedFields){
				delete obj[key];
			}
			continue;
		}
		if(field && field.type != "relation" && !expose  && db.dataType[field.type] && db.dataType[field.type].serialize && obj.hasOwnProperty(key)){			
			obj[key] = db.dataType[field.type].serialize(obj[key],key,record);
			continue;
		}
		if(partObj && partObj.hasOwnProperty(key)){
			var partPload = {},
			_bDef = getSchemaObj(db, field.relatedTo),
			bPk = _bDef._pK,
			doCont = false;
			partObj[key].forEach(function(item, partPk){
				partPload[bPk] = partPk.$.pK;
				_defProp(partPload, "$", {});
				_defProp(partPload.$, "partialType", "removed");
				_defProp(partPload.$, "pK", partPk.$.pK);
				if(partialObj){
					var partial = partialObj[key] = partialObj[key] || {};
					_defProp(partial, "$", {});
					var partial$ = partial.$;
					Object.defineProperties(partial$, {
						pkVal : {
							value : partPk.$.pK
						},
						type : {
							value : "removed"
						},
						schema : {
							value : _bDef
						},
						parent : {
							value : record
						},
						record: {
							value: db.cache.getEntity(field.relatedTo, partPk.$.pK)
						}
					});
				}
				if((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && field.opts && /^(id|record)$/.test(field.opts.serialize)){
					obj[key] = null;
					doCont = true;
				}
				else if(field.opts.serialize == "partial"){
					obj[key] = partPload;
					doCont = true;
				}
				if(field && field.opts && /^(id|record)$/.test(field.opts.serialize)){
					Object.defineProperties(partial$, {
						onlyDetach:{
							value: true
						},
						relKey: {
							value: key
						}
					});
				}
			});		
			if(doCont){
				continue;
			}
		}
		if((expose == true || expose == "clone" || expose == "state") && obj[key] && typeof obj[key] == "object" && field && field.type != "relation"){
			obj[key] = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(obj[key]);
			continue;
		}
		if(obj[key] && field && field.type == "relation"){
			relTo = field.relatedTo;
			relType = field.relType;
			bDef = getSchemaObj(db, relTo);
			if(bDef == undefined){
				continue;
			}
			var relKey = field.relKey, rel = {};
			if(swap){
				getRelations(db, extMod, field.relKey, bDef, rel);						
			}
			else{
				getRelations(db, def, relKey, bDef, rel);
			}
			var opts = field.opts;
			var serialize = opts ? opts.serialize : undefined, val = obj[relKey];
			if(expose == "idb"){
				idbSerialize(db, val, rel, def, bDef, pkVal, expose);
			}
			else if(expose || serialize == "id"){
				idSerialize(db, obj, rel, expose, partialObj, partialRef);
			}
			else if(serialize === "record"){
				var ret = recordSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef);
				if(ret == 0){
					if(relType === "hasMany" && (unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && Array.isArray(record[key]) && record[key].partial && record[key].partial.size){
						var emptyArr = true;
						record[key].partial.forEach(function(pobj){
							if(pobj.type !== "removed"){
								emptyArr = false;
							}
						});
						if(emptyArr){
							obj[key] = [];
							continue;
						}
					}
				}
			}
			else if(serialize === "partial"){
				partialSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef)
			}
			else{
				delete obj[relKey];
				continue;
			}
			val = obj ? obj[relKey] : undefined;
			if( val && (relType == "hasMany" && Array.isArray(val) && val.length == 0) || (relType == "belongsTo" && typeof val == "object" && Object.keys(val).length == 0)) {
				if((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && relType == "hasMany" && field.opts && /^(id|record)$/.test(field.opts.serialize)){
					obj[relKey] = [];
				}
				else{
					delete obj[relKey];
				}
			}
		}
		
	}
	if(partialRef){
		var refKey = partialRef.refKey;
		obj[refKey] = refId;
	}
}

function getpKVal(ins, schema){
	var schema = schema ? schema : ins.$.schema, 
	arr = schema._arrPk;
	if(arr.length == 1){
		return ins[arr[0]];
	}
	else{
		var obj = {};
		arr.forEach(function(item){
			obj[item] = ins[item];
		});
	}
	return obj;
}

function toJSONObj(db, schema, data, expose, type, partial, parentRel, addNotDefinedFields){
	var copyObj, 
	pkVal, 
	name = schema._name, 
	pK = schema._pK;
	if(expose == true || expose == "state" || expose == "clone"){
		copyObj = Object.assign({},data);
	}
	else{
		copyObj = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(data)
	}
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(copyObj)){
		pkVal = copyObj.$.pK;
	}
	else{
		pkVal = db.cache.getEntity(schema.def, getpKVal(copyObj, schema)).$.pK;
	}
	var partialObj = partial ? partial.obj : undefined, partialMp;
	if(partialObj && !partialObj.has(pkVal)){
		partialObj.set(pkVal,{});
		partialMp = partialObj.get(pkVal); 
	}
	removeSelfCircularReference(db, name, copyObj,expose,type, partialMp, partial && partial.ref ? partial.ref : undefined, parentRel,addNotDefinedFields);
	if(expose == "idb"){
		db.idbIns.removeNotNeededKeys(db, name, copyObj);
	}
	return copyObj;
}

function toJSON(db,name,obj,expose,type,partialObj,parentRel,addNotDefinedFields){
	var copyObj, 
	def = db.schema[name];
	db.$.recStack = {};
	if(Array.isArray(obj)){
		var arr = [];
		for(var i=0; i<obj.length; i++){
			copyObj = toJSONObj(db, def, obj[i], expose, type, partialObj, parentRel,addNotDefinedFields);
			arr.push(copyObj);
		}
		return arr;
	}
	else if(obj && (typeof obj === "object" || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(obj))){
		copyObj = toJSONObj(db, def, obj, expose, type, partialObj, parentRel,addNotDefinedFields);
	}
	db.$.recStack = {};
	return copyObj;
}

function createCopy(data){
	if(Array.isArray(data)){
		if(data.save){
			var arr = [];
			for(var i=0; i<data.length; i++){
				var rec = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(data[i]);
				arr.push(rec);
			}
			return arr;
		}
	}
	else if(data && ( (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data) || typeof data == "object")){
		return (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(data);
	}
	return data;
}

function initPartialObj(db, name, type, qP, key, url, customData, argsObj){
	var partial = { obj : new Map() };
	// rKey = "recId", 
	// refKey, 
	// res,
	// def = db.schema[name];
	// partial.ref = new Map();
	// res = initCB(db,"serializer", def.serializer, def.serializer.constructor.REFERENCEKEY, { argsObj: argsObj, args:[name,type,qP,key,url,customData]});
	// refKey = res ? res.data : undefined;
	// if(!isEmpty(refKey)){
	// 	rKey = refKey;
	// }
	// partial.ref.refKey = rKey;
	return partial;
}

function recChk(lyte, rec){
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(rec)){
		if(rec.$.isUnloaded !== true){
			return true;
		}
		else{
			_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.error(lyte, rec+ "has been dropped. So no operations can be performed over this entity");
		}
	}
	return false;
}

function initCB(db, type, ins, key, obj){
	var args = obj.args, ret = {}, _appC, _appS;
	obj.argsObj ? obj.argsObj.callback = key : undefined;
	if(ins){
		if(ins[key]){
			ret.data = ins[key].apply(ins, obj.argsObj ? [obj.argsObj] : obj.args);
			// if(db.debug){
			// 	Dberror.log(key+" of "+ type+"-"+ins.constructor.name+ " called", "#008000")
			// }
			return ret;
		}
	}
	else{
		var appC = db.applicationConnector, appS = db.applicationSerializer;
		if(type == "connector" && appC){
			if(appC[key]){
				ret.data = appC[key].apply(appC, obj.argsObj ? [obj.argsObj] : obj.args);
				return ret;
			}
		}
		else if(type == "serializer" && appS){
			if(appS[key]){
				ret.data = appS[key].apply(appS, obj.argsObj ? [obj.argsObj] : obj.args);
				return ret;
			}
		}
	}
}

function cB(callback,args){
	return callback.func.apply(callback.context, args.concat(callback.name));
}

function cbScp(db, ins, key, type){
	if(ins){
		if(ins[key]){
			return { func : ins[key], context: ins, name:key};
		}
	}
	else{
		var appC = db.applicationConnector, appS = db.applicationSerializer;
		if(type == "connector" && appC && appC[key]){
			return { func : appC[key], context: appC, name:key };
		}
		else if(type == "serializer" && appS && appS[key]){
			return { func : appS[key], context: appS, name:key};
		}
	}
}

function getFromCB(db, type, ins, key){
	var _appC, _appS, appC = db.applicationConnector, appS = db.applicationSerializer;
	if(ins){
		return ins[key];
	}
	else{
		// var appC = db.applicationConnector, appS = db.applicationSerializer;
		if(type == "connector"){
			if(appC){
				return appC[key];
			}
		}
		else if(type == "serializer" && appS){
			if(appS){
				return appS[key];
			}
		}
	}
}

function comparePk(ins, pkVal){
	var pK = ins.$.pK, 
	pkType = typeof pK;
	if(pkType == "string" || pkType == "number"){
		return pK === pkVal;
	}
	else if(typeof pK == "object"){
		var len = Object.keys(pK).length, i=0;
		for(var key in pK){
			if(pK[key] === pkVal[key]){
				i++;
			}
		}
		return len === i;
	}
}

function newRecord(db, def, opts, skipValidation){
	var lyte = db.lyte;
	if(opts == undefined){
		opts = {};
	}
	if(opts && typeof opts !== "object"){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.warn(db.lyte, "LD25", opts);
		var err = new _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError(db.lyte, undefined, undefined, db.lyte.getErrorMessage("LD25", opts));
		return err;
	}
	var fields = def.fieldList, 
	record = {}, 
	errorObj = new _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError(db.lyte), 
	pK = def._arrPk;
	if(!pkPresence(opts, pK)){
		generateRandomPk(def, opts, pK, fields)
	}
	else if(isDuplicateRecord(def, opts, pK)){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj, pK, {code : "ERR16", message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR16})
	}
	for(var field in fields){
		var fieldKeys = fields[field];
		if(fieldKeys.relType == "hasMany"){
			record[field] = [];
		}
		var val = opts[field];     
		var fldType = fieldKeys.type;
		if(fldType != "relation"){
			if(val === undefined || val === ""){
				if(fieldKeys.hasOwnProperty("default")){
					val = record[field] = getDefaultVal(record, fieldKeys.default);
				}
			}
			// if(fldType !== Lyte.getDataType(val) && (val !== undefined  || fldType === "boolean")) {
			// 	val = Lyte.typeCast(val, fldType);
			// }		
			if(!skipValidation){
				for(var property in fieldKeys){
					var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkProperty)(property, val, field, fieldKeys[property], record, def._name, db, _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.errorCodes, undefined, fieldKeys, true);
					if(resp != true){
						if(typeof resp == "object"){
							resp.value = val;
						}
						_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj,field,resp);
						break;
					}
				}
			}	
		}    
	}
	for(var opt_key in opts){
		record[opt_key] = opts[opt_key];
	}
	record = new def.def(record, {}, db);
	cmpSet(lyte, record.$, "isNew", true);
	changePersist(record, false);
	// record.$.isNew = true;
	var relations = def.relations;
	relations.forEach(function(relation, key){
		for(var i=0; i<relation.length; i++){
			var relObj = relation[i];
			var relKey = relObj.relKey;
			var polymorphic = relObj.opts ? relObj.opts.polymorphic : undefined; 
			if(record && record[relKey]){
				var optsRelVal = opts[relKey];
				record[relKey] = undefined;
				var fieldKeys = relation[i], rel = {}, resp = getRelations(db, def, fieldKeys.relKey, getSchemaObj(db, fieldKeys.relatedTo), rel),ingore=false;
				if(resp != true){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : resp, data : relation, message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes[resp]});
					continue;
				}
				var bDef = getSchemaObj(db, fieldKeys.relatedTo), bPk = bDef._pK , isComp = bDef.isComp, bPkType = !isComp ? bDef.fieldList[bDef._pK].type : undefined;
				if(!Array.isArray(optsRelVal)){
					optsRelVal = [optsRelVal];
				}
				else if(relation[i].relType == "belongsTo"){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : "ERR21", data : optsRelVal, message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR21});
					continue;
				}
				errorObj[fieldKeys.relKey] = [];
				for(var j=0; j<optsRelVal.length; j++){
					var relRecord = undefined, relMod = getSchemaObj(db, fieldKeys.relatedTo), ind;
					if(optsRelVal[j] && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(optsRelVal[j])){
						relRecord = optsRelVal[j];
					}
					else if(isComp && typeof optsRelVal[j] == "object"){
						var ind = getIndex(bDef.data, bPk, getpKVal(optsRelVal[j], bDef));
						if(ind != -1){
							relRecord = bDef.data[ind];
						}
						else{
							if(polymorphic){
								if(optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")){
									relMod =  optsRelVal[j]._type;
								}
								else{
									_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj, fieldKeys.relKey, {code : "ERR22", data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR22});
									continue;		
								}
							}
							relRecord = newRecord(db, relMod, optsRelVal[j]);									
						}
					}
					else if(optsRelVal[j] && typeof optsRelVal[j] == bPkType.toLowerCase()){
						relRecord = db.cache.getEntity(relMod.def, optsRelVal[j]);
					}
					else if(optsRelVal[j] && typeof optsRelVal[j] == "object"){
						if(polymorphic){
							if(optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")){
								relMod =  optsRelVal[j]._type;
							}
							else{
								_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj, fieldKeys.relKey, {code : "ERR22", data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR22});
								continue;		
							}
						}
						relRecord = newRecord(db, relMod, optsRelVal[j]);
						// ingore = true;
					}
					if(relRecord && relRecord.$ && relRecord.$.isError){
						_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj, fieldKeys.relKey,{code : "ERR15", data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
						continue;
					}
					if(relRecord && relRecord.$ && !relRecord.$.isError){
						resp = establishLink(db, rel.forward, rel.backward, record, relRecord, undefined, ingore);
						if(resp != true){
							_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : resp, data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes[resp]});
						}							
					}
				}
				if(errorObj[fieldKeys.relKey].length == 0){
					delete errorObj[fieldKeys.relKey];
				}
				if(relation[i].relType == "hasMany"){
					var fieldkey = relKey;
					if(record[fieldkey] == undefined){
						record[fieldkey] = [];
					}
					if(!record[fieldkey].add){
						if(polymorphic){
							_defProp(record[fieldkey], "polymorphic", true);
						}
						defArrUtls(record[fieldkey]);
						defUtls(record[fieldkey], relation[i].relatedTo,record,fieldkey);
						defPolyUtls(record[fieldkey]);
					}
				}
			}
		}	
	});
	if(errorObj && errorObj.$ && Object.keys(errorObj.$.error).length > 0){
		return errorObj;
	}
	var toRel = db.$.toRelate[def._name], pkVal = record.$.pK;
	if(toRel && toRel.has(pkVal)){
		establishToRelated(record, toRel.get(pkVal));
		toRel.delete(pkVal);
	}
	if(def.didLoad){
		var callBack = def.didLoad;
		for(var i=0;i<callBack.length;i++){
			callBack[i].apply(record);				
		}
	}
	handleArrOp(lyte, def.data,"push",record);
	checkAndAddToArray(def.dirty, record.$.pK);
	def.emit("add",[record]);
	db.emit("add",[def._name,record]);
	if(skipValidation){
		record.$.validatedOnCreate = false;
	}
	return record;
}

function getIndex(data,pKey,pkVal,type,def){
	var isComp = def ? def.isComp : (pKey.split(',').length > 1 ? true : false); 
	if(!isComp){
		return getInd(data, pKey, pkVal, type)
	}
	else{
		return getCompInd(data, pkVal, type, def)
	}
}

function getCompInd(data,pkVal,type,def){
	for(var i=0;data && i<data.length;i++){
		var rec = data[i];
		if(type && data[i]._type !== type){
			continue;
		}
		if(compareObjects(getpKVal(rec,def), pkVal)) {
			return i;
		}
	}
	return -1;
}

function getInd(data,pKey,pkVal,type){
	for(var i=0;data && i<data.length;i++){
		var rec = data[i];
		if(type && rec._type !== type){
			continue;
		}
		if(rec[pKey] == pkVal){
			return i;
		}
	}
	return -1;
}

function isDuplicateEntity(def,obj){
	var data = def.data, pK = def._pK, isComp = def.isComposite;
	if(data.length){
		if(!isComp && def.data._recMap){
			var pkVal = obj[pK];
			return def.data._recMap.get(pkVal ? pkVal.toString() : pkVal) !== undefined;
		}
		else{
			return data.some(function(record){
				if(compareObjects( getpKVal(obj, def), getpKVal(record) )){
					return true;
				}
			});
		}
	}
	return false;
}

function compareRecords(a,b,pK,type,def){
	var pK = def._arrPk;
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(a) && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(b) && pK.length){
		if(type && a._type && type !== a._type){
			return false;
		}
		var pkLen = pK.length;
		for(var i=0;i<pkLen;i++){
			var itm = pK[i];
			if(a[itm] && b[itm] && a[itm] !== b[itm]){
				return false;
			}
		}
		return true;
	}
	return false;
}

function hasRecordInArray(array,record,pK,type,isComp){
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record) && pK){
		var len = array.length;
		for(var i=0; i<len; i++){
			var itm = array[i];
			if(type && itm._type !== type){
				continue;
			}
			if(isComp){
				if(compareRecords(itm, record, pK, undefined, record.$.schema)){
					return true;
				}
			}
			else{
				if((type && itm._type && type === record._type && itm[pK] === record[pK]) || (itm[pK] === record[pK])){
					return true;
				}
			}
		}
	}
	return false;
}

function hasDuplicateRelation(toRelate,relation,pK,type,def){
	var isComp = def.isComp;
	if(Array.isArray(relation)){
		if(!isComp && !relation.isPolymorphic && relation._recMap){
			return relation._recMap.get(toRelate[pK]);
		}
		else{
			return hasRecordInArray(relation, toRelate, pK, type, isComp);
		}
	}
	else if(relation && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(relation)){
		return compareRecords(toRelate, relation, pK, type, def);
	}
	return false;
}

function toInsertData(db, def, payLoad, saveParent, index){
	// var def = db.schema[name];
	var name = def._name ? def._name : def;
	var data = insertIntoStore(db, def, payLoad[name],saveParent,true, undefined, index);
	def ? delete def.rel : undefined;
	return data;
}

function insertIntoStore(db,schemaCls,data,saveParent,stack,partialObj,index, checkRelData){
	var ret;
	if(Array.isArray(data)){
		ret = [];
		for(var i=0; i<data.length; i++){
			ret[i] = insertIntoStore(db, schemaCls, data[i], saveParent, stack, partialObj, index);
			if(ret[i] && ret[i].$ && ret[i].$.isError){
				if(!ret.$){
					_defProp(ret, "$", {}, true, true ,true); 
				} 
				// ret.$.isError = true;y
				cmpSet(db.lyte, ret.$, "isError", true);
			}
		}
	}
	else if(data && typeof data == "object" && Object.keys(data).length){
		// var cDef = db.getSchemaObj(name);
		var cDef = getSchemaObj(db, schemaCls);
		if(cDef){
			if(data._type && cDef.extendedBy){
				cDef = (cDef.extendedBy[data._type]) ? db.getSchemaObj(data._type) : undefined;
				// cDef = getSchemaObj(db, cDef);
			}
			if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data))
			{
				return undefined;
			}
			if(checkRelData && data && cDef){
				var rels = cDef.relations;
				if(rels){
					rels.forEach(function(relArr, key){
						relArr.forEach(function(rel){
							var key = rel.relKey,
							type = rel.relType;
							if(type == "hasMany" && data.hasOwnProperty(key) && Array.isArray(data[key]) && data[key].length){
								var arr = data[key], newArr = [];
								arr.forEach(function(itm){
									if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(itm)){
										newArr.push(itm.$.pK);
									}
									else{
										newArr.push(itm);
									}
								});
								data[key] = newArr;
							}
							else if(type == "belongsTo" && data.hasOwnProperty(key) && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data[key])){
								data[key] = data[key].$.pK;
							}
						});
					});
				}
			}
			if(!isDuplicateEntity(cDef, data, cDef._pK)){
				var rec = new cDef.def(data, {}, db);
				cDef.data.push(rec);
				var toRel = db.$.toRelate[cDef._name], pkVal = rec.$.pK;
				if(saveParent){
					db.$.saveParent = rec;
				}
				ret = validateAndPush(db,cDef,rec,partialObj);
				if(toRel && toRel.has(pkVal)){
					establishToRelated(rec, toRel.get(pkVal));
					toRel.delete(pkVal);
				}
			}
			else{
				ret = validateAndMerge(cDef,data,partialObj);
				if(ret && ret.data){
					ret = ret.data;
				}
				else if(ret && ret.type){
					Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
					_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror, result.args || [db.lyte]);
					return;
				}
			}
			if(saveParent){
				db.$.saveParent = undefined;
			}
			if(stack){
				db.$.recStack = {};
			}
		}
		else if(typeof schemaCls == "string"){
			var defobj = db.schemaless, 
			def = defobj[schemaCls] = defobj[schemaCls] || {};
			if(index){
				if(!typeof index == "string"){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.error(db.lyte,"Index should be a string");
				}
				if(def._pK){
					if(def._pK !== index){
						_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.error(db.lyte,"");
						return;
					}
				}
				def._pK = index;
				def._arrPk = [index];
			}
			else{
				def._pK = index = "id";
				def._arrPk = [index];
			}
			def.data = def.data || [];
			(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.defProp)(def.data,"schemaless", {value:true});
			(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.defProp)(def.data, "pK", {value:def._pK});
			var ind = getInd(def.data, index, data[index]);
			if(ind == -1){
				handleArrOp(db.lyte, def.data, "push", data);
			}
			else{
				handleArrOp(db.lyte, def.data, "replaceAt", data, ind);
			}
			return data;
		}
	}
	return ret;
}

function validateAndPush(db,def,data,partialObj){
	if(!def.rel){
		def.rel = {};
	}
	var pkVals = def._arrPk, pkValsLen = pkVals.length, index;
	for(var i=0; i<pkValsLen; i++){
		var item = pkVals[i];
		if(!data.hasOwnProperty(item)){
			index = def.data.indexOf(data);
			def.data.splice(index,1);	
			return new _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError(db.lyte, item, {code : "ERR23", data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR23});
		}
		else if(data[item] == undefined || data[item] == null){
			index = def.data.indexOf(data);
			def.data.splice(index,1);	
			return new _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError(db.lyte, item, {code : "ERR26", data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR26});
		}
	}
	var mapPk = (( data.$.pK == undefined || typeof data.$.pK == "object") ? data.$.pK : data.$.pK.toString());
	def.data._recMap.set(mapPk, data);
	data = validateJSON(db, def, data, undefined, undefined, partialObj);
	var index = def.data.indexOf(data); //have to check if the removal of these lines, doesn't affect any
	def.data.splice(index, 1);
	handleArrOp(db.lyte,def.data,"push",data);
	if(def.didLoad){
		var callBack = def.didLoad;
		for(var i=0;i<callBack.length;i++){
			callBack[i].apply(data);	
		}
	}
	def.emit("add",[data]);
	db.emit("add",[def._name,data]);
	return data;
}

function validateJSON(db,def,data,keys,toValidate,partialObj){
	var validate = (toValidate) ? toValidate.toValidate : undefined;
	var fields = (validate && Object.keys(validate).length) ? validate : def.fieldList;
	var extended = def.extend ? true : false;
	for(var key in data){
		if(keys && keys.indexOf(key) == -1){
			continue;
		}
		var fld = fields[key];
		if(fld){
			if(fld.type == "relation" && data[key]){
				var partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;
				var resp = handleRelation(db, key, def, fld, data, partialAdd, partialObj);
				if(resp != true){
					return new _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError(db.lyte, key, {code : resp, data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes[resp]});
				}
				if(fld.relType == "hasMany" && !data[key].add){
					defArrUtls(data[key]);
					defPolyUtls(data[key]);
					defUtls(data[key],fld.relatedTo,data,key);
				}
			}
			else if(fld.type){
				var fieldKeys = fld;
				if(data[key] === undefined && fieldKeys.default){
					data[key] = getDefaultVal(data, fieldKeys.default);
				}
				var empD = getDsrzEmpData(def, fld, def._name);
				var boolChk = !empD && data[key]
				if(data.hasOwnProperty(key) && (boolChk || empD) && db.dataType.hasOwnProperty(fieldKeys.type) && db.dataType[fieldKeys.type].hasOwnProperty("deserialize")){
					data[key] = db.dataType[fieldKeys.type].deserialize(data[key],key,def._name,getpKVal(data,def));
				}
			}
		}
		else{
			if(extended){
				var extMod = db.getSchemaObj(def.extend);
				var extKey = extMod.fieldList[key];
				if(extKey && extKey.type == "relation"){
					var partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;
					var resp = handleRelation(db, key, extMod, extKey, data, partialAdd);
					if(resp != true){
						return new _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError(db.lyte, key, {code : resp, data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes[resp]});
					}
					if(extKey.relType == "hasMany" && !data[key].add){
						defArrUtls(data[key]);
						defPolyUtls(data[key]);
						defUtls(data[key],extMod,data,key);
					}
				}
			}
		}
	}
	return data;
}

function handleRelation(db,key,def,field,data,partialAdd, partialObj){
	var rel = {},
	mRel = def.rel = def.rel || {};
	if (!mRel.hasOwnProperty(key)){
		var relResp = getRelations(db, def,key,getSchemaObj(db, field.relatedTo),rel);	
		if(relResp !== true){
			return relResp;
		}
		mRel[key] = rel;
	}
	else{
		rel = mRel[key];
	}
	return solveRelation(db, rel, def, getSchemaObj(db, field.relatedTo), key, data, partialAdd, partialObj);
}

function getRelations(db,fDef,key,bDef,rel){
	if(bDef == undefined){
		_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.error("LD05",fDef.fieldList[key].relatedTo,key,fDef._name)
		return "ERR11";
	}
	rel.forward = fDef.fieldList[key];
	rel.backward = getBackwardRel(fDef,rel.forward,bDef);
	if(rel.backward === undefined){
		var temp_backward = {type: "relation",relatedTo:fDef.def, dummy:rel.forward.relKey, relKey:undefined};
		if(!bDef.relations.get(fDef.def)){
			bDef.relations.set(fDef.def, []);
		}
		var bArr = bDef.relations.get(fDef.def);
		bArr.push(temp_backward);
		rel.backward = temp_backward;
	}
	return true;
}

function getBackwardRel(fDef,rel,bDef){
	var inverse, 
	polymorphic, 
	db = fDef.db;
	if(rel.opts){
		inverse = rel.opts.reverseKey;
		polymorphic = rel.opts.polymorphic;
		if(inverse === null){
			return undefined;
		}
		if(polymorphic){
			var extDefs = bDef.extendedBy;
			if(extDefs){
				for(var key in extDefs){
					var extDef = db.getSchemaObj(key);
					// extDef = getSchemaObj(db, extDef);
					if(extDef.relations.get(fDef.def)){
						bDef = extDef;
						break;
					}
				}
			}
		}
	}
	var relatedTo;
	if(inverse && inverse != ""){
		relatedTo = inverse;
	}
	else{
		var bRel = bDef.relations.get(fDef.def);
		var extFDef = db.getSchemaObj(fDef.extend), checkPoly;
		if(!bRel && extFDef && bDef.relations.get(extFDef.def)){
			bRel = bDef.relations.get(extFDef.def);
			checkPoly = true;
		}
		relatedTo = (bRel && bRel.length == 1 && (bRel[0].opts && bRel[0].opts.reverseKey && bRel[0].opts.reverseKey !== rel.relKey ? false : true ) && (!checkPoly || (checkPoly && bRel[0].opts && bRel[0].opts.polymorphic))) ? bRel[0].relKey : undefined;
	}
	if(!relatedTo){
		var bRels = bDef.relations.get(fDef.def);
		var extFDef_1 = db.getSchemaObj(fDef.extend);
		if(!bRels && extFDef_1 && bDef.relations.get(extFDef_1.def) && bDef.relations.get(extFDef_1.def).opts && bDef.relations.get(extFDef_1.def).opts.polymorphic){
			bRels = bDef.relations.get(extFDef_1.def);
		}
		if(rel.dummy && bRels){
			for(var i=0;i<bRels.length;i++){
				if(bRels[i] && bRels[i].relKey && bRels[i].relKey == rel.dummy)
				{
					 relatedTo = bRels[i].relKey;
					 break;
				}
			}
		}
		else if(bRels){
			for(var i=0;i<bRels.length;i++){
				if(bRels[i] && bRels[i].opts && bRels[i].opts.reverseKey && bRels[i].opts.reverseKey === rel.relKey){
					relatedTo = bRels[i].relKey;
					break;
				}
				else if(bRels[i] && bRels[i].dummy && bRels[i].dummy == rel.relKey)
				{
					 relatedTo = bRels[i];
					 break;
				}
			}
		}
	}
	if(relatedTo && relatedTo.dummy){
		return relatedTo;
	}
	if(relatedTo && fDef._fldGrps.reverseKey.has(rel.relatedTo) && !rel.dummy){
		if(relatedTo && fDef.relations.get(rel.relatedTo) && fDef.relations.get(rel.relatedTo).length>1 && !inverse){
			if((!bDef.fieldList[relatedTo].opts) || bDef.fieldList[relatedTo].opts && !bDef.fieldList[relatedTo].opts.reverseKey){
				return undefined;
			}
		}
	}
	return relatedTo?bDef.fieldList[relatedTo]:undefined;			
}

function solveRelation(db,rel,fDef,bDef,key,data,partialAdd,partialObj){
	var forward = rel.forward, 
	partial = partialObj ? partialObj[key] : undefined, 
	partialRel = partial && partial.partial, 
	val = [];
	if(partialAdd){
		val = partialAdd;
	}
	else if(!partialRel){
		if(data[key] && (data[key].add || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data[key]) ) ){
			return true;
		}
		if(!Array.isArray(data[key])){
			data[key] = [data[key]];
		}
		else if(forward.relType == "belongsTo"){
			return "ERR21";
		} 
		val = data[key].splice(0, data[key].length);
		if(forward.relType == "belongsTo"){
			data[key] = undefined;				
		}                
	}
	else if(Array.isArray(data[key])){
		var val = data[key].splice(0, data[key].length);
	}
	for(var i=0; i<val.length; i++){
		var ret;
		ret = createAndRelate(db, fDef, bDef, data, key, val[i], rel, partial);
		if(ret != true){
			return ret;
		}
	}
	return true;
}

function createAndRelate(db, fDef, bDef, data, key, val, rel, partial){
	if(!rel.backward){
		if(rel.forward.relatedTo === fDef){
			rel.backward = rel.forward;
		}
		if(rel.backward === undefined){
			return "ERR12";
		}
	}
	var pK = fDef._pK, 
	isComp = bDef.isComp, 
	isPoly = rel.forward && rel.forward.opts ? rel.forward.opts.polymorphic : undefined,
	relatedRecord, 
	newPartial = partial && partial.hasOwnProperty(val[pK]) ? partial[val[pK]] : partial;
	if(!isComp && typeof val == bDef.fieldList[bDef._pK].type){
		relatedRecord = db.cache.getEntity(bDef.def, val);
	}
	else if(typeof val == "object" && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(val)){
		relatedRecord = insertIntoStore(db, bDef.def, val, undefined, undefined, newPartial);					
	}
	if(relatedRecord && relatedRecord.$ && relatedRecord.$.isError){
		cmpSet(db.lyte, data.$, "isError", true);
		var errObj = {code:"ERR24", message: _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.errorCodes.ERR24, data: data, error: relatedRecord.$.error};
		cmpSet(db.lyte, data.$.error, key, errObj );
	}
	else if(relatedRecord){
		if(!hasDuplicateRelation(relatedRecord, data[key], bDef._pK, isPoly ? val._type : undefined, bDef)){
			establishLink(db, rel.forward, rel.backward, data, relatedRecord, undefined, true, false);							
		}
	}
	else{
		addToRelate(db, fDef._name, data, rel, val);
	}
	return true;
}

function singleEstablishLink(forward,data,relatedRecord){
	var relation = relatedRecord.$._relationships , fName = data.$.schema._name , fRelKey = forward.relKey ;
	relation[fName] = relation[fName] || {};
	relation[fName][fRelKey] = relation[fName][fRelKey] || [];
	if(!hasDuplicateRelation(data,relation[fName][fRelKey],data.$.schema._pK, undefined, data.$.schema)){
		relation[fName][fRelKey].push(data);
	}
}	

function establishLink(db,forward,backward,data,relatedRecord,index,ignorePartial, isDuplicate,partRemoveOnly){
	if(!relatedRecord){
		return "ERR13";
	}
	if( !checkForCorrectRelation(db, forward, relatedRecord) ){
		return "ERR14";
	}
	var fRelKey = forward.relKey, 
	lyte = db.lyte,
	isPoly = forward.opts && forward.opts.polymorphic, 
	type = isPoly ? relatedRecord._type : undefined,
	ignoreRel = {};
	if(forward.relType == "belongsTo"){
		if(data[fRelKey] !== relatedRecord){
			cmpSet( lyte, data, fRelKey, relatedRecord, undefined, true );
		}
		if(data.$.partial && Object.keys(data.$.partial).length && data.$.partial[fRelKey]){
			delete data.$.partial[fRelKey];
		}
	}
	else if(forward.relType === "hasMany"){
		if(!data[fRelKey]){
			cmpSet(lyte,data,fRelKey,[],undefined,true);
		}
		if(!data[fRelKey].schema){
			var relDef = relatedRecord.$.schema;
			if(isPoly && type){
				_defProp(data[fRelKey], "polymorphic", true);
				relDef = db.getSchemaObj(relDef.extend);
			}
			establishObsBindings(data,data.$.schema._properties);
			defArrUtls(data[fRelKey]);
			defPolyUtls(data[fRelKey]);
			defUtls(data[fRelKey],relDef,data,fRelKey);
		}
		var mdl = forward ? getSchemaObj(db, forward.relatedTo) : undefined;
		if( isDuplicate == false || !hasDuplicateRelation(relatedRecord, data[fRelKey], (forward?mdl._pK : undefined),type, mdl) ){
			if(index != undefined){
				handleArrOp(db.lyte, data[fRelKey], "insertAt", relatedRecord, index);
				// if(typeof Lyte.arrayUtils != "undefined"){
				// 	Lyte.arrayUtils(data[fRelKey],"insertAt",index,relatedRecord);						
				// }
				// else{
				// 	data[fRelKey].splice(index, 0, relatedRecord);
				// }	
			}
			else{
				handleArrOp(db.lyte, data[fRelKey],"push",relatedRecord);
			}
		}
		var ret;

		if((!ignorePartial || partRemoveOnly)&& forward.opts && forward.opts.serialize){
			ret = partialData(data, fRelKey, relatedRecord, "added",undefined,partRemoveOnly);
			ignoreRel.relKey = fRelKey;
			ignoreRel.model = data.$.schema._name;
		}
	}
	var fnest = false;
	if(!ignorePartial){
		fnest = ret ? false : true;
	}
	// if(forward == backward){
	// 	singleEstablishLink(forward,data,relatedRecord);
	// 	return true;
	// }
	if(backward === null){
		if(relatedRecord.hasOwnProperty(bRelKey)){
			delete relatedRecord[bRelKey];
		}
		return true;
	}
	if(backward.dummy || forward == backward){
		singleEstablishLink(forward,data,relatedRecord);
	}
	else{
		var bRelKey = backward.relKey, relRecMod = relatedRecord.$.schema;
		if( !checkForCorrectRelation(db, backward, data) ){
			return "ERR14";
		}
		if(backward.relType == "belongsTo"){
			if(relatedRecord[bRelKey] != undefined  && relatedRecord[backward.relKey] !== data){
				toDemolishLink(relRecMod, relatedRecord, backward, ignorePartial);
			}
			if(relatedRecord[bRelKey] !== data){
				cmpSet(lyte,relatedRecord, bRelKey, data, undefined, true);
			}
			if(relatedRecord.$.partial && Object.keys(relatedRecord.$.partial).length && relatedRecord.$.partial[bRelKey]){
				delete relatedRecord.$.partial[bRelKey];
			}
		}
		else if(backward.relType === "hasMany"){
			if(!relatedRecord[bRelKey]){
				cmpSet(lyte,relatedRecord, bRelKey, [], undefined, true);
			}
			if(!relatedRecord[bRelKey].schema){
				defArrUtls(relatedRecord[bRelKey]);
				defPolyUtls(relatedRecord[bRelKey]);
				defUtls(relatedRecord[bRelKey],data.$.schema,relatedRecord,bRelKey);
			}
			var bMdl = backward ? getSchemaObj(db, backward.relatedTo) : undefined;
			if( !hasDuplicateRelation(data, relatedRecord[bRelKey], (backward ? bMdl._pK : undefined), type, bMdl) ){
				handleArrOp(db.lyte, relatedRecord[bRelKey],"push",data);
			}
			var bret;
			if((!ignorePartial || partRemoveOnly) && backward.opts && backward.opts.serialize){
				bret = partialData(relatedRecord, bRelKey, data, "added" , undefined,partRemoveOnly);
			}
			var bnest;
			if(!ignorePartial){
				bnest = bret ? false : true;
			}
		} 
	}
	if(fnest){
		if(forward && forward.opts && forward.opts.deepNest){
			var type = "added";
			if(data[forward.relKey].partial && data[forward.relKey].partial.get(relatedRecord.$.pK)){
				type = data[forward.relKey].partial.get(relatedRecord.$.pK).type;
			}
			setDeepNest(data, forward.relKey, relatedRecord.$.pK, "added", undefined, relatedRecord);
			bnest = false;
		}
		// addDeepNest(relatedRecord, undefined, !ignorePartial ? "added" : undefined, ignoreRel);
	}
	if(bnest){
		if(backward && backward.opts && backward.opts.deepNest){
			setDeepNest(relatedRecord, backward.relKey, data.$.pK, "added", undefined, data);
		}
	}
	return true;
}

function removeFromStore(def,keys,fromStore,ignorePartial, delayPer, onlyRem, deep, parentRel ,partOnlyRem){
	var data = def.data,
	db = def.db,
	lyte = db.lyte;
	if(data.length == 0){
		return;
	}
	if(!Array.isArray(keys)){
		keys = [keys];
	}
	var pKey = def._pK;
	for(var i=0; i<keys.length; i++){
		var index = getIndex(data, pKey, keys[i]);
		if(index == -1){
			continue;
		}
		var rec = data[index];
		var pK = rec.$.pK;
		var relations = def.relations;
		if(rec.$.isNew){
			onlyRem = delayPer = undefined;
			fromStore = true;
		} 
		if(relations.size){
			toDemolishRelation(def, index, ignorePartial, onlyRem, delayPer,partOnlyRem);	
		}
		var deleted;
		if(delayPer !== true && onlyRem !== false){
			deleted = handleArrOp(db.lyte, data,"removeAt",undefined,index,1);
			deep && deleted && deleted.length ? deepRelIter("unload", def, deleted[0], parentRel) : undefined;
			def.emit("remove", [deleted[0]]);
			db.emit("remove", [def._name,deleted[0]]);	
			if(def._properties){
				demoLishObserverBindings(rec, def._properties);
			}
		}
		if(fromStore === true){
			cmpSet(lyte, rec.$, "isUnloaded", true);
			var scpObj = rec.$.__scpObj;
			for(var key in scpObj){
				var sid = scpObj[key];
				var sidArr = sid.split("_");
				var nestObj = _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.nestScp[sidArr[0]];
				nestObj ? (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.removeNestScp)(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model: def._name, pK:rec.$.pK, attr: key}) : undefined;
			}
			var cqueries = db.schema.cachedQueries;
			if(cqueries){
				var n=def._name, Nm = cqueries[n]
				if(Nm && Nm.length){
					for(var j=Nm.length-1; j>=0; j--){
						var obj = Nm[j];
						if(obj.hasDeletedRecords){
							if(obj.data){
								var ind = obj.data[n].indexOf(rec);
								if(ind !== -1){
									Nm.splice(j,1);					
								}
							}
						}
					}					
				}
			}
		}
		if(onlyRem == true){
			continue;
		}
		var remRec = deleted ? deleted[0] : rec;
		if(!fromStore){
			cmpSet( lyte, remRec.$, "isDeleted", true);
			changePersist(remRec, true);
			// deleted[0].$.isDeleted = true;
			if((delayPer !== true && onlyRem !== false) && (remRec.$.isNew || remRec.$.isModified)){
				deleteFromArray(def.dirty, remRec.$.pK);
			}
			if(!remRec.$.isNew){
				addTo_Del(def, remRec, index);
				// model._deleted.push(deleted[0]);
			}
			var cqueries = db.schema.cachedQueries;		
			if(cqueries){
				var n=def._name, Nm = cqueries[n];
				if(Nm && Nm.length){
					for(var j=Nm.length-1; j>=0; j--){
						var obj = Nm[j];
						if(obj && obj.data){
							var ind = obj.data[n].indexOf(rec);
							if(ind != -1){
								obj.hasDeletedRecords = true;
							}							
						}
					}					
				}
			}
		}
		var ind;
		if(Array.isArray(def.dirty) && (ind = def.dirty.indexOf(pK)) != -1){
			def.dirty.splice(ind, 1);
		}
	}
}

function toDemolishRelation(def,index,ignorePartial,onlyRem,delayPers,partOnlyRem){
	var record = def.data[index], 
	relations = def.relations,
	db = def.db;
	relations.forEach(function(rel, key){
		for(var i=0; i<rel.length; i++){
			var relation = rel[i],
			relDef = getSchemaObj(db, relation.relatedTo);
			if(relDef){
				var relPriKey = relDef._pK, 
				relkey = relation.relKey;
				// if(def._name == relDef._name){
				// 	var data = relDef.data,index1,index2;
				// 	for(index1=0 ; index1<data.length; index1++){
				// 		var item=data[index1];
				// 		if(Array.isArray(item[relkey])){
				// 			for(var index2=0;index2<item[relkey].length;index2++){
				// 				var value = item[relkey][index2];
				// 				if(value[relPriKey] == record[relPriKey] && onlyRem !== false)
				// 				{
				// 					handleArrOp(db.lyte, item[relkey],"removeAt",undefined,index2,1);
				// 				}
				// 			}
				// 		}
				// 		else if (isEntity(item[relkey])){
				// 			if(item[relkey][relPriKey] == record[relPriKey] && onlyRem !== false)
				// 				{
				// 					item[relkey] = undefined ;
				// 				}
				// 		}
				// 	}
				// }
				if(!record[relation.relKey] && !relation.dummy){
					continue;
				}
				toDemolishLink(def, record, relation, ignorePartial, onlyRem, delayPers,partOnlyRem);
			}
		}		
	});
}

function toDemolishLink(def,record,relation,ignorePartial,onlyRem,delayPers,partOnlyRem){
	var db = def.db,
	records = record[relation.relKey], 
	priKey = def._pK,  
	relDef = relation.relatedTo;
	if(!relDef){
		return;
	}
	var bRelation = getBackwardRel(def, relation, getSchemaObj(db, relDef));
	if(relation.dummy || (relation == bRelation)){
		records = getRelatedRecord(record,getSchemaObj(db, relation.relatedTo),relation.dummy);
	}
	if(bRelation){
		if(Array.isArray(records)){
			for(var i=0; i<records.length; i++){
				demolishLink(db, record, priKey, records[i], bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers,partOnlyRem);
			} 
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(records)){
			demolishLink(db, record, priKey, records, bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers,partOnlyRem);
		}
	}
}

function demolishSingleRelation(record,fName,key,relatedRecord,priKey,onlyRem,delayPers){
	var arr,index;
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record)){
		arr = record.$._relationships;
		if(arr && arr[fName] && arr[fName][key] && (onlyRem !== false && delayPers !== true)){
			arr = arr[fName][key];
			index = getIndex(arr,priKey,relatedRecord[priKey]);
			if(index > -1){
				arr.splice(index,1);
			}
		}
	}
} 

function demolishLink(db, record, priKey, relatedRecord, bRelKey, relation, bRelation, ignorePartial, ignoreAttrCheck, onlyRem, delayPers, partOnlyRem){
	var links = relatedRecord[bRelKey], 
	relMod = relatedRecord.$.schema,
	lyte = relMod.Lyte,
	pK = record.$.pK, 
	poly = links ? links.polymorphic : undefined, 
	polymorphicType;
	if(Array.isArray(links)){
		var ind = getIndex(links, priKey, pK, poly ? record._type : undefined), 
		_attrs = relatedRecord.$._attributes, 
		initialVal = _attrs.hasOwnProperty(bRelKey) && _attrs[bRelKey] && _attrs[bRelKey].size  ? relatedRecord.$.getInitialValues(bRelKey) : undefined, 
		toRem = links.partial && links.partial.has(record) && links.partial.get(record).type == "added" ? true : false;
		if(ind != -1 && (toRem || (onlyRem !== false && delayPers !== true))){
			poly ? polymorphicType = links[ind].$.schema._name : undefined;
			handleArrOp(lyte, relatedRecord[bRelKey],"removeAt",undefined,ind,1);
		}
		if(!ignoreAttrCheck && initialVal){
			if(!hasRecordsArrayChanged(relatedRecord, bRelKey, initialVal)){
				   delete relatedRecord.$._attributes[bRelKey];
				   if(!Object.keys(relatedRecord.$._attributes).length){
					//    changeModified(lyte, relatedRecord, false, relatedRecord.$.pK)
					   cmpSet(lyte, relatedRecord.$, "isModified", false);
					   changePersist(relatedRecord, true);
					   if(!relatedRecord.$.isNew){
						   deleteFromArray(relMod.dirty, relatedRecord[relMod._pK]);
						   if(!relatedRecord.$.dN || (relatedRecord.$.dN && !Object.keys(relatedRecord.$.dN).length)){
							removeParentNesting(relatedRecord);
						}			
					}
				}
			}
		}
	}
	else if( links && (typeof links == "object" || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(links)) && (onlyRem !== false && delayPers !== true) ){
		if(lyte != undefined && lyte.objectUtils != undefined){
			lyte.objectUtils(relatedRecord, "delete", bRelKey, undefined, undefined, true);
		}
		else {
			delete relatedRecord[bRelKey];
		}
	}
	else{
		demolishSingleRelation(relatedRecord,record.$.schema._name,relation.relKey,record,priKey, onlyRem, delayPers);
	}
	if(!bRelation){
		bRelation = relMod.fieldList[bRelKey];
	}
	if((!ignorePartial || partOnlyRem )&& onlyRem !== true){
		var relType, isPartial, ret, nest, serz;
		if(bRelation){
			if(bRelation.opts){
				isPartial = bRelation.opts.serialize == "partial";
				serz = bRelation.opts.serialize ? true : false;
				nest = bRelation.opts.deepNest;
			}
			var relType = bRelation ? bRelation.relType : undefined;
		}
		// if(delayPers && bRelation && bRelation.opts && /^(id|record)$/.test(bRelation.opts.serialize)){
		// 	return;
		// }
		if(relType == "belongsTo" && serz && !record.$.isNew){
			var partObj = relatedRecord.$.partial = relatedRecord.$.partial || {};
			partObj = partObj[bRelKey] = partObj[bRelKey] || new Map();
			if(!partObj.has(record)){
				partObj.set(record, {});
			}
			partObj = partObj.get(record);
			partObj.type = "removed";
		}
		if(bRelation && bRelation.opts && bRelation.opts.serialize){
			ret = partialData(relatedRecord, bRelKey, record, "removed", polymorphicType ,partOnlyRem);
			nest = ret && relType == "hasMany" ? false : nest;
		}
		if(nest == true){
			makeDirty(relatedRecord, "removed", bRelation, pK, undefined, record);
			addDeepNest(relatedRecord);
		}
	}
	if(ignorePartial){
		if(bRelation && bRelation.opts && bRelation.opts.serialize){
			partialData(relatedRecord, bRelKey, record, "delete", polymorphicType);
			var _attrs = relatedRecord.$._attributes, _attr = _attrs[bRelKey];
			if(_attr && _attr.size && _attr.get(record)){
				_attr.delete(record);
			}
			if(_attr && _attr.size){
				delete relatedRecord.$._attributes[bRelKey];
			}
		}
	}
}

function validateAndMerge(def, data, partialObj, mergeErr, ignoreStrict){
	var db = def.db;
	if(!def.rel){
		def.rel  = {};
	}
	var pkVal = getpKVal(data, def);
	if(pkVal === undefined){
		return { type:"error", args:["LD28", def._name, (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data) ? data : JSON.stringify(data)]};				
	}

	var record = db.cache.getEntity(def.def, getpKVal(data, def));
	if(!record || !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record)){
		return { type:"error", args:["LD04",(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data) ? data : JSON.stringify(data)]};
	}
	if(!ignoreStrict && record.$.strict && (record.$.isNew || record.$.isModified || record.$.isDeleted)){
		return { type:"error", args:["LD29"]};
	}
	mergeData(db, record, data, partialObj, mergeErr);
	if(def.didLoad){
		var callBack = def.didLoad;
		for(var i=0;i<callBack.length;i++){
			callBack[i].apply(record);				
		}
	}
	return { data : record};
}

function mergeData(db,record,data,partialObj,mergeErr){
	if(!record || !data){
		return;
	}
	var def = record.$.schema, field, _estObsBind = false;
	if(mergeErr){
		mergeError(def, record, data);
	}
	for(var key in data){
		field = def.fieldList[key];
		if(field){
			if(field.type != "relation"){
				var empD = getDsrzEmpData(def, field, def._name);
				var boolChk = !empD && data[key]
				if(data.hasOwnProperty(key) && (boolChk || empD) && db.dataType.hasOwnProperty(field.type) && db.dataType[field.type].hasOwnProperty("deserialize")){
					data[key] = db.dataType[field.type].deserialize(data[key],key,def._name,getpKVal(data,def));
				}
				var isPropPresent = def._properties && def._properties.hasOwnProperty(key), propObj = {};
				if(isPropPresent){
					propObj[key] = def._properties[key];
					demoLishObserverBindings(record, propObj);
				}
				cmpSet(db.lyte,record,key,data[key],undefined,true);
				def._properties && def._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
			}
			else if(field && field.type == "relation"){
				var todo = {};
				var rel = {};
				getRelations(db, record.$.schema, key, getSchemaObj(db, field.relatedTo), rel);
				var bMod = rel.forward.relatedTo;
				var result = compareRelations(db, record,data,key,field,partialObj ? partialObj[key] : undefined ,todo, mergeErr);
				mergeRecords(db, todo, result, def, getSchemaObj(db, bMod), record, key, data, rel, partialObj, mergeErr);
			}
		}
		else if(key != "$"){
			cmpSet( db.lyte,record,key,data[key],undefined, true );
		}
	}
	if(_estObsBind){
		establishObsBindings(record, def._properties);
	}
}

function mergeRecords(db, todo, result, def, bMod, record, key, data, rel, partialObj, mergeErr){
	if(!rel){
		var rel = {};
		getRelations(db, def, key, bMod, rel);	
	}
	var pK = def._pK;
	if(rel.forward.relType == "hasMany" && isEmptyArray(data[key])){
		cmpSet(db.lyte, record, key, [], undefined, true);
		establishObsBindings(record,record.$.schema._properties);
		defArrUtls(record[key]);
		defPolyUtls(record[key]);
		defUtls(record[key],bMod,record,key);
	}
	if(Array.isArray(todo.add)){
		todo.add.forEach(function(item){
			createAndRelate(def.db, def, bMod, record, key, item, rel, partialObj);
		});
	}
	if(Array.isArray(todo.remove)){
		todo.remove.forEach(function(obj){
			var pkVal = obj.pK, schemaName = obj.schema, _def = db.getSchema(schemaName);
			demolishLink(db, record, pK, db.cache.getEntity(_def, pkVal), rel.backward.relKey,  rel.forward, rel.backward, true); 
			demolishLink(db, db.cache.getEntity(_def, pkVal), db.getSchemaObj(schemaName)._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); 
		});
	}
	if(record && record.hasOwnProperty(key)){
		deleteDeepNest(record, key);
		if(Array.isArray(record[key]) && record[key].hasOwnProperty("partial")){
			var partObj = record[key].partial, partKeys = [];
			partObj.forEach(function(value, partKey){
				partKeys.push(partKey);
				record[key].partial.delete(partKey);
			});
		}
	}
	switch(result){
		case 0:{
			if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(record[key])){
				demolishLink(db, record, pK, record[key], rel.backward.relKey, rel.forward, rel.backward, true); 
				demolishLink(db, record[key], bMod._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); 								
			}
			createAndRelate(def.db, def, bMod, record, key, data[key], rel, partialObj);
			break;
		}
		case 1:{
			break;
		}
		case 2:{
			mergeData(db,record[key],data[key],undefined,mergeErr);
			break;
		}
		default : break;    
	}
}

function compareRelations(db,record,data,key,field,partialObj,todo,mergeErr){
	//return 0 - not same, 1 -same, 2 - merge, 3 - partial add, 4 - delete and partial add
	var def = getSchemaObj(db, field.relatedTo), 
	pK = def._pK, 
	result = [];
	if(field.relType == "belongsTo"){
		if(partialObj && partialObj.$.type === "removed" && (!data || (data && comparePk(record, getpKVal(data, def))))){
			return 1;
		}
		return compareRecordWithObj(record[key],data[key],pK, partialObj,mergeErr);
	}else{
		var isPartial = false;
		if((partialObj && partialObj.partial)){
			isPartial = true;
		}
		if(!isPartial && (!record.hasOwnProperty(key) || (record && record.hasOwnProperty(key) && (isEmpty(record[key]) || isEmptyArray(record[key]))))){
			if(todo){
				var arr = data[key] || [];
				arr.forEach(function(item){
					var add = todo.add = todo.add || [];
					add.push(item);
				});
				return;
			}
			return 0;
		}
		var len = data[key] ? data[key].length : 0,
		old=0,
		status=1,
		oldPks = [];
		for(var i=0;i<len;i++){
			var obj = data[key][i];
			if(partialObj && partialObj[i] && partialObj[i].$.type == "removed"){
				continue;
			}
			var ind = getIndex(record[key], pK, (typeof obj == "object") ? getpKVal(obj,def) : obj);
			if(ind == -1){
				if(todo){
					var add = todo.add = todo.add || [];
					add.push(obj);
				}
				status = 0;
				continue;
			}
			oldPks.push(record[key][ind].$.pK);
			var res = compareRecordWithObj(record[key][ind],obj,pK,partialObj ? partialObj[i] : undefined,mergeErr);
			if(res == 1){
				old++;
			}
			if(res == 2){
				mergeData(db,record[key][ind],obj, partialObj ? partialObj[i] : undefined, mergeErr);
			}
			else if(res == 0){
				status = 0;
			}
		}
		if(todo && !isPartial){
			var arr = record[key] || [];
			arr.forEach(function(item){
				var pkVal = item.$.pK;
				if(oldPks.indexOf(pkVal) == -1){
					var remove = todo.remove = todo.remove || [];
					remove.push({pK: pkVal, schema: item.$.schema._name});
				}
			});
		}
	}
}

function compareRecordWithObj(rec,obj,pK,partialObj, mergeErr){
	if( !rec || !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(rec) ){
		return 0;
	}
	var recDef = rec.$.schema, 
	db = recDef.db,
	isComp = recDef.isComp, 
	recFields = recDef.fieldList;
	if(!isComp) {
		var field = recDef.fieldList[pK];
		if(typeof obj == field.type ){
			if(rec[pK] == obj){
				return 1;
			}
			else{
				return 0;
			}
		}
	}
	if(obj && typeof obj == "object"){
		if(!comparePk(rec, getpKVal(obj, recDef))){
			return 0;
		}
		for(var data_key in obj){
			var field = recFields[data_key];
			if(field){
				if(field.type == "relation"){
					var todo = {};
					var res = compareRelations(db, rec, obj, data_key, field, partialObj ? partialObj[data_key] : undefined, todo, mergeErr);
					mergeRecords(db, todo, res, recDef, getSchemaObj(db, field.relatedTo), rec, data_key, obj, undefined, partialObj);
				}
				else if(rec[data_key] != obj[data_key]){
					return 2;
				}                    
			}
			else{
				if(rec[data_key] != obj[data_key]){
					return 2;
				}
			}	
		}
		return 1;
	}
	return 0;
}

function rllBckRecArr(db, oldVal, ins, def, field){
	var rel = {}, 
	pK = def._pK,
	bDef = getSchemaObj(db, field.relatedTo),
	relPK = bDef._pK;
	getRelations(db, def, field.relKey, bDef, rel);
	if(oldVal.size){
		var keys = Array.from(oldVal.keys()).reverse();
		var self = this;
		keys.forEach(function(itm, idx){
			var val = oldVal.get(itm);
			if(val._type == "added"){
				var relatedRecord = itm;
				if(!relatedRecord.$.isUnloaded){
					demolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey, rel.forward);
					if(rel.backward != null){
						demolishLink(db, ins, pK, relatedRecord, rel.backward.relKey, rel.forward);
					}
				}
			}
			else if(val._type == "removed"){
				var relatedRecord = itm;
				if(!relatedRecord.$.isUnloaded){
					establishLink(db, rel.forward, rel.backward, ins, relatedRecord, val.index);
				}
			}			
		});
	}
	else{
		for(var i=oldVal.length-1; i>=0; i--){
			var records = oldVal[i].records;
			if(oldVal[i]._type == "added"){
				for(var j=0; j<records.length; j++){
					var relatedRecord = records[j];
					if(recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store
						demolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey);
						if(rel.backward != null){
							demolishLink(db, ins, pK, relatedRecord, rel.backward.relKey, rel.forward);
						}
					}
				}
			}
			else if(oldVal[i]._type == "removed"){
				for(var j=records.length-1; j>=0; j--){
					var relatedRecord = records[j];
					if(recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store
						establishLink(db, rel.forward, rel.backward, ins, relatedRecord, oldVal[i]._indices[j]);
					}
				}
			}
			else if(oldVal[i]._type == "changed"){
				var currentRecords = ins[field.relKey];
				if(!Array.isArray(currentRecords)){
					currentRecords = [currentRecords]; 
				}
				var self = this;
				var kLen = currentRecords.length;
				for(var k=0; k<kLen; k++){
					var relatedRecord = currentRecords[0];
					if(relatedRecord != undefined && recChk(db.lyte, relatedRecord)){
						demolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey);
						if(rel.backward != null){
							demolishLink(db, ins, pK, relatedRecord, rel.backward.relKey,rel.forward);
						}
					}
				}
				if(!Array.isArray(records)){
					records = [records];
				}
				for(var j=0; j<records.length; j++){
					var relatedRecord = records[j];
					if(typeof relatedRecord == "string"){
						relatedRecord = db.cache.getEntity(rel.forward.relatedTo,relatedRecord);
					}
					if(relatedRecord != undefined && recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store
						establishLink(db, rel.forward, rel.backward, ins, relatedRecord, undefined);
					}
				}						
			}
		}
	}
}

function sortBy(field, order){
	var fieldArr = mapBy.call(this, field),
	def = this.schema;
	var fie = def.fieldList[field];
	if(fie && fie.type == "string"){
		fieldArr.sort();
		if(order == "desc"){
			fieldArr.reverse();
		}                
	}
	else{
		fieldArr.sort(function(a,b){return a-b;});
		if(order == "desc"){
			fieldArr.sort(function(a,b){return b-a;});
		}
	}
	var oldArr = this.slice(0), newArr = [];
	for(var i=0; i<fieldArr.length; i++){
		if(fieldArr[i] == undefined){
			continue;
		}
		var index = getIndex(oldArr, field, fieldArr[i]);
		newArr.push(oldArr[index]);
		oldArr.splice(index, 1);
	}
	if(oldArr.length > 0){
		if(order == "desc"){
			newArr = newArr.concat(oldArr);
		}
		else{
			newArr = oldArr.concat(newArr);
		}				
	}
	defArrUtls(newArr);
	defUtls(newArr,this.schema);
	return newArr;
}

function mapBy(field){
	return this.map(function(value){
		return value.$.get(field);
	});
}

function revertToOldVal(ins, attr, oldVal, rel){
	if(oldVal == undefined || oldVal.length == 0){
		return;
	}
	else{
		if(!Array.isArray(oldVal)){
			oldVal = [oldVal];
		}
		for(var i =0; i<oldVal.length; i++){
			var fRec = oldVal[i];
			establishLink(ins.$.schema.db, rel.forward, rel.backward, ins, fRec, undefined);
		}
	}
}

function removePartial(ins, key){
	var parObj = ins.$.partial;
	if(parObj && parObj[key] ){
		delete parObj[key];
	}
}

function rollBackDelete(def, pkVal, index){
	var arr = [], db = def.db;
	if(!pkVal){
		def._deleted.forEach(function(itm){
			arr.push(itm);
		});
	}
	else{
		var deleted = def._deleted, obj = deleted.get(pkVal), pK = def._pK;
		arr = [obj];
	}
	var len = arr.length;
	for(var i=len-1;i>=0;i--){
		var obj = arr[i];
		var rec = obj.data;
		//var currentInd = findCurrentInd(model, pkVal);
		var isRecInDef = def.data._recMap ? def.data._recMap.get(rec.$.pK) : (def.data.indexOf(rec) !== -1) ;
		if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(rec)){
			cmpSet(db.lyte, rec.$, "isDeleted", false);
			changePersist(rec, true);
			var isDuplicate = isDuplicateEntity(def, rec);
			if(!isRecInDef){
				if(index){
					handleArrOp(db.lyte, def.data,"insertAt",rec,obj.index);
					// db.$.modifyDelInd(model, pkVal);
				}
				else{
					handleArrOp(db.lyte, def.data,"push",rec);
				}
				def.emit("add", [rec]);
				db.emit("add", [def._name,rec]);	
				var relArr = def.relations;
				if(relArr){
					rollBackDeleteRel(db, def, rec, relArr);
				}
			}
			else{
				removeParentNesting(rec);
				addDeepNest(rec, undefined, "added");
			}
			// else{
			// 	Lyte.error("Cannot rollback record of model, since another instance of same record exists in store");
			// }
			var cqueries = db.schema.cachedQueries;	
			if(cqueries){
				var n=def._name, Nm = cqueries[n];
				if(Nm && Nm.length){
					for(var j=Nm.length-1; j>=0; j--){
						var obj = Nm[j];
						if(obj && obj.hasDeletedRecords){
							var ind = obj.data[n].indexOf(rec);
							if(ind != -1){
								delete obj.hasDeletedRecords;
							}							
						}
					}					
				}
			}
			if(rec.$.isNew || rec.$.isModified){
				checkAndAddToArray(def.dirty, rec[def._pK]);
			}
			_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(rec.$, pK, "ERR17");
			!isDuplicate ? def.data._recMap.set(typeof rec.$.pK == "object" ? rec.$.pK : rec.$.pK.toString(), rec) : undefined; //old handling
			def._deleted.delete(rec.$.pK);
		}
	}
}

function rollBackDeleteRel(db, def, rec, relArr){
	relArr.forEach(function(rel){
		var rLen = rel.length;
		for(var j=0;j<rLen;j++){
			var item = rel[j];
			var key = item.relKey, bRel, bMod;
			//if(rec.hasOwnProperty(key)){
				bMod = item.relatedTo;
				bRel = getBackwardRel(def,item,getSchemaObj(db, bMod));
				var data = rec[key];
				if(!item.relKey || (item == bRel)){
					data = getRelatedRecord(rec,getSchemaObj(db , item.relatedTo),item.dummy?item.dummy:item.relKey)
				}
				else{
					data = rec[item.relKey];
				}
				if(Array.isArray(data)){
					var dLen = data.length;
					for(var k=0; k<dLen; k++){
						if(item == bRel){
							establishLink(db,bRel,item,data[k],rec,undefined,false)
						}else{
							establishLink(db,item,bRel,rec,data[k],undefined,false);	
						}									
					}
				}
				else{
					if(item == bRel){
						establishLink(db,bRel,item,data,rec,undefined,false)
					}else{
						establishLink(db,item,bRel,rec,data,undefined,false);
					}
				}
			//}
		}						
	});
}
function rollBackNew(def, record, pK){
	removeFromStore(def, record.$.pK, true);
	// var pkVal = record.$.pK;
	// var index = this.getIndex(model.data, pK, pkVal);
	// store.$.toDemolishRelation(model, index);
	// this.handleArrOp(model.data,"removeAt",undefined,index,1);
	// // record.$.isNew = false;
	// store.$.cmpSet(record.$, "isNew", false);
	// store.$.cmpSet(record, "$",  {});
	// model.emit("remove", [record]);
	// store.emit("remove", [model._name,record]);

}

function emit(db, type, record, attr, err){
	record.$.emit(type, [record,attr,err]);
	record.$.schema.emit(type, [record, attr, err]);
	db.emit(type, [record.$.schema._name, record, attr, err]);
}

function hasRecordsArrayChanged(record, attr, old){
	var arr = old || record.$.getInitialValues(attr), 
	changed = true;
	if(arr && arr.length == record[attr].length){
		changed = false;
		for(var i=0; i<arr.length; i++){
			if(record[attr].indexOf(arr[i]) == -1){
				return true;
			}
		}
	}
	return changed;
}

function cacheQuery(db, name, cacheQuery, data, status){
    var cq = db.schema.cachedQueries;
    cq = db.schema.cachedQueries = cq || {};
    cq = cq[name] = cq[name] || [];
    cq.push({cacheQuery : cacheQuery, data : data, status : status});
}

function cacheRecordQuery(db, name, key, cacheQuery, data, status){
    var crq = db.schema.cachedRecordQueries;
    crq = db.schema.cachedRecordQueries = crq || {};
    crq = crq[name] = crq[name] || {};
    crq = crq[key] = crq[key] || [];
    crq.push({cacheQuery : cacheQuery, data : data, status : status});
}

function isDefData(data){
    if(Array.isArray(data) && (data.schemaless || (data.schema && data.schema.__class === _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema && !data.polymorphic))){
        return true;
    } 
}

function handleArrOp(lyte,data,type,obj,pos,len){
    len = len != undefined ? len : 0;
    // var toBind = typeof lyte.arrayUtils != "undefined" ? true : false, 
	var ret;
    switch(type){
        case "push": {
            if(isDefData(data)){
                data._recMap == undefined ? _defProp(data, "_recMap", new Map()) : undefined;
				if(!data.schemaless){
					data._recMap.set(typeof obj.$.pK == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
				}
				else{
					data._recMap.set(obj[data.pK], obj);					
				}
            }
			ret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, "push", obj) : data.push(obj);
            break;
        }
        case "removeAt": {
            if(isDefData(data)){
                var cpyLen = len;
                for(var i=0;i<cpyLen;i++){
					var mpKey = undefined;
					if(!data.schemaless){
						var pkVal = data[pos+i] ? data[pos+i].$.pK : undefined;
						pkVal = ((typeof pkVal == "object") ? pkVal : pkVal.toString());
						mpKey = pkVal;
					}
					else{
						mpKey = data[pos+i][data.pK];
					}
                    mpKey !== undefined && data._recMap ? data._recMap.delete(mpKey) : undefined;
                }
            }
            // ret =  data.$splice ? data.$splice(pos,len) : data.splice(pos,len);
			ret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, "splice", pos, len) : data.splice(pos,len);
            break;
        }
        case "insertAt": {
            if(isDefData(data)){
                data._recMap == undefined ? _defProp(data, "_recMap", new Map()) : undefined;
				if(!data.schemaless){
					data._recMap.set(typeof obj.$.pK == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
				}
				else{
					data._recMap.set(obj[data.pK], obj);					
				}
            }
            // ret = data.$splice ? data.$splice(pos,len,obj) : data.splice(pos,len,obj);
			ret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, "splice", pos, len, obj) : data.splice(pos, len, obj);
            break;
        }
        case "replaceAt": {
            // ret = data.$splice ? data.splice(pos,len,obj) : data.splice(pos,len,obj);
			ret = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils(data, "splice", pos, 1, obj) : data.splice(pos, 1, obj);
			break;
        }
        default: {
            _dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.error(lyte,"LD07", type);
            break;
        }
    }
    return ret;
}

function defArrUtls(obj){
    Object.defineProperties(obj, {
        filterBy : {
            value : filterBy
        },
        sortBy : {
            value : sortBy
        },
        mapBy : {
            value : mapBy
        }
    });
}

function defPolyUtls(obj){
    Object.defineProperties(obj,{
        add : {
            value : add
        },
        remove : {
            value : remove
        }
    })
}

function defUtls(obj,def,ins,key){
    if(def){
        _defProp(obj, "schema", def);
    }
    if(ins){
        _defProp(obj, "entity", ins, false, true);
    }
    if(key){
        _defProp(obj, "key", key);
    }
}

function defPar(arr){
    _defProp(arr, "partial", new Map());
}

function cmpSet(lyte, obj, key, value, opts, fromStore){
    if(lyte && lyte.$utils && lyte.$utils.set){
        lyte.$utils.set(obj, key, value, opts, fromStore);
    }
    else{
        obj[key] = value;
    }
}

function _defProp(scp, key, val, enume, write, conf){
    enume = (enume === undefined) ? false : enume;
    write = (write === undefined) ? false : write;
	conf = (conf === undefined) ? false : conf;
    Object.defineProperty(scp, key, {
        value : val,
        enumerable : enume,
        writable : write,
		configurable : conf
    });
}


function removePartialKeys(db, data, schema){
    var rels = schema.relations,
	db = schema.db;
	rels.forEach(function(relArr, key){
		relArr.forEach(function(rel){
			var relObj = {}, 
			inv, 
			bMod = rel.relatedTo;
			if(bMod){
				var inv = getBackwardRel(schema, rel, getSchemaObj(db, bMod));
				if(inv && inv.relType == "hasMany" && inv.opts && inv.opts.serialize){
					var relKey = rel.relKey, invRelKey = inv.relKey, invObj = data[relKey];
					if(invObj){
						if(Array.isArray(invObj)){
							invObj.forEach(function(invRelRec){
								var invRelObj = invRelRec[invRelKey];
								if(invRelObj && invRelObj.partial && invRelObj.partial.get(data)){
									invRelObj.partial.delete(data);
								}		
							});
						}
						else if(invObj[invRelKey]){
							var invRelObj = invObj[invRelKey];
							if(invRelObj && invRelObj.partial && invRelObj.partial.get(data)){
								invRelObj.partial.delete(data);
							}
						}
					}
				}
			}
		});		
	});
}

function mergeResponse(db, data , schema , response , pK , partialObj, cPersist){
    var db = schema.db;
	removePartialKeys(db, data, schema, pK);
    if(partialObj && Object.keys(partialObj).length){
        mergeNewDataKeys(db, partialObj, data, response, cPersist);
    }
    if(mergeError(schema, data, response)){
        return;
    }
    var isRec = db.cache.getEntity(data.$.schema.def, data.$.pK), 
	dirtyId, 
	mergeDone = false,
	result;
    if(data.$.isDeleted){
       mergeDeletedRec(db, partialObj, data, cPersist);
    }
    if(data.$.isNew && isRec){
        mergeDone = mergeNewRecord(db, partialObj, data, response, true, cPersist);
    }
    if(data.$.isModified && isRec){
        mergeModifiedRec(db, partialObj, data, response, true, mergeDone, cPersist);
    }
    if(schema.dirty.length){
        deleteFromArray(schema.dirty, dirtyId);
    }
    if(partialObj && Object.keys(partialObj).length && response && !mergeDone){
        if(response){
            if(isRec){
                result = validateAndMerge(schema, response, partialObj, true, true);
				if(result && result.data){
					result = result.data;
				}
				else if(result && result.type){
					Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
					_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror, result.args || [db.lyte]);
				}
            }
            else{
                result = insertIntoStore(db, schema.def, response, undefined, undefined, partialObj);
            }
        }					
    }
    // var dirty = data.$.isDirty();
    // for(var j=0; j < dirty.length ;j++){
    //     var records = data[dirty[j]];
    //     if(Array.isArray(records)){
    //         for(var k=0;k<records.length;k++){
    //             if(isEntity(records[k])){
    //                 cmpSet(db.lyte, records[k].$, "isModified", false);
	// 				changePersist(records[k], true);
    //             }
    //         }
    //     }
    //     else if(isEntity(records)){
    //         cmpSet(db.lyte, records.$, "isModified", false);
	// 		changePersist(records, true);
    //     }
    // }
    removeDirtyStack(data, partialObj);
    // removeDeepNest(data);
}

function removeDirtyStack(data,partial){
    if(partial && partial._removedAttr && Object.keys(partial._removedAttr).length !=0){
		for(var key in data.$._attributes){
			if(!partial._removedAttr.hasOwnProperty(key)){
				delete data.$._attributes[key];
			}
		}
	}
	else{
		data.$._attributes = {};
	}
	// data.$._attributes={};
	data.$.undoStack = genUnRedoStack();
	data.$.redoStack = genUnRedoStack();
	delete data.$._savedState;
	_dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.clrRecErr(data.$); 
}

function mergeNewDataKeys(db, partialObj, data, response, cPersist){
    if(partialObj && ((data && data.partial && data.partial.size) || partialObj.partial == true)){ //true checked since partial key can come in this 
        if(Array.isArray(partialObj)){				
            partialObj.forEach(function(item, index){
                if(item.$){
                    var pK = item.$.schema._pK;
                    var ind = getIndex(data, pK, item.$.pkVal);
                    if(item.$.onlyDetach === true){
						if(data.entity && data.key){
							deleteDeepNest(data.entity,data.key,item.$.pkVal);
						}
                        handleArrOp(db.lyte, data, "removeAt", undefined, ind, 1);
                    }
                    else{
                        mergeNewDataKeys(db, item, ind != -1 ? data[ind] : undefined, response ? response[index] : undefined, cPersist);
						data.partial ? data.partial.delete(item.$.pkVal) : undefined;
                    }
					if(!item._removedAttr || (item._removedAttr && Object.keys(item._removedAttr).length)){
						data.partial ? data.partial.delete(item.$.pkVal) : undefined;
					}
                }
            });
			if(Array.isArray(data) && data.partial && data.partial.size && data.entity && data.key && data.entity.$.schema){
				var relFld = data.entity.$.schema.fieldList[data.key], toRemPart = [];
				if(relFld.opts && /^(id|record)$/.test(relFld.opts.serialize)){
					data.partial.forEach(function(pObj, pKey){
						if(pObj.type == "removed"){
							toRemPart.push(pKey);
						}
					});
					toRemPart.forEach(function(rItm){
						var rec = db.cache.getEntity(db.getSchema(data.schema._name), rItm) || db.cache.getEntity(db.getSchema(data.schema._name), rItm, true);
						data.partial.delete(rItm);
						rec ? removeParentNesting(rec) : undefined;
					});	
				}
			}
        }
    }
    else if(partialObj && partialObj.$ && partialObj.$.type){
        if(partialObj.$.onlyDetach){ //only for belongsTo
			var parent = partialObj.$.parent;
			if(parent && parent.$.partial && parent.$.partial[partialObj.$.relKey] && parent.$.partial[partialObj.$.relKey].has(partialObj.$.pkVal) && parent.$.partial[partialObj.$.relKey].get(partialObj.$.pkVal).type == "removed"){                        
				var rec = db.cache.getEntity(db.getSchema(partialObj.$.schema.__class), partialObj.$.pkVal) || store.peekRecord(partialObj.$.model, partialObj.$.pkVal, true);
				parent.$.partial[partialObj.$.relKey].delete(partialObj.$.pkVal);
				if(!parent.$.partial[partialObj.$.relKey].size){
					delete parent.$.partial[partialObj.$.relKey];
					if(!Object.keys(parent.$.partial).length){
						delete parent.$.partial;
					}
				}
				rec ? removeParentNesting(rec) : undefined;
			}
		}
		else{
			mergePartialObj(db,partialObj, data, response, undefined, cPersist);
		}
    }
    else{
        if(Array.isArray(partialObj)){
            partialObj.forEach(function(item, index){
                mergeNewDataKeys(db, item, data[index], response ? response[index] : undefined, cPersist);
            });
        }
        else if(typeof partialObj == "object"){
            for(var key in partialObj){
                mergeNewDataKeys(db, partialObj[key], data[key], response ? response[key] : undefined, cPersist);
            }
        }
    }
}

function mergeError(schema, data, response){
    if(response && response.$ && response.$.isError){
        if(response.$.error){
            var obj = response.$.error;
            for(var key in obj){
                if(schema.fieldList.hasOwnProperty(key)){
                    _dberror__WEBPACK_IMPORTED_MODULE_0__.ValidationError.setRecErr(data.$, key, obj[key]);
                }
            }
        }
		if(response.$.revert){
			data.$.revert();
		}
		delete response.$.revert;
        delete response.$.error;
        delete response.$.isError;
        return true;
    }
}

function mergePartialObj(db, partialObj, data, response, doMerge, cPersist){
    var prec = db.cache.getEntity(partialObj.$.schema.def, partialObj.$.pkVal), data = data || prec, isRec = prec ? true : false, mergeDone;
    if(partialObj && partialObj.$ && partialObj.$.processed){
        return;
    }
    if(mergeError(db.schema[partialObj.$.schema], data, response)){
        return;
    }
	if(partialObj.$.type == "removed"){
        mergeDeletedRec(db, partialObj, data, cPersist);
        return;
    }
    else if((partialObj.$.type == "added" || (data && data.$ && data.$.isNew == true)) && isRec){
        mergeDone = mergeNewRecord(db, partialObj, data, response, doMerge, cPersist);
    }
    else if((partialObj.$.type == "modified" || partialObj.$.type == "related" || (data && data.$ && data.$.isModified == true)) && isRec){
        mergeModifiedRec(db, partialObj, data, response, doMerge, mergeDone, cPersist);
    }
    if(isRec){
        if(partialObj.$.type != "removed"){
            for(var key in partialObj){
                var part = partialObj[key];
                mergeNewDataKeys(db, part, data[key], response ? response[key] : undefined,cPersist);
            }
        }
        if(data.$.partial && Object.keys(data.$.partial)){
            data.$.partial = new Map();
        }
        removeDirtyStack(data,partialObj);
    }
}

function mergeNewRecord(db, partialObj, data, response, doMerge, cPersist){
	var mdl = partialObj.$ ? partialObj.$.schema : data.$.schema,
	pKeys = mdl._arrPk, 
	oldPk = data.$.pK, 
	lyte = db.lyte,
	rec = db.cache.getEntity(mdl.def, oldPk), 
	result, 
	partRec = partialObj.$ ? partialObj.$.entity : undefined;
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(partRec) && partRec !== rec){
		return;
	}
	if(rec){
		var oldRelPk = typeof oldPk == "object" ? oldPk : oldPk.toString(), 
		crProcessed = false;
		if(cPersist !== true){
			pKeys.forEach(function(item){
				if(!response || !response.hasOwnProperty(item)){
					_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror.error(lyte,"LD16", mdl._name, (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(data) ? (typeof data.$.pK == "object" ? JSON.stringify(data.$.pK) : data.$.pK) : undefined);
					return;
				}	
				cmpSet(lyte, data, item, response[item], undefined, true);
				crProcessed = true;
			});
			var newPk = getpKVal(data);
			cmpSet(lyte, data.$, "pK", getpKVal(data));
			var newRelPk = typeof newPk == "object" ? newPk : newPk.toString();
			if(mdl.data._recMap){
				mdl.data._recMap.delete(oldRelPk);
				mdl.data._recMap.set(newRelPk, data);
			}
			changeRelPkMaps(data, oldRelPk, newRelPk);
			updateNestScp(data, oldPk);
		}
		if(crProcessed && partialObj && partialObj.$ ){
			partialObj.$.processed = true;
		}
		if(doMerge && cPersist !== true){
			result = validateAndMerge(mdl, response, partialObj, true, true);
			if(result && result.data){
				result = result.data;
			}
			else if(result && result.type){
				Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
				_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror, result.args || [db.lyte]);
			}
		}
		cmpSet(lyte, data.$, "isNew", false);
		if(partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length!=0){
			return result;
		}
		cmpSet(lyte, data.$, "isModified", false);
		changePersist(data, true);
		deleteFromArray(mdl.dirty, oldPk);
		if(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){
			removeParentNesting(data);
		}
	}
	return result;
}

function mergeModifiedRec(db, partialObj, data, response, doMerge, mergeDone, cPersist){
	var dirtyId = !dirtyId ? data.$.pK : dirtyId, result, lyte = db.lyte;
	if(!data.$.isDeleted && response && !mergeDone && cPersist !== true){
		if(response && doMerge){
			result =  validateAndMerge(data.$.schema, response, partialObj, true, true);
			if(result && result.data){
				result = result.data;
			}
			else if(result && result.type){
				Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
				_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_0__.Dberror, result.args || [db.lyte]);
			}
		}
		mergeDone = true;						
	}
	// changeModified(lyte, data, false, data.$.pK);
	if(partialObj && partialObj.hasOwnProperty("_removedAttr") && partialObj._removedAttr.length){
		return result;
	}
	cmpSet(lyte, data.$, "isModified", false);
	changePersist(data, true);
	if(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){
		removeParentNesting(data);
	}
	return result;
} 

function mergeDeletedRec(db, partialObj, data){
	var pkVal, schema, obj;
	if(partialObj){
		schema = partialObj.$.schema;
		pkVal = partialObj.$.pkVal;
	}
	else if(data){
		schema = data.$.schema;
		pkVal = data.$.pK;
	}
	obj = schema._deleted.get(pkVal); 
	var rec = obj ? obj.data : undefined;
	var isRec = db.cache.getEntity(schema.def, pkVal);
	if(rec){
		cmpSet(db.lyte, rec.$, "isDeleted", false);
		cmpSet(db.lyte, rec.$, "isUnloaded", true);
		cmpSet(db.lyte, rec.$, "isPersisted", true);
		var scpObj = rec.$.__scpObj;
		for(var key in scpObj){
			var sid = scpObj[key];
			var sidArr = sid.split("_");
			var nestObj = _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.nestScp[sidArr[0]];
			nestObj ? (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.removeNestScp)(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model:schema._name, pK: pkVal, attr: key}) : undefined;
		}	
		schema._deleted.delete(pkVal);
		removeParentNesting(rec);
	}
	if(isRec){
		removeFromStore(schema, pkVal, true, undefined, undefined, true);
		removeParentNesting(isRec);
	}
	else{
		var cqueries = db.schema.cachedQueries;
		if(cqueries){
			var n=schema._name, Nm = cqueries[n];
			if(Nm && Nm.length){
				for(var i=Nm.length-1; i>=0; i--){
					var obj = Nm[i];
					if(obj.hasDeletedRecords){
						if(obj.data){
							var ind = obj.data[n].indexOf(rec);
							if(ind !== -1){
								Nm.splice(i,1);					
							}
						}
					}
				}					
			}
		}
	}
	if(partialObj && partialObj.$ && partialObj.$.parent){
		partialObj.$.parent.$.partial = {};
	}
	partialObj && partialObj.$ ? partialObj.$.processed = true : undefined;
}

function changeRelPkMaps(data, oldPk, newPk){
	var schema = data.$.schema,
	db = schema.db,
	relations = schema.relations;
	relations.forEach(function(rels, key){
		rels.forEach(function(itm){
			var attr = itm.relKey, relType = itm.relType, inv;
			if(data.hasOwnProperty(attr)){
				var relRec = data[attr],
				bMod = getSchemaObj(db, itm.relatedTo), inv;
				if(bMod){
					inv = getBackwardRel(schema,itm,bMod);
					if(inv && inv.relType == "hasMany"){
						if(relType == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(relRec)){
							relRec[inv.relKey] && relRec[inv.relKey]._recMap && relRec[inv.relKey]._recMap.delete(oldPk) ? relRec[inv.relKey]._recMap.set(newPk, data) : undefined;
						}
						else if(relType == "hasMany" && Array.isArray(relRec)){
							relRec.forEach(function(rec){
								(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(rec) && rec[inv.relKey] && rec[inv.relKey]._recMap && rec[inv.relKey]._recMap.delete(oldPk) ? rec[inv.relKey]._recMap.set(newPk, data) : undefined;
							});
						}
					}
				}
			}
		});
	});
	var _rels = data.$._relationships;
	for(var md in _rels){
		var mdObj = _rels[md];
		for(var attr in mdObj){
			var arr = mdObj[attr];
			arr.forEach(function(rec){
				var relData = rec[attr];
				if(Array.isArray(relData)){
					relData._recMap && relData._recMap.delete(oldPk) ? relData._recMap.set(newPk, data) : undefined;
				}
			});
		}
	}
}

function updateNestScp(obj, oldPk){
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEntity)(obj)){
		var scpObj = obj.$.__scpObj || {};
		for(var key in scpObj){
			var val = scpObj[key];
			val = val.split("_")[0];
			if(_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.nestScp && _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.nestScp.hasOwnProperty(val) && _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.nestScp[val].model){
				var mp1 = _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.nestScp[val].model.get(obj.$.schema._name);
				if(mp1.has(oldPk)){
					var val = mp1.get(oldPk);
					mp1.delete(oldPk);
					mp1.set(obj.$.pK, val);
				}
				// Lyte.nestScp[val].pK = record.$.pK;
			}
		}
	}
}

function getDsrzEmpData(schema, field){
	if(field.hasOwnProperty("deserializeEmptyData")){
		return field.deserializeEmptyData;
	}
	else{
		var desrz = getFromCB(schema.db, "serializer", schema.serializer, "deserializeEmptyData");
		if(desrz !== undefined){
			return desrz;
		}
	}
	return false;
}

// function defpayObjUtls(obj){
// 	Object.defineProperties(obj,{
// 		set:{
// 			value: payloadSet
// 		},
// 		remove:{
// 			value: payloadRemove
// 		}
// 	})
// }

// function defPayArrUtls(obj){
// 	Object.defineProperties(obj,{
// 		add : {
// 			value : payloadAdd
// 		},
// 		remove : {
// 			value : payloadRemove
// 		}
// 	})
// }

// function payloadAdd(key,index){
// 	if(!Array.isArray(key)){
// 		key=[key];
// 	}
// 	var def = this._schema, db = def.db, partObj=this._partialObj, payload=this._payloadObj;
// 	for(var i =0 ; i<key.length; i++){
// 		var record = db.cache.getEntity({schema:def, pK:key[i]}), partial={};
// 		_defProp(partial, "$", {});
// 		var nPartial = 	partial.$;
// 		Object.defineProperties(nPartial,{
// 			pkVal : {
// 				value : record.$.pK
// 			},
// 			type : {
// 				value : "related"
// 			},
// 			schema : {
// 				value : def
// 			},
// 			record : {
// 				value : record
// 			}
// 		});
// 		var _pk = typeof(record.$.pK) == "object" ? record.$.pK : { [record.$.model._pK] : record.$.pK };
// 		if(index){
// 			Lyte.arrayUtils(partObj,"insertAt",index,partial);
// 			Lyte.arrayUtils(payload,"insertAt",index,_pK);
// 			index=index++;
// 		}
// 		else{
// 			Lyte.arrayUtils(partObj,"push",partial);
// 			Lyte.arrayUtils(payload,"push",_pk);
// 		}
// 		store.$.defProp(_pk, "$", {});
// 		store.$.defpayObjUtls(_pk.$);
// 		Object.defineProperties(_pk.$,{
// 			_pkVal : {
// 				value : record.$.pK
// 			},
// 			_model : {
// 				value : modelName
// 			},
// 			_partialObj : {
// 				value : partial
// 			},
// 			_payloadObj:{
// 				value:_pk
// 			}
// 		});
// 	}
// }

// function payloadRemove(key){
// 	var def = this._schema, 
// 	partObj=this._partialObj, 
// 	payload=this._payloadObj;
// 	if(!Array.isArray(key)){
// 		key=[key];
// 	}
// 	for(var j =0; j<key.length; j++){
// 		if(Array.isArray(payload)){
// 			var len = payload.length;
// 			for(var i =0; i<len; i++){
// 				if(partObj[i].$.pkVal == key){
// 					partObj.splice(i, 1);
// 					payload.splice(i, 1);
// 					// Lyte.arrayUtils(partObj,"removeAt",i,1);
// 					// Lyte.arrayUtils(payload,"removeAt",i,1);
// 				}
// 			}
// 		}
// 		else{
// 			if(payload[key] && partObj[key]){
// 				delete payload[key[j]];
// 				delete partObj[key[j]];
// 				// Lyte.objectUtils(payload,"delete",key[j]);
// 				// Lyte.objectUtils(partObj,"delete",key[j]);
// 			}
// 		}
// 	}
// }

// function payloadSet(fkey){
// 	if(!Array.isArray(fkey)){
// 		fkey=[fkey];
// 	}
// 	var def = this._schema, db = def.db, pk = this._pkVal, payload = this._payloadObj;
// 	var record = db.cache.getEntity({schema:def.def,pK:pk}), partial=this._partialObj;
// 	for(i_key=0; i_key<fkey.length; i_key++){
// 		var key = fkey[i_key];
// 		var field = def.fieldList[key];
// 		if(record[key] && field.type == "relation"){
// 			if(field.relType == "hasMany"){
// 				partial[key]=[];
// 				payload[key]=[];
// 				_defProp(payload[key], "$", {});
// 				defPayArrUtls(payload[key].$);
// 				Object.defineProperties(payload[key].$,{
// 					_key:{
// 						value:field.relKey
// 					},
// 					_partialObj:{
// 						value:partial[key]
// 					},
// 					_schema:{
// 						value:field.relatedTo
// 					},
// 					_payloadObj:{
// 						value:payload[key]
// 					},
// 					// replace:{
// 					// 	value:store.$.replaceCheck,
// 					// 	writable:true
// 					// }
// 				})
// 				for(i=0; i<record[key].length; i++){
// 					payload[key].$.add(record[key][i].$.pK);
// 				}
// 			}
// 			else{
// 				partial[key]={};
// 				payload[key]={};
// 				payload[key]=typeof record[key].$.pK =="object" ? record[key].$.pK:{[record[key].$.model._pK]:record[key].$.pK};
// 				_defProp(partial[key], "$", {});
// 				var nPartial = 	partial[key].$;
// 				Object.defineProperties(nPartial,{
// 					pkVal : {
// 						value : record.$.pK
// 					},
// 					type : {
// 						value : "related"
// 					},
// 					schema : {
// 						value : def
// 					},
// 					record : {
// 						value : record[key]
// 					}
// 				});
// 				_defProp(payload[key], "$", {});
// 				Object.defineProperties(payload[key].$,{
// 					_pkVal : {
// 						value : record[key].$.pK
// 					},
// 					_schema : {
// 						value : field.relatedTo
// 					},
// 					_partialObj : {
// 						value : partial[key]
// 					},
// 					_payloadObj:{
// 						value:payload[key]
// 					}
// 				});
// 				defpayObjUtls(payload[key].$);
// 			}
// 		}
// 		else{
// 			payload[key]=record[key];
// 			partial[key]=record[key];
// 		}
// 	}
// }

// function replaceCheck(bool){
// 	store.$.defProp(this._partialObj,"replace",bool)
// }




/***/ }),

/***/ 2224256:
/*!*********************************************!*\
  !*** ./node_modules/@slyte/router/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "History": () => (/* reexport safe */ _src_history__WEBPACK_IMPORTED_MODULE_0__.History),
/* harmony export */   "Route": () => (/* reexport safe */ _src_route__WEBPACK_IMPORTED_MODULE_2__.Route),
/* harmony export */   "Router": () => (/* reexport safe */ _src_router__WEBPACK_IMPORTED_MODULE_3__.Router),
/* harmony export */   "RouterMap": () => (/* reexport safe */ _src_map_parser__WEBPACK_IMPORTED_MODULE_1__.RouterMap)
/* harmony export */ });
/* harmony import */ var _src_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/history */ 58399038);
/* harmony import */ var _src_map_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/map-parser */ 88013180);
/* harmony import */ var _src_route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/route */ 34225158);
/* harmony import */ var _src_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/router */ 19412727);







/***/ }),

/***/ 46565158:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/router/src/go-to.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linkToRegistration": () => (/* binding */ linkToRegistration)
/* harmony export */ });
/* harmony import */ var _router_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router-errors */ 11841938);
/* harmony import */ var _router_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router-utils */ 35263095);



const startFromStr = "start-from",
ltPropStr = "lt-prop",
routeStr = "route",
pReplace = ltPropStr+"-replace",
pStartFrom = ltPropStr+"-"+startFromStr,
pFragment = ltPropStr+"-fragment",
pDp = ltPropStr+"-dp",
pQp = ltPropStr+"-qp",
pTd = ltPropStr+"-td",
pData = ltPropStr+"-data",
pTrans = ltPropStr+"-trans",
pMeta = ltPropStr+"-meta",
refreshHRouteStr = "refresh-"+routeStr,
pRefreshRoute = ltPropStr+"-"+refreshHRouteStr,
linktoStr = "link-to",
ltPropWarning = "Error while parsing ltProp in "+linktoStr,
pRoute = ltPropStr+"-"+routeStr;
const parse = JSON.parse;

function linkToRegistration(lyte,LR,config) {
    LR.__lp.navigationCompleted = function(trans) {
        if(config.linkActiveClass && config.allLinks[trans.target]) {
            config.allLinks[trans.target].forEach(function(tag) {
                if(!tag.classList.contains(config.linkActiveClass)) {
                    tag.classList.add(config.linkActiveClass);
                    config.activeLinkTags.push(tag);
                }
            });
        }
    }

    LR.__lp.mutateCache = function(target) {
        if(config.allLinks[target]) {
            config.allLinks[target].forEach(function(tag) {
                if(config.linkActiveClass) {
                    tag.classList.add(config.linkActiveClass);
                }
                config.activeLinkTags.push(tag);
                var aTag = tag.getElementsByTagName('A')[0]
                if(aTag) {
                    aTag.setAttribute("href", LR.getURL(tag.getMatchedObject())); 
                }
            });
        }
    }

    class LinkTo extends HTMLElement {
        static get observedAttributes() {
            return [pRoute, pDp, pFragment, pQp, ltPropStr, 'lt-prop-class', 'lt-prop-id', 'lt-prop-rel', 'lt-prop-title', 'lt-prop-style', 'lt-prop-target','lt-prop-data-tabindex', 'lt-prop-aria-attributes','lt-prop-tabindex','lt-prop-aria-label'];
        }
        attributeChangedCallback(attr, oldValue, newValue) {
            if(this.matched && this.hasAttribute("lyte-rendered")) {
                let Atag = this.getElementsByTagName('A')[0];
                if(Atag) {
                    //If attr is ltProp
                    if(attr === ltPropStr) {
                        this.handleLtProp();
                        if(!this.hasAttribute("lt-prop-custom")) {
                            this.setCustomAttributes(Atag, true);
                        }
                        this.constructHref(Atag);
                    } else if(/^(lt-prop-route|lt-prop-fragment|lt-prop-dp|lt-prop-qp)$/.test(attr)) {
                        //if it is a route transition attribute
                        this.getMatchedObject();
                        this.constructHref(Atag, attr, oldValue, newValue);
                    } else if(!this.hasAttribute('lt-prop-custom')) {
                        //for rest of the attributes
                        Atag.setAttribute(attr.substring(8), newValue);
                    }
                }
            }
        }

        connectedCallback() {
            this.ltProp = this.ltProp || {};
            this.handleLtProp();
            if(this.hasAttribute("lyte-rendered")) {
                if(this.getElementsByTagName('A')[0] && !this.matched) {
                    this.getMatchedObject();
                }
                return;
            } 
            var isCustom = this.hasAttribute("lt-prop-custom") || this.ltProp.custom,
            aTag;
            if(isCustom) {
                if(aTag = this.getElementsByTagName('A')[0]) {
                    this.getMatchedObject();
                    this.constructHref(aTag);
                }
            } else {
                aTag = document.createElement("a");
                while(this.childNodes[0]) {
                    aTag.appendChild(this.childNodes[0]);
                }
                this.setCustomAttributes(aTag);
                this.getMatchedObject();
                this.constructHref(aTag);
                this.appendChild(aTag);
            }
            if(lyte.$.modules.component) {
                this._linkToEventId = lyte.$.modules.component[0].addAction(this, "click", function(event) {
                    linkToEventListener(event, this);
                }, this);
            } else {
                this.addEventListener("click", linkToEventListener);
            }
            this.setAttribute("lyte-rendered", "");
        }

        modifyLinkToTagsInRoute(remove) {
            var strRoute = Array.isArray(this.matched.route) ? this.matched.route.join('.') : this.matched.route,
            allLinks = config.allLinks[strRoute];
            if(remove) {
                if(allLinks) {
                    let pos = allLinks.indexOf(this);
                    if(pos != -1) {
                        allLinks.splice(pos,1);
                    }
                }
            } else {
                if(allLinks) {
                    allLinks.push(this);
                } else {
                    config.allLinks[strRoute] = [this];
                }
            }
            if(config.cacheRoutes[strRoute]) {
                let routesObj = config.routes,
                routes;
                if(remove) {
                    if(this.matched) {
                        routes = remove;
                    } else {
                        return;
                    }
                } else {
                    routes = this.matched.route;
                }
                if(!routes) {
                    return;
                } 
                routes = Array.isArray(routes) ? routes : _dotSerperator(routes);
                for(var i = 0,l = routes.length,r; i < l; i++) {
                    r = routes[i];
                    routesObj =  (0,_router_utils__WEBPACK_IMPORTED_MODULE_1__._getObj)(r,routesObj);
                    if(!routesObj || !routesObj.__lp) {
                        _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error(422,routes,i);
                        return false;
                    }
                    var def = routesObj.__lp.handler && routesObj.__lp.options;
                    if(remove) {
                        let pos = def.cacheLinks.indexOf(this);
                        if(pos !== -1) {
                            def.cacheLinks.splice(pos,1);
                        }
                    } else if(def.qpdef) {
                        def.cacheLinks.push(this);  
                    }
                }
            }
        }

        disconnectedCallback() {
            let m = this.modifyLinkToTagsInRoute.bind(this);
            if(lyte.$.component && !lyte.$.component.shouldIgnoreDisconnect()) {
                if(this.matched && this.matched.route) {
                    m(this.matched.route);
                }
                if(this._linkToEventId) {
                    lyte.$.component.removeLyteEventListener(this, this._linkToEventId);
                }
            }
        }
        
        handleLtProp(ignoreError) {
            var ltProp = this.getAttribute(ltPropStr);
            if(ltProp) {
                try{
                    this.ltProp = parse(ltProp);
                } catch(e) {
                    if(!ignoreError) {
                        lyte.error(ltPropWarning,ltProp);
                    }
                }
            }
        }

        setCustomAttributes(linkTag, onlyLtProp) {
            for(let key in this.ltProp) {
                if(/^(id|class|style|target)$/.test(key)) {
                    linkTag.setAttribute(key, this.ltProp[key]);
                }
            }
            if(!onlyLtProp) {
                for(let i=0,attr,attrName; attr = this.attributes[i]; i++) {
                    if((attrName = attr.nodeName) !== ltPropStr && /^(lt-prop-id|lt-prop-rel|lt-prop-class|lt-prop-style|lt-prop-target|lt-prop-data-tabindex|lt-prop-tabindex|lt-prop-aria-label|lt-prop-aria-attributes)$/.test(attrName)) {
                        linkTag.setAttribute(attrName.substring(8), attr.nodeValue);
                    }
                }
            }
        }

        constructHref(linkTag, attr, oldValue) {
            var href,
            m = this.modifyLinkToTagsInRoute.bind(this);
            if(href = LR.getURL.call(this,this.matched)) { /* deepCopyObj this.matched. ??*/
                linkTag.setAttribute("href", href); 
                if(attr === pRoute) {
                    m(oldValue);
                    m();
                } else {
                    m();
                }
            }
        }
    }
    
    LinkTo.prototype.getMatchedObject = function() {
        var matched = this.matched || {},
        ga = this.getAttribute.bind(this),
        dynamicParams = ga(pDp) || this.ltProp.dp || [],
        queryParams = ga(pQp) || this.ltProp.qp || {};
        if(!(dynamicParams instanceof Array)) {
            try {
                dynamicParams = parse(dynamicParams);  
            } catch(e) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error("498A","dynamicParams",this.outerHTML);
                return;
            }
        }
        if(!(queryParams instanceof Object)) {
            try{
                queryParams = parse(queryParams);
                if(Array.isArray(queryParams)) {
                    _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error("498A","queryParams",this.outerHTML);
                    return;
                }
            } catch(e) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error("498A","queryParams",this.outerHTML);
                return;
            }
        }
        var routeFromAlias = _router_utils__WEBPACK_IMPORTED_MODULE_1__._getRouteFromAlias.call(lyte,{route : ga(pRoute) || this.ltProp.route, map : config.aliasRouteMap});/* ga(pRoute) || this.ltProp.route; */
        matched.route = routeFromAlias.route;
        matched.alias = routeFromAlias.alias;
        matched.fragment = ga(pFragment) || this.ltProp.fragment;
        matched.dynamicParams = dynamicParams || [];
        matched.queryParams = queryParams || {};
        matched.refreshRoute = ga(pRefreshRoute) != undefined ? ga(pRefreshRoute) : this.ltProp[refreshHRouteStr];
        matched.refreshRoute = (matched.refreshRoute == "" || matched.refreshRoute == 'true') ? matched.route.join(".") : matched.refreshRoute;
        matched.startFrom = ga(pStartFrom) || this.ltProp[startFromStr];
        return this.matched = matched;
    };
    customElements.define(linktoStr, LinkTo);
    customElements.define("go-to", (function() {
        class GoTo extends LinkTo {}
        return GoTo;
    })());

    function linkToEventListener(event, linkTo) {
        if(event.button == 2 || event.defaultPrevented) {
            return;
        }
        var targetElem = linkTo || event.currentTarget;
        if(targetElem.children[0].tagName === "A" && (event.ctrlKey == true || event.metaKey == true || event.which == 2 || (targetElem.children[0].hasAttribute("target") && targetElem.children[0].getAttribute("target") !== "_self")) ) {
            return;  
        }
        event.preventDefault();
        if(!targetElem.matched) {
            targetElem.getMatchedObject();
        }
        var matched = Object.assign({},targetElem.matched);
        matched.route = Array.isArray(matched.route) ? matched.route.join('.') : matched.route;
        var replace = targetElem.ltProp.replace  || targetElem.hasAttribute(pReplace),
        transitionInstance = LR[replace && replace != "false" ? "replaceWith" : "navigateTo"](targetElem.matched);
        targetElem.handleLtProp(true)
        var transObj = {},
        transProp,
        ltProp = targetElem.ltProp;
        if(transProp = targetElem.getAttribute(pMeta) || targetElem.getAttribute(pTrans) || (ltProp && ltProp.meta)) {
            try{
                transObj = parse(transProp);  
            } catch(e) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error("498A", pMeta , linkTo.outerHTML);
            }
        }
        let transitionData = targetElem.getAttribute(pData) || targetElem.getAttribute(pTd) || (ltProp && ltProp.data);
        if(transitionData/* = (transitionData || transObj.data)*/) {
            if(typeof transitionData === "string") {
                try {
                    transitionData = parse(transitionData);
                } catch(e) {
                    _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error("498A", pData , linkTo.outerHTML);
                }
            }
            transObj.data = transitionData;
        }
        for(var key in transObj) {
            transitionInstance[key] = transObj[key];
        }
    }
}



/***/ }),

/***/ 58399038:
/*!***************************************************!*\
  !*** ./node_modules/@slyte/router/src/history.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "History": () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var _router_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router-utils */ 35263095);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);



class Location {
    constructor(obj) {
        var ignore = ["reload","ancestorOrigins","replace","toString","assign"]
        for(var key in obj) {
            if(ignore.indexOf(key) == -1) {
                this[key] = obj[key];
            }
        }
    }
}

class History {
    constructor({ historyType, popState, parent}) {
        var __lh = this.__lh = {
            historyType : parent && parent.history.type || historyType,
            allowHistoryChange : false,
            fromHistory : false,
            historyLength : 1,
            exp : {                
            }
        };
        this.parent = parent;

        window.addEventListener('popstate', function(event) {
            __lh.fromHistory = true;
            setHistoryObj.call(this, event.state);
            popState(event);
        }.bind(this));
       

        // Object.defineProperty(this.constructor.prototype, 'state', {
        //     get : function() {
        //         return this.getData();
        //     },
        //     set : function(data) {
        //         if(this.__lh.allowHistoryChange) {
        //             debugger;
        //             this.__lh.allowHistoryChange = false;
        //         } else {
        //             lyte.warn('setting on data will not be pushed to history. If needed, use `LR.history.replaceState`.');
        //         }
        //         return data;
        //     }
        // });

        __lh.exp.pushState = this.pushState = function(data, title, url, metaData) {
            url = mergeWithParentUrl.call(this,{url})
            return stateChange.call(this, data,title,url,metaData);
        };
    
        __lh.exp.replaceState = this.replaceState = function(data,title,url,metaData) {
            url = mergeWithParentUrl.call(this,{url})
            return stateChange.call(this,data,title,url,metaData, true);
        };
        __lh.exp.go = this.go = history.go
        __lh.exp.back = this.back = history.back
        __lh.exp.forward = this.forward = history.forward
        __lh.exp.length = this.length = history.length
        Object.defineProperty(this,"scrollRestoration",{
            get : () => {
                return history.scrollRestoration;
            },
            set : (value) => {
                history.scrollRestoration = value;
            }
        })
    
        this.getMeta = function() {
            var meta = history.state && history.state.meta
            return meta;
        }

        function mergeWithParentUrl({url}) {
            if(this.parent) {
                debugger;
                var i,
                pUrl = this.parent.history.url,
                serch = ((i = url.indexOf('?')) != -1) ? "?"+url.slice(i+1) : "";
                serch = this.parent.history.search+serch;
                if(url.indexOf("#") != -1) {
                    url = (0,_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(url.split("#")[1])
                }
                if(this.__lh.historyType == "hash") {
                    pUrl = this.parent.path
                    url = pUrl+ url
                } else if(pUrl.indexOf("#")) {
                    pUrl = this.parent.path + url + (0,_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(pUrl.split("#")[1])
                } 
                url += (serch ? "?"+serch : "");
            }
            return url
        }
        
        __lh.exp.getData = this.getData = function() {
            return history.state && history.state.data;
        }
        
        // this.getHistoryObj = function() {
        //     var retObj =  {
        //         historyType : historyType,
        //         index : this.__lh.currentMeta ?  this.__lh.currentMeta.__lh.index : 0,
        //         fromHistory : this.__lh.fromHistory ? (this.__lh.prevMeta ? (this.__lh.prevMeta.__lh.index < this.__lh.currentMeta.__lh.index ? 'forward' : 'back') : 'reload') : false,
        //         initial : this.__lh.historyLength == 0
        //     }
        //     // allowHistoryChange = true;
        //     retObj.state = history.state;
        //     retObj.meta = this.getMeta() || {};
        //     retObj.data = this.getData() || {};
        //     return retObj;
        // }
    }
}

function getHistoryState(obj) {
    /* 
    {
            matched : obj.matched,
            url : obj.url,
            index : obj.fromHistory ? (this.getMeta() ? this.getMeta().index : historyLength) : ((obj.replace && this.getMeta()) ? this.getMeta().index : (historyLength = historyLength+1))
        }

        state data which needs to be pushed to history. 
        - Matched object is added to process url directly with history back and forward.
        - Index is used to detect browser back or forward.
    */
    var metaData = obj.metaData || {},
    currentMeta = this.__lh.prevMeta = this.__lh.currentMeta;
    metaData.__lh = {
        index : obj.replace ? (currentMeta ? currentMeta.__lh.index : this.__lh.historyLength-1) : (currentMeta ? currentMeta.__lh.index+1 : this.__lh.historyLength),
        url : obj.url,
        title : obj.title
    }
    return {
        meta : this.__lh.currentMeta = metaData,
        data : obj.data
    };
}

function stateChange(data,title,url, metaData, replace) {
    var args = [getHistoryState.call(this, {data , metaData, replace, title, url}) , title] 
    if(url) {
        /* support for windows, undefined is appended to url */
        args.push(url)
    }
    // this.__lh.prevMeta = history.state && history.state.meta;
    window.history[replace ? "replaceState" : "pushState"].apply(window.history, args);
    var hstry = setHistoryObj.call(this) //this.getHistoryObj();
    // this.__lh.index = his.index;
    if(!hstry.fromHistory && !replace) {
        this.__lh.historyLength++;
    }
    return hstry;
}

function setHistoryObj(popHistory) {
    var self = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(this);
    if(popHistory) {
        self.__lh.currentMeta = self.__lh.prevMeta = popHistory.meta;
        return self.__lh.exp;
    }
    self.__lh.exp = new Location(window.location);
    var href = self.getMeta() && self.getMeta().__lh.url || window.location.href,
    urlSplit = href.split("?"),
    search = urlSplit[1] || "",
    hash = urlSplit[0].split("#")[1] || "";
    self.__lh.exp.index = self.__lh.index = self.__lh.currentMeta ?  self.__lh.currentMeta.__lh.index : 0;
    self.__lh.exp.fromHistory = self.__lh.fromHistory = self.__lh.fromHistory ? (self.__lh.prevMeta ? (self.__lh.prevMeta.__lh.index < self.__lh.currentMeta.__lh.index ? 'forward' : 'back') : 'reload') : false;
    self.__lh.exp.initial = self.__lh.initial = self.__lh.historyLength == 0;
    self.__lh.exp.data = self.getData && self.getData() || history.state && history.state.data;
    self.__lh.exp.url = href;
    self.__lh.exp.type = this.parent ? this.parent.history.type : this.__lh.historyType;
    self.__lh.exp.href = self.__lh.exp.origin+self.__lh.exp.pathname+href;
    self.__lh.exp.search = search && "?"+search;
    self.__lh.exp.hash = hash && "#"+hash;
    self.__lh.state = history.state;
    self.__lh.currentMeta = self.__lh.prevMeta = self.getMeta && self.getMeta() || history.state && history.state.meta;
    return self.__lh.exp;
}


    

/***/ }),

/***/ 88013180:
/*!******************************************************!*\
  !*** ./node_modules/@slyte/router/src/map-parser.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterMap": () => (/* binding */ RouterMap),
/* harmony export */   "_parseRouteMap": () => (/* binding */ _parseRouteMap),
/* harmony export */   "_traverseMap": () => (/* binding */ _traverseMap)
/* harmony export */ });
/* harmony import */ var _slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/router/src/router-utils */ 35263095);


const parseRouteMappingStr = "parseRouteMapping",
functionStr = "function";
var  mapObj = {}, 
pathStringArr = [], 
routeStringArr = [],
_config,
_initialRegisterRoute,
routesObj;

class RouterMap {
    constructor() {
        this.aliasPrefix = [];
        this.lazyRoute = this.route;
        this.mountRoute = this.route;

        this.setAlias = function(lyte,_config,alias,route) {
            var _alias="";
            if(alias) {
                if(this.aliasPrefix.length) {
                    this.aliasPrefix.forEach((a) => {
                        _alias += a;
                    });
                }
                alias = _alias+alias
            };
            if(_config.aliasRouteMap[alias]) {
                lyte.error('Duplicate entries found for alias "'+ alias +'". Existing entry will be overwritten');
            }
            _config.aliasRouteMap[alias] = route;
            _config.routeAliasMap[route] = alias;
        };
    }

    route(routeName, obj, nestedFn) {
        // var lazyRoute;
        // if(typeof obj.class == functionStr && obj.class.name == "__routeProm__") {
        //     // className = obj.cName;
        //     lazyRoute = true
        // }
        // if(!obj.class) {
        //     return "No route file map"
        // };
        if(typeof obj == "object"/*  || lazyRoute*/) {
            if(!obj.path) {
                obj.path = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(routeName);
            } else {
                if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._strPresence)(obj.path,"?")) {
                    var split = obj.path.split('?');
                    obj.defQP = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._frameQueryParams)(split[1]);
                    obj.path = split[0] || "/";
                }  
            }
            if(obj.queryParams) {
                obj.defQP = obj.queryParams;
            }
        } else {
            if(typeof obj == functionStr) {
                nestedFn = obj;
            }
            obj = {path : (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(routeName) /* ,cName : obj.class.name */};  
        }
        mapObj = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(pathStringArr,_config.routeHash)[obj.path] = {__lp : {}};
        if(obj.path == '/') {
            pathStringArr.push('/');
        } else {
            var trimedPath = obj.path;
            if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(trimedPath) || (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._wildcardRouteCheck)(trimedPath)) {
                (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(trimedPath).every(function(seg,index,arr) {
                if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(seg) || (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._wildcardRouteCheck)(seg)) {
                    var dkey;
                    if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(seg)) {
                        dkey = seg.replace(":","");
                    } else  {
                        dkey = seg.replace("*","");
                        obj.wildcard = mapObj.__lp.wildcard = true;
                        obj.sufix = mapObj.__lp.sufix = [];
                        for(var i = index+1,j; j = arr[i]; i++) {
                            mapObj.__lp.sufix.push(j);
                        }
                    }
                    obj.dkey = mapObj.__lp.dkey = dkey;
                    obj.dIndex = mapObj.__lp.dIndex = index;
                    return false;
                }
                return true;
                });
            } 
            pathStringArr.push(trimedPath);
        }
        if(obj && obj.mount) {
            mapObj.__lp.mount = true;
        }
        var routes = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(routeStringArr,routesObj) || routesObj;
        routeStringArr.push(routeName);
        mapObj.__lp.route = Array.from(routeStringArr);
        routes[routeName] ? (Object.assign(routes[routeName].__lp,obj)) : (routes[routeName] = {__lp : obj});
        if(obj.alias) {
            this.setAlias(this.lyte,_config,obj.alias,mapObj.__lp.route.join('.'))
        }
        if(obj.handler.name == "__routeProm__") {
            // obj.then = function(routeStringArr,data) {
            //     debugger;
            //     _initialRegisterRoute(routeStringArr,data[obj.cName]);    
            // }.bind(undefined,Array.from(routeStringArr))
        } else {
            _initialRegisterRoute(routeStringArr,obj.handler);
        }
        if(nestedFn) {
            nestedFn.call(this,{});
        }
        // if(obj && obj.mount) {
        //     _config.dependenciesApps[obj.mount] = _config.dependenciesApps[obj.mount] ? _config.dependenciesApps[obj.mount].push(routeStringArr) : [routeStringArr]
        //     obj.mount.prototype.map.call(this,{});
        // }
        routeStringArr.pop();
        pathStringArr.pop();
        this.aliasPrefix.pop();
    }
    include(mapClass, obj) {
        try {
            obj = obj || {};
            if(obj.aliasPrefix) {
                this.aliasPrefix.push(obj.aliasPrefix)
            }
            obj && new mapClass().map.call(this,{});
        } catch(e) {
            console.error(e, "Error in includes")
        }
    }
}

RouterMap.__lMod = "RouterMap";

function _parseRouteMap(MapClass,{ lyte, config , initialRegisterRoute }) {
    _config = config;
    _initialRegisterRoute = initialRegisterRoute;
    lyte.time(parseRouteMappingStr);
    routesObj = _config.routes ? _config.routes : (_config.routes = {})
    var ins = new MapClass({ lyte }),
    err = ins.map(_config);
    if(typeof err == "string") { lyte.log(err)};
    lyte.time(parseRouteMappingStr);
    return routesObj;
}

function _traverseMap(path, config) {
    if(!path) {
     return;
    }
    var selectedPaths = [],
    fragment;
    if(config.historyType) {
        var fragSplit = path.split('#');
        if(fragment = fragSplit[1]) {
            path = fragSplit[0];
        }
    }
    var pathSplit = path.split('?');
    path = decodeURI(pathSplit[0]);
    if(path == '/') {
        if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(['/'],config.routeHash)) {
            selectedPaths.push([path]);  
        } else {
            return;
        }
    } else {
        var params = pathSplit[1],
        pathSplitArr = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(path);
        var pathLevel = 0,
        pathArrLevel = [0],
        exactMatch,
        matchedPath = [];
        matchedPath.dynamicParams = [];
        findPossibleMatch(config.routeHash);

        function checkArrayMatch(arr1,arr2,l,pathObj,matchedPath) {
            if(!(pathObj.__lp.wildcard || pathObj.__lp.dkey)) {
            var prevObj;
            if(prevObj = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(matchedPath,config.routeHash).__lp) {
                if(prevObj.wildcard) {
                var pathArr = arr2.slice(l);
                if(!(l += pathArr.indexOf(arr1[0]))) {
                    return false;
                }  
                }
            }
            }
            for(var i = 0,a1;a1 = arr1[i]; i++,l++) {
            if(a1 != arr2[l] && !(0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(a1)) {
                if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._wildcardRouteCheck)(a1)) {
                if(pathObj.__lp.sufix.length) {
                    l = arr2.indexOf(pathObj.__lp.sufix[0])-1; 
                }
                } else if(arr1[l] == '/') {
                l--;
                } else {
                return false;  
                }
            }
            }
            return l;
        }

        function findPossibleMatch(mapObj) {
            for(var mapPath in mapObj) {
                if(!exactMatch) {
                    var pathObj = mapObj[mapPath],
                    innerLevel;
                    if(mapPath != "__lp") {
                        var mapPathSplit = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(mapPath);
                        if(mapPathSplit) {
                            if((innerLevel = checkArrayMatch(mapPathSplit,pathSplitArr,pathLevel,pathObj,matchedPath)) !== false) {
                            pathArrLevel.push(innerLevel);
                            pathLevel = pathArrLevel[pathArrLevel.length-1];
                                if(pathSplitArr.length == pathLevel || pathObj.__lp.mount) {
                                    var path = Array.from(matchedPath.concat(mapPath));
                                    if(pathObj["/"]) {
                                        path = path.concat('/');
                                    }
                                    selectedPaths.push(path);
                                    if(pathObj.__lp.wildcard || pathObj.__lp.dkey || pathObj.__lp.mount) {
                                        pathArrLevel.pop();
                                        pathLevel = pathArrLevel[pathArrLevel.length-1];
                                    } else {
                                        if(!/[:*]/.test(path.join(''))) {
                                            exactMatch = path;  
                                        }
                                        return;
                                    }
                                } else {
                                    var innerRoutes = Object.keys(pathObj);
                                    matchedPath.push(mapPath);
                                    if(pathSplitArr[pathLevel]) {
                                    if(pathObj.__lp.wildcard && !pathObj.__lp.sufix.length && innerRoutes.length == 1) {
                                        var wildcard= Array.from(matchedPath);
                                        if(pathObj["/"]) {
                                        wildcard = wildcard.concat('/');
                                        }
                                        selectedPaths.push(wildcard);
                                    } else if(innerRoutes.length > 1) {
                                        findPossibleMatch(pathObj);    
                                    }
                                    } 
                                    matchedPath.pop();
                                    pathArrLevel.pop();
                                    pathLevel = pathArrLevel[pathArrLevel.length-1];
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if(exactMatch) {
        return [exactMatch,path,params,fragment];
    } else if(selectedPaths.length == 1) {
        return [selectedPaths[0],path,params,fragment];
    } else if(selectedPaths.length) {
        return [getBestMatch(getStaticMatches(selectedPaths),selectedPaths),path,params,fragment];

        function getBestMatch(staticMatches, selectedPaths, position) {
            position = position || 0;
            var traversedStaticMatch = traversedStaticMatch || traverseArray(staticMatches),
            maxStaticSeg = Math.max(...traversedStaticMatch[position]),
            duplicatePos;
            while(duplicatePos = checkForArrayDuplicates(traversedStaticMatch[position], maxStaticSeg, selectedPaths, staticMatches)) {
                position = position+1;
                var newSelectedPaths = [],
                newStaticMatches = [];
                for(var i = 0,l = duplicatePos.length; i < l; i++) {
                    newSelectedPaths.push(selectedPaths[i]);
                    newStaticMatches.push(staticMatches[i]);
                }
                var newSelectedPathsFiltered = [],
                newStaticMatchesFiltered = [];
                for(var i = 0,l = newStaticMatches.length; i < l; i++) {
                    if(newStaticMatches[i][position] != undefined) {
                        newSelectedPathsFiltered.push(newSelectedPaths[i]);
                        newStaticMatchesFiltered.push(newStaticMatches[i]);
                    }
                }
                if(!newSelectedPathsFiltered.length) {
                    return newSelectedPaths[0];
                } else if(newSelectedPathsFiltered.length == 1) {
                    return newSelectedPathsFiltered[0];
                }
                return getBestMatch(newStaticMatchesFiltered, newSelectedPathsFiltered, position);
            }
            return selectedPaths[traversedStaticMatch[position].indexOf(maxStaticSeg)];
        }
        

        function getStaticMatches(selectedPaths) {
            var staticSegmentsInMatch = [];
            for(var i = 0,l = selectedPaths.length; i < l; i++) {
                var arr = Array.from(selectedPaths[i]),
                staticPath = 0,
                result = [];
                if(arr[0] == "/") {
                    arr.shift();
                }
                if(arr[arr.length-1] == "/") {
                    arr.pop();
                }
                var counter = -1;
                arr.every(function(seg,i) {
                    var noWildcard = true;
                    (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(seg).every(function(innerSeg,j) {
                    counter++;
                    if(innerSeg == pathSplitArr[counter]) {
                        staticPath++;
                        if(arr.length == i+1){
                        result.push(staticPath);
                        }
                        return true;
                    } else if(innerSeg.indexOf(':') != -1) {
                        result.push(staticPath);
                        staticPath = 0;
                        return true;
                    } else {
                        if(innerSeg.indexOf('*') != -1) {
                        noWildcard = false;
                        }
                        result.push(staticPath);
                        return false;
                    }
                    });  
                    return noWildcard;
                });
                staticSegmentsInMatch.push(result);
            }
            return staticSegmentsInMatch;
        }
    } else {
        return false;
    }
}

function checkForArrayDuplicates(arr, value) {
    var pos = [];
    for(var i = 0,l = arr.length;i < l; i++) {
        if(arr[i] == value) {
            pos.push(i);
        }
    }
    return pos.length == 1 ? false : pos;
}

function traverseArray(arr) {
    var res = [],
    maxArrLen = 0;
    for(var i = 0,l = arr.length; i < l; i++) {
        var a = arr[i];
        maxArrLen = a.length > maxArrLen ? a.length : maxArrLen;
    }
    for(var i=0,a ;a = arr[i]; i++) {
        for(var j=0; j<maxArrLen; j++) {
            res[j] = res[j] || [];    
            res[j][i] = a[j];
        } 
    }
    return res;
}



/***/ }),

/***/ 34225158:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/router/src/route.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Route": () => (/* binding */ Route)
/* harmony export */ });
/* harmony import */ var _slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/router/src/router-utils */ 35263095);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/service */ 10723535);



/*convert to custom class*/
class Route extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__.Service {
    constructor({ i, routeName, options, init})  {
		super();
		const { lyte, LR } = options;
		this.routeName = routeName;
		this.$router = LR;
		Object.defineProperties(this,{
			"navigation" : {
				get : function() {
					return LR.__lp.nav.get(this)._trans;
				}
			}, 
			"__lp" : {
				get : function() {
					return LR.__lp.nav.get(this).rOpts[i];
				},
				set : function(key, value) {
					if(key == "toBeUsed") {
						if(this.__lp.toBeUsed.length){
							var self = this;
							lyte.extendService({services : this.__lp.toBeUsed || [], type:"route", ins: this, callback : function(serv, key, aName, serName){
								var obj = {};
								obj.key = key;
								obj.service = serName;
								lyte.extendService({services : [obj], type:"route", ins: self});
							}});
						}
					}
					LR.__lp.nav.get(this).rOpts[i][key] = value;
				}
			},
			"$" : {
				get : function() {
					return LR.__lp.nav.get(this).rOpts[i].$;
				},
				set : function(key, value) {
					LR.__lp.nav.get(this).rOpts[i].$[key] = value;
				}
			},
			"currentData" : {
				get : function() {
					return LR.__lp.nav.get(this).rOpts[i].currentData;
				},
				set : function(value) {
					LR.__lp.nav.get(this).rOpts[i].currentData = value;
				}
			}
		});
		// this.parent = routes[i-1] instanceof Promise ? routes[i-1].then(function() {this.parent = routes[i-1]}.bind(this)) : routes[i-1];
		this.removeFromCache = function(arr) {
			lyte.removeFromCache.assign.call(lyte,arr);
		};
		this.replaceWith = LR.replaceWith;
		this.navigateTo = LR.navigateTo;
		this.navigateForward = LR.navigateForward;
		this.navigateBack = LR.navigateBack;
		this.refresh = function(obj) {
			var refreshFrom = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dotSerperator)(this.__lp.objPath).length-1,
			trans = options.trans,
			route = Array.from(trans.matched.route),
			processed = {
				matched : trans.matched,
				R : trans.R,
				rOpts : trans.rOpts,
				transComp : {
					unRendered : route.splice(refreshFrom),
					rendered : route
				}
			};
			trans.abort({state : 308, iAbort : true});
			options.newTransInfo = {replace : true, data : trans.data, fromHistory : false, url : trans.url};
			if(obj && obj.refreshTemplate) {
				processed.refreshFrom = refreshFrom;
			}
			return options.dispatch(trans.url, processed)._trans;
		};
		this.setTitle = function(title) {
			d.title = this.title = title;
		};
		this.getQueryParams = function() {
			return this.__lp.param.queryParams;
		};
		this.getDynamicParam = function() {
			return this.__lp.param.dynamicParam;
		};
		Object.defineProperty(this,'$lg', {
			value : lyte.__gl
		});
		this.getRouteInstance = function(routeName) {
			return LR.getRouteInstance(routeName);
		};
		this.setDynamicParam = function(value) {
			if(value && this.__lp.param.dynamicParam && this.__lp.param.dynamicParam != value) {
				var dynamicParams = Array.from(options.trans.matched.dynamicParams);
				options.trans.matched.dpObj
				dynamicParams.splice(this.__lp.objPath.split(".").length-1, 1, value);
				return paramChangeTrans(options, cloneMatchedObj(options.trans.matched,{dynamicParams : dynamicParams}));
			}
			return options.trans._trans;
		};

		this.setQueryParams = function(key,value,opts)  {
			var obj = {},
			refresh;
			if(typeof key == "object") {
				obj = key;
				opts = value;
			} else {
				obj[key] = value;
			}
			if(typeof opts == "object") {
				refresh = opts.refresh;
			}
			refresh = opts;
			var matched = cloneMatchedObj(options.trans.matched,{queryParams : Object.assign({},options.trans.matched.queryParams,obj)});
			if(!(0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._compareObj)(options.trans.matched.queryParams,matched.queryParams)) {
				matched.refreshData = matched.refreshData == undefined ? refresh : matched.refreshData;
				return paramChangeTrans(options, matched);
			}
			return options.trans._trans;
		};
		//give support for remove query params
		this.throwEvent = typeof lyte.$.component !== "undefined" && lyte.$.component.throwEvent;
		init(this)
		if(this.init) {this.init();}
	}
}

Route.__lMod = "Route";

function paramChangeTrans(options, matched) {
	var url = options.constructURLFromRoute(matched),
	processed = {
		matched : matched,
		R : options.trans.R,
		rOpts : options.trans.rOpts
	};
	options.newTransInfo = {
		data: options.trans.data,
		url: url,
		fromHistory: false
	};
	options.dispatch(url, options.decideTransition(processed));
	return options.newTrans._trans;
}

function cloneMatchedObj(matched, data) {
	var obj = Object.assign({}, matched);
	obj.route = data.route || Array.from(matched.route)
	obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams)
	obj.queryParams = data.queryParams || Object.assign({}, matched.queryParams)
	delete obj.refreshRoute;
	delete obj.refreshData;
	return obj;
	// var obj = Object.assign({},matched);
	// obj.route = data.route || Array.from(matched.route);
	// obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams);
	// obj.queryParams = data.queryParams || Object.assign({},matched.queryParams);
	// return obj;
}



// src = prevInstance || this.constructor,
// routePredefined = options.routePredefined;
// for(var key in src) {
// 	if(_strPresence(routePredefined,key)) {
// 		this.#__lp__.fns[key] = src[key];
// 	} else if(key == "actions") {
// 		if(typeof ins.constructor.actions == "function") {
// 			ins.actions = ins.constructor.actions();
// 		}
// 		options.fns.actions = RouteClass.actions && RouteClass.actions() || {};
// 	} 
// else if(prevInstance) {
// 	if(key != "__lp") {
// 		this[key] = src[key]; // need to remove this;
// 	}
// } 
// }
// routePredefined.forEach(function(key) {
// 	if(key == "actions") {
// 		if(typeof ins.constructor.actions == "function") {
// 			ins.actions = ins.constructor.actions();
// 		}

// 		options.fns.actions = RouteClass.actions && RouteClass.actions() || {};
// 	} else {
// 		options.fns[key] = RouteClass.prototype[key]
// 	}
// 	delete RouteClass.prototype[key];
// });

// for(var key in src) {
// 	if(prevInstance || !_strPresence(routePredefined,key)) {
// 		if(key != "__lp") {
// 			this[key] = src[key];
// 		}
// 	} 
// }

// [beforeFetch,fetch,afterFetch].forEach(function(key) {
// 	Object.defineProperties(this.$, {
// 		[key] : {
// 			get : function() {
// 				return this.__lt.rOpts[i].$[key];
// 			},
// 			set : function() {
// 				this.__lt.rOpts[i].$[key] = value;
// 			}
// 		}
// 	})
// })
// this.__lp = deepCopyObject(prevInstance && prevInstance.__lp || routeOptions);
// this.__lp = deepCopyObject((prevInstance && prevInstance.__lp) || RouteClass.__lp); make only one instance
// delete this.__lt.rendered;
// this.transition = this.navigation = options.newTrans._trans;
// if(processed.transComp && !processed.transComp.rendered[i] && processed.transComp.redirected) {
// 	if(processed.transComp.redirected.i < i) {
// 		delete this.__lp.loadDependencies;
// 		delete this.__lp.loadResources;
// 		this.$ = {};
// 		delete this.currentModel;
// 	} else if(processed.transComp.redirected.i != i) {
// 		delete this.__lp.stencils;
// 	}
// } else {
// 	delete this.__lp.stencils;
// }
// this.__lp.param = {
// 	queryParams :{},
// 	dynamicParam : undefined
// }
// this.__lp.queryParams = {};

/***/ }),

/***/ 11841938:
/*!*********************************************************!*\
  !*** ./node_modules/@slyte/router/src/router-errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterError": () => (/* binding */ RouterError)
/* harmony export */ });
/* harmony import */ var _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../node_modules/@slyte/core/index.js */ 2800903);


class RouterError extends _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_0__.Logger {
    static getErrorMessage(code) {
        arguments[0] = `LR${code}`
        var msg = super.getErrorMessage.apply(this,arguments);
        return msg;
    }
}

RouterError.errorCodes = {
    LR400 : `url "{0}" is not defined in router.`,
    LR400A : `Base path of url is not specified.`,
    LR422 : `There is no route definition for the route {args[1].splice(0,args[2]+1).join('.')}.`,
    LR498 : `Invalid argument {0}`,
    LR498A : `Invalid argument {0} provided in {1}.`,
    LR499 : `Dynamic params for the route {0} is not provided.`,
    LR499A : `Dynamic params for the route {0} is not provided {args[2].outerHTML}.`,
    LR499B: `Transition tried without arguments.`,
    LR405 : `Method invocation before Router initialized.`,
     // LR203 : `Data provided for component is not valid.`,
     LR428 : `There is no outlet named {0}.`,
     LR420A : `Error in {0} of route {1}.`,
     LR420 : `Promise rejected`
    //  LR424 : `File not loaded in {0} of route {1}.\n {args[3][0].target.outerHTML}`,
};




// var lyte;

// function _getError() {
//     var args = arguments,
//     error;
//     switch(args[0]) {
//         case 400 :
//             error = args[1] ? "url '"+args[1]+"' is not defined in router." : "Base path of url is not specified.";
//             break;
//         case 422 :
//             error = "There is no route definition for the route "+(args[1].splice(0,args[2]+1).join('.'))+".";
//             break;
//         case 424 : 
//             error = "File not loaded in "+args[1]+ " of route "+args[2]+".\n"+args[3][0].target.outerHTML;
//             break;
//         case 498: 
//             error = "Invalid argument " + args[1] + (args[2] ? " provided in "+args[2] : ".");
//             break;
//         case 499 : 
//             error = args[1] ? ("Dynamic params for the route "+args[1]+" is not provided" + (args[2] && args[2].outerHTML  ? " in "+args[2].outerHTML : ".")) : "Transition tried without arguments.";
//             break;
//         case 420 : 
//             error = (args[3]? "Promise rejected" : "Error")+" in "+args[1]+" of route "+args[2]+".";
//             break;
//         case 428 : 
//             error = "There is no outlet named "+args[1]+".";
//             break;
//         case 203 :
//             error =  "Data provided for component is not valid.";
//             break;
//         case 405 :
//             error =  "Method invocation before Router initialized.";
//             break;
//     }
//     return 'LR '+args[0]+': '+error;
// }

// function _bindLyteInstanceToError(ins) {
//     lyte = ins;
// }

// function _consoleError() {
//     return lyte.error(arguments[0].stack ? arguments[0] : _getError.apply(this,arguments),arguments[3]);
// }

// export {
//     _bindLyteInstanceToError,
//     _getError,
//     _consoleError
// }



// class ValidationError extends Dberror{
//     static errorCodes = {
//         ERR01 : "Primary key cannot be modified", 
//         ERR02 : "Mandatory prop cannot be empty", 
//         ERR03 : "Type of value does not match the specified data type",
//         ERR04 : "Value is greater than the maximum value allowed",
//         ERR05 : "Value is less than the minimum value allowed", 
//         ERR06 : "Length of string/array is greater than the maximum limit allowed", 
//         ERR07 : "Length of string/array is less than the minimum limit allowed",
//         ERR08 : "String does not match the specified pattern", 
//         ERR09 : "Values in array are not unique", 
//         ERR10 : "Value is not equal to the specified constant", 
//         ERR11 : "Schema of related field is not defined",
//         ERR12 : "Schema of backward relation is not defined", 
//         ERR13 : "Entity not found", 
//         ERR14 : "Schema does not match the schema defined in the related field", 
//         ERR15 : "Error in creating a entity as a relation",
//         ERR16 : "Entity with primary key already exists", 
//         ERR17 : "Value cannot be changed because entity has been deleted", 
//         ERR18 : "Action not defined", 
//         ERR19 : "Schema not defined",
//         ERR20 : "Key not specified", 
//         ERR21 : "'one' relationship expects a single object/id", 
//         ERR22 : "Type not specified for polymorphic relation", 
//         ERR23: "Primary Key value not present", 
//         ERR24: "Error while relating entities", 
//         ERR25: "Backward relation not present",
//         ERR26: "Primary key value cannot be undefined or null",
//         ERR27: `Observer can observe only string data type value, {0} value cannot be observed in the function named '{0}' in the component '{1}'`,
//         ERR29: "Property not defined in the object",
//         ERR30: "Property's value is not an instanceof the mentioned class"      
//     }
//     constructor(lyte, attr, obj, message){
//         super();
//         Object.defineProperties(this, {
//              : {
//                 value : {isError : true , error:message?message:{}}
//             }
//         });
//         if(attr){
//             ValidationError.setError(lyte,this,attr,obj);
//         }    
//     }

//     static setError(lyte,err,attr,codeObj){
//         if(err..hasOwnProperty("error")){
//             if(Array.isArray(attr)){
//                 attr.forEach(function(itm){
//                     cmpSet(lyte, err..error, itm, codeObj);
//                 });
//             }
//             else{
//                 cmpSet(lyte, err..error,attr,codeObj);
//             }
//         }
//         else{
//             ValidationError.error("LD03",err,attr);
//         }
//     }

//     static setRecErr(ent, field, code, value){
//         var lyte = ent.schema.Lyte;
//         cmpSet(lyte, ent, "isError", true);
//         var errObj = code;
//         if(typeof errObj == "object"){
//             cmpSet(lyte, ent.error,field,errObj);
//         }
//         else{
//             if(typeof code == "string"){
//                 var errMes = ValidationError.errorCodes[code];
//                 if(errMes){
//                     errObj = {code : code, message : ValidationError.errorCodes[code]};
//                 }
//                 else{
//                     errObj = code;
//                 }
//             }
//             cmpSet(lyte, ent.error, field, errObj);
//             if(value){
//                 cmpSet(lyte, ent.error[field],"value",value);
//             }				
//         }
// 		var db = ent.schema.db;
//         emit(db,"error",ent.entity,field,errObj);
//     }

//     static clrRecErr(ent, field, code){
//         var lyte = ent.schema.Lyte;
//         var objUtl = lyte.objectUtils;
//         var err = ent.error;
//         if(code){
//             if(ent.error.code == code){
//                 if(typeof objUtl != "undefined"){
//                     objUtl(err,"delete",field);
//                 }
//                 else{
//                     delete err[field];                        
//                 }
//             }
//         }
//         else if(field){
//             if(typeof objUtl != "undefined"){
//                 objUtl(err,"delete",field);
//             }
//             else{
//                 delete err[field];                       
//             }
//         }
//         else{
//             if(typeof objUtl != "undefined"){
//                 for(var err in err){
//                     objUtl(err,"delete",err);
//                 }
//             }	
//             else{
//                 ent.error = {};
//             }   
//         }
//         if(Object.keys(ent.error).length == 0){
//             cmpSet(lyte, ent, "isError", false);
//         }
//     }
// }

// class ConnectorError extends Dberror {
//     constructor(msg, xhr){
//         super();
//         this.message = msg;
//         this.xhr = xhr;
//     }
// }

// class SerializerError extends Dberror{
//     constructor(msg, xhr){
//         super();
//         this.message = msg;
//         this.xhr = xhr;
//     }
// }

// export { ValidationError, Dberror, ConnectorError, SerializerError };

/***/ }),

/***/ 35263095:
/*!********************************************************!*\
  !*** ./node_modules/@slyte/router/src/router-utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_checkIfSameRoute": () => (/* binding */ _checkIfSameRoute),
/* harmony export */   "_compareObj": () => (/* binding */ _compareObj),
/* harmony export */   "_delimit": () => (/* binding */ _delimit),
/* harmony export */   "_dotSerperator": () => (/* binding */ _dotSerperator),
/* harmony export */   "_dynamicRouteCheck": () => (/* binding */ _dynamicRouteCheck),
/* harmony export */   "_frameDynamicParams": () => (/* binding */ _frameDynamicParams),
/* harmony export */   "_frameQueryParams": () => (/* binding */ _frameQueryParams),
/* harmony export */   "_getObj": () => (/* binding */ _getObj),
/* harmony export */   "_getRouteFromAlias": () => (/* binding */ _getRouteFromAlias),
/* harmony export */   "_normalizeTransitionParams": () => (/* binding */ _normalizeTransitionParams),
/* harmony export */   "_splitPath": () => (/* binding */ _splitPath),
/* harmony export */   "_strPresence": () => (/* binding */ _strPresence),
/* harmony export */   "_validateURL": () => (/* binding */ _validateURL),
/* harmony export */   "_wildcardRouteCheck": () => (/* binding */ _wildcardRouteCheck),
/* harmony export */   "scriptExecution": () => (/* binding */ scriptExecution)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);
/* harmony import */ var _router_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router-errors */ 11841938);



const _strPresence = (str, char) => str.includes(char),

_dotSerperator = (str) => str.split('.').filter(Boolean),

_dynamicRouteCheck = (route) => _strPresence(route,":"),

_wildcardRouteCheck = (route) => _strPresence(route,"*"),

_delimit = (seg) => seg[0] == "/" ? seg : "/"+seg,

_splitPath = (path) => path.match(/[^/?]+/g) || [];

function scriptExecution(scriptNode) {
    for(var i=0,currentScript;currentScript = scriptNode[i];i++) {
        var parent = currentScript.parentNode,
        s = d.createElement("script");
        for(var j = 0,attributes;attributes = currentScript.attributes[j]; j++) {
        s.setAttribute(attributes.name, attributes.value);
        }
        s.innerHTML = currentScript.innerHTML;
        parent.appendChild(s);
        parent.removeChild(currentScript);
    }
}

function _compareObj(obj1,obj2) {
    var obj1keys = Object.keys(obj1),
    obj2keys = Object.keys(obj2);
    if(obj1keys.length != obj2keys.length) {
    return false;
    } else {
    for(var key in obj1) {
        if(obj1[key] != obj2[key]) {
        return false;
        }
    }
    return true;
    }
}

function _getObj(arr,obj) {
    /**
     *  get nested property from an object
     * @params {array} array
     * @params {object} object
     * @returns
     */
    if(!obj) {
        return;
    } else if(!arr) {
        return obj;
    } else if(!Array.isArray(arr) && typeof arr == 'string') {
        arr = _dotSerperator(arr);
    }
    arr.every(function(key)  {
        if(obj && obj[key]) {
            obj = obj[key];
            return true;
        }
        return obj = false;
    });
    return obj;
}

function _frameQueryParams(url) {
    if(url) {
        var qp = {},
        split,
        params = _strPresence(url,"?") ? url.split("?")[1] : url;
        params = _strPresence(params,"&") ? params.split(/&/g) : [params];
        for(var i = 0,l = params.length; i < l; i++) {
            qp[(split = params[i].split('='))[0]] = split[1] ? decodeURIComponent(split[1]) : split[1];
        }
        return qp;
    } 
}

function _frameDynamicParams(url,matched, routesObj) {
    var dynamicParam,
    fdp,
    framedDP = [],
    urlSplit = _splitPath(url.split('?')[0]);
    for(var i = 0,l = matched.route.length,r; i < l; i++) {
        r = matched.route[i];
        routesObj = _getObj([r],routesObj);
        var routeObj =  routesObj.__lp;
        if(routeObj.wildcard) {
            if(routeObj.sufix.length) {
            var dp = urlSplit.slice(0,urlSplit.indexOf(routeObj.sufix[0]));
            fdp = decodeURI(dp.join('/'));
            pop(dp.concat(routeObj.sufix),urlSplit);
            } else {
            fdp = decodeURI(urlSplit.join('/'));
            }
        } else if(routeObj.dkey) {
            dynamicParam = urlSplit[routeObj.dIndex];
            pop(_splitPath(routeObj.path),urlSplit);
            fdp = decodeURI(dynamicParam);
        } else {
            pop(_splitPath(routeObj.path),urlSplit);
            fdp = undefined;
        }
        framedDP.push(fdp);
    };
    return framedDP;
}

function _validateURL(url) {
    url = url.replace(/\/\//g,'/');
    url = url.replace(/\/\?/g,'?');
    return url;
}

function _normalizeTransitionParams(obj) {
    // To normalize argument for transition, returns matched obj from obj or native tranisitionTo argument.
    var params;
    if(typeof obj == "object") {
        params = obj;
    } else {
        params = {
            queryParams : {},
            dynamicParams : []
        };
        Array.from(arguments).forEach(function(arg,index) {
            if(Array.isArray(arg)) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__._consoleError.call(lyte,498,JSON.stringify(arg));
                return;
        } else {
            if(index == 0) {
                params.route = arg;
        } else if(arg && typeof arg == "object") {
            params.queryParams = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(arg);
            } else {
                params.dynamicParams.push(arg);
            }  
        }
        });
    }
    return params;
}

function _getRouteFromAlias(obj) {
	var route = obj.route,
    alias;
	if(typeof route == "string") {
        if(route.indexOf('$') == 0) {
            alias = route.split('$')[1],
            map = obj.map;
            // if(map || (map = config.engineConf[config.mountedEngines[obj.parent]].aliasRouteMap)) {
            // }
                if(map[alias]) {
                    route = map[alias]
                } else {
                    _router_errors__WEBPACK_IMPORTED_MODULE_0__._consoleError.call(this,obj.route+' is not a valid route alias')
                    return;
                }
        }
        route = route.split('.');
	}
    return { route, alias};
}

function _checkIfSameRoute(transInfo1, transInfo2) {
    if(transInfo1 && transInfo2 && transInfo1.route == transInfo2.route && transInfo1.fragment == transInfo2.fragment && transInfo1.dynamicParams.length === transInfo2.dynamicParams.length && _compareObj(transInfo1.queryParams,transInfo2.queryParams)) {
        if(transInfo1.dynamicParams.length) {
            for(let i = 0,dynamicParam; dynamicParam = transInfo1.dynamicParams[i]; i++) {
                if(dynamicParam != transInfo2.dynamicParams[i]){
                    return false;
                }
            }
        }
        return true;
    }
    return false;
};

function pop(path,urlSplit) {
    for(var i = 0,l = path.length; i < l; i++) {
        urlSplit.shift();
    };
}



/***/ }),

/***/ 19412727:
/*!**************************************************!*\
  !*** ./node_modules/@slyte/router/src/router.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Router": () => (/* binding */ Router)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @slyte/core */ 53501236);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 33115194);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @slyte/core/src/service */ 10723535);
/* harmony import */ var _go_to__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./go-to */ 46565158);
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./history */ 58399038);
/* harmony import */ var _map_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-parser */ 88013180);
/* harmony import */ var _router_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./router-errors */ 11841938);
/* harmony import */ var _router_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./router-utils */ 35263095);









/*-----------string declaration starts------------*/
const routeStr = "route",
RouteStr = "Route",
fetchStr = "fetch",
FetchStr = "Fetch",
forceFetchStr = "force" + FetchStr,
NavigationStr = "Navigation",
NavigateStr = "Navigate",
pendingStr = "pending",
completedStr = "completed",
abortedStr = "aborted",
beforeStr = "before",
afterStr = "after",
didStr = "did",
willStr = "will",
nestedForcedPromisesStr = "nestedForcedPromises",
constructRunLoopStr = "constructRunLoop",
getRequirementsStr = "getRequirements",
divertStr = "divert",
renderStr = "render",
onErrorStr = "onError",
beforeLoadStr = "beforeLoad",
onBeforeLoadStr = "onBeforeLoad",
LINKTOStr = "LINK-TO",
stateChangeStr = "stateChange",
DestroyStr = "Destroy",
RouteNavigationStr = "Route" + NavigateStr,
afterRenderStr = afterStr + "Render",
beforeExitStr = beforeStr + "Exit",
didDestroyStr = didStr + DestroyStr,
pRoute = "lt-prop-" + routeStr,
NavigationAbortedStr = NavigationStr+" "+abortedStr + ".",
NavigationResumedStr = NavigationStr + " resumed.",
NavigationPausedStr = NavigationStr + " paused.",
NavigationComletedStr = NavigationStr+" "+completedStr + ".",
beforeFetchStr = beforeStr + FetchStr,
afterFetchStr = afterStr + FetchStr,
willNavigateStr = willStr + NavigateStr,
didNavigateStr = didStr + NavigateStr,
beforeRouteNavigationStr = beforeStr+RouteStr + NavigationStr,
afterRouteNavigationStr = afterStr+RouteStr + NavigationStr,
beforeTemplateDestroyStr = beforeStr+"Template" + DestroyStr,
renderLoadingTemplateStr = "renderLoadingTemplate",
renderTemplateWarning = renderStr+" hook should return either component or HTML. Rendering of HTML directly into the DOM within the "+renderStr + " hook is deprecated.",
__routeProm__Str = "__routeProm__",
/*-----------string declaration ends------------*/
fontColor = "MediumOrchid",
dloc = document.location,
resolvedPromise = Promise.resolve(),
emptyFn = function() {};

function getHook(routeInstance, hook) {
	return routeInstance.__lp.fns[hook]
}

function getAction(routeInstance, action) {
	return routeInstance.__lp.fns.actions && routeInstance.__lp.fns.actions[action]
}

/*convert to custom class*/
class Router extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_5__.Service {
    constructor(a) {
        super(a)
        this.__lp = {
            version : "1.0.0-beta.4",
            pendingReg : [],
            mountedApps : {},
            config : {},
            nav : new WeakMap()
        };

        this.checkIfSameRoute = _router_utils__WEBPACK_IMPORTED_MODULE_4__._checkIfSameRoute;
        var newTransInfo,
		newTransInfoClone,
		newTransInfoTimer,
		lHistory,
		config = {
			historyType : false,
			baseURL : "",
			deferInit : false,
			preserveUrlOnBrowserNavigation : false,
			queryParamOptions : { cache : true},
			routeHash : {},
			urlCache : {},
			aliasRouteMap : {},
			routeAliasMap : {},
			cacheRoutes : {},
			allLinks : {},
			activeLinkTags : []
		},
		trans,
		prevTrans,
		newTrans,
		visibleTrans,
		historyObj,
		initialLoad = true,
		fromHistoryGo = false,
		processedDispatch;

        const run = {},
		lyte = this.$app,
		LR = this;

        lyte.extendEventListeners(this);

        run[getRequirementsStr] = function(hook,index) {
			const r = this.routes[index],
			res = r.__lp.loadResources =  [],
			dep = r.__lp.loadDependencies = [],
			callback = r.__lp.fns[hook];
			if(callback) {
				callHookWithoutPromise.call(this,callback,hook,index,[r.__lp.param, res, dep]);
			} 
			r.__lp.req = {
				resources : r.__lp.loadResources = Promise.all(res).then(function() {
					r.__lp.resourcesLoaded = true
				}),
				dependencies : r.__lp.loadDependencies = Promise.all(dep).then(function() {
					r.__lp.dependenciesLoaded = true	
				})
			}
			return resolvedPromise;
		}

        run[beforeFetchStr] = 
		run[fetchStr] = 
		run[afterFetchStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			args = [getHook(routeInstance, hook),routeInstance];
			args.push(hook == afterFetchStr ? [routeInstance.currentData, routeInstance.__lp.param] : [routeInstance.__lp.param]);
			return callHookWithPromise.apply(this,args).then(setDataIn$,setDataIn$);
			function setDataIn$(data) {
				routeInstance.$[hook] = data;
				if(hook == fetchStr) {
					routeInstance.currentData = data;
				}
			}
		};

        run[divertStr] = function(hook,index) {
			var routeInstance = this.routes[index];
			return callHookWithPromise.apply(this,[getHook(routeInstance,hook),routeInstance,[routeInstance.currentData, routeInstance.__lp.param]]);
		};

        run[onErrorStr] = function(hook,index,err,state,options) {
			setPendingResume.call(trans,trans.prom);
			trans._trans.triggerEvent(onErrorStr,{error : err,hook : hook});
			var errIns = this.routes[index];
			for(; index >= 0 && !this.aborted && this.paused; index--) {
				var instance = this.routes[index];
				lyte.log(onErrorStr+" of "+ instance.routeName,routeStr,fontColor);
				if(callAction.call(this,onErrorStr,index,[err,this._trans, instance.__lp.param, hook]) == false) {
					break;
				}  
			}
			if(!options || !options.consoled) {
				_consoleErrorFromCallback(err,hook,errIns.routeName,state,options);
			}
		};

        run[willNavigateStr] = function(hook,index) {
			if(callAction.call(prevTrans,hook,index,[trans._trans]) == false) {
				removeHook(trans.runLoop.previous,hook);
			}
			return resolvedPromise;
		};

        run[beforeRouteNavigationStr] = function() {
			if(validateTransition(this)) {
				var pt;
				if(pt = prevTrans && prevTrans._trans) {
					delete pt.abort;
					delete pt.pause;
				}
				var obj = {
					prevNav : pt,
					nav : trans._trans,
					location : {fromHistory : (initialLoad ? "reload" : (newTrans && newTrans.navigationType ? false : true)), initial : initialLoad}
				}
				var callback = LR[beforeRouteNavigationStr]
				callback && callback.call(LR, obj.prevNav, obj.nav , obj.location);
				triggerEventOnInsAndClass(beforeRouteNavigationStr, obj)
			}
			return resolvedPromise;	
		};

        function triggerEventOnInsAndClass(ev,args) {
			trans._trans.triggerEvent(ev,args);
			LR.triggerEvent(ev, args);
			lyte.triggerEvent(ev, args);
		}

        run[afterRouteNavigationStr] = function(_trans) {
			var callback = LR[afterRouteNavigationStr];
			callback && callback.call(LR, _trans);
			triggerEventOnInsAndClass(afterRouteNavigationStr, {nav : _trans})
		};

        run[beforeLoadStr] = function(hook,index) {
			var routeProp = this.routes[index].__lp;
			if(routeProp.fns[hook]) {
				lyte.log(beforeLoadStr +' callback is depricated. Use renderLoadingTemplate callback');
			}
			callHookWithoutPromise.call(this,routeProp.fns[hook],hook,index,[routeProp.param]);
			return resolvedPromise;
		};

        run[onBeforeLoadStr] = function() {
			return new Promise(function(resolve,reject) {
				for(var len = trans.matched.route.length, i=1; i <= len && validateTransition(trans); i++) {
					var l = len-i,
					// actions,
					routeInstance = trans.routes[l];
					// if((actions = routeInstance.__lp.fns.actions) && actions.onBeforeLoad) {
					// 	// lyte.log(onBeforeLoadStr +' action is depricated. Use beforeLoad callback');
					// }
					if(!(routeInstance instanceof Promise) && trans.onLoadCalled.indexOf(l) == -1) {
						trans.onLoadCalled.push(l)
						if((callAction.call(trans,onBeforeLoadStr,l,[routeInstance.__lp.param]) == false) || (trans.onLoadCalled.length == len) || (i == len)) {
							resolve();
							break;
						}
					} else if(i == len){resolve();}
				}
			});
		};

        run[afterRenderStr] =
		run[didNavigateStr] = function(hook,index) {
			return new Promise(function(resolve, reject) {
				var routeInstance = this.routes[index],
				st = setTimeout(function() {
					if(hook == afterRenderStr) {
						this.rOpts[index].rendered = true;
						callHookWithPromise.call(this,getHook(routeInstance, hook),routeInstance,[routeInstance.currentData,routeInstance.__lp.param,routeInstance.component]).then(function(data) {
							if(!trans.routes[index+1]) {
								trans._trans.triggerEvent(afterRenderStr);
							}
							resolve(data);
						}, function(data) {
							reject(data);
						});
					} else {
						run.removeTemplate.call(this);
						if(callAction.call(this,hook,index,[routeInstance.__lp.param, trans._trans]) == false) {
							removeHook(trans.runLoop.current,hook);
							index = 0;
						}
						setVisibleTrans.call(this)
						resolve();
						lyte.time(this.prom.hook + this.prom.index);
						if(index == 0) {
							transitionCompleted({state : 200});
						}
					}
				}.bind(this,hook,index),0);
				this.fns.push(st);          
			}.bind(this));
		};

        run[beforeExitStr] = function(hook,index) {
			var prevTransRouteInstance = prevTrans.routes[index];
			return callHookWithPromise.call(this,prevTransRouteInstance.__lp.fns[hook],prevTransRouteInstance,[prevTransRouteInstance.currentData, prevTransRouteInstance.__lp.param]);
		};

        // run.getMountApp = function(hook,index) {
        // 	var ins = trans.routes[index];
        // 	var prom = callHookWithPromise.call(this,ins.__lp.fns[hook],ins,[ins.__lp.param]).then(function(resp) {
        // 		resp.$.mountedTo = {path : LR.getURL(ins.__lp.objPath), app : lyte};
        // 		LR.__lp.mountedApps[ins.__lp.objPath] = resp;
        // 	});
        // 	return prom
        // };

        run[renderLoadingTemplateStr] = function(hook, index) {
			var route = this.routes[index],
  			loadingTemplate = callHookWithoutPromise.call(this,route.__lp.fns[hook],hook,index,[route.__lp.param]),
			outlet;
			// routeProp.stencils = loadingTemplate || {};
			if(loadingTemplate && loadingTemplate.outlet && (outlet = getOutlet(loadingTemplate.outlet,route.parent))) {
				if(outlet.childNodes[0]) {
					triggerTemplateDestroy({outlet,route},false);
				}
				route.outlet = outlet;
				if(loadingTemplate.component) {
					renderComp(outlet, loadingTemplate.component, {data : loadingTemplate.data , ins : route, hook,index , registry : loadingTemplate.registry || LR.__lp.config.registry})
				} else if(loadingTemplate.html) {
					renderHTML(outlet, loadingTemplate.html)
				}
			}
			return resolvedPromise;
		};

        run[renderStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			callback = routeInstance.__lp.fns[hook] || routeInstance.__lp.fns.renderTemplate;
			if(callback) {
				run.removeTemplate.call(this);
				setVisibleTrans.call(this)
				// if(routeInstance.outlet) {
				// 	routeInstance.outlet.innerHTML = "";
				// }
				var renderTemplate = callHookWithoutPromise.call(
                    this,
                    callback,
                    hook,
                    index,
                    [routeInstance.currentData, routeInstance.__lp.param]
                ),
				outlet;
				if(validateTransition(this)) {
					if(renderTemplate && (routeInstance.outletName = outlet = (renderTemplate.outlet || routeInstance.outlet))) {
						var data = routeInstance.currentData;
						if(routeInstance.outlet = outlet = getOutlet(renderTemplate.outlet,routeInstance.parent)) {
							var  obj = {
								outlet : renderTemplate.outlet,
								route : routeInstance
							};
							if(renderTemplate.component) {
								if(routeInstance.component && !renderTemplate.reRender && (routeInstance.component.localName == renderTemplate.component._compName) && routeInstance.outlet == outlet && outlet.contains(routeInstance.component)) {
									// componentDataCheck.call(this,data,routeInstance,hook,index);
									routeInstance.component.setData(data)
								} else {
									triggerTemplateDestroy(obj,false);
									routeInstance.component = renderComp(outlet, renderTemplate.component,{data, ins : routeInstance , hook,index , registry : renderTemplate.registry || LR.__lp.config.registry})
								}
							} else if(renderTemplate.html) {
								routeInstance.component = undefined;
								triggerTemplateDestroy(obj,false);
								renderHTML(outlet, renderTemplate.html)
							}
						} else {
							_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(428,renderTemplate.outlet);
						}
					} else {
						lyte.warn(renderTemplateWarning);
					}
				}  
			} else if(validateTransition(this) && this.runLoop.templateToRemove && this.routes.length == index+1) {
				run.removeTemplate.call(this);
			}
			return resolvedPromise;
		};

        // function componentDataCheck(data,routeInstance,hook,index) {
        // 	if(data) {
        // 		if(typeof data != "object" && Array.isArray(data)) {
        // 			processError.call(this,{stopTrans : true, err :Error(RouterError.getErrorMessage(203)).stack,instance :routeInstance,hook : hook,index : index});
        // 		}   
        // 	}
        // }

        function renderHTML(outlet, html) {
			outlet.innerHTML = html;
			var scripts = outlet.getElementsByTagName('script');
			if(scripts.length) {
				(0,_router_utils__WEBPACK_IMPORTED_MODULE_4__.scriptExecution)(Array.from(scripts),outlet);
			}
		}

        function renderComp(outlet, component, {data, ins, hook,index, registry }) {
			if(typeof component == "string") {
				console.error("Component name cannot be string");
				return;
			}
			// componentDataCheck.call(this,data,ins,hook,index);
			var compIns = component._render({
				outlet : outlet,
				data : data,
				options : {clearOutlet : true},
				registryInstance : registry,
				_route : ins.__lp.objPath
			})
			return compIns;
		}

        function getOutlet(outlet,parent) {
			var _outlet;
			if(parent) {
				_outlet =  parent.outlet ? parent.outlet.querySelector(outlet) : undefined;
				if(!_outlet) {
					return getOutlet(outlet,parent.parent);
				}
			} else if(!(_outlet = document.querySelector(outlet))) {
				return false;
			}
			return _outlet;
		}

        run.removeTemplate = function() {
			var arr = this.runLoop.templateToRemove;
			if(!this.cleared) {
				if(prevTrans && arr) {
					templateDelete.call(visibleTrans,arr);
				}
				this.cleared = true;
				delete this.runLoop.templateToRemove;
				lyte.removeFromCache();
			}
		};

        function setVisibleTrans() {
			if(visibleTrans != this) {
				visibleTrans = this;
				if(prevTrans != LR.__lp.visibleTrans) {
					removeNavWeakMap(LR.__lp.visibleTrans,this)
				}
				LR.__lp.visibleTrans = visibleTrans;
			}
		}

        function validateTransition(trans) {
			return !trans.aborted && !trans.paused;
		}

        function addToHistory(obj) {
			var type = obj.replace ? "replaceState" : "pushState";
			obj.title = obj.title || document.title;
			/* support for windows, undefined is appended to url */
			var args = [obj.data, obj.title]
			args.push(config.historyType ? (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(shiftBaseURL(obj.url, true)) : '#' + (config.slashAfterHash ? (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(obj.url) : (obj.url[0] == "/" && obj.url.length > 1 ? obj.url.substring(1,obj.url.length) : obj.url)));
			args.push(obj.meta);
			LR.location = lHistory[type].apply(lHistory,args);
			if(trans) {
				trans.location = LR.location
			}
		}

        this.getRouteDefinition = function(arr,def) {
			if(arr == "*" || !arr) {
				return config.routes;
			} else {
			def = def || config.routes;
			def = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(arr,def);
				return def && def.__lp && def.__lp.handler || undefined;  
			}
		}

        this.setConfig = function(defConfig) {
			for(var key in defConfig) {
				if(key == "queryParamOptions") {
					config.queryParamOptions.cache = defConfig.queryParamOptions.cache;
				} else if(key == "historyType"){
					config[key] = defConfig[key] == "html5";
				} else if(key == "history"){
					config.historyType = defConfig.history == "html5";
				} else {
					config[key] = defConfig[key];
				}
			}
			this.__lp.config = config;
		}
        this.setConfig(this.getConfig && this.getConfig());
        this.__lp.config.registry = this.getComponentRegistry && this.getComponentRegistry();

        configureRoutes.call(this,this.__lp.config && this.__lp.config.baseMap && this.__lp.config.baseMap);

        function configureRoutes(baseMap) {
			_map_parser__WEBPACK_IMPORTED_MODULE_2__._parseRouteMap.call(this,baseMap, {lyte, config, initialRegisterRoute });
			for(var i = 0,l = this.__lp.pendingReg.length; i < l; i++) {
				registerRoute.apply({},this.__lp.pendingReg[i]);
			}
			this.__lp.pendingReg = [];
			this.__lp.routesConfigured = true;
		}

        function init () {
			if(!config.deferInit && !LR.__lp.initCalled) {
				if(lyte.$.isApp) {
					LR.init();
				} else {
					setTimeout(function() {
						LR.init();
					},0)
				}
			} else {
				return;
			}
		}

        this.init = function(r) {
			if(!this.__lp.initCalled) {
				this.__lp.initCalled = true;
			} else {
				return;
			}
			if(this.onInit) { this.onInit();}
			lHistory = new _history__WEBPACK_IMPORTED_MODULE_1__.History({
				historyType : LR.__lp.config.historyType ? "html5" : "hash",
				popState : popState
			}) 
			this.history = lHistory.__lh.exp;
			this.pushData = function(data,title,url) {
				lHistory.pushState(data,title,url,lHistory.getMeta());
			}
			this.replaceData = function(data,title,url) {
				lHistory.replaceState(data,title,url,lHistory.getMeta());
			}
			this.navigateBack = function(value) {
				if(!value) {
					lHistory.back.call(history);
				} else {
					lHistory.go.call(history,value);
				}
			}
			this.navigateForward = function(value) {
				if(!value) {
					lHistory.forward.call(history);
				} else {
					lHistory.go.call(history,value);
				}

			}
			this.scrollRestoration = lHistory.scrollRestoration;
			function popState(onChangeEvent) {
				var goValue,
				meta,
				url = getUrlFromMeta(onChangeEvent);
				historyObj = {
					fromHistory : true,
					url : url
				};
				if(onChangeEvent && lHistory.getData()) {
					historyObj.data = lHistory.getData();
				}
				if(config.preserveUrlOnBrowserNavigation) {
					if(fromHistoryGo) {
						fromHistoryGo = false;
						return;
					}
					if(lHistory && prevTrans && (meta = lHistory.getMeta()) && (lHistory.__lh.currentMeta.__lh.index !=  meta.__lh.index)) {
						fromHistoryGo = true
						goValue = lHistory.__lh.currentMeta.__lh.index - meta.__lh.index;
						history.go(goValue);
					}
					// if(lHistory && prevTrans && (meta = lHistory.getMeta()) && (prevTrans.history.index !=  meta.__lh.index)) {
					// 	fromHistoryGo = true
					// 	// goValue = prevTrans.history._meta.__lh.index - meta.__lh.index;
					// 	goValue = trans.history.__lh.prevMeta.__lh.index - meta.__lh.index;
					// 	history.go(goValue);
					// }
				}
				historyObj.goValue = goValue;
				if(trans && !trans.aborted) {
					trans.abort({state : 308, iAbort : true});
			   	}
				dispatch(url);
			}
			if(lyte.$.isApp) {
				if(config.historyType) {
					popState();
				} else {
					historyObj = {
						fromHistory : true,
						url : getLocation()
					};
					dispatch(historyObj.url);
				}
				(0,_go_to__WEBPACK_IMPORTED_MODULE_0__.linkToRegistration)(lyte,this,config);
			}
			return this;
		};

        function getUrlFromMeta(onChangeEvent) {
			var url;
			if(!(lHistory.getMeta() && (url = lHistory.getMeta().url))) {
				if(config.historyType) {
					url = getLocation();
				} else {
					var newURL = onChangeEvent && onChangeEvent.newURL || dloc.hash;
					url = checkForEmptyPath(newURL.replace(/.*#/, ''));
				}  
			}
			return url;
		}

        function setRouteDef(dir, {RouteClass, options}) {
			var cache = config.routes,
			len = dir.length,
			dirLen = len - 1;
			for(var i = 0, key; i < len; i++) {
				key = dir[i];
				if (dirLen === i) {
					var obj = cache[key];
					if (obj && obj.__lp) {
						obj.__lp.handler = RouteClass;
						obj.__lp.options = options
					} else if (obj) {
						obj.__lp = { class : RouteClass, options };
					} else {
						cache[key] = { __lp: { class : RouteClass,  options } };
					}
				} else if (!cache[key]) {
					cache[key] = {};
				}
				cache = cache[key];
			}
		}

        function convertMatchedObjToRouteInfo(matched) {
			var info = {
				route : matched.route.join("."),
				fragment : matched.fragment,
				dynamicParams : matched.dynamicParams.filter(_arrayClean),
				queryParams : matched.queryParams

			};
			return info;
		}

        function _arrayClean(e) {
			return e != undefined;
		}

        this.replaceWith = function() {
			return routeTransition.call(this,_router_utils__WEBPACK_IMPORTED_MODULE_4__._normalizeTransitionParams.apply(this,arguments), true);   
		};

        this.navigateTo = function() {
			return routeTransition.call(this,_router_utils__WEBPACK_IMPORTED_MODULE_4__._normalizeTransitionParams.apply(this,arguments));  
		};

        /**
		 * @functionType getURL 
		 *  To get url for a route
		 * @author authorName
		 * @version 1.0.0
		 * @params {string} routeName
		 * @params {options} options
		 * @params {function} nestedRoute 
		 * @returns
		 */
        this.getURL = function(matched) {
			if(matched) {
				if(!matched.route) {
					matched = _router_utils__WEBPACK_IMPORTED_MODULE_4__._normalizeTransitionParams.apply(this,arguments)
				} else if(!matched.queryParams) {
					matched.queryParams = {}
				}
				var url,
				l,
				linkTo = this.tagName == LINKTOStr,
				cache = config.urlCache,
				matchedCache,
				sticky = config.queryParamOptions.cache;
				if(!sticky && (matchedCache = cache[Array.isArray(matched.route) ? matched.route.join('.') : matched.route])) {
					url = matchedCache.url;
					if(l = matched.dynamicParams && matched.dynamicParams.length) {
						for(var i = 0; i < l; i++) {
							url = url.replace('<<dp>>',matched.dynamicParams[i]);	
						}
					} else if(url.indexOf('<<dp>>') != -1) {
						_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(linkTo ? "499A" : 499,matched.route,linkTo ? this : undefined);
					}
					if(!matched.queryParams) {matched.queryParams = {}}
					for(var key in matchedCache.defQP) {
						if(!matched.queryParams[key] && matchedCache.defQP[key]) {
							matched.queryParams[key] = matchedCache.defQP[key];
						}
					}
					url = appendQueryParamsAndFrag(url,matched);
				} else {
					if(linkTo) {
						url = constructURLFromRoute.apply(this,arguments);
					} else {
						url = constructURLFromRoute.call(this,matched);
					}
				}
				if(url) {
					url = config.historyType ? shiftBaseURL(url, true) : '#'+url;
					return url;
				}
			}
		};

        this.getRoute = function(url) {
			var matched = traverse(shiftBaseURL(url),true);
			if(matched && !matched.error) {
				if(config.routeAliasMap[matched.route]) {
					matched.alias = config.routeAliasMap[matched.route];
				}
				matched.dynamicParams = matched.dynamicParams.filter(_arrayClean);
				matched.route = matched.route.join('.');
				return matched;  
			}
		};

        function routeTransition(args, replace ) {
			var processed = normalizeMatchedObj.call(this,args);
			if(processed.error) {
				if(trans.running) {
					trans.pause();
					run[onErrorStr].call(trans,trans.prom.hook,trans.prom.index,processed.error,"420A",{ consoled : true});
				}
				return;
			}
			if(replace) {
				processed.matched.replace = true;
			}
			if(!LR.__lp.initCalled) {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(405);
				return 
			}
			var matched = processed.matched,
			currRoute;
			processed.currRoute = currRoute = matched.route.join('.');
			matched.refreshRoute && currRoute == prevTrans.info.route;
			routeOptions.newTransInfo = newTransInfo = {
				replace : matched.replace || (matched.refreshRoute && LR.checkIfSameRoute(convertMatchedObjToRouteInfo(processed.matched),convertMatchedObjToRouteInfo(prevTrans.matched)) ? true :  matched.replace),
				title : trans ? trans.title : document.title,
				fromHistory : false
			};
			var url = dispatchTransition(processed);
			if(url && newTrans) {
				newTrans.navigationType = replace ? "replaceState" : "pushState";
				lyte.log(NavigateStr+' to '+currRoute+' '+url,routeStr);
				return newTrans._trans;  
			} else {
				lyte.log(NavigateStr+' failed')
				return {};
			}
		}

        function getLocation(obj) {
			if(config.historyType) {
				var path = checkForEmptyPath(dloc.pathname + dloc.search + (dloc.hash || ""));
				path = shiftBaseURL(path);
				return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(path);  
			} else if(obj && obj.withHash)	{
				return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(checkForEmptyPath(dloc.hash));
			} else {
				return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(checkForEmptyPath(dloc.hash.replace('#','')));
			}
		}

        function checkForEmptyPath(path) {
			if(!path) {
				path = '/'
			}
			return path;
		}

        function shiftBaseURL(path,append) {
			var baseURL;
			if((baseURL = config.baseURL) && path) {
			baseURL = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(baseURL);
			if(path.indexOf(baseURL) == 0 && !append) {
				return path.replace(baseURL,'');
			} else if(append && path.indexOf(baseURL) != 0) {
				return baseURL+path;
			} 
			} 
			return path;
		}

        function constructURLFromRoute(matched) {
			if(matched && matched.route) {
				var strRoute;
				if(!Array.isArray(matched.route)) {
					matched.route = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._dotSerperator)(strRoute = matched.route);
				} else {
					strRoute = matched.route.join('.')
				}
				matched.queryParams = matched.queryParams || {};
				matched.dynamicParams = matched.dynamicParams || [];
				matched.refreshData = false;
				var url,
				sameRoute = !!trans,
				dynamicPos = matched.dynamicParams.length != matched.route.length,
				dynamicParamPos = 0,
				linkTo = this && this.tagName == LINKTOStr,
				routeObj = config.routes,
				templateUrl = url = '',
				defQPTemp = {},
				route;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					if(sameRoute && trans.matched.route[i] != route) {
						sameRoute = false;
					}
					routeObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(route,routeObj);
					if(!(routeObj && routeObj.__lp && routeObj.__lp.path)) {
						_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(422,matched.route,i);
						return false;
					}
					var def = routeObj.__lp.handler && routeObj.__lp.handler.name != __routeProm__Str ? routeObj.__lp.handler : undefined,
					rOpts = routeObj.__lp.options;
					// if(!def && !linkTo) {
					// 	_consoleError.call(lyte,422,matched.route,i);
					// }
					var path = routeObj.__lp.path,
					defaultQP;
					if(!def) {
						if(defaultQP = routeObj.__lp.defQP) {
						for(var key in defaultQP) {
							if(matched.queryParams && !matched.queryParams.hasOwnProperty(key)) {
								defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
							} else {
								defQPTemp[key] = defaultQP[key];
							} 
						}
						}
					} else if(def.queryParams) {
						defaultQP = routeObj.__lp.defQP;
						var qpdef = rOpts.qpdef;
						for(var key in qpdef) {
							if(!matched.queryParams.hasOwnProperty(key)) {
								if(sameRoute && qpdef[key].cache) {
									matched.queryParams[key] = trans.rOpts[i].param.queryParams[key];
								} else if(defaultQP && defaultQP.hasOwnProperty(key)) {
									defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
								}
							}
							if(!linkTo && !matched.refreshData && qpdef[key].refreshData) {
								matched.refreshData = true;
							}
						}
					}
					if(routeObj.__lp.dkey) {
						var dynamicPathSplit = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._splitPath)(path),
						dynamicPathSplitTemp = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._splitPath)(path),
						pos = dynamicPos ? dynamicParamPos : i;
						if(!matched.dynamicParams || !matched.dynamicParams[pos]) {
							_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(linkTo ? "499A" : 499,route,linkTo ? this : undefined);
						return false;   
						} else {
							dynamicPathSplit[routeObj.__lp.dIndex] = encodeURI(matched.dynamicParams[pos]);
							dynamicPathSplitTemp[routeObj.__lp.dIndex] = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)('<<dp>>');
							templateUrl += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(dynamicPathSplitTemp.join('/')); 
							url += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(dynamicPathSplit.join('/')); 
							dynamicParamPos++;
						} 
					} else {
						templateUrl += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(path);
						url += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(path);
					}
				}
				if(!config.cacheRoutes[strRoute]) {
					config.urlCache[strRoute] = {url : (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._validateURL)(templateUrl), defQP : defQPTemp};
				}
				return appendQueryParamsAndFrag(url,matched);
			}
		}

        function appendQueryParamsAndFrag(url,matched) {
			url = url[url.length-1] == '/' && url.length != 1 ? url.slice(0,-1) : url;
			if(matched.queryParams) {
				var ques = true;
				for(var key in matched.queryParams) {
					if(matched.queryParams[key] != undefined) {
						if(ques) {
							url += '?';
							ques = false
						} else {
							url += '&';
						}
						url+= key+'='+encodeURIComponent(matched.queryParams[key]);  
					}
				}
			}
			if(config.historyType && matched.fragment) {
			url = url+"#"+matched.fragment;
			}
			return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._validateURL)(url);
		}

        var invokeRunLoop;
        function dispatch(path,processed) {
			let history;
			lyte.time(RouteNavigationStr);
			if(path && config.baseURL && document.location.pathname.indexOf(config.baseURL) == -1) {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error("400A");
				return;
			}
			processed = processed || (!initialLoad && (history = lHistory.getMeta()) && history.matched && history.__lh.url == getLocation({withHash : true}) /* && history.__lh.url.indexOf(path) != -1 */ ? normalizeMatchedObj(history.matched) : traverse(path));
			if(!processed || processed.error) {return};
			clearTimeout(invokeRunLoop);
			processed.prevTrans = processed.prevTrans || LR.__lp.prevTrans;
			processed.path = processed.path || path;
			processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
			invoke(processed);
			lyte.triggerEvent("navigationStart", {prevTrans : prevTrans && prevTrans._trans, nextTrans : newTrans._trans});
			invokeRunLoop = setTimeout(function() {
				if(processed.matched.route.length) {
					downloadLazyRoutes(processed)
					newTrans._data = newTrans._trans.data ? (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(newTrans._trans.data) : {};
					if(trans && trans.state == 102 && newTrans && LR.checkIfSameRoute(newTrans.info,trans.info) && !trans.aborted && JSON.stringify(trans._data) == JSON.stringify(newTrans._data)) {
						if(trans.iPause == true) {
							trans.resume();    
						}
						return;
					} else if(trans && trans.state == 102) {
						trans.abort({state : 409}); 
					}
					newTrans.transComp = processed.transComp;
					// if(trans) {
					// 	newTrans.pRoutes = trans.routes;
					// }
					routeOptions.trans = trans = newTrans;
					newTrans.runLoop = constructPrevRunLoop(processedDispatch = processed);
					newTransInfo = routeOptions.newTransInfo;
					trans.run();
					// trans.transComp = processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
					// routeOptions.trans = trans = newTrans;
					// newTransInfo = routeOptions.newTransInfo;
					// if(trans._trans.data) {
					// 	newTransInfo.data = trans._trans.data;
					// }
					// newTransInfo.meta = trans.meta = {matched : trans.matched}
					// newTransInfo.state = trans.stateObj = getHistoryState({
					// 	replace : newTransInfo.replace,
					// 	data : newTransInfo.data,
					// 	url : trans.url,
					// 	matched : trans.matched,
					// 	fromHistory : newTransInfo.fromHistory
					// });
					// getHistoryObj(newTransInfo);
					
				} 
			},0);
			return newTrans;
		}

        function downloadLazyRoutes(processed) {
			var R = processed.R,
			promArr = [];
			R.forEach(function(fn,i) {
				if(fn.name == __routeProm__Str) {
					var dirArr = processed.matched._routes[i],
					routeDetail = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(dirArr, config.routes);
					promArr.push(fn.call(routeDetail.__lp).then(function(data) {
						initialRegisterRoute(dirArr, data[routeDetail.__lp.cName]);
						processed.R[i] = routeDetail.__lp.handler;
					}));
				}
			})
			return Promise.all(promArr);
		}

        function getTransitionDiffernce(prevTrans, matched, R) {
			var like = true,
			similar = true,
			rendered = [],
			common = [],
			unRendered = [],
			templateToRemove,
			currRoute = matched.route.join('.'),
			r,
			tar = "";   
	
			if(prevTrans) {
				var prevMatched = prevTrans.matched,
				route,
				startFrom = matched.refreshRoute && currRoute == prevTrans.info.route ?  matched.refreshRoute : matched.startFrom;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					tar = tar + (tar ? "." : "") + route;
					if(similar && route == prevMatched.route[i] && (!startFrom || tar != startFrom)) {
						r = R ? R[i] : LR.getDefinition(route.slice(0,i));
						if(r.name != __routeProm__Str && like && compareRoute(matched._routes[i],i,prevMatched,matched)) {
							common.push(route);
							if(prevTrans.rOpts[i].rendered) {
								rendered.push(route);  
							} else {
								// like = false; dont change this code. It is commented for decideTransition function
								unRendered.push(route);  
							}
						} else {
							like = false;
							unRendered.push(route);
						}
					} else {
						similar = false;
						if(templateToRemove == undefined && prevTrans.routes[i] && prevTrans.rOpts[i].rendered != -1 && prevTrans.routes[i].outlet) {
							templateToRemove = i;
						}
						unRendered.push(route);
					}
				}
				if(prevMatched.route.length > matched.route.length) {
					var index = matched.route.length;
					if(templateToRemove == undefined && prevTrans.rOpts[i].rendered/* && prevTrans.routes[i].outlet */) {
					templateToRemove = index;
					}
				}
			} else {
				unRendered = unRendered.concat(matched.route);
			}
			return { rendered, unRendered, common, templateToRemove };
		}

        function compareRoute(rArr,index,prevMatched,matched) {
			var same = true,
			routeObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(rArr,config.routes),
			ropt = routeObj.__lp.options;
			if(!ropt.queryParams && !routeObj.__lp.dkey) {
				return true;
			}
			if(routeObj.__lp.dkey && prevMatched.dynamicParams[index] != matched.dynamicParams[index]) {
				return false;
			} else if(ropt.queryParams && matched.refreshData) {
				ropt.queryParams.every(function(key) {
					if(same && ropt.qpdef[key].refreshData && (matched.queryParams || prevMatched.queryParams) && matched.queryParams[key] != prevMatched.queryParams[key]) {
					return same = false;
					} else {
					return true;
					} 
				});
			}
			return same;
		}

        const basicHooks = [fetchStr,divertStr,renderStr,afterRenderStr];

        function constructPrevRunLoop() {
			lyte.time(constructRunLoopStr);
			var b4Exit = [],
			willNavigate = [],
			b4RouteTrans = [{hook : beforeRouteNavigationStr}];
			if(prevTrans) {
				for(var i = prevTrans.matched.route.length-1,r;r = prevTrans.matched.route[i]; i--) {
					var r1 = trans.matched._routes[i];
					if(!r1 || (r1.join('.') != prevTrans.matched._routes[i].join('.'))) {
						b4Exit.push({hook : beforeExitStr, index : i});
					}
					willNavigate.push({hook : willNavigateStr, index : i});
				}
				lyte.time(constructRunLoopStr);
				return {previous : willNavigate.concat(b4RouteTrans).concat(b4Exit) ,current : b4Exit};
			}
			return {};
			// return { previous : b4RouteTrans };
		}

        function pushFetchHooks(loop, index) {
			loop.push(
				{hook : beforeFetchStr, index : index},
				{hook : fetchStr, index : index},
				{hook : afterFetchStr, index : index})
		}

        function convertToFF({ trans, index }) {
			var r = trans.routes[index];
			if(typeof r.__lp.fns.forceFetch && callHookWithoutPromise.call(trans,r.__lp.fns.forceFetch,forceFetchStr,index,[])) {
				trans.runLoop.forceFetch[index] = []
				pushFetchHooks((trans.runLoop.forceFetch[index] = []),index)
				trans.runLoop.current.every(function(obj,i) {
					if(obj.hook == beforeFetchStr && obj.index == index) {
						trans.runLoop.current.splice(i, 3);
						return false;
					}
					return true;
				})
				r.__lp.fetchStatus = pendingStr;
			}
		}

        function constructRunLoop(processed) {
			lyte.time(constructRunLoopStr);
			var transComp = processed.transComp,
			runLoop = trans.runLoop = {
				previous : [],
				current : [],
				forceFetch : {}
			},
			current = runLoop.current,
			// forceFetch = {},
			loadingTemplate = [],
			req = [],
			didTransit = [];
			
			if(transComp.rendered && transComp.rendered.length) {
				transComp.rendered.forEach(function(hook,index) {
					trans.rOpts[index].rendered = true;
					current.push({hook : divertStr,index : index});
					didTransit.push({hook : didNavigateStr,index : trans.matched.route.length-index-1});
				});
			}
			if(transComp.unRendered && transComp.unRendered.length) {
				transComp.unRendered.forEach(function(hook,orgIndex) {
					var index = transComp.rendered.length+orgIndex,
					r = trans.routes[index];
					if(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {
						loadingTemplate.push({hook : renderLoadingTemplateStr, index})
						req.push({hook : getRequirementsStr,index});
					}
					basicHooks.forEach(function(h,i) {
						if(i == 0) {
							if(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {
								pushFetchHooks(current,index)
								// if(!transComp.unRendered[orgIndex+1] && trans.matched.mountRoute) {
								// 	current.push({hook : "getMountApp", index});
								// }		
								if(r instanceof Promise) {
									r.then(function() {
										convertToFF({trans, index})
									})
								} else {
									convertToFF({trans, index})
								}
							}
						}  else {
							current.push({hook : h, index}); 
							if(h == renderStr && transComp.unRendered[orgIndex+1]) {
								current.push({hook : renderLoadingTemplateStr,index : index+1});
							}    
						}
					});  
					didTransit.push({hook : didNavigateStr,index : trans.matched.route.length-index-1});
				});		
			}
			trans.runLoop.current = [{hook : onBeforeLoadStr}].concat(loadingTemplate).concat(req).concat(current).concat(didTransit)
			if(!prevTrans) {
				trans.runLoop.current.unshift({hook : beforeRouteNavigationStr})
			}
			runLoop.templateToRemove = (prevTrans && prevTrans.runLoop.templateToRemove) ? prevTrans.runLoop.templateToRemove : [];
			if(transComp.templateToRemove != undefined) {
				runLoop.templateToRemove.push({index : transComp.templateToRemove, routes : visibleTrans.routes});
			}
			lyte.time(constructRunLoopStr);
		}

        function invoke(processed) {
			routeOptions.newTrans = LR.__lp.newTrans = newTrans = new Navigation(processed);
			newTrans.url = processed.path;
			newTrans.runLoop = {};
			newTrans._trans = limitTransition(newTrans);
			lyte.extendEventListeners(newTrans._trans);
			if(historyObj) {
				routeOptions.newTransInfo = newTransInfo = historyObj;
				newTransInfo.url = processed.path;
				newTrans._trans.data = historyObj.data || lHistory.getData() || {};
				newTransInfo.replace = true;
				historyObj = undefined;
			} else if(newTrans._trans.data) {
				LR.history.replaceState(newTrans._trans.data);
			}
		}

        function abortRunningPromises(trans) {
			if(trans.runningProm) {
				trans.runningProm.reject(abortedStr);  
			}
			if(trans.fRunningProm) {
				trans.fRunningProm.reject(abortedStr);   
			}
		}

        var navId = 0;
        function Navigation(processed) {
			this.navId = navId = navId+1;
			this.matched = processed.matched;
			this.target = processed.matched.target;
			this.logs = [];
			this.onLoadCalled = [];
			this.fns = [];

			this.getDynamicParams = function() {
				var dpObj = {};
				if(this.matched.dynamicParams) {
					this.matched.dynamicParams.forEach(function(dp,i) {
						if(dp) {
							var routesObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(this.matched._routes[i], config.routes)
							dpObj[routesObj.__lp.dkey] = dp;
						}
					}.bind(this))
				}
				return dpObj;
			};
			this.pending = {
				dependencies : new Set(),
				resources : new Set(),
				forceFetch : new Set()
			};
			this.info = {
				route : processed.matched.target,
				queryParams : processed.matched.queryParams,
				dynamicParams : processed.matched.dynamicParams.filter(_arrayClean),
				alias : processed.matched.alias
			};
			if(processed.matched.fragment) {
				this.info.fragment = processed.matched.fragment;
			}
			this.R = processed.R;
			this.rOpts = processed.rOpts;
			this.running = this.aborted = this.paused = false;
			this.abort = function(obj) {
				if(newTransInfo && newTransInfo.goValue) {
					fromHistoryGo = false;
				}
				this.abort = emptyFn;
				abortRunningPromises(this);
				this.aborted = true;
				if(!obj) {
					obj = {state : 308};
				} 
				if(this.running) {
					lyte.log(NavigationAbortedStr,routeStr);
				}
				if(!obj.iAbort) {
					delete this.runLoop.templateToRemove;
				}
				transitionCompleted(obj);
			}.bind(this);
			this.pause = function (obj) {
			lyte.log(NavigationPausedStr, routeStr);
			if (obj && obj.iPause) {
				this.iPause = true;
			} else {
				this.iPause = false;
				this.state = this._trans.state = 307;
				this._trans.triggerEvent(stateChangeStr,this.state);
			}
			this.paused = trans.prom || true;
			this.resume = this._trans.resume = function (t) {
				t = t || this;
				if (t.prom != t.eProm) {
					if (!t.pendingResume) {
						t.pendingResume = t.resume;
						delete t._trans.resume;
						delete t.resume;
					}
					return;
				}
				delete t._trans.resume;
				delete t.resume;
				lyte.log(NavigationResumedStr, routeStr);
				if (t.paused) {
					var state,
					prom = t.prom;
					if(t.paused != true) {
						state = t.paused.state;
					}
					if (t.runLoop[state]) {
						if(state == forceFetchStr) {
							var newProm = t.runLoop.forceFetch[prom.index];
							if(newProm[0] && prom.hook == newProm[0].hook) {
								newProm.splice(0, 1);
							}
						} else if(t.runLoop[state][0] && t.runLoop[state][0].hook == t.paused.hook && t.runLoop[state][0].index == t.paused.index) {
							removeHook(t.runLoop[state], t.paused.hook, t.paused.index);
						}
					}
					t.iPause = t.paused = false;
					t.state = t._trans.state = 102;
					this._trans.triggerEvent(stateChangeStr,t.state);
					if(this.forceFetchRunning) {
						if(t.runLoop.forceFetch[prom.index][0]) {
							t.run(t.runLoop.forceFetch[prom.index][0]);
						} else {
							t.routes[prom.index].__lp.fetchStatus = completedStr;
							if (t.pending.waitingForFF != undefined && t.pending.waitingForFF == prom.index) {
								delete t.pending.waitingForFF;
								t.run();
							}
						}
					} else {
						if(state && state == forceFetchStr && !t.runLoop.forceFetch[prom.index][0]) {
							t.routes[prom.index].__lp.fetchStatus = completedStr;
						} 
						t.run();  
					}
				}
			}.bind(this);
			return this._trans;
			}.bind(this);
		}

        function templateDelete(arr) {
		/* clears outlet, from parent to child */
			for(var i = 0,l = arr.length,obj; i < l; i++) {
				obj = arr[i];
				for (var inst, j = obj.routes.length - 1; j >= obj.index; j--) {
					inst = obj.routes[j];
					if (inst.outlet) {
						triggerTemplateDestroy({outlet : inst.outletName, route : inst},true)
						inst.outlet.innerHTML = "";
						if(!trans.routes[j] || trans.routes[j].__lp.objPath != inst.__lp.objPath) {
							callDidDestroy.call(this,inst,j,obj);
						}
					}
				}
			}
		}

        function triggerTemplateDestroy(obj) {
			LR.triggerEvent(beforeTemplateDestroyStr,obj);
			lyte.triggerEvent(beforeTemplateDestroyStr,obj);
		}

        function callDidDestroy(inst,index) {
			lyte.log(didDestroyStr+" of "+ inst.routeName,routeStr,fontColor);
			lyte.time(didDestroyStr+index);
			callHookWithoutPromise.call(this,inst.didDestroy,didDestroyStr,index,[inst.currentData, inst.__lp.param]);
			lyte.time(didDestroyStr+index);
		}

        var stoppableHooks = [getRequirementsStr,beforeFetchStr,fetchStr,afterFetchStr];
        // error in these hooks should pause transition and call onerror action
        function errorStoppableHook(hook) {
			return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._strPresence)(stoppableHooks,hook);
		}

        function callHookWithPromise(callback,instance, args) {
			/* executes route hooks which will returns promise */
			if(callback) { 
				var resp,
				t = trans,
				prom = trans.prom,
				hook = prom.hook,
				index = prom.index,
				stopNav = errorStoppableHook(hook),
				self = this;
				return new Promise(function(resolve,reject) {
					try {
						t.logs.push(hook +' of route '+instance.routeName+ ' called');
						var result = callback.apply(instance,args);
						if(stopNav && result) { /* check why stopTrans is needed? */
							result = lyte.resolvePromises(result);
						}
						resp = Promise.resolve(result);
					} catch(err) {
						processError.call(self,{hook : hook, index : index, stopNav , err : err,instance : instance, promise : {resolve : resolve, reject : reject}});
						return;
					}
					resp.then(function(data) {
						if(prom.state != "previous" && trans._trans != instance.navigation) {
							t.logs.push("old navigation's promise rejected");
							reject()
						} else {
							resolve(data);
							callback.then && callback.then.success.apply(this,arguments);
						}
					},function(err) {
						t.prom = prom;
						reject(err)
						callback.then && callback.then.failure.apply(this,arguments)
						processError.call(self,{hook, index,stopNav,err,instance, PR : true});
					});  
				});
			} else {
				return resolvedPromise;
			}
		}

        function callHookWithoutPromise(callback,hook,index,args,splInstance) {
			/* executes route hooks which wont return promise  */
			if(callback) {
				var instance = this.routes[index];
				try {
					trans.logs.push(hook +' of route '+instance.routeName+ ' called');
					return callback.apply(splInstance || instance,args);
				} catch(err) {
					processError.call(this,{hook, index, stopNav : errorStoppableHook(hook),err,instance});
					return;
				}  
			}
		}

        function callAction(hook,index,args) {
			/* executes route's actions  */
			var action,
			routeInstance = this.routes[index] && this.routes[index];
			if(action = getAction(routeInstance, hook)) {
				try {
					trans.logs.push(hook +' of route '+routeInstance.routeName+ ' called');
					if(action.apply(routeInstance,args) == false) {
						return false;
					}
				} catch(e) {
					_consoleErrorFromCallback(e,hook,routeInstance.routeName);
					return false;
				} 
			}
		}

        function _consoleErrorFromCallback(err,hook,routeName,state,options) {
			if(typeof err == "string" || (typeof err == "object" && err.stack && !err.$)) {
				if(!err.stack) {
					err = Error(err);
				}
				err.$ = true;
				var internalErr = _router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.getErrorMessage(state) || _router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.getErrorMessage("420A",hook,routeName);
				err.stack = err.stack.replace(err.message,err.message = err.message+"\n\t"+internalErr);
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(err);
			} else {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(state,hook,routeName,err,options && options.PR);
			}
		}

        function processError(options) {
			/* handles error in hooks */
			var instance = options.instance,
			stopNav = options.stopNav,
			err = options.err,
			hook = options.hook,
			index = options.index;
			if(stopNav) {
				trans.pause();
				run[onErrorStr].call(this,hook,index,err,"420",options);
			} else {
				_consoleErrorFromCallback(err,hook,instance.routeName);
				// if(_strPresence([willNavigateStr,didNavigateStr,beforeExitStr,redirectStr],hook)) {
					if(options.promise) {
						options.promise.resolve();
					}
				// } else {
					// trans.abort({state : 4, iAbort : true});
				// }
			}  
		}

        function runLoopPromise(fn,fnName,loop,success,failure) {
			success = success || emptyFn;
			failure = failure || function(error) {
				if(error != abortedStr) {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(error);
				}
			};
			new Promise(function(resolve,reject) {
				if(fnName == nestedForcedPromisesStr ) {
					this.fRunningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop.forceFetch,resolve);
				} else {
					this.runningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop,loop,resolve);  
				}
			}.bind(this)).then(success,failure);
		}

        Navigation.prototype.run = function (pausedForcedProm) {
			if(pausedForcedProm) {
				nestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,pausedForcedProm);
				return;
			}
			processRunLoop.call(this);
		};

        function processRunLoop() {
			runLoopPromise.call(trans,nestedPromises,"nestedPromises",'previous',function() {
			if(processedDispatch && !trans.running && !trans.aborted ) {
				initRoute(trans, processedDispatch);
				if(processedDispatch.hasOwnProperty("refreshFrom")) {
					for(var i = processedDispatch.refreshFrom,r; r = newTrans.routes[i]; i++) {
						delete r.component;
					}
				}
				document.title = this.title = this.routes[this.routes.length-1].title || document.title;
				if(trans._trans.data) {
					newTransInfo.data = trans._trans.data;
				}
				newTransInfo.meta = trans.meta = {matched : trans.matched}
				trans.state = trans._trans.state = 102;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(newTransInfo) {
					if(config.preserveUrlOnBrowserNavigation && newTransInfo.fromHistory) {
						// if(newTransInfo) {
							// if(config.preserveUrlOnBrowserNavigation) {
						if(/* newTransInfo.fromHistory && */ !!newTransInfo.goValue) {
							fromHistoryGo = true;
							history.go(-(newTransInfo.goValue));
						}
						newTransInfo.data = trans._trans.data || newTransInfo.data;
						// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						newTransInfoClone = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(newTransInfo);
						trans.stateObj = newTransInfo.state;
						newTransInfoTimer = setInterval(function() {
							if(!newTransInfoClone) {
								clearInterval(newTransInfoTimer);
								return;
							}
							if(!fromHistoryGo) {
								clearInterval(newTransInfoTimer);
								addToHistory(newTransInfoClone);
								newTransInfoClone = undefined;
								
							}
						},0)
					} else {
						newTransInfo.data = trans._trans.data || newTransInfo.data;
						// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						addToHistory(newTransInfo);
						trans.stateObj = newTransInfo.state;
					}
				}

					// 	newTransInfo.data = trans._trans.data || newTransInfo.data;
					// 	// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
					// 	newTransInfoClone = deepCopyObject(newTransInfo);
					// 	trans.stateObj = newTransInfo.state;
					// 	newTransInfoTimer = setInterval(function() {
					// 		if(!newTransInfoClone) {
					// 			clearInterval(newTransInfoTimer);
					// 			return;
					// 		}
					// 		if(!fromHistoryGo) {
					// 			clearInterval(newTransInfoTimer);
					// 			addToHistory(newTransInfoClone);
					// 			newTransInfoClone = undefined;
								
					// 		}
					// 	},0)
					// } else {
					// 	newTransInfo.data = trans._trans.data || newTransInfo.data;
					// 	// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
					// 	addToHistory(newTransInfo);
					// 	trans.stateObj = newTransInfo.state;
					// }
				// }
				LR.__lp.trans = trans;            
				processedDispatch.previous = false;
				constructRunLoop(processedDispatch);
				setParamsInInst(processedDispatch);
				routeOptions.newTransInfo = processedDispatch = newTransInfo = undefined;
				trans.running = true;
			}
			runLoopPromise.call(trans,nestedPromises,"nestedPromises",'current');
			}.bind(this));
		}

        function setPendingResume(promise) {
			trans.eProm = promise;
			if (this.pendingResume) {
			var resume = this.pendingResume;
			delete this.pendingResume;
			resume();
			}
		}

        function nestedForcedPromises(forcedLoop, resolve, promise) {
			if (validateTransition(this) && forcedLoop) {
				if(!promise) {
					for(var key in forcedLoop) {
						var routeLoop = forcedLoop[key],
						p = routeLoop[0];
						if(p) {
							if(!p.running) {
								nestedForcedPromises.call(this, forcedLoop, resolve,p);    
							}
						}
					}
					return;
				}
				var routeInstance = this.routes[promise.index];
				promise.state = forceFetchStr;
				trans.prom = promise;
				if (promise.hook == beforeFetchStr && !routeInstance.__lp.dependenciesLoaded) {
					routeInstance.__lp.loadDependencies.then(function() {
						nestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,this.runLoop.forceFetch[promise.index][0]);
					}.bind(this))
					return;
				}
				logCallbacks(promise);
				forcedLoop[promise.index][0].running = true;
				forcedLoop[promise.index].splice(0, 1);
				lyte.time(promise.hook+promise.index);
				run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
					lyte.time(promise.hook+promise.index);
					setPendingResume.call(trans, trans.prom);
					if(promise.hook == afterFetchStr) {
						routeInstance.__lp.fetchStatus = completedStr;
						if (this.pending.waitingForFF != undefined && this.pending.waitingForFF == promise.index) {
							delete this.pending.waitingForFF;
							nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
						}
					} else if(promise.hook == fetchStr) {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterFetchStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					} else {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == fetchStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					}
				}.bind(this),function() {debugger;});
			} else {
				this.forceFetchRunning = false;
			}
		}

        function logCallbacks(promise) {
			if(lyte.config.debug) {
				var hook = promise.hook,
				index = promise.index;
				if([beforeRouteNavigationStr, onBeforeLoadStr].indexOf(promise.hook) != -1) {
					lyte.log(hook,routeStr,fontColor);
					return;  
				}
				var route = promise.state == "previous" ? prevTrans.R[index] : trans.R[index];
				lyte.log(hook +' of route '+route.routeName,routeStr,fontColor);    
			}
		}

        function nestedPromiseCall(promise, routeInstance, loop, state, resolve) {
			if(promise.hook == beforeFetchStr && !routeInstance.__lp.dependenciesLoaded) {
				routeInstance.__lp.loadDependencies.then(function() {
					routeInstance.__lp.dependenciesLoaded = true
					nestedPromises.call(this,loop,state,resolve);
				}.bind(this));
				return;
			} else if(promise.hook == renderStr && !routeInstance.__lp.resourcesLoaded) {
				routeInstance.__lp.loadResources.then(function() {
					routeInstance.__lp.resourcesLoaded = true
					nestedPromises.call(this,loop,state,resolve);
				}.bind(this));
				return;
			} else if(promise.hook == divertStr && routeInstance.__lp.fns.forceFetch && routeInstance.__lp.fetchStatus == pendingStr) {
				if(!this.forceFetchRunning) {
					this.forceFetchRunning = true;
					runLoopPromise.call(this,nestedForcedPromises,nestedForcedPromisesStr);
				}
				this.pending.waitingForFF = promise.index;
				return;
			} else {
				promise.state = state;
				trans.prom = promise;
				logCallbacks(promise);
				lyte.time(promise.hook+promise.index);
				run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
					lyte.time(promise.hook+promise.index);
					setPendingResume.call(trans,trans.prom);
					if(this.runningProm.resolve == resolve) {
					removeHook(loop[state],promise.hook,promise.index);
					nestedPromises.call(this,loop,state,resolve);  
					}
				}.bind(this));
			}
		}

        function nestedPromises(loop,state,resolve) {
			if(validateTransition(this)) {
				var runLoop = loop[state];
				if(runLoop && runLoop.length) {
					var promise = runLoop[0],
					routeInstance = state == "previous"? prevTrans.routes[promise.index] : this.routes[promise.index];
					if(routeInstance instanceof Promise) {
						routeInstance.then(function() {
							if(this.onLoadCalled.length && runLoop[0].hook != onBeforeLoadStr) {
								runLoop.unshift({hook : onBeforeLoadStr});
							}
							nestedPromises.call(this, loop, state, resolve);
						}.bind(this))
						return;
					} else {
						nestedPromiseCall.call(this,promise, routeInstance, loop, state, resolve)
					}
				} else if(resolve) {
					resolve();
				}
			} else if(this.paused && this.runningProm) {
				this.runningProm.reject(abortedStr);  
			}
		}

        function removeHook(loop,hook,index) {
			for(var i = 0,obj;obj = loop[i]; i++) {
				if(obj.hook == hook) {
					if(index != undefined) {
						if(index == obj.index) {
							loop.splice(i,1);
							break;
						}
					} else {
						loop.splice(i,1);
						i--;
					}
				}
			}
		}

        function transitionCompleted(obj) {
			/* called after a atransition is completed or aborted*/
			trans.fns = [];
			if(trans.running) {
				if(trans == newTrans) {
					routeOptions.newTrans = LR.__lp.newTrans = newTrans = undefined;  
				}
				if(newTransInfoClone) {
					clearInterval(newTransInfoTimer);
					addToHistory(newTransInfoClone);
					newTransInfoClone = undefined;
				}
				LR.__lp.navigationCompleted && LR.__lp.navigationCompleted(trans)
				for(var i = 0,l = trans.fns.length; i < l; i++) {
					clearTimeout(trans.fns[i]);
				};
				
				trans.pendingResume = undefined;
				trans.running = false;
				trans.state = trans._trans.state = obj.state;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(initialLoad || trans.state == 200) {
					removeNavWeakMap(prevTrans, trans)
					routeOptions.prevTrans = LR.__lp.prevTrans = prevTrans = trans;
					lyte.log(NavigationComletedStr,routeStr);
					lyte.time(RouteNavigationStr);
					if(config.historyType && trans.info.fragment) {
						var elem;
						if((elem = document.getElementById(trans._trans.info.fragment)) && elem.scrollIntoView && (LR.beforeScroll && LR.beforeScroll(trans._trans) != false)) {
							elem.scrollIntoView();
						}
					}
					run[afterRouteNavigationStr](trans._trans);
				} else if(obj.iAbort || visibleTrans == trans) {
					removeNavWeakMap(prevTrans, trans)
					routeOptions.prevTrans = LR.__lp.prevTrans = prevTrans = trans;
					if (trans.state && trans.state != 201) {
					run[afterRouteNavigationStr](trans._trans);
					}
				} else {
					if (trans.state && trans.state != 201) {
						run[afterRouteNavigationStr](trans._trans);
					}
					removeNavWeakMap(trans, newTrans || prevTrans)
					routeOptions.trans = LR.__lp.trans = trans = prevTrans;  
				}
				if(initialLoad) {
					initialLoad = false;
				}
			} else if(prevTrans){
				routeOptions.trans = LR.__lp.trans = trans = prevTrans;
			}
		}

        function removeNavWeakMap(p,t) {
			if(p && (visibleTrans && p != visibleTrans)) {
				setTimeout(function() {
					p.routes.forEach(function(route,i) {
						if(/*!t.rOpts[i] || p.rOpts[i].objPath != t.rOpts[i].objPath || */p.routes[i] != t.routes[i]) {
							LR.__lp.nav.delete(route);
						}
					})
				},0)
			}
		}

        function traverse(path, get) {
			if(path) {
				var routeObj = (0,_map_parser__WEBPACK_IMPORTED_MODULE_2__._traverseMap)(path, config)
				if(routeObj) {
					return pathProcessor.apply(this,[get].concat(routeObj));
				} else {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error("400A",config.baseURL && path.indexOf(config.baseURL) != 0 ? '' : path);
					return { error : true }
				}
			}
		}

        function pathProcessor(get,selectedPath,path,params,fragment) {
			var newURL,
			orgMatched,
			newMatched,
			matched = {
			route : (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(selectedPath,config.routeHash).__lp.route,
			queryParams : params ? (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._frameQueryParams)(params) : {}
			};
			if(config.historyType) {
				matched.fragment = fragment;
			}
			matched.dynamicParams = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._frameDynamicParams)(path,matched,config.routes);
			if(get) {return matched;}
			matched.dpProcessed = true;
			var transInfo = normalizeMatchedObj(matched);
			if(transInfo != false) {
				orgMatched = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(transInfo.matched);
				newMatched = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(transInfo.matched);
				if(!transInfo.matched.hasOwnProperty('refreshData')) {
					if(!constructURLFromRoute(transInfo.matched)) {
						return;
					}
				}
				newURL = constructURLFromRoute(newMatched);
				if(!(0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._compareObj)(newMatched.queryParams,orgMatched.queryParams)) {
					addToHistory({replace : true,state : window.history.state,url : newURL,fromHistory : true});
					transInfo.path = newURL;
				}  
			}
			return transInfo;
		}

        function setParamsInInst(processed) {
			if(config.linkActiveClass) {
				config.activeLinkTags.forEach(function(tag) {
						tag.classList.remove(config.linkActiveClass);
				});
			}
			config.activeLinkTags = [];
			var R,
			r,
			matched = processed.matched;
			try {
				function linkTagPush(tag) {
					if(tag.getAttribute('lt-prop-route') == matched.target && activeLinkTags.indexOf(tag) == -1) {
						activeLinkTags.push(tag);
					}
				}
				function setParams(i){
					var rOpts = trans.rOpts[i];
					// r = trans.routes[i];
					if(rOpts.qpdef) {
						for(var key in rOpts.qpdef) {
							rOpts.param.queryParams[key] = matched.queryParams[key];
						};
					}
					rOpts.param.dynamicParam = matched.dynamicParams[i];
					if(i+1 == l) {
						rOpts.linkTags.forEach(linkTagPush);
					}
				}

				function callSetParams(i) {
					setParams(i)
				}
				
				for(var i = 0,l = trans.R.length; i < l; i++) {
					if(trans.routes[i] instanceof Promise) {
						trans.routes[i].then(callSetParams.bind(this,i))
					} else {
						setParams(i)
					}
					
				}
				LR.__lp.mutateCache(matched.target)
			} catch(e) {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(e);
			}
			return;
		}

        function initialRegisterRoute() {
			if(config.routes) {
				registerRoute.apply({},arguments);
			} else {
				this.__lp.pendingReg.push(arguments);
			}
		}

        function registerRoute(dir,RouteClass) {
			if(RouteClass.name != __routeProm__Str) {
				var options = {fns : {actions : {}}, $ : {}}
				if(!RouteClass.__lp || !RouteClass.__lp.fns) {
					RouteClass.__lp = { fns : options.fns };
					[renderLoadingTemplateStr,getRequirementsStr,forceFetchStr,beforeFetchStr,fetchStr,afterFetchStr,divertStr,renderStr,afterRenderStr,"actions",beforeExitStr/*,"getMountApp"*/].forEach(function(key) {
						var prop = RouteClass.prototype[key];
						options.fns[key] = prop
						delete RouteClass.prototype[key];
					});
					if(typeof RouteClass.actions == "function") {
						options.fns.actions = RouteClass.prototype.actions = RouteClass.actions();
					}
					// RouteClass.prototype.routeName = dir[dir.length-1];
				} else {
					options.fns = RouteClass.__lp.fns;
				}
				options.objPath = dir.join('.');
				options.cacheLinks = [];
				options.linkTags = [];
				options.param = {
					queryParams :{},
					dynamicParam : undefined
				};
				var cache = config.queryParamOptions.cache;
				if(options.queryParams = RouteClass.queryParams) {
					options.qpdef = {};
					options.$ = {};
					RouteClass.queryParams.forEach(function(qp,i) {
						if(typeof qp == "string") {
							options.qpdef[qp] = {
							cache : cache,
							refreshData : true
						};
						if(config.cacheRoutes[dir] == undefined && cache) {
							config.cacheRoutes[dir] = cache
						}
					} else if(typeof qp == "object") {
						for(var key in qp) {
							options.qpdef[key] = {
								cache : qp[key].hasOwnProperty('cache') ? qp[key].cache : cache,
								refreshData : qp[key].hasOwnProperty('refreshData') ? qp[key].refreshData : true
							};
							if(!config.cacheRoutes[dir] && options.qpdef[key].cache) {
								config.cacheRoutes[options.objPath] = true
							}
						}
						RouteClass.queryParams[i] = key;
						}
					});  
				}
				RouteClass.routeName = dir[dir.length -1];
				setRouteDef(dir,{RouteClass, options});
			}
		}

        const transPredefined = ['runLoop','running','paused','R','routes',abortedStr,'prom','run',pendingStr,'matched','fns','rOpts','logs','onLoadCalled','getDynamicParams'];

        function limitTransition(int) {
			var _trans = new navigation(int);
			int.state = _trans.state = 201;
			return _trans;
		}

        function dummy() {
			/*
			Dont delete this function.
			This one is to avoid function to be merged during minification.
			*/
			var _trans = new navigation(int);
		}

        function navigation(int) {
			for(var prop in int) {
				if(transPredefined.indexOf(prop) == -1) {
					if(prop == 'info') {
						this.info = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(int[prop]);
					} else {
						this[prop] = int[prop];
					}
				}
			}
		}

        this.getRouteInstance = function(routeName,t) {
			var newTrans;
			if(LR && LR.__lp.initCalled && (newTrans = (t || (LR.__lp && LR.__lp.trans) || trans)) && newTrans.routes) {
				var routeLen = newTrans.routes.length;
				if(!routeName) {
					return newTrans.routes[routeLen-1];
				} else if(routeName == "*") {
					return newTrans.routes;
				} else {
					var reqRouteLen = routeName.split('.').length-1,
					reqRoute = newTrans.routes[reqRouteLen];
					return reqRoute && reqRoute.__lp.objPath == routeName ? reqRoute : undefined;
				}
			}
		};

        function normalizeMatchedObj(obj) {
			// To construct dynamic params array.
			if(obj.route) {
				var routesObj = config.routes,
				// parentRouteObj,
				matched,
				// def,
				R = [],
				rOpts = [],
				errorCheck = function(route,i) {
					routesObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(route,routesObj);
					if(!routesObj) {
						throw Error(_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.getErrorMessage("400A",matched.target));
					}
					R.push(routesObj.__lp.handler)
				};
				if(obj._routes) {
					matched = obj;
				} else {
					var routeFromAlias = _router_utils__WEBPACK_IMPORTED_MODULE_4__._getRouteFromAlias.call(this,{route : obj.route, map : config.aliasRouteMap});
					matched = {
						route : routeFromAlias.route, /* Array.isArray(obj.route) ? obj.route : _dotSerperator(obj.route), */
						alias : routeFromAlias.alias,
						queryParams : obj.queryParams || {},
						dynamicParams : [],
						fragment : obj.fragment,
						target : "",
						refreshRoute : obj.refreshRoute,
						startFrom : obj.startFrom,
						_routes : []
					};
					if(obj.dynamicParams) {
						if(obj.dpProcessed) {
							matched.dynamicParams = Array.from(obj.dynamicParams);
						} else {
							var dynamicParams =  Array.from(obj.dynamicParams);
						}
					}
				}
				try {
					matched.route.forEach(obj._routes ? errorCheck : function(route,i) {
						matched.target = matched.target ? matched.target+'.'+route : route;
						matched._routes.push((0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._dotSerperator)(matched.target));
						errorCheck(route,i)
						if(dynamicParams) {
							matched.dynamicParams.push(routesObj.__lp.dkey ? dynamicParams.shift() : undefined);
						}
					});
					var r = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(matched._routes[matched._routes.length-1],config.routes)
					if(r && r.__lp.mount) {
						matched.mountRoute = true
					}
					if(dynamicParams && dynamicParams.length) {
						lyte.error('Extra dynamic params found. Provide exact numbers dynamic params required for the transition '+ JSON.stringify(dynamicParams));
					}
				} catch(e) {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(e);
					return {error : e};
				}
				return { 
					rOpts,
					matched,
					R
				};
			} else {
				if(this.tagName == LINKTOStr) {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error("498A", pRoute ,this.outerHTML);
				} else {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error("499B");  
				}
			}
		}

        function initRoute(trans, processed, from) {
			trans.routes = [];
			processed.rOpts = processed.rOpts || [];
			var RouteClass,
			routeObj,
			matched = processed.matched,
			refMatch = processed.prevTrans,
			similarRoute = true;
			trans.routes = [];

			function pushRoute(i, routeObj, ins) {
				LR.__lp.nav.set(ins, newTrans);
				ins.parent = newTrans.routes[i-1] instanceof Promise ? newTrans.routes[i-1].then(function() {ins.parent = newTrans.routes[i-1]}.bind(this)) : newTrans.routes[i-1];
				trans.rOpts[i] = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(routeObj.__lp.options);
				newTrans.routes[i] = ins
			}

			function promFunc({routeStringArr, i, routeObj}, res) {
				routeObj.__lp.handler().then(function(data) {
					initialRegisterRoute(routeStringArr,(trans.R[i] = RouteClass = routeObj.__lp.handler = data[routeObj.__lp.cName]));
					lyte.scopedInstance(RouteClass,[{ i ,routeName : routeStringArr[i],options : routeOptions, init : pushRoute.bind(this,i,routeObj)}],emptyFn,[LR]);
					res()
				}.bind(routeObj));
			};

			for(var i = from || 0, route; route = matched.route[i]; i++) {
				routeObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(newTrans.matched._routes[i], config.routes);
				RouteClass = routeObj.__lp.handler;
				if(!RouteClass) {return false;}
				if(refMatch && similarRoute && refMatch.matched && refMatch.matched.route[i] == route) {
					modifyInstance({route : refMatch.routes[i],i,processed, nav : newTrans});
					// lyte.scopedInstance(RouteClass,[rOpts,trans.routes,i,processed,routeOptions,refMatch.routes[i]],pushRoute.bind(this,i),[LR]);
				} else {
					if(RouteClass.name == __routeProm__Str) {
						trans.routes.push(new Promise(promFunc.bind(this, {routeStringArr : matched._routes[i], i, routeObj})))
					} else {
						lyte.scopedInstance(RouteClass,[{i ,routeName : route, options : routeOptions, init : pushRoute.bind(this,i, routeObj)}],emptyFn,[LR]);
					}
					similarRoute = false;
				}
			}
			refMatch = undefined;
		}

        function modifyTransition(trans) {
			if(trans.changedInstance) {
				trans.routes.forEach(function(route,i) {
					LR.__lp.nav.set(route,trans);
					LR.__lp.nav.get(route).rOpts = trans.rOpts[i]
				})
			}
			return trans;
		}

        function modifyInstance({route, i, processed, nav }) {
			var rOpts = nav.rOpts[i] = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(LR.__lp.nav.get(route).rOpts[i])
			LR.__lp.nav.set(route, nav);
			delete rOpts.rendered;
			if(processed.transComp && !processed.transComp.rendered[i] && processed.transComp.redirected) {
				if(processed.transComp.redirected.index < i) {
					delete rOpts.loadDependencies;
					delete rOpts.loadResources;
					route.$.beforeFetch = route.$.fetch = route.$.afterFetch = undefined;
				} else if(processed.transComp.redirected.index != i) {
					delete rOpts.stencils;
				}
			} else {
				delete rOpts.stencils;
			}
			nav.routes[i] = route;
		}

        function dispatchTransition(processed) {
			const url = constructURLFromRoute(processed.matched);
			if(url) {
				processed.path = newTransInfo.url = url;
				dispatch(url,decideTransition(processed));
			}
			return url;
		}

        const allHooks = [getRequirementsStr,beforeFetchStr,fetchStr,afterFetchStr,divertStr,renderStr,afterRenderStr];
        function decideTransition(processed) {
			/* determines which transition to consider as previous transition */
			if(trans) {
				if(trans.running) {
					var matched = processed.matched;
					if(trans.state == 102 && trans.prom && trans.prom.hook == divertStr) {
						var transComp = getTransitionDiffernce(trans,matched,processed.R),
						transitioningRoute = allHooks.indexOf(trans.prom.hook) <= 6 ? trans.prom.index : trans.prom.index+1,
						visibleTransComparison = getTransitionDiffernce(visibleTrans,matched,processed.R);
						if(transComp.common.length < visibleTransComparison.common.length) {
							if(trans.runLoop.templateToRemove.length) {
								trans.runLoop.templateToRemove.pop();
							}
							if(transComp.rendered.length < visibleTransComparison.rendered.length) {
								processed.prevTrans = modifyTransition(visibleTrans);
							}
							transComp = visibleTransComparison;
							if(trans.prom.index <= visibleTransComparison.common.length -1) {
								transComp.redirected = trans.prom;
							}
						} else if(transComp.common.length-1 >= transitioningRoute) {
							if(trans.prom.index <= transComp.common.length -1) {
								processed.prevTrans = trans;
								transComp.redirected = trans.prom;
							}
						}  
					}
					const info = {
						route : matched.target,
						queryParams : matched.queryParams,
						dynamicParams : matched.dynamicParams.filter(_arrayClean)
					};
					if(LR.checkIfSameRoute(trans.info,info) && !trans.aborted) {
						trans.pause({iPause : true});  
					} else {
						trans.abort({state : 409, iAbort : true});
					}
					processed.transComp = transComp;
				} else if(trans && !trans.aborted) {
					trans.abort({state : 409, iAbort : true});
				}
			}
			return processed;
		}

        if(lyte.$.modules.triggerEvent) {
			lyte.$.modules.triggerEvent("add", "router", this);
		}
        var routeOptions = {
			lyte,
			dispatch,
			LR,
			constructURLFromRoute,
			decideTransition
		}
        _slyte_core__WEBPACK_IMPORTED_MODULE_7__.Lyte.domContentLoaded(init);
        return this;
    }
}

Router.__lMod = "Router";



/***/ })

}]);
//# sourceMappingURL=lyte.js.map