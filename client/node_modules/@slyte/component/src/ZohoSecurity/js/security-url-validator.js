

/**
 * URLValidator
 * */
'use strict'; // No I18N
(function() {
    var constants = {
        unsafeProtocolRegex : /^(?:\w+script|data)$/i,
        sanitizeAction : {
            ACTION_ENCODE : "ENCODE",
            ACTION_REMOVE : "REMOVE"
        }
    }

    /**
     * URLValidator is the main object that is set to ZSEC.
     * Create a new URLValidator instance and pass as argument
     * @type {Object}
     */
    var URLValidator = {};

    (function(root){

    /*--------------------------------------------------------------------------*/
    /*-----------------------Punycode.js Code Starts----------------------------*/
    /*--------------------------------------------------------------------------*/

     /**
     * The `punycode` object.
     * @name punycode
     * @type Object
     */
    var punycode,

    /** Highest positive signed 32-bit float value */
    maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    base = 36,
    tMin = 1,
    tMax = 26,
    skew = 38,
    damp = 700,
    initialBias = 72,
    initialN = 128, // 0x80
    delimiter = '-',  // No I18N
    // '\x2D'

    /** Regular expressions */
    regexPunycode = /^xn--/,
    regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

    /** Error messages */
    errors = {
        'overflow': 'Overflow: input needs wider integers to process', // No I18N
        'not-basic': 'Illegal input >= 0x80 (not a basic code point)', // No I18N
        'invalid-input': 'Invalid input' // No I18N
    },

    /** Convenience shortcuts */
    baseMinusTMin = base - tMin,
    floor = Math.floor,
    stringFromCharCode = String.fromCharCode,

    /** Temporary variable */
    key;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
        throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    function ucs2encode(array) {
        return map(array, function(value) {
            var output = '';
            if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
        }).join('');
    }

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
            return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
            return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
            return codePoint - 97;
        }
        return base;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    function decode(input) {
        // Don't use UCS-2
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            /** Cached calculation results */
            baseMinusT;

        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.

        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
            basic = 0;
        }

        for (j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
                error('not-basic');  // No I18N
            }
            output.push(input.charCodeAt(j));
        }

        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.

        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

                if (index >= inputLength) {
                    error('invalid-input'); // No I18N
                }

                digit = basicToDigit(input.charCodeAt(index++));

                if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow'); // No I18N
                }

                i += digit * w;
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

                if (digit < t) {
                    break;
                }

                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                    error('overflow'); // No I18N
                }

                w *= baseMinusT;

            }

            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
                error('overflow'); // No I18N
            }

            n += floor(i / out);
            i %= out;

            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);

        }

        return ucs2encode(output);
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,
            /** Cached calculation results */
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;

        // Convert the input in UCS-2 to Unicode
        input = ucs2decode(input);

        // Cache the length
        inputLength = input.length;

        // Initialize the state
        n = initialN;
        delta = 0;
        bias = initialBias;

        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(stringFromCharCode(currentValue));
            }
        }

        handledCPCount = basicLength = output.length;

        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.

        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(delimiter);
        }

        // Main encoding loop:
        while (handledCPCount < inputLength) {

            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error('overflow'); // No I18N
            }

            delta += (m - n) * handledCPCountPlusOne;
            n = m;

            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];

                if (currentValue < n && ++delta > maxInt) {
                    error('overflow'); // No I18N
                }

                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base; /* no condition */; k += base) {
                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(
                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                        );
                        q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }

            ++delta;
            ++n;

        }
        return output.join('');
    }

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string)
                ? decode(string.slice(4).toLowerCase())
                : string;
        });
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string)
                ? 'xn--' + encode(string) // No I18N
                : string;
        });
    }

    /*--------------------------------------------------------------------------*/

    /** Define the public API */
    punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        'version': '1.4.1', // No I18N
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        'ucs2': { // No I18N
            'decode': ucs2decode, // No I18N
            'encode': ucs2encode // No I18N
        },
        'decode': decode, // No I18N
        'encode': encode, // No I18N
        'toASCII': toASCII, // No I18N
        'toUnicode': toUnicode // No I18N
    };

    root.punycode = punycode;
    /*--------------------------------------------------------------------------*/
    /*-----------------------Punycode.js Code Ends------------------------------*/
    /*--------------------------------------------------------------------------*/
    })(URLValidator);

    /**
     * Sanitizes the given URL and returns a safe URL/Object based on the given 
     * configuration. By default, it resolves a partial URL to a complete URL, 
     * punycodes non-ASCII domain names by default, allows only http/https protocols.
     * 
     * @param  {String} userURL URL to Sanitize
     * @param  {Object} config  Custom Config for URL Sanitization
     * @return {String/Object}         Sanitized URL
     */
    URLValidator.sanitize = function(userURL, config) {

        if (!userURL) {
            //  No User URL, return empty
            return "";
        }
        //  If no config is given, use default config
        config = config || {};

        config.ALLOWED_PROTOCOLS    = config.ALLOWED_PROTOCOLS  || ["https", "http"]; // No I18N
        config.RETURN_PUNYCODE      = config.RETURN_PUNYCODE    != false;
        config.ACTION               = config.ACTION             || constants.sanitizeAction.ACTION_ENCODE;
        config.RETURN_OBJECT        = config.RETURN_OBJECT      || false;
        config.RETURN_ORIGINAL      = config.RETURN_ORIGINAL    || false;

        var anchorTag;

/*
        ////////////////////////////
        //  Original Method Start //
        ////////////////////////////
        
        //  URL is set through innerHTML and not through href property of anchor tag.
        //  This is because if a partial URL is set and got through the href property,
        //  it will only be returned as the original partial value. But setting
        //  through innerHTML and getting through href property will return
        //  the fully resolved URL.
        //
        //  Example - While in sites.zoho.com,
        //
        //  1) USING HREF PROPERTY:
        //      anchorTag.href = "/pages/page/1";
        //      return anchorTag.href;
        //
        //  This will return "/pages/page/1" in some old browsers
        //
        //  2) USING INNERHTML:
        //      divTag.innerHTML = "<a href='/pages/page/1'>Link</a>";
        //      return divTag.childNodes[0].href;
        //
        //  This will return "https://sites.zoho.com/pages/page/1" in all browsers

        //  Also, encodeURI will encode all double quotes(") but not single quotes(').
        //  So the href attribute in the innerHTML should be enclosed with double quotes
        //  to prevent the URL from breaking out of the href attribute value.

        var tempContainer = document.createElement('div');
        tempContainer.innerHTML = '<a href="' + encodeURI(userURL) + '">a</a>';
        anchorTag = tempContainer.childNodes[0];

        //////////////////////////
        //  Original Method End //
        //////////////////////////
*/      
        ///////////////////////////////////////////////////
        //  New Method Start (Method #3)                 //
        //  Tested in all browsers. See here for results //
        ///////////////////////////////////////////////////
        
        var a = document.createElement('a');
        a.href = userURL;
        anchorTag = a.cloneNode(false);

        /////////////////////////////////
        //  New Method End (Method #3) //
        /////////////////////////////////


        var protocol        = anchorTag.protocol.slice(0, -1); // This is to remove the trailing colon ':' which is returned when getting the protocol
        var domain          = anchorTag.host;
        var port            = anchorTag.port;
        var path            = anchorTag.pathname;
        var hash            = anchorTag.hash;
        var resolvedURL     = anchorTag.href;

        var isDomainSafe    = true;
        var isProtocolSafe  = true;

        //  Return in non-ASCII characters only if explicitly mentioned in config.
        //  Otherwise, return punycoded value by default
        if (!config.RETURN_PUNYCODE){
            domain = URLValidator.punycode.toUnicode(domain);
            resolvedURL = URLValidator.punycode.toUnicode(resolvedURL);
        } else {
            domain = URLValidator.punycode.toASCII(domain);
            resolvedURL = URLValidator.punycode.toASCII(resolvedURL);
        }

        // Protocol Check
        if (config.ALLOWED_PROTOCOLS){
            isProtocolSafe = false; // Should be false by default. Make it true only if it matches any of the protocol values
            if (config.ALLOWED_PROTOCOLS.constructor === Array && config.ALLOWED_PROTOCOLS.length > 0 ){
                for(var i = 0; i < config.ALLOWED_PROTOCOLS.length && isProtocolSafe != true; i++){
                    var eachProtocol = config.ALLOWED_PROTOCOLS[i];
                    if(eachProtocol.constructor === RegExp){
                        if(eachProtocol.test(protocol)){
                            isProtocolSafe = true;
                        }
                    } else if (eachProtocol.constructor === String){
                        if(eachProtocol == protocol){
                            isProtocolSafe = true;
                        }
                    }
                }
            }
        } else if (constants.unsafeProtocolRegex.test(protocol)) {
            // Matches our default unsafe protocol regex so protocol is not safe, return false
            isProtocolSafe = false;
        }

        // Domain Check
        if (config.ALLOWED_DOMAINS){
            isDomainSafe = false; // Should be false by default. Make it true only if it matches any of the domain values
            var punycodedDomain     = URLValidator.punycode.toASCII(domain);    // We need both punycoded and non-punycoded domain values
            var nonPunycodedDomain  = URLValidator.punycode.toUnicode(domain);  // to check the ALLOWED_DOMAINS list for ease of use
            if (config.ALLOWED_DOMAINS.constructor === Array && config.ALLOWED_DOMAINS.length > 0 ){
                for(var i = 0; i < config.ALLOWED_DOMAINS.length && isDomainSafe != true; i++){
                    var eachDomain = config.ALLOWED_DOMAINS[i];
                    if(eachDomain.constructor === RegExp){
                        if(eachDomain.test(punycodedDomain) || eachDomain.test(nonPunycodedDomain)){ // Check both punycoded and non-punycoded domain values
                            isDomainSafe = true;
                        }
                    } else if (eachDomain.constructor === String){
                        if(eachDomain == punycodedDomain || eachDomain == nonPunycodedDomain){ // Check both punycoded and non-punycoded domain values
                            isDomainSafe = true;
                        }
                    }
                }
            }
        }

        if(isDomainSafe){
            if(isProtocolSafe){
                if(config.RETURN_OBJECT){
                    return {
                        "PROTOCOL":     protocol, // No I18N
                        "DOMAIN":       domain, // No I18N
                        "PORT":         port, // No I18N
                        "PATH":         path, // No I18N
                        "HASH":         hash, // No I18N
                        "RESOLVED_URL": resolvedURL, // No I18N
                        "ORIGINAL_URL": userURL // No I18N
                    }
                }
                if(config.RETURN_ORIGINAL){
                    return userURL;
                }
                return resolvedURL;
            } else {
                if (config.ACTION == constants.sanitizeAction.ACTION_ENCODE) {
                    return resolvedURL.replace(/:/, "%3A");
                }
            }
        }
        return "";
    };


    URLValidator.sanitize.config = {
        ACTION              : constants.sanitizeAction.ACTION_ENCODE,
        ALLOWED_PROTOCOLS   : ["https", "http"], // No I18N
        RETURN_PUNYCODE     : true,
        RETURN_OBJECT       : false,
        RETURN_ORIGINAL     : false
    }

    if (Object.freeze) {
        URLValidator = Object.freeze(URLValidator);
    }

    ZSEC.util.defineProperty(ZSEC, 'URLValidator', URLValidator, true, false, false, true); // No I18N
})();